!function(e){function n(r){if(t[r])return t[r].exports;var s=t[r]={exports:{},id:r,loaded:!1};return e[r].call(s.exports,s,s.exports,n),s.loaded=!0,s.exports}var t={};return n.m=e,n.c=t,n.p="dist/",n(0)}([function(e,n,t){var r,s,a,i,o;t(48),t(47),t(19),t(18),t(20),s=t(9),r=t(30),a=t(34),i=t(35),o=s.createContext(),o.setPerspective(2e3),o.add(new r),o.add(new a)},function(e,n,t){var r;r=function(e,n,t){function r(e){return 2===e.length?e[0]*e[0]+e[1]*e[1]:e[0]*e[0]+e[1]*e[1]+e[2]*e[2]}function s(e){return Math.sqrt(r(e))}function a(e){return 0>e?-1:1}var i={};i.precision=1e-6,i.identity=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1],i.multiply4x4=function(e,n){return[e[0]*n[0]+e[4]*n[1]+e[8]*n[2]+e[12]*n[3],e[1]*n[0]+e[5]*n[1]+e[9]*n[2]+e[13]*n[3],e[2]*n[0]+e[6]*n[1]+e[10]*n[2]+e[14]*n[3],e[3]*n[0]+e[7]*n[1]+e[11]*n[2]+e[15]*n[3],e[0]*n[4]+e[4]*n[5]+e[8]*n[6]+e[12]*n[7],e[1]*n[4]+e[5]*n[5]+e[9]*n[6]+e[13]*n[7],e[2]*n[4]+e[6]*n[5]+e[10]*n[6]+e[14]*n[7],e[3]*n[4]+e[7]*n[5]+e[11]*n[6]+e[15]*n[7],e[0]*n[8]+e[4]*n[9]+e[8]*n[10]+e[12]*n[11],e[1]*n[8]+e[5]*n[9]+e[9]*n[10]+e[13]*n[11],e[2]*n[8]+e[6]*n[9]+e[10]*n[10]+e[14]*n[11],e[3]*n[8]+e[7]*n[9]+e[11]*n[10]+e[15]*n[11],e[0]*n[12]+e[4]*n[13]+e[8]*n[14]+e[12]*n[15],e[1]*n[12]+e[5]*n[13]+e[9]*n[14]+e[13]*n[15],e[2]*n[12]+e[6]*n[13]+e[10]*n[14]+e[14]*n[15],e[3]*n[12]+e[7]*n[13]+e[11]*n[14]+e[15]*n[15]]},i.multiply=function(e,n){return[e[0]*n[0]+e[4]*n[1]+e[8]*n[2],e[1]*n[0]+e[5]*n[1]+e[9]*n[2],e[2]*n[0]+e[6]*n[1]+e[10]*n[2],0,e[0]*n[4]+e[4]*n[5]+e[8]*n[6],e[1]*n[4]+e[5]*n[5]+e[9]*n[6],e[2]*n[4]+e[6]*n[5]+e[10]*n[6],0,e[0]*n[8]+e[4]*n[9]+e[8]*n[10],e[1]*n[8]+e[5]*n[9]+e[9]*n[10],e[2]*n[8]+e[6]*n[9]+e[10]*n[10],0,e[0]*n[12]+e[4]*n[13]+e[8]*n[14]+e[12],e[1]*n[12]+e[5]*n[13]+e[9]*n[14]+e[13],e[2]*n[12]+e[6]*n[13]+e[10]*n[14]+e[14],1]},i.thenMove=function(e,n){return n[2]||(n[2]=0),[e[0],e[1],e[2],0,e[4],e[5],e[6],0,e[8],e[9],e[10],0,e[12]+n[0],e[13]+n[1],e[14]+n[2],1]},i.moveThen=function(e,n){e[2]||(e[2]=0);var t=e[0]*n[0]+e[1]*n[4]+e[2]*n[8],r=e[0]*n[1]+e[1]*n[5]+e[2]*n[9],s=e[0]*n[2]+e[1]*n[6]+e[2]*n[10];return i.thenMove(n,[t,r,s])},i.translate=function(e,n,t){return void 0===t&&(t=0),[1,0,0,0,0,1,0,0,0,0,1,0,e,n,t,1]},i.thenScale=function(e,n){return[n[0]*e[0],n[1]*e[1],n[2]*e[2],0,n[0]*e[4],n[1]*e[5],n[2]*e[6],0,n[0]*e[8],n[1]*e[9],n[2]*e[10],0,n[0]*e[12],n[1]*e[13],n[2]*e[14],1]},i.scale=function(e,n,t){return void 0===t&&(t=1),[e,0,0,0,0,n,0,0,0,0,t,0,0,0,0,1]},i.rotateX=function(e){var n=Math.cos(e),t=Math.sin(e);return[1,0,0,0,0,n,t,0,0,-t,n,0,0,0,0,1]},i.rotateY=function(e){var n=Math.cos(e),t=Math.sin(e);return[n,0,-t,0,0,1,0,0,t,0,n,0,0,0,0,1]},i.rotateZ=function(e){var n=Math.cos(e),t=Math.sin(e);return[n,t,0,0,-t,n,0,0,0,0,1,0,0,0,0,1]},i.rotate=function(e,n,t){var r=Math.cos(e),s=Math.sin(e),a=Math.cos(n),i=Math.sin(n),o=Math.cos(t),l=Math.sin(t),c=[a*o,r*l+s*i*o,s*l-r*i*o,0,-a*l,r*o-s*i*l,s*o+r*i*l,0,i,-s*a,r*a,0,0,0,0,1];return c},i.rotateAxis=function(e,n){var t=Math.sin(n),r=Math.cos(n),s=1-r,a=e[0]*e[0]*s,i=e[0]*e[1]*s,o=e[0]*e[2]*s,l=e[1]*e[1]*s,c=e[1]*e[2]*s,u=e[2]*e[2]*s,h=e[0]*t,d=e[1]*t,p=e[2]*t,f=[a+r,i+p,o-d,0,i-p,l+r,c+h,0,o+d,c-h,u+r,0,0,0,0,1];return f},i.aboutOrigin=function(e,n){var t=e[0]-(e[0]*n[0]+e[1]*n[4]+e[2]*n[8]),r=e[1]-(e[0]*n[1]+e[1]*n[5]+e[2]*n[9]),s=e[2]-(e[0]*n[2]+e[1]*n[6]+e[2]*n[10]);return i.thenMove(n,[t,r,s])},i.skew=function(e,n,t){return[1,0,0,0,Math.tan(t),1,0,0,Math.tan(n),Math.tan(e),1,0,0,0,0,1]},i.perspective=function(e){return[1,0,0,0,0,1,0,0,0,0,1,-1/e,0,0,0,1]},i.getTranslate=function(e){return[e[12],e[13],e[14]]},i.inverse=function(e){var n=e[5]*e[10]-e[6]*e[9],t=e[4]*e[10]-e[6]*e[8],r=e[4]*e[9]-e[5]*e[8],s=e[1]*e[10]-e[2]*e[9],a=e[0]*e[10]-e[2]*e[8],i=e[0]*e[9]-e[1]*e[8],o=e[1]*e[6]-e[2]*e[5],l=e[0]*e[6]-e[2]*e[4],c=e[0]*e[5]-e[1]*e[4],u=e[0]*n-e[1]*t+e[2]*r,h=1/u,d=[h*n,-h*s,h*o,0,-h*t,h*a,-h*l,0,h*r,-h*i,h*c,0,0,0,0,1];return d[12]=-e[12]*d[0]-e[13]*d[4]-e[14]*d[8],d[13]=-e[12]*d[1]-e[13]*d[5]-e[14]*d[9],d[14]=-e[12]*d[2]-e[13]*d[6]-e[14]*d[10],d},i.transpose=function(e){return[e[0],e[4],e[8],e[12],e[1],e[5],e[9],e[13],e[2],e[6],e[10],e[14],e[3],e[7],e[11],e[15]]},i.interpret=function(e){var n=[e[0],e[1],e[2]],t=a(n[0]),o=s(n),l=[n[0]+t*o,n[1],n[2]],c=2/r(l);if(c>=1/0)return{translate:i.getTranslate(e),rotate:[0,0,0],scale:[0,0,0],skew:[0,0,0]};var u=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1];u[0]=1-c*l[0]*l[0],u[5]=1-c*l[1]*l[1],u[10]=1-c*l[2]*l[2],u[1]=-c*l[0]*l[1],u[2]=-c*l[0]*l[2],u[6]=-c*l[1]*l[2],u[4]=u[1],u[8]=u[2],u[9]=u[6];var h=i.multiply(u,e),d=[h[5],h[6]],p=a(d[0]),f=s(d),m=[d[0]+p*f,d[1]],v=2/r(m),b=[1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1];b[5]=1-v*m[0]*m[0],b[10]=1-v*m[1]*m[1],b[6]=-v*m[0]*m[1],b[9]=b[6];var y=i.multiply(b,u),g=i.multiply(y,e),_=i.scale(g[0]<0?-1:1,g[5]<0?-1:1,g[10]<0?-1:1);g=i.multiply(g,_),y=i.multiply(_,y);var P={};return P.translate=i.getTranslate(e),P.rotate=[Math.atan2(-y[6],y[10]),Math.asin(y[2]),Math.atan2(-y[1],y[0])],P.rotate[0]||(P.rotate[0]=0,P.rotate[2]=Math.atan2(y[4],y[5])),P.scale=[g[0],g[5],g[10]],P.skew=[Math.atan2(g[9],P.scale[2]),Math.atan2(g[8],P.scale[2]),Math.atan2(g[4],P.scale[0])],Math.abs(P.rotate[0])+Math.abs(P.rotate[2])>1.5*Math.PI&&(P.rotate[1]=Math.PI-P.rotate[1],P.rotate[1]>Math.PI&&(P.rotate[1]-=2*Math.PI),P.rotate[1]<-Math.PI&&(P.rotate[1]+=2*Math.PI),P.rotate[0]<0?P.rotate[0]+=Math.PI:P.rotate[0]-=Math.PI,P.rotate[2]<0?P.rotate[2]+=Math.PI:P.rotate[2]-=Math.PI),P},i.average=function(e,n,t){t=void 0===t?.5:t;for(var r=i.interpret(e),s=i.interpret(n),a={translate:[0,0,0],rotate:[0,0,0],scale:[0,0,0],skew:[0,0,0]},o=0;3>o;o++)a.translate[o]=(1-t)*r.translate[o]+t*s.translate[o],a.rotate[o]=(1-t)*r.rotate[o]+t*s.rotate[o],a.scale[o]=(1-t)*r.scale[o]+t*s.scale[o],a.skew[o]=(1-t)*r.skew[o]+t*s.skew[o];return i.build(a)},i.build=function(e){var n=i.scale(e.scale[0],e.scale[1],e.scale[2]),t=i.skew(e.skew[0],e.skew[1],e.skew[2]),r=i.rotate(e.rotate[0],e.rotate[1],e.rotate[2]);return i.thenMove(i.multiply(i.multiply(r,t),n),e.translate)},i.equals=function(e,n){return!i.notEquals(e,n)},i.notEquals=function(e,n){return e===n?!1:e&&n?!(e&&n)||e[12]!==n[12]||e[13]!==n[13]||e[14]!==n[14]||e[0]!==n[0]||e[1]!==n[1]||e[2]!==n[2]||e[4]!==n[4]||e[5]!==n[5]||e[6]!==n[6]||e[8]!==n[8]||e[9]!==n[9]||e[10]!==n[10]:!0},i.normalizeRotation=function(e){var n=e.slice(0);for((n[0]===.5*Math.PI||n[0]===.5*-Math.PI)&&(n[0]=-n[0],n[1]=Math.PI-n[1],n[2]-=Math.PI),n[0]>.5*Math.PI&&(n[0]=n[0]-Math.PI,n[1]=Math.PI-n[1],n[2]-=Math.PI),n[0]<.5*-Math.PI&&(n[0]=n[0]+Math.PI,n[1]=-Math.PI-n[1],n[2]-=Math.PI);n[1]<-Math.PI;)n[1]+=2*Math.PI;for(;n[1]>=Math.PI;)n[1]-=2*Math.PI;for(;n[2]<-Math.PI;)n[2]+=2*Math.PI;for(;n[2]>=Math.PI;)n[2]-=2*Math.PI;return n},i.inFront=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,.001,1],i.behind=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,-.001,1],t.exports=i}.call(n,t,n,e),/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/.
	 *
	 * Owner: mark@famo.us
	 * @license MPL 2.0
	 * @copyright Famous Industries, Inc. 2014
	 */
!(void 0!==r&&(e.exports=r))},function(e,n,t){var r;r=function(e,n,r){function s(e){this.options={},this.properties={},this.content="",this.classList=[],this.size=null,this._classesDirty=!0,this._stylesDirty=!0,this._sizeDirty=!0,this._contentDirty=!0,this._dirtyClasses=[],this._matrix=null,this._opacity=1,this._origin=null,this._size=null,this.eventForwarder=function(e){this.emit(e.type,e)}.bind(this),this.eventHandler=new f,this.eventHandler.bindThis(this),this.id=p.register(this),e&&this.setOptions(e),this._currTarget=null}function a(e){for(var n in this.eventHandler.listeners)e.addEventListener(n,this.eventForwarder)}function i(e){for(var n in this.eventHandler.listeners)e.removeEventListener(n,this.eventForwarder)}function o(e){for(var n=0;n<this._dirtyClasses.length;n++)e.classList.remove(this._dirtyClasses[n]);this._dirtyClasses=[]}function l(e){for(var n in this.properties)e.style[n]=this.properties[n]}function c(e){for(var n in this.properties)e.style[n]=""}function u(e){e[12]=Math.round(e[12]*b)/b,e[13]=Math.round(e[13]*b)/b;for(var n="matrix3d(",t=0;15>t;t++)n+=e[t]<1e-6&&e[t]>-1e-6?"0,":e[t]+",";return n+=e[15]+")"}function h(e){return(100*e[0]).toFixed(6)+"% "+(100*e[1]).toFixed(6)+"%"}function d(e,n){return e&&n?e[0]!==n[0]||e[1]!==n[1]:e!==n}var p=t(10),f=t(5),m=t(1),v=void 0!==document.body.style.webkitTransform,b=window.devicePixelRatio||1;s.prototype.elementType="div",s.prototype.elementClass="famous-surface",s.prototype.on=function(e,n){this._currTarget&&this._currTarget.addEventListener(e,this.eventForwarder),this.eventHandler.on(e,n)},s.prototype.removeListener=function(e,n){this.eventHandler.removeListener(e,n)},s.prototype.emit=function(e,n){n&&!n.origin&&(n.origin=this);var t=this.eventHandler.emit(e,n);return t&&n&&n.stopPropagation&&n.stopPropagation(),t},s.prototype.pipe=function(e){return this.eventHandler.pipe(e)},s.prototype.unpipe=function(e){return this.eventHandler.unpipe(e)},s.prototype.render=function(){return this.id},s.prototype.setProperties=function(e){for(var n in e)this.properties[n]=e[n];this._stylesDirty=!0},s.prototype.getProperties=function(){return this.properties},s.prototype.addClass=function(e){this.classList.indexOf(e)<0&&(this.classList.push(e),this._classesDirty=!0)},s.prototype.removeClass=function(e){var n=this.classList.indexOf(e);n>=0&&(this._dirtyClasses.push(this.classList.splice(n,1)[0]),this._classesDirty=!0)},s.prototype.setClasses=function(e){var n=0,t=[];for(n=0;n<this.classList.length;n++)e.indexOf(this.classList[n])<0&&t.push(this.classList[n]);for(n=0;n<t.length;n++)this.removeClass(t[n]);for(n=0;n<e.length;n++)this.addClass(e[n])},s.prototype.getClassList=function(){return this.classList},s.prototype.setContent=function(e){this.content!==e&&(this.content=e,this._contentDirty=!0)},s.prototype.getContent=function(){return this.content},s.prototype.setOptions=function(e){e.size&&this.setSize(e.size),e.classes&&this.setClasses(e.classes),e.properties&&this.setProperties(e.properties),e.content&&this.setContent(e.content)};var y;y=navigator.userAgent.toLowerCase().indexOf("firefox")>-1?function(e,n){e.style.zIndex=1e6*n[14]|0,e.style.transform=u(n)}:v?function(e,n){e.style.webkitTransform=u(n)}:function(e,n){e.style.transform=u(n)};var g=v?function(e,n){e.style.webkitTransformOrigin=h(n)}:function(e,n){e.style.transformOrigin=h(n)},_=v?function(e){e.style.webkitTransform="scale3d(0.0001,0.0001,1)",e.style.opacity=0}:function(e){e.style.transform="scale3d(0.0001,0.0001,1)",e.style.opacity=0};s.prototype.setup=function(e){var n=e.allocate(this.elementType);if(this.elementClass)if(this.elementClass instanceof Array)for(var t=0;t<this.elementClass.length;t++)n.classList.add(this.elementClass[t]);else n.classList.add(this.elementClass);n.style.display="",a.call(this,n),g(n,[0,0]),this._currTarget=n,this._stylesDirty=!0,this._classesDirty=!0,this._sizeDirty=!0,this._contentDirty=!0,this._matrix=null,this._opacity=void 0,this._origin=null,this._size=null},s.prototype.commit=function(e){this._currTarget||this.setup(e.allocator);var n=this._currTarget,t=e.transform,r=e.opacity,s=e.origin,a=e.size;if(this.size){var i=a;a=[this.size[0],this.size[1]],void 0===a[0]&&i[0]&&(a[0]=i[0]),void 0===a[1]&&i[1]&&(a[1]=i[1])}if(d(this._size,a)&&(this._size=[a[0],a[1]],this._sizeDirty=!0),!t&&this._matrix)return this._matrix=null,this._opacity=0,void _(n);if(this._opacity!==r&&(this._opacity=r,n.style.opacity=r>=1?"0.999999":r),d(this._origin,s)||m.notEquals(this._matrix,t)){t||(t=m.identity),this._matrix=t;var c=t;s&&(this._origin||(this._origin=[0,0]),this._origin[0]=s[0],this._origin[1]=s[1],c=m.moveThen([-this._size[0]*s[0],-this._size[1]*s[1],0],t)),y(n,c)}if(this._classesDirty||this._stylesDirty||this._sizeDirty||this._contentDirty){if(this._classesDirty){o.call(this,n);for(var u=this.getClassList(),h=0;h<u.length;h++)n.classList.add(u[h]);this._classesDirty=!1}this._stylesDirty&&(l.call(this,n),this._stylesDirty=!1),this._sizeDirty&&(this._size&&(n.style.width=this._size[0]!==!0?this._size[0]+"px":"",n.style.height=this._size[1]!==!0?this._size[1]+"px":""),this._sizeDirty=!1),this._contentDirty&&(this.deploy(n),this.eventHandler.emit("deploy"),this._contentDirty=!1)}},s.prototype.cleanup=function(e){var n=0,t=this._currTarget;this.eventHandler.emit("recall"),this.recall(t),t.style.display="none",t.style.width="",t.style.height="",this._size=null,c.call(this,t);var r=this.getClassList();for(o.call(this,t),n=0;n<r.length;n++)t.classList.remove(r[n]);if(this.elementClass)if(this.elementClass instanceof Array)for(n=0;n<this.elementClass.length;n++)t.classList.remove(this.elementClass[n]);else t.classList.remove(this.elementClass);i.call(this,t),this._currTarget=null,e.deallocate(t),_(t)},s.prototype.deploy=function(e){var n=this.getContent();if(n instanceof Node){for(;e.hasChildNodes();)e.removeChild(e.firstChild);e.appendChild(n)}else e.innerHTML=n},s.prototype.recall=function(e){for(var n=document.createDocumentFragment();e.hasChildNodes();)n.appendChild(e.firstChild);this.setContent(n)},s.prototype.getSize=function(e){return e?this._size:this.size||this._size},s.prototype.setSize=function(e){this.size=e?[e[0],e[1]]:null,this._sizeDirty=!0},r.exports=s}.call(n,t,n,e),/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/.
	 *
	 * Owner: mark@famo.us
	 * @license MPL 2.0
	 * @copyright Famous Industries, Inc. 2014
	 */
!(void 0!==r&&(e.exports=r))},function(e,n,t){var r;r=function(e,n,r){function s(e){this._transformGetter=null,this._opacityGetter=null,this._originGetter=null,this._sizeGetter=null,this._legacyStates={},this._output={transform:i.identity,opacity:1,origin:null,size:null,target:null},e&&(e.transform&&this.transformFrom(e.transform),void 0!==e.opacity&&this.opacityFrom(e.opacity),e.origin&&this.originFrom(e.origin),e.size&&this.sizeFrom(e.size))}function a(){this._transformGetter&&(this._output.transform=this._transformGetter()),this._opacityGetter&&(this._output.opacity=this._opacityGetter()),this._originGetter&&(this._output.origin=this._originGetter()),this._sizeGetter&&(this._output.size=this._sizeGetter())}var i=t(1),o=t(6),l=t(15);s.prototype.transformFrom=function(e){return e instanceof Function?this._transformGetter=e:e instanceof Object&&e.get?this._transformGetter=e.get.bind(e):(this._transformGetter=null,this._output.transform=e),this},s.prototype.opacityFrom=function(e){return e instanceof Function?this._opacityGetter=e:e instanceof Object&&e.get?this._opacityGetter=e.get.bind(e):(this._opacityGetter=null,this._output.opacity=e),this},s.prototype.originFrom=function(e){return e instanceof Function?this._originGetter=e:e instanceof Object&&e.get?this._originGetter=e.get.bind(e):(this._originGetter=null,this._output.origin=e),this},s.prototype.sizeFrom=function(e){return e instanceof Function?this._sizeGetter=e:e instanceof Object&&e.get?this._sizeGetter=e.get.bind(e):(this._sizeGetter=null,this._output.size=e),this},s.prototype.setTransform=function(e,n,t){return n||this._legacyStates.transform?(this._legacyStates.transform||(this._legacyStates.transform=new l(this._output.transform)),this._transformGetter||this.transformFrom(this._legacyStates.transform),this._legacyStates.transform.set(e,n,t),this):this.transformFrom(e)},s.prototype.setOpacity=function(e,n,t){return n||this._legacyStates.opacity?(this._legacyStates.opacity||(this._legacyStates.opacity=new o(this._output.opacity)),this._opacityGetter||this.opacityFrom(this._legacyStates.opacity),this._legacyStates.opacity.set(e,n,t)):this.opacityFrom(e)},s.prototype.setOrigin=function(e,n,t){return n||this._legacyStates.origin?(this._legacyStates.origin||(this._legacyStates.origin=new o(this._output.origin||[0,0])),this._originGetter||this.originFrom(this._legacyStates.origin),this._legacyStates.origin.set(e,n,t),this):this.originFrom(e)},s.prototype.setSize=function(e,n,t){return e&&(n||this._legacyStates.size)?(this._legacyStates.size||(this._legacyStates.size=new o(this._output.size||[0,0])),this._sizeGetter||this.sizeFrom(this._legacyStates.size),this._legacyStates.size.set(e,n,t),this):this.sizeFrom(e)},s.prototype.halt=function(){this._legacyStates.transform&&this._legacyStates.transform.halt(),this._legacyStates.opacity&&this._legacyStates.opacity.halt(),this._legacyStates.origin&&this._legacyStates.origin.halt(),this._legacyStates.size&&this._legacyStates.size.halt(),this._transformGetter=null,this._opacityGetter=null,this._originGetter=null,this._sizeGetter=null},s.prototype.getTransform=function(){return this._transformGetter()},s.prototype.getFinalTransform=function(){return this._legacyStates.transform?this._legacyStates.transform.getFinal():this._output.transform},s.prototype.getOpacity=function(){return this._opacityGetter()},s.prototype.getOrigin=function(){return this._originGetter()},s.prototype.getSize=function(){return this._sizeGetter?this._sizeGetter():this._output.size},s.prototype.modify=function(e){return a.call(this),this._output.target=e,this._output},r.exports=s}.call(n,t,n,e),/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/.
	 *
	 * Owner: mark@famo.us
	 * @license MPL 2.0
	 * @copyright Famous Industries, Inc. 2014
	 */
!(void 0!==r&&(e.exports=r))},function(e,n,t){var r;r=function(e,n,r){function s(e){this._node=new o,this._eventInput=new a,this._eventOutput=new a,a.setInputHandler(this,this._eventInput),a.setOutputHandler(this,this._eventOutput),this.options=Object.create(this.constructor.DEFAULT_OPTIONS||s.DEFAULT_OPTIONS),this._optionsManager=new i(this.options),e&&this.setOptions(e)}var a=t(5),i=t(11),o=t(12);s.DEFAULT_OPTIONS={},s.prototype.getOptions=function(){return this._optionsManager.value()},s.prototype.setOptions=function(e){this._optionsManager.patch(e)},s.prototype.add=function(){return this._node.add.apply(this._node,arguments)},s.prototype._add=s.prototype.add,s.prototype.render=function(){return this._node.render()},s.prototype.getSize=function(){return this._node&&this._node.getSize?this._node.getSize.apply(this._node,arguments)||this.options.size:this.options.size},r.exports=s}.call(n,t,n,e),/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/.
	 *
	 * Owner: mark@famo.us
	 * @license MPL 2.0
	 * @copyright Famous Industries, Inc. 2014
	 */
!(void 0!==r&&(e.exports=r))},function(e,n,t){var r;r=function(e,n,r){function s(){a.apply(this,arguments),this.downstream=[],this.downstreamFn=[],this.upstream=[],this.upstreamListeners={}}var a=t(23);s.prototype=Object.create(a.prototype),s.prototype.constructor=s,s.setInputHandler=function(e,n){e.trigger=n.trigger.bind(n),n.subscribe&&n.unsubscribe&&(e.subscribe=n.subscribe.bind(n),e.unsubscribe=n.unsubscribe.bind(n))},s.setOutputHandler=function(e,n){n instanceof s&&n.bindThis(e),e.pipe=n.pipe.bind(n),e.unpipe=n.unpipe.bind(n),e.on=n.on.bind(n),e.addListener=n.on,e.removeListener=n.removeListener.bind(n)},s.prototype.emit=function(e,n){a.prototype.emit.apply(this,arguments);var t=0;for(t=0;t<this.downstream.length;t++)this.downstream[t].trigger&&this.downstream[t].trigger(e,n);for(t=0;t<this.downstreamFn.length;t++)this.downstreamFn[t](e,n);return this},s.prototype.trigger=s.prototype.emit,s.prototype.pipe=function(e){if(e.subscribe instanceof Function)return e.subscribe(this);var n=e instanceof Function?this.downstreamFn:this.downstream,t=n.indexOf(e);return 0>t&&n.push(e),e instanceof Function?e("pipe",null):e.trigger&&e.trigger("pipe",null),e},s.prototype.unpipe=function(e){if(e.unsubscribe instanceof Function)return e.unsubscribe(this);var n=e instanceof Function?this.downstreamFn:this.downstream,t=n.indexOf(e);return t>=0?(n.splice(t,1),e instanceof Function?e("unpipe",null):e.trigger&&e.trigger("unpipe",null),e):!1},s.prototype.on=function(e){if(a.prototype.on.apply(this,arguments),!(e in this.upstreamListeners)){var n=this.trigger.bind(this,e);this.upstreamListeners[e]=n;for(var t=0;t<this.upstream.length;t++)this.upstream[t].on(e,n)}return this},s.prototype.addListener=s.prototype.on,s.prototype.subscribe=function(e){var n=this.upstream.indexOf(e);if(0>n){this.upstream.push(e);for(var t in this.upstreamListeners)e.on(t,this.upstreamListeners[t])}return this},s.prototype.unsubscribe=function(e){var n=this.upstream.indexOf(e);if(n>=0){this.upstream.splice(n,1);for(var t in this.upstreamListeners)e.removeListener(t,this.upstreamListeners[t])}return this},r.exports=s}.call(n,t,n,e),/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/.
	 *
	 * Owner: mark@famo.us
	 * @license MPL 2.0
	 * @copyright Famous Industries, Inc. 2014
	 */
!(void 0!==r&&(e.exports=r))},function(e,n,t){var r;r=function(e,n,r){function s(e){this.currentAction=null,this.actionQueue=[],this.callbackQueue=[],this.state=0,this.velocity=void 0,this._callback=void 0,this._engineInstance=null,this._currentMethod=null,this.set(e)}function a(){if(this._callback){var e=this._callback;this._callback=void 0,e()}if(this.actionQueue.length<=0)return void this.set(this.get());this.currentAction=this.actionQueue.shift(),this._callback=this.callbackQueue.shift();var n=null,t=this.currentAction[0],r=this.currentAction[1];r instanceof Object&&r.method?(n=r.method,"string"==typeof n&&(n=l[n])):n=o,this._currentMethod!==n&&(this._engineInstance=!(t instanceof Object)||n.SUPPORTS_MULTIPLE===!0||t.length<=n.SUPPORTS_MULTIPLE?new n:new i(n),this._currentMethod=n),this._engineInstance.reset(this.state,this.velocity),void 0!==this.velocity&&(r.velocity=this.velocity),this._engineInstance.set(t,r,a.bind(this))}var i=t(26),o=t(27),l={};s.registerMethod=function(e,n){return e in l?!1:(l[e]=n,!0)},s.unregisterMethod=function(e){return e in l?(delete l[e],!0):!1},s.prototype.set=function(e,n,t){if(!n)return this.reset(e),t&&t(),this;var r=[e,n];return this.actionQueue.push(r),this.callbackQueue.push(t),this.currentAction||a.call(this),this},s.prototype.reset=function(e,n){this._currentMethod=null,this._engineInstance=null,this.state=e,this.velocity=n,this.currentAction=null,this.actionQueue=[],this.callbackQueue=[]},s.prototype.delay=function(e,n){this.set(this._engineInstance.get(),{duration:e,curve:function(){return 0}},n)},s.prototype.get=function(e){return this._engineInstance&&(this._engineInstance.getVelocity&&(this.velocity=this._engineInstance.getVelocity()),this.state=this._engineInstance.get(e)),this.state},s.prototype.isActive=function(){return!!this.currentAction},s.prototype.halt=function(){this.set(this.get())},r.exports=s}.call(n,t,n,e),/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/.
	 *
	 * Owner: david@famo.us
	 * @license MPL 2.0
	 * @copyright Famous Industries, Inc. 2014
	 */
!(void 0!==r&&(e.exports=r))},function(e,n,t){var r;r=function(e,n,t){var r={};r.Direction={X:0,Y:1,Z:2},r.after=function(e,n){var t=e;return function(){t--,0===t&&n.apply(this,arguments)}},r.loadURL=function(e,n){var t=new XMLHttpRequest;t.onreadystatechange=function(){4===this.readyState&&n&&n(this.responseText)},t.open("GET",e),t.send()},r.createDocumentFragmentFromHTML=function(e){var n=document.createElement("div");n.innerHTML=e;for(var t=document.createDocumentFragment();n.hasChildNodes();)t.appendChild(n.firstChild);return t},t.exports=r}.call(n,t,n,e),/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/.
	 *
	 * Owner: mark@famo.us
	 * @license MPL 2.0
	 * @copyright Famous Industries, Inc. 2014
	 */
!(void 0!==r&&(e.exports=r))},function(e){e.exports=function(e){var n=document.createElement("style");n.type="text/css",n.styleSheet?n.styleSheet.cssText=e:n.appendChild(document.createTextNode(e));var t=document.getElementsByTagName("head")[0];return t.appendChild(n),function(){t.removeChild(n)}}},function(e,n,t){var r;r=function(e,n,r){function s(){g.runLoop?(h.step(),requestAnimationFrame(s)):v=!1}function a(){for(var e=0;e<d.length;e++)d[e].emit("resize");y.emit("resize")}var i,o,l=t(21),c=t(5),u=t(11),h={},d=[],p=[],f=[],m=Date.now(),v=!0,b={},y=new c,g={containerType:"div",containerClass:"famous-container",fpsCap:void 0,runLoop:!0},_=new u(g),P=10;h.step=function(){var e=Date.now();if(!(o&&o>e-m)){var n=0;for(i=e-m,m=e,y.emit("prerender"),n=0;n<p.length;n++)p[n].call(this);for(p.splice(0);f.length&&Date.now()-e<P;)f.shift().call(this);for(n=0;n<d.length;n++)d[n].update();y.emit("postrender")}},requestAnimationFrame(s),window.addEventListener("resize",a,!1),a(),window.addEventListener("touchmove",function(e){e.preventDefault()},!0),h.pipe=function(e){return e.subscribe instanceof Function?e.subscribe(h):y.pipe(e)},h.unpipe=function(e){return e.unsubscribe instanceof Function?e.unsubscribe(h):y.unpipe(e)},h.on=function(e,n){return e in b||(b[e]=y.emit.bind(y,e),document.body.addEventListener(e,b[e])),y.on(e,n)},h.emit=function(e,n){return y.emit(e,n)},h.removeListener=function(e,n){return y.removeListener(e,n)},h.getFPS=function(){return 1e3/i},h.setFPSCap=function(e){o=Math.floor(1e3/e)},h.getOptions=function(){return _.getOptions.apply(_,arguments)},h.setOptions=function(){return _.setOptions.apply(_,arguments)},h.createContext=function(e){if(void 0===e)e=document.createElement(g.containerType),e.classList.add(g.containerClass),document.body.appendChild(e);else if(!(e instanceof Element))throw e=document.createElement(g.containerType),new Error("Tried to create context on non-existent element");var n=new l(e);return h.registerContext(n),n},h.registerContext=function(e){return d.push(e),e},h.nextTick=function(e){p.push(e)},h.defer=function(e){f.push(e)},_.on("change",function(e){"fpsCap"===e.id?h.setFPSCap(e.value):"runLoop"===e.id&&!v&&e.value&&(v=!0,requestAnimationFrame(s))}),r.exports=h}.call(n,t,n,e),/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/.
	 *
	 * Owner: mark@famo.us
	 * @license MPL 2.0
	 * @copyright Famous Industries, Inc. 2014
	 */
!(void 0!==r&&(e.exports=r))},function(e,n,t){var r;r=function(e,n,t){function r(e){return o[e]}function s(e,n){o[e]=n}function a(e){var n=o.length;return s(n,e),n}function i(e){s(e,null)}var o=[];t.exports={register:a,unregister:i,get:r,set:s}}.call(n,t,n,e),/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/.
	 *
	 * Owner: mark@famo.us
	 * @license MPL 2.0
	 * @copyright Famous Industries, Inc. 2014
	 */
!(void 0!==r&&(e.exports=r))},function(e,n,t){var r;r=function(e,n,r){function s(e){this._value=e,this.eventOutput=null}function a(){this.eventOutput=new i,this.eventOutput.bindThis(this),i.setOutputHandler(this,this.eventOutput)}var i=t(5);s.patch=function(e){for(var n=new s(e),t=1;t<arguments.length;t++)n.patch(arguments[t]);return e},s.prototype.patch=function(){for(var e=this._value,n=0;n<arguments.length;n++){var t=arguments[n];for(var r in t)r in e&&t[r]&&t[r].constructor===Object&&e[r]&&e[r].constructor===Object?(e.hasOwnProperty(r)||(e[r]=Object.create(e[r])),this.key(r).patch(t[r]),this.eventOutput&&this.eventOutput.emit("change",{id:r,value:this.key(r).value()})):this.set(r,t[r])}return this},s.prototype.setOptions=s.prototype.patch,s.prototype.key=function(e){var n=new s(this._value[e]);return(!(n._value instanceof Object)||n._value instanceof Array)&&(n._value={}),n},s.prototype.get=function(e){return this._value[e]},s.prototype.getOptions=s.prototype.get,s.prototype.set=function(e,n){var t=this.get(e);return this._value[e]=n,this.eventOutput&&n!==t&&this.eventOutput.emit("change",{id:e,value:n}),this},s.prototype.value=function(){return this._value},s.prototype.on=function(){return a.call(this),this.on.apply(this,arguments)},s.prototype.removeListener=function(){return a.call(this),this.removeListener.apply(this,arguments)},s.prototype.pipe=function(){return a.call(this),this.pipe.apply(this,arguments)},s.prototype.unpipe=function(){return a.call(this),this.unpipe.apply(this,arguments)},r.exports=s}.call(n,t,n,e),/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/.
	 *
	 * Owner: mark@famo.us
	 * @license MPL 2.0
	 * @copyright Famous Industries, Inc. 2014
	 */
!(void 0!==r&&(e.exports=r))},function(e,n,t){var r;r=function(e,n,r){function s(e){this._object=null,this._child=null,this._hasMultipleChildren=!1,this._isRenderable=!1,this._isModifier=!1,this._resultCache={},this._prevResults={},this._childResult=null,e&&this.set(e)}function a(e,n,t){for(var r=o.parse(e,n),s=Object.keys(r),l=0;l<s.length;l++){var c=s[l],u=i.get(c),h=r[c];h.allocator=n.allocator;var d=u.commit(h);d?a(d,n,t):t[c]=h}}var i=t(10),o=t(24);s.prototype.add=function(e){var n=e instanceof s?e:new s(e);return this._child instanceof Array?this._child.push(n):this._child?(this._child=[this._child,n],this._hasMultipleChildren=!0,this._childResult=[]):this._child=n,n},s.prototype.get=function(){return this._object||(this._hasMultipleChildren?null:this._child?this._child.get():null)},s.prototype.set=function(e){return this._childResult=null,this._hasMultipleChildren=!1,this._isRenderable=e.render?!0:!1,this._isModifier=e.modify?!0:!1,this._object=e,this._child=null,e instanceof s?e:this},s.prototype.getSize=function(){var e=null,n=this.get();return n&&n.getSize&&(e=n.getSize()),!e&&this._child&&this._child.getSize&&(e=this._child.getSize()),e},s.prototype.commit=function(e){for(var n=Object.keys(this._prevResults),t=0;t<n.length;t++){var r=n[t];if(void 0===this._resultCache[r]){var s=i.get(r);s.cleanup&&s.cleanup(e.allocator)}}this._prevResults=this._resultCache,this._resultCache={},a(this.render(),e,this._resultCache)},s.prototype.render=function(){if(this._isRenderable)return this._object.render();var e=null;if(this._hasMultipleChildren){e=this._childResult;for(var n=this._child,t=0;t<n.length;t++)e[t]=n[t].render()}else this._child&&(e=this._child.render());return this._isModifier?this._object.modify(e):e},r.exports=s}.call(n,t,n,e),/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/.
	 *
	 * Owner: mark@famo.us
	 * @license MPL 2.0
	 * @copyright Famous Industries, Inc. 2014
	 */
!(void 0!==r&&(e.exports=r))},function(e,n,t){var r;r=function(e,n,r){function s(e){this._transformState=new l(i.identity),this._opacityState=new o(1),this._originState=new o([0,0]),this._sizeState=new o([0,0]),this._modifier=new a({transform:this._transformState,opacity:this._opacityState,origin:null,size:null}),this._hasOrigin=!1,this._hasSize=!1,e&&(e.transform&&this.setTransform(e.transform),void 0!==e.opacity&&this.setOpacity(e.opacity),e.origin&&this.setOrigin(e.origin),e.size&&this.setSize(e.size))}var a=t(3),i=t(1),o=t(6),l=t(15);s.prototype.setTransform=function(e,n,t){return this._transformState.set(e,n,t),this},s.prototype.setOpacity=function(e,n,t){return this._opacityState.set(e,n,t),this},s.prototype.setOrigin=function(e,n,t){return null===e?(this._hasOrigin&&(this._modifier.originFrom(null),this._hasOrigin=!1),this):(this._hasOrigin||(this._hasOrigin=!0,this._modifier.originFrom(this._originState)),this._originState.set(e,n,t),this)},s.prototype.setSize=function(e,n,t){return null===e?(this._hasSize&&(this._modifier.sizeFrom(null),this._hasSize=!1),this):(this._hasSize||(this._hasSize=!0,this._modifier.sizeFrom(this._sizeState)),this._sizeState.set(e,n,t),this)},s.prototype.halt=function(){this._transformState.halt(),this._opacityState.halt(),this._originState.halt(),this._sizeState.halt()},s.prototype.getTransform=function(){return this._transformState.get()},s.prototype.getFinalTransform=function(){return this._transformState.getFinal()},s.prototype.getOpacity=function(){return this._opacityState.get()},s.prototype.getOrigin=function(){return this._hasOrigin?this._originState.get():null},s.prototype.getSize=function(){return this._hasSize?this._sizeState.get():null},s.prototype.modify=function(e){return this._modifier.modify(e)},r.exports=s}.call(n,t,n,e),/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/.
	 *
	 * Owner: mark@famo.us
	 * @license MPL 2.0
	 * @copyright Famous Industries, Inc. 2014
	 */
!(void 0!==r&&(e.exports=r))},function(e,n,t){var r;r=function(e,n,r){function s(){this._imageUrl=void 0,a.apply(this,arguments)}var a=t(2);s.prototype=Object.create(a.prototype),s.prototype.constructor=s,s.prototype.elementType="img",s.prototype.elementClass="famous-surface",s.prototype.setContent=function(e){this._imageUrl=e,this._contentDirty=!0},s.prototype.deploy=function(e){e.src=this._imageUrl||""},s.prototype.recall=function(e){e.src=""},r.exports=s}.call(n,t,n,e),/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/.
	 *
	 * Owner: mark@famo.us
	 * @license MPL 2.0
	 * @copyright Famous Industries, Inc. 2014
	 */
!(void 0!==r&&(e.exports=r))},function(e,n,t){var r;r=function(e,n,r){function s(e){this._final=o.identity.slice(),this.translate=new i([0,0,0]),this.rotate=new i([0,0,0]),this.skew=new i([0,0,0]),this.scale=new i([1,1,1]),e&&this.set(e)}function a(){return o.build({translate:this.translate.get(),rotate:this.rotate.get(),skew:this.skew.get(),scale:this.scale.get()})}var i=t(6),o=t(1),l=t(7);s.prototype.setTranslate=function(e,n,t){return this.translate.set(e,n,t),this._final=this._final.slice(),this._final[12]=e[0],this._final[13]=e[1],void 0!==e[2]&&(this._final[14]=e[2]),this},s.prototype.setScale=function(e,n,t){return this.scale.set(e,n,t),this._final=this._final.slice(),this._final[0]=e[0],this._final[5]=e[1],void 0!==e[2]&&(this._final[10]=e[2]),this},s.prototype.setRotate=function(e,n,t){return this.rotate.set(e,n,t),this._final=a.call(this),this._final=o.build({translate:this.translate.get(),rotate:e,scale:this.scale.get(),skew:this.skew.get()}),this},s.prototype.setSkew=function(e,n,t){return this.skew.set(e,n,t),this._final=o.build({translate:this.translate.get(),rotate:this.rotate.get(),scale:this.scale.get(),skew:e}),this},s.prototype.set=function(e,n,t){this._final=e;var r=o.interpret(e),s=t?l.after(4,t):null;return this.translate.set(r.translate,n,s),this.rotate.set(r.rotate,n,s),this.skew.set(r.skew,n,s),this.scale.set(r.scale,n,s),this},s.prototype.setDefaultTransition=function(e){this.translate.setDefault(e),this.rotate.setDefault(e),this.skew.setDefault(e),this.scale.setDefault(e)},s.prototype.get=function(){return this.isActive()?a.call(this):this._final},s.prototype.getFinal=function(){return this._final},s.prototype.isActive=function(){return this.translate.isActive()||this.rotate.isActive()||this.scale.isActive()||this.skew.isActive()},s.prototype.halt=function(){this._final=this.get(),this.translate.halt(),this.rotate.halt(),this.skew.halt(),this.scale.halt()},r.exports=s}.call(n,t,n,e),/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/.
	 *
	 * Owner: david@famo.us
	 * @license MPL 2.0
	 * @copyright Famous Industries, Inc. 2014
	 */
!(void 0!==r&&(e.exports=r))},function(e,n,t){var r;r=function(e,n,r){function s(e){return h.on(d,e),e}function a(e,n){var t=p(),r=function(){var s=p();s-t>=n&&(e.apply(this,arguments),h.removeListener(d,r))};return s(r)}function i(e,n){var t=p(),r=function(){var r=p();r-t>=n&&(e.apply(this,arguments),t=p())};return s(r)}function o(e,n){if(void 0===n)return void 0;var t=function(){n--,0>=n&&(e.apply(this,arguments),c(t))};return s(t)}function l(e,n){n=n||1;var t=n,r=function(){n--,0>=n&&(e.apply(this,arguments),n=t)};return s(r)}function c(e){h.removeListener(d,e)}function u(e,n){var t,r,s,i,o;return function(){r=this,o=arguments,s=p();var l=function(){var c=p-s;n>c?t=a(l,n-c):(t=null,i=e.apply(r,o))};return t||(t=a(l,n)),i}}var h=t(9),d="prerender",p=window.performance?function(){return window.performance.now()}:function(){return Date.now()};r.exports={setTimeout:a,setInterval:i,debounce:u,after:o,every:l,clear:c}}.call(n,t,n,e),/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/.
	 *
	 * Owner: mark@famo.us
	 * @license MPL 2.0
	 * @copyright Famous Industries, Inc. 2014
	 */
!(void 0!==r&&(e.exports=r))},function(e){var n,t={}.hasOwnProperty,r=function(e,n){function r(){this.constructor=e}for(var s in n)t.call(n,s)&&(e[s]=n[s]);return r.prototype=n.prototype,e.prototype=new r,e.__super__=n.prototype,e};n=function(e){function n(){return n.__super__.constructor.apply(this,arguments)}return r(n,e),n.prototype.defaults={question:"",mood:""},n.prototype.className="Sets",n}(Parse.Object),e.exports=n},function(){/*! @source http://purl.eligrey.com/github/classList.js/blob/master/classList.js*/
"undefined"==typeof document||"classList"in document.createElement("a")||!function(e){"use strict";var n="classList",t="prototype",r=(e.HTMLElement||e.Element)[t],s=Object,a=String[t].trim||function(){return this.replace(/^\s+|\s+$/g,"")},i=Array[t].indexOf||function(e){for(var n=0,t=this.length;t>n;n++)if(n in this&&this[n]===e)return n;return-1},o=function(e,n){this.name=e,this.code=DOMException[e],this.message=n},l=function(e,n){if(""===n)throw new o("SYNTAX_ERR","An invalid or illegal string was specified");if(/\s/.test(n))throw new o("INVALID_CHARACTER_ERR","String contains an invalid character");return i.call(e,n)},c=function(e){for(var n=a.call(e.className),t=n?n.split(/\s+/):[],r=0,s=t.length;s>r;r++)this.push(t[r]);this._updateClassName=function(){e.className=this.toString()}},u=c[t]=[],h=function(){return new c(this)};if(o[t]=Error[t],u.item=function(e){return this[e]||null},u.contains=function(e){return e+="",-1!==l(this,e)},u.add=function(e){e+="",-1===l(this,e)&&(this.push(e),this._updateClassName())},u.remove=function(e){e+="";var n=l(this,e);-1!==n&&(this.splice(n,1),this._updateClassName())},u.toggle=function(e){e+="",-1===l(this,e)?this.add(e):this.remove(e)},u.toString=function(){return this.join(" ")},s.defineProperty){var d={get:h,enumerable:!0,configurable:!0};try{s.defineProperty(r,n,d)}catch(p){-2146823252===p.number&&(d.enumerable=!1,s.defineProperty(r,n,d))}}else s[t].__defineGetter__&&r.__defineGetter__(n,h)}(self)},function(){Function.prototype.bind||(Function.prototype.bind=function(e){if("function"!=typeof this)throw new TypeError("Function.prototype.bind - what is trying to be bound is not callable");var n=Array.prototype.slice.call(arguments,1),t=this,r=function(){},s=function(){return t.apply(this instanceof r&&e?this:e,n.concat(Array.prototype.slice.call(arguments)))};return r.prototype=this.prototype,s.prototype=new r,s})},function(){window.requestAnimationFrame||(window.requestAnimationFrame=window.webkitRequestAnimationFrame||window.mozRequestAnimationFrame||window.oRequestAnimationFrame||window.msRequestAnimationFrame||function(e){return window.setTimeout(function(){e(+new Date)},1e3/60)})},function(e,n,t){var r;r=function(e,n,r){function s(e){return[e.clientWidth,e.clientHeight]}function a(e){this.container=e,this._allocator=new l(e),this._node=new i,this._eventOutput=new o,this._size=s(this.container),this._perspectiveState=new u(0),this._perspective=void 0,this._nodeContext={allocator:this._allocator,transform:c.identity,opacity:1,origin:h,size:this._size},this._eventOutput.on("resize",function(){this.setSize(s(this.container))}.bind(this))}var i=t(12),o=t(5),l=t(22),c=t(1),u=t(6),h=[0,0];a.prototype.getAllocator=function(){return this._allocator},a.prototype.add=function(e){return this._node.add(e)},a.prototype.migrate=function(e){e!==this.container&&(this.container=e,this._allocator.migrate(e))},a.prototype.getSize=function(){return this._size},a.prototype.setSize=function(e){e||(e=s(this.container)),this._size[0]=e[0],this._size[1]=e[1]},a.prototype.update=function(e){e&&(e.transform&&(this._nodeContext.transform=e.transform),e.opacity&&(this._nodeContext.opacity=e.opacity),e.origin&&(this._nodeContext.origin=e.origin),e.size&&(this._nodeContext.size=e.size));var n=this._perspectiveState.get();n!==this._perspective&&(this.container.style.perspective=n?n.toFixed()+"px":"",this.container.style.webkitPerspective=n?n.toFixed():"",this._perspective=n),this._node.commit(this._nodeContext)},a.prototype.getPerspective=function(){return this._perspectiveState.get()},a.prototype.setPerspective=function(e,n,t){return this._perspectiveState.set(e,n,t)},a.prototype.emit=function(e,n){return this._eventOutput.emit(e,n)},a.prototype.on=function(e,n){return this._eventOutput.on(e,n)},a.prototype.removeListener=function(e,n){return this._eventOutput.removeListener(e,n)},a.prototype.pipe=function(e){return this._eventOutput.pipe(e)},a.prototype.unpipe=function(e){return this._eventOutput.unpipe(e)},r.exports=a}.call(n,t,n,e),/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/.
	 *
	 * Owner: mark@famo.us
	 * @license MPL 2.0
	 * @copyright Famous Industries, Inc. 2014
	 */
!(void 0!==r&&(e.exports=r))},function(e,n,t){var r;r=function(e,n,t){function r(e){e||(e=document.createDocumentFragment()),this.container=e,this.detachedNodes={},this.nodeCount=0}r.prototype.migrate=function(e){var n=this.container;if(e!==n){if(n instanceof DocumentFragment)e.appendChild(n);else for(;n.hasChildNodes();)e.appendChild(n.removeChild(n.firstChild));this.container=e}},r.prototype.allocate=function(e){e=e.toLowerCase(),e in this.detachedNodes||(this.detachedNodes[e]=[]);var n,t=this.detachedNodes[e];return t.length>0?n=t.pop():(n=document.createElement(e),this.container.appendChild(n)),this.nodeCount++,n},r.prototype.deallocate=function(e){var n=e.nodeName.toLowerCase(),t=this.detachedNodes[n];t.push(e),this.nodeCount--},r.prototype.getNodeCount=function(){return this.nodeCount},t.exports=r}.call(n,t,n,e),/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/.
	 *
	 * Owner: mark@famo.us
	 * @license MPL 2.0
	 * @copyright Famous Industries, Inc. 2014
	 */
!(void 0!==r&&(e.exports=r))},function(e,n,t){var r;r=function(e,n,t){function r(){this.listeners={},this._owner=this}r.prototype.emit=function(e,n){var t=this.listeners[e];if(t)for(var r=0;r<t.length;r++)t[r].call(this._owner,n);return this},r.prototype.on=function(e,n){e in this.listeners||(this.listeners[e]=[]);var t=this.listeners[e].indexOf(n);return 0>t&&this.listeners[e].push(n),this},r.prototype.addListener=r.prototype.on,r.prototype.removeListener=function(e,n){var t=this.listeners[e].indexOf(n);return t>=0&&this.listeners[e].splice(t,1),this},r.prototype.bindThis=function(e){this._owner=e},t.exports=r}.call(n,t,n,e),/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/.
	 *
	 * Owner: mark@famo.us
	 * @license MPL 2.0
	 * @copyright Famous Industries, Inc. 2014
	 */
!(void 0!==r&&(e.exports=r))},function(e,n,t){var r;r=function(e,n,r){function s(){this.result={}}function a(e,n){return[e[0]*n[0]+e[1]*n[4]+e[2]*n[8],e[0]*n[1]+e[1]*n[5]+e[2]*n[9],e[0]*n[2]+e[1]*n[6]+e[2]*n[10]]}var i=t(1);s._instance=new s,s.parse=function(e,n){return s._instance.parse(e,n)},s.prototype.parse=function(e,n){return this.reset(),this._parseSpec(e,n,i.identity),this.result},s.prototype.reset=function(){this.result={}};var o=[0,0];s.prototype._parseSpec=function(e,n,t){var r,s,l,c,u,h;if("number"==typeof e){if(r=e,l=n.transform,n.size&&n.origin&&(n.origin[0]||n.origin[1])){var d=[n.origin[0]*n.size[0],n.origin[1]*n.size[1],0];l=i.thenMove(l,a(d,t))}this.result[r]={transform:l,opacity:n.opacity,origin:n.origin||o,size:n.size}}else{if(!e)return;if(e instanceof Array)for(var p=0;p<e.length;p++)this._parseSpec(e[p],n,t);else{s=e.target,l=n.transform,c=n.opacity,u=n.origin,h=n.size;var f=t;if(void 0!==e.opacity&&(c=n.opacity*e.opacity),e.transform&&(l=i.multiply(n.transform,e.transform)),e.origin&&(u=e.origin,f=n.transform),e.size){var m=n.size;h=[void 0!==e.size[0]?e.size[0]:m[0],void 0!==e.size[1]?e.size[1]:m[1]],m&&u&&(u[0]||u[1])&&(l=i.thenMove(l,a([u[0]*m[0],u[1]*m[1],0],t)),l=i.moveThen([-u[0]*h[0],-u[1]*h[1],0],l)),f=n.transform,u=null}this._parseSpec(s,{transform:l,opacity:c,origin:u,size:h},f)}}},r.exports=s}.call(n,t,n,e),/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/.
	 *
	 * Owner: mark@famo.us
	 * @license MPL 2.0
	 * @copyright Famous Industries, Inc. 2014
	 */
!(void 0!==r&&(e.exports=r))},function(e,n,t){var r;r=function(e,n,t){var r={inQuad:function(e){return e*e},outQuad:function(e){return-(e-=1)*e+1},inOutQuad:function(e){return(e/=.5)<1?.5*e*e:-.5*(--e*(e-2)-1)},inCubic:function(e){return e*e*e},outCubic:function(e){return--e*e*e+1},inOutCubic:function(e){return(e/=.5)<1?.5*e*e*e:.5*((e-=2)*e*e+2)},inQuart:function(e){return e*e*e*e},outQuart:function(e){return-(--e*e*e*e-1)},inOutQuart:function(e){return(e/=.5)<1?.5*e*e*e*e:-.5*((e-=2)*e*e*e-2)},inQuint:function(e){return e*e*e*e*e},outQuint:function(e){return--e*e*e*e*e+1},inOutQuint:function(e){return(e/=.5)<1?.5*e*e*e*e*e:.5*((e-=2)*e*e*e*e+2)},inSine:function(e){return-1*Math.cos(e*(Math.PI/2))+1},outSine:function(e){return Math.sin(e*(Math.PI/2))},inOutSine:function(e){return-.5*(Math.cos(Math.PI*e)-1)},inExpo:function(e){return 0===e?0:Math.pow(2,10*(e-1))},outExpo:function(e){return 1===e?1:-Math.pow(2,-10*e)+1},inOutExpo:function(e){return 0===e?0:1===e?1:(e/=.5)<1?.5*Math.pow(2,10*(e-1)):.5*(-Math.pow(2,-10*--e)+2)},inCirc:function(e){return-(Math.sqrt(1-e*e)-1)},outCirc:function(e){return Math.sqrt(1- --e*e)},inOutCirc:function(e){return(e/=.5)<1?-.5*(Math.sqrt(1-e*e)-1):.5*(Math.sqrt(1-(e-=2)*e)+1)},inElastic:function(e){var n=1.70158,t=0,r=1;return 0===e?0:1===e?1:(t||(t=.3),n=t/(2*Math.PI)*Math.asin(1/r),-(r*Math.pow(2,10*(e-=1))*Math.sin(2*(e-n)*Math.PI/t)))},outElastic:function(e){var n=1.70158,t=0,r=1;return 0===e?0:1===e?1:(t||(t=.3),n=t/(2*Math.PI)*Math.asin(1/r),r*Math.pow(2,-10*e)*Math.sin(2*(e-n)*Math.PI/t)+1)},inOutElastic:function(e){var n=1.70158,t=0,r=1;return 0===e?0:2===(e/=.5)?1:(t||(t=.3*1.5),n=t/(2*Math.PI)*Math.asin(1/r),1>e?-.5*r*Math.pow(2,10*(e-=1))*Math.sin(2*(e-n)*Math.PI/t):r*Math.pow(2,-10*(e-=1))*Math.sin(2*(e-n)*Math.PI/t)*.5+1)},inBack:function(e,n){return void 0===n&&(n=1.70158),e*e*((n+1)*e-n)},outBack:function(e,n){return void 0===n&&(n=1.70158),--e*e*((n+1)*e+n)+1},inOutBack:function(e,n){return void 0===n&&(n=1.70158),(e/=.5)<1?.5*e*e*(((n*=1.525)+1)*e-n):.5*((e-=2)*e*(((n*=1.525)+1)*e+n)+2)},inBounce:function(e){return 1-r.outBounce(1-e)},outBounce:function(e){return 1/2.75>e?7.5625*e*e:2/2.75>e?7.5625*(e-=1.5/2.75)*e+.75:2.5/2.75>e?7.5625*(e-=2.25/2.75)*e+.9375:7.5625*(e-=2.625/2.75)*e+.984375},inOutBounce:function(e){return.5>e?.5*r.inBounce(2*e):.5*r.outBounce(2*e-1)+.5}};t.exports=r}.call(n,t,n,e),/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/.
	 *
	 * Owner: david@famo.us
	 * @license MPL 2.0
	 * @copyright Famous Industries, Inc. 2014
	 */
!(void 0!==r&&(e.exports=r))},function(e,n,t){var r;r=function(e,n,r){function s(e){this.method=e,this._instances=[],this.state=[]}var a=t(7);s.SUPPORTS_MULTIPLE=!0,s.prototype.get=function(){for(var e=0;e<this._instances.length;e++)this.state[e]=this._instances[e].get();return this.state},s.prototype.set=function(e,n,t){for(var r=a.after(e.length,t),s=0;s<e.length;s++)this._instances[s]||(this._instances[s]=new this.method),this._instances[s].set(e[s],n,r)},s.prototype.reset=function(e){for(var n=0;n<e.length;n++)this._instances[n]||(this._instances[n]=new this.method),this._instances[n].reset(e[n])},r.exports=s}.call(n,t,n,e),/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/.
	 *
	 * Owner: david@famo.us
	 * @license MPL 2.0
	 * @copyright Famous Industries, Inc. 2014
	 */
!(void 0!==r&&(e.exports=r))},function(e,n,t){var r;r=function(e,n,t){function r(e){this.options=Object.create(r.DEFAULT_OPTIONS),e&&this.setOptions(e),this._startTime=0,this._startValue=0,this._updateTime=0,this._endValue=0,this._curve=void 0,this._duration=0,this._active=!1,this._callback=void 0,this.state=0,this.velocity=void 0}function s(e,n,t){return(1-t)*e+t*n}function a(e){return e instanceof Object?e instanceof Array?e.slice(0):Object.create(e):e}function i(e,n){var t={curve:n.curve};return n.duration&&(t.duration=n.duration),n.speed&&(t.speed=n.speed),e instanceof Object&&(void 0!==e.duration&&(t.duration=e.duration),e.curve&&(t.curve=e.curve),e.speed&&(t.speed=e.speed)),"string"==typeof t.curve&&(t.curve=r.getCurve(t.curve)),t}function o(e,n,t,r,s){var a,i=1e-7,o=(t(s)-t(s-i))/i;if(e instanceof Array){a=[];for(var l=0;l<e.length;l++)a[l]=o*(e[l]-n[l])/r}else a=o*(e-n)/r;return a}function l(e,n,t){var r;if(e instanceof Array){r=[];for(var a=0;a<e.length;a++)r[a]=s(e[a],n[a],t)}else r=s(e,n,t);return r}r.Curves={linear:function(e){return e},easeIn:function(e){return e*e},easeOut:function(e){return e*(2-e)},easeInOut:function(e){return.5>=e?2*e*e:-2*e*e+4*e-1},easeOutBounce:function(e){return e*(3-2*e)},spring:function(e){return(1-e)*Math.sin(6*Math.PI*e)+e}},r.SUPPORTS_MULTIPLE=!0,r.DEFAULT_OPTIONS={curve:r.Curves.linear,duration:500,speed:0};var c={};r.registerCurve=function(e,n){return c[e]?!1:(c[e]=n,!0)},r.unregisterCurve=function(e){return c[e]?(delete c[e],!0):!1},r.getCurve=function(e){return c[e]},r.getCurves=function(){return c},r.prototype.setOptions=function(e){void 0!==e.curve&&(this.options.curve=e.curve),void 0!==e.duration&&(this.options.duration=e.duration),void 0!==e.speed&&(this.options.speed=e.speed)},r.prototype.set=function(e,n,t){if(!n)return this.reset(e),void(t&&t());if(this._startValue=a(this.get()),n=i(n,this.options),n.speed){var r=this._startValue;if(r instanceof Object){var s=0;for(var o in r)s+=(e[o]-r[o])*(e[o]-r[o]);n.duration=Math.sqrt(s)/n.speed}else n.duration=Math.abs(e-r)/n.speed}this._startTime=Date.now(),this._endValue=a(e),this._startVelocity=a(n.velocity),this._duration=n.duration,this._curve=n.curve,this._active=!0,this._callback=t},r.prototype.reset=function(e,n){if(this._callback){var t=this._callback;this._callback=void 0,t()}this.state=a(e),this.velocity=a(n),this._startTime=0,this._duration=0,this._updateTime=0,this._startValue=this.state,this._startVelocity=this.velocity,this._endValue=this.state,this._active=!1},r.prototype.getVelocity=function(){return this.velocity},r.prototype.get=function(e){return this.update(e),this.state},r.prototype.update=function(e){if(this._active){if(e||(e=Date.now()),!(this._updateTime>=e)){this._updateTime=e;var n=e-this._startTime;if(n>=this._duration)this.state=this._endValue,this.velocity=o(this.state,this._startValue,this._curve,this._duration,1),this._active=!1;else if(0>n)this.state=this._startValue,this.velocity=this._startVelocity;else{var t=n/this._duration;this.state=l(this._startValue,this._endValue,this._curve(t)),this.velocity=o(this.state,this._startValue,this._curve,this._duration,t)}}}else if(this._callback){var r=this._callback;this._callback=void 0,r()}},r.prototype.isActive=function(){return this._active},r.prototype.halt=function(){this.reset(this.get())},r.registerCurve("linear",r.Curves.linear),r.registerCurve("easeIn",r.Curves.easeIn),r.registerCurve("easeOut",r.Curves.easeOut),r.registerCurve("easeInOut",r.Curves.easeInOut),r.registerCurve("easeOutBounce",r.Curves.easeOutBounce),r.registerCurve("spring",r.Curves.spring),r.customCurve=function(e,n){return e=e||0,n=n||0,function(t){return e*t+(-2*e-n+3)*t*t+(e+n-2)*t*t*t}},t.exports=r}.call(n,t,n,e),/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/.
	 *
	 * Owner: david@famo.us
	 * @license MPL 2.0
	 * @copyright Famous Industries, Inc. 2014
	 */
!(void 0!==r&&(e.exports=r))},function(e,n,t){var r;r=function(e,n,r){function s(e){this.options=Object.create(s.DEFAULT_OPTIONS),this._optionsManager=new h(this.options),e&&this.setOptions(e),this._entityId=l.register(this),this.header=new c,this.footer=new c,this.content=new c}function a(e,n){var t=e.getSize();return t?t[this.options.direction]:n}function i(e){return this.options.direction===s.DIRECTION_X?u.translate(e,0,0):u.translate(0,e,0)}function o(e,n){return this.options.direction===s.DIRECTION_X?[e,n[1]]:[n[0],e]}var l=t(10),c=t(12),u=t(1),h=t(11);s.DIRECTION_X=0,s.DIRECTION_Y=1,s.DEFAULT_OPTIONS={direction:s.DIRECTION_Y,headerSize:void 0,footerSize:void 0,defaultHeaderSize:0,defaultFooterSize:0},s.prototype.render=function(){return this._entityId},s.prototype.setOptions=function(e){return this._optionsManager.setOptions(e)},s.prototype.commit=function(e){var n=e.transform,t=e.origin,r=e.size,s=e.opacity,l=void 0!==this.options.headerSize?this.options.headerSize:a.call(this,this.header,this.options.defaultHeaderSize),c=void 0!==this.options.footerSize?this.options.footerSize:a.call(this,this.footer,this.options.defaultFooterSize),h=r[this.options.direction]-l-c;r&&(n=u.moveThen([-r[0]*t[0],-r[1]*t[1],0],n));var d=[{size:o.call(this,l,r),target:this.header.render()},{transform:i.call(this,l),size:o.call(this,h,r),target:this.content.render()},{transform:i.call(this,l+h),size:o.call(this,c,r),target:this.footer.render()}];return{transform:n,opacity:s,size:r,target:d}},r.exports=s}.call(n,t,n,e),/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/.
	 *
	 * Owner: felix@famo.us
	 * @license MPL 2.0
	 * @copyright Famous Industries, Inc. 2014
	 */
!(void 0!==r&&(e.exports=r))},function(e,n,t){var r,s,a,i={}.hasOwnProperty,o=function(e,n){function t(){this.constructor=e}for(var r in n)i.call(n,r)&&(e[r]=n[r]);return t.prototype=n.prototype,e.prototype=new t,e.__super__=n.prototype,e};r=t(38),s=t(17),a=function(e){function n(){return n.__super__.constructor.apply(this,arguments)}return o(n,e),n.prototype.model=s,n}(r.Collection),e.exports=a},function(e,n,t){var r,s,a,i,o,l,c,u,h,d,p,f,m,v=function(e,n){return function(){return e.apply(n,arguments)}},b={}.hasOwnProperty,y=function(e,n){function t(){this.constructor=e}for(var r in n)b.call(n,r)&&(e[r]=n[r]);return t.prototype=n.prototype,e.prototype=new t,e.__super__=n.prototype,e};m=t(4),f=t(7),a=t(28),h=t(2),d=t(1),p=t(6),l=t(3),u=t(29),c=t(17),i=t(32),o=t(33),s=t(31),r=function(e){function n(){this.toggleMenu=v(this.toggleMenu,this),n.__super__.constructor.apply(this,arguments),this.page=new a({headerSize:60,footerSize:50}),this.initHeader(),this.initMenu(),this.initContent()}return y(n,e),n.DEFAULT_OPTIONS={menu:{width:280,transition:{duration:300,curve:"easeOut"}}},n.prototype.menuOpen=!1,n.prototype.initHeader=function(){return this.header=new i,this.header.on("toggleMenu",this.toggleMenu),this.page.header.add(this.header)},n.prototype.initMenu=function(){return this.menuPosition=new p(0),this.menu=new o,this.menu.on("toggleMenu",this.toggleMenu)},n.prototype.initContent=function(){var e;return this.content=new s,e=new l({origin:[.5,.5]}),this.page.content.add(e).add(this.content)},n.prototype.toggleMenu=function(){return this.menuOpen?this.closeMenu():this.openMenu()},n.prototype.closeMenu=function(){return this.menuPosition.set(0,this.options.menu.transition,function(e){return function(){return e.menuOpen=!1}}(this))},n.prototype.openMenu=function(){return this.menuPosition.set(this.options.menu.width,this.options.menu.transition,function(e){return function(){return e.menuOpen=!0}}(this))},n.prototype.render=function(){return[{transform:d.translate(0,0,-1),target:this.menu.render()},{transform:d.translate(this.menuPosition.get(),0,0),target:this.page.render()}]},n}(m),e.exports=r},function(e,n,t){var r,s,a,i,o,l,c,u=function(e,n){return function(){return e.apply(n,arguments)}},h={}.hasOwnProperty,d=function(e,n){function t(){this.constructor=e}for(var r in n)h.call(n,r)&&(e[r]=n[r]);return t.prototype=n.prototype,e.prototype=new t,e.__super__=n.prototype,e};t(49),c=t(4),i=t(2),s=t(3),a=t(13),o=t(1),l=t(7),r=function(e){function n(){this.flip=u(this.flip,this),n.__super__.constructor.apply(this,arguments),this.init()}return d(n,e),n.DEFAULT_OPTIONS={width:400,height:600,depth:10,borderRadius:30},n.prototype.init=function(){var e,n,t;return t=this.options.width,n=this.options.height,e=this.options.depth,this.state=new a,this.mainNode=this.add(this.state),this.addSurface({size:[t,n],content:"<h2>Front of card.</h2>",classes:["card__front"],properties:{borderRadius:""+this.options.borderRadius+"px"},transform:o.translate(0,0,e/2)}),this.addSurface({size:[t,n],classes:["card__backing"],properties:{borderRadius:""+this.options.borderRadius+"px"},transform:o.multiply(o.translate(0,0,e/2-1),o.multiply(o.rotateZ(Math.PI),o.rotateX(Math.PI)))}),this.addSurface({size:[e-2,n],classes:["card__shim"],transform:o.multiply(o.translate(-t/2+this.options.borderRadius,0,1),o.rotateY(-Math.PI/2))}),this.addSurface({size:[t,n],content:"<h3>Back of card</h3>",classes:["card__back"],properties:{borderRadius:""+this.options.borderRadius+"px"},transform:o.multiply(o.translate(0,0,-e/2),o.multiply(o.rotateZ(Math.PI),o.rotateX(Math.PI)))}),this.addSurface({size:[t,n],classes:["card__backing"],properties:{borderRadius:""+this.options.borderRadius+"px"},transform:o.translate(0,0,-e/2+1)})},n.prototype.addSurface=function(e){var n,t;return t=new i({size:e.size,content:e.content,classes:e.classes,properties:e.properties}),n=new s({transform:e.transform}),t.on("click",this.flip),this.mainNode.add(n).add(t)},n.prototype.flip=function(e){return null==this.currentSide&&(this.currentSide=0),this.currentSide=0===e||1===e?e:1===this.currentSide?0:1,this.state.setTransform(o.rotateY(Math.PI*this.currentSide),{duration:500,curve:"easeInOut"})},n}(c),e.exports=r},function(e,n,t){var r,s,a,i,o,l,c,u={}.hasOwnProperty,h=function(e,n){function t(){this.constructor=e}for(var r in n)u.call(n,r)&&(e[r]=n[r]);return t.prototype=n.prototype,e.prototype=new t,e.__super__=n.prototype,e};t(50),c=t(4),l=t(7),i=t(2),s=t(14),a=t(3),o=t(1),r=function(e){function n(){n.__super__.constructor.apply(this,arguments),this.build(),this.initEvents()}return h(n,e),n.prototype.title="Pegg",n.prototype.cssPrefix="header",n.prototype.build=function(){return this.background=new i({classes:[""+this.cssPrefix+"__background"]}),this.logo=new s({size:[55,40],classes:[""+this.cssPrefix+"__logo"],content:"images/mark_tiny.png"}),this.title=new i({content:this.title,classes:[""+this.cssPrefix+"__title"]}),this.add(this.background),this.add(new a({origin:[0,0],transform:o.multiply(o.inFront,o.translate(10,10))})).add(this.logo),this.add(new a({transform:o.translate(0,10)})).add(this.title)},n.prototype.initEvents=function(){return this.logo.on("click",function(e){return function(){return e._eventOutput.emit("toggleMenu")}}(this))},n}(c),e.exports=r},function(e,n,t){var r,s,a,i={}.hasOwnProperty,o=function(e,n){function t(){this.constructor=e}for(var r in n)i.call(n,r)&&(e[r]=n[r]);return t.prototype=n.prototype,e.prototype=new t,e.__super__=n.prototype,e};a=t(4),s=t(2),r=function(e){function n(){n.__super__.constructor.apply(this,arguments),this.background=new s({size:[280,void 0],content:"MENU!!!"}),this.add(this.background),this.background.on("click",function(e){return function(){return e._eventOutput.emit("toggleMenu")}}(this))}return o(n,e),n}(a),e.exports=r},function(e,n,t){var r,s,a,i,o,l,c,u=function(e,n){return function(){return e.apply(n,arguments)}},h={}.hasOwnProperty,d=function(e,n){function t(){this.constructor=e}for(var r in n)h.call(n,r)&&(e[r]=n[r]);return t.prototype=n.prototype,e.prototype=new t,e.__super__=n.prototype,e};t(51),c=t(4),i=t(2),a=t(3),r=t(9),o=t(16),l=t(1),s=function(e){function n(){this.update=u(this.update,this),this.toggleState=u(this.toggleState,this),this.tick=u(this.tick,this),n.__super__.constructor.apply(this,arguments),this.initTime(),this.surface=new i({size:[100,20],classes:["fpsmeter"],content:""}),this.add(new a({origin:[1,1],transform:l.inFront})).add(this.surface),this.surface.on("click",this.toggleState),this.start()}return d(n,e),n.prototype.currTime=0,n.prototype.lastTime=0,n.prototype.frameTime=0,n.prototype.state=!0,n.prototype.filterStrength=10,n.prototype.updateFrequency=100,n.prototype.initTime=function(){var e,n;return e=window.performance,e&&(e.now||e.webkitNow)&&(n=e.now?"now":"webkitNow",this.getTime=e[n].bind(e)),this.lastTime=this.getTime()},n.prototype.tick=function(){var e;return this.currTime=this.getTime(),e=this.currTime-this.lastTime,this.frameTime+=(e-this.frameTime)/this.filterStrength,this.lastTime=this.currTime},n.prototype.toggleState=function(){return this.state?this.stop():this.start(),this.state=!this.state},n.prototype.start=function(){return r.on("prerender",this.tick),this.interval=o.setInterval(this.update,this.updateFrequency)},n.prototype.stop=function(){return r.removeListener("prerender",this.tick),o.clear(this.interval)},n.prototype.update=function(){return this.surface.setContent(""+(1e3/this.frameTime).toFixed(1)+" fps")},n.prototype.getTime=function(){return+new Date},n}(c),e.exports=s},function(e,n,t){var r,s,a,i,o,l,c,u,h,d={}.hasOwnProperty,p=function(e,n){function t(){this.constructor=e}for(var r in n)d.call(n,r)&&(e[r]=n[r]);return t.prototype=n.prototype,e.prototype=new t,e.__super__=n.prototype,e};h=t(4),l=t(2),s=t(14),i=t(3),o=t(13),u=t(1),r=t(25),c=t(16),a=function(e){function n(){n.__super__.constructor.apply(this,arguments),this.stateModifier=new o,this.modifier=this.add(this.stateModifier),this.modifier.add(new s({size:[417,800],content:"/images/mascot_medium.png"})),this.stateModifier.setTransform(u.translate(0,300),{duration:1e3,curve:r.inExpo}),this.stateModifier.setTransform(u.translate(100,300),{duration:800,curve:r.outElastic},function(e){return function(){return e.modifier.add(new i({transform:u.translate(400,0)})).add(new s({size:[192,200],content:"images/talk_medium.png"})),e.modifier.add(new i({transform:u.translate(480,60)})).add(new l({content:"Sup?"})),c.setTimeout(function(){return e.fadeOut()},1e3)}}(this))}return p(n,e),n.prototype.fadeOut=function(){return this.stateModifier.setOpacity(0,{duration:500,curve:r.outCubic})},n}(h),e.exports=a},function(e,n,t){e.exports={"public":t(37)}},function(e){e.exports={parse:{appId:"sMSeqS1EP23z0vo3TgZKd38MBiP9qzrvnv0OHMk8",jsKey:"XrA5EweJyzPmhxQZY6DqE8qotDmAk13s5JKhkyql"},facebook:{appId:"1410524409215955"},gatekeeper:{server:"http://localhost:9999"},upload:{server:"http://localhost:9998",s3bucket:"http://pegg.s3.amazonaws.com"},aviary:{apiKey:"cdef40f2d4f076a2"}}},function(e,n,t){var r;t(45),r=t(36)["public"].parse,Parse.initialize(r.appId,r.jsKey),e.exports=window.Parse},function(e){e.exports="html{transform-style:preserve-3d}html,body{width:100%;height:100%;margin:0;padding:0;-webkit-transform-style:preserve-3d;overflow:hidden}body{-webkit-font-smoothing:antialiased;-webkit-tap-highlight-color:transparent;-webkit-perspective:0;perspective:none}body,.famous-container{position:absolute;transform-style:preserve-3d}.famous-container,.famous-group{top:0;left:0;bottom:0;right:0;overflow:visible;-webkit-backface-visibility:visible;backface-visibility:visible;pointer-events:none;-webkit-transform-style:preserve-3d}.famous-group{width:0;height:0;margin:0;padding:0}.famous-group,.famous-surface{position:absolute;transform-style:preserve-3d}.famous-surface{-webkit-transform-origin:center center;transform-origin:center center;-webkit-backface-visibility:hidden;backface-visibility:hidden;-webkit-transform-style:flat;-webkit-box-sizing:border-box;-moz-box-sizing:border-box;-webkit-tap-highlight-color:transparent;pointer-events:auto}.famous-container-group{position:relative;width:100%;height:100%}"},function(e){e.exports='body {\n  font-family: "Helvetica Neue", "Helvetica", Helvetica, Arial, sans-serif; }\n\nbutton {\n  width: 100%;\n  height: 100%; }\n\n.answer {\n  background-color: #00a5ff;\n  padding: 10px;\n  border: 10px solid white;\n  text-align: center; }\n'},function(e){e.exports=".backface-visible, .card__shim {\n  backface-visibility: visible;\n  -webkit-backface-visibility: visible;\n  -moz-backface-visibility: visible;\n  -ms-backface-visibility: visible; }\n\n.card__front, .card__middle, .card__back {\n  text-align: center;\n  cursor: pointer; }\n\n.card__front {\n  background-color: #9fcacf; }\n\n.card__backing {\n  background-color: #000; }\n\n.card__shim {\n  background-color: #000; }\n\n.card__back {\n  background-color: #ffd500; }\n"},function(e){e.exports=".header__background, .footer {\n  background-color: #0c0d2a;\n  color: #fff;\n  line-height: 100px;\n  text-align: center; }\n\n.header__title {\n  font-weight: bold;\n  font-size: 30px;\n  text-align: center;\n  color: #fff; }\n\n.header__logo {\n  cursor: pointer; }\n"},function(e){e.exports=".fpsmeter {\n  color: #000;\n  cursor: pointer; }\n"},function(e){e.exports=function(e){window.execScript?window.execScript(e):eval.call(null,e)}},function(e,n,t){t(44)(t(46))},function(e){e.exports='/*!\n * Parse JavaScript SDK\n * Version: 1.2.18\n * Built: Wed Mar 12 2014 15:36:03\n * http://parse.com\n *\n * Copyright 2014 Parse, Inc.\n * The Parse JavaScript SDK is freely distributable under the MIT license.\n *\n * Includes: Underscore.js\n * Copyright 2009-2012 Jeremy Ashkenas, DocumentCloud Inc.\n * Released under the MIT license.\n */\n(function(root) {\n  root.Parse = root.Parse || {};\n  root.Parse.VERSION = "js1.2.18";\n}(this));\n//     Underscore.js 1.4.4\n//     http://underscorejs.org\n//     (c) 2009-2013 Jeremy Ashkenas, DocumentCloud Inc.\n//     Underscore may be freely distributed under the MIT license.\n\n(function() {\n\n  // Baseline setup\n  // --------------\n\n  // Establish the root object, `window` in the browser, or `global` on the server.\n  var root = this;\n\n  // Save the previous value of the `_` variable.\n  var previousUnderscore = root._;\n\n  // Establish the object that gets returned to break out of a loop iteration.\n  var breaker = {};\n\n  // Save bytes in the minified (but not gzipped) version:\n  var ArrayProto = Array.prototype, ObjProto = Object.prototype, FuncProto = Function.prototype;\n\n  // Create quick reference variables for speed access to core prototypes.\n  var push             = ArrayProto.push,\n      slice            = ArrayProto.slice,\n      concat           = ArrayProto.concat,\n      toString         = ObjProto.toString,\n      hasOwnProperty   = ObjProto.hasOwnProperty;\n\n  // All **ECMAScript 5** native function implementations that we hope to use\n  // are declared here.\n  var\n    nativeForEach      = ArrayProto.forEach,\n    nativeMap          = ArrayProto.map,\n    nativeReduce       = ArrayProto.reduce,\n    nativeReduceRight  = ArrayProto.reduceRight,\n    nativeFilter       = ArrayProto.filter,\n    nativeEvery        = ArrayProto.every,\n    nativeSome         = ArrayProto.some,\n    nativeIndexOf      = ArrayProto.indexOf,\n    nativeLastIndexOf  = ArrayProto.lastIndexOf,\n    nativeIsArray      = Array.isArray,\n    nativeKeys         = Object.keys,\n    nativeBind         = FuncProto.bind;\n\n  // Create a safe reference to the Underscore object for use below.\n  var _ = function(obj) {\n    if (obj instanceof _) return obj;\n    if (!(this instanceof _)) return new _(obj);\n    this._wrapped = obj;\n  };\n\n  // Export the Underscore object for **Node.js**, with\n  // backwards-compatibility for the old `require()` API. If we\'re in\n  // the browser, add `_` as a global object via a string identifier,\n  // for Closure Compiler "advanced" mode.\n  if (typeof exports !== \'undefined\') {\n    if (typeof module !== \'undefined\' && module.exports) {\n      exports = module.exports = _;\n    }\n    exports._ = _;\n  } else {\n    root._ = _;\n  }\n\n  // Current version.\n  _.VERSION = \'1.4.4\';\n\n  // Collection Functions\n  // --------------------\n\n  // The cornerstone, an `each` implementation, aka `forEach`.\n  // Handles objects with the built-in `forEach`, arrays, and raw objects.\n  // Delegates to **ECMAScript 5**\'s native `forEach` if available.\n  var each = _.each = _.forEach = function(obj, iterator, context) {\n    if (obj == null) return;\n    if (nativeForEach && obj.forEach === nativeForEach) {\n      obj.forEach(iterator, context);\n    } else if (obj.length === +obj.length) {\n      for (var i = 0, l = obj.length; i < l; i++) {\n        if (iterator.call(context, obj[i], i, obj) === breaker) return;\n      }\n    } else {\n      for (var key in obj) {\n        if (_.has(obj, key)) {\n          if (iterator.call(context, obj[key], key, obj) === breaker) return;\n        }\n      }\n    }\n  };\n\n  // Return the results of applying the iterator to each element.\n  // Delegates to **ECMAScript 5**\'s native `map` if available.\n  _.map = _.collect = function(obj, iterator, context) {\n    var results = [];\n    if (obj == null) return results;\n    if (nativeMap && obj.map === nativeMap) return obj.map(iterator, context);\n    each(obj, function(value, index, list) {\n      results[results.length] = iterator.call(context, value, index, list);\n    });\n    return results;\n  };\n\n  var reduceError = \'Reduce of empty array with no initial value\';\n\n  // **Reduce** builds up a single result from a list of values, aka `inject`,\n  // or `foldl`. Delegates to **ECMAScript 5**\'s native `reduce` if available.\n  _.reduce = _.foldl = _.inject = function(obj, iterator, memo, context) {\n    var initial = arguments.length > 2;\n    if (obj == null) obj = [];\n    if (nativeReduce && obj.reduce === nativeReduce) {\n      if (context) iterator = _.bind(iterator, context);\n      return initial ? obj.reduce(iterator, memo) : obj.reduce(iterator);\n    }\n    each(obj, function(value, index, list) {\n      if (!initial) {\n        memo = value;\n        initial = true;\n      } else {\n        memo = iterator.call(context, memo, value, index, list);\n      }\n    });\n    if (!initial) throw new TypeError(reduceError);\n    return memo;\n  };\n\n  // The right-associative version of reduce, also known as `foldr`.\n  // Delegates to **ECMAScript 5**\'s native `reduceRight` if available.\n  _.reduceRight = _.foldr = function(obj, iterator, memo, context) {\n    var initial = arguments.length > 2;\n    if (obj == null) obj = [];\n    if (nativeReduceRight && obj.reduceRight === nativeReduceRight) {\n      if (context) iterator = _.bind(iterator, context);\n      return initial ? obj.reduceRight(iterator, memo) : obj.reduceRight(iterator);\n    }\n    var length = obj.length;\n    if (length !== +length) {\n      var keys = _.keys(obj);\n      length = keys.length;\n    }\n    each(obj, function(value, index, list) {\n      index = keys ? keys[--length] : --length;\n      if (!initial) {\n        memo = obj[index];\n        initial = true;\n      } else {\n        memo = iterator.call(context, memo, obj[index], index, list);\n      }\n    });\n    if (!initial) throw new TypeError(reduceError);\n    return memo;\n  };\n\n  // Return the first value which passes a truth test. Aliased as `detect`.\n  _.find = _.detect = function(obj, iterator, context) {\n    var result;\n    any(obj, function(value, index, list) {\n      if (iterator.call(context, value, index, list)) {\n        result = value;\n        return true;\n      }\n    });\n    return result;\n  };\n\n  // Return all the elements that pass a truth test.\n  // Delegates to **ECMAScript 5**\'s native `filter` if available.\n  // Aliased as `select`.\n  _.filter = _.select = function(obj, iterator, context) {\n    var results = [];\n    if (obj == null) return results;\n    if (nativeFilter && obj.filter === nativeFilter) return obj.filter(iterator, context);\n    each(obj, function(value, index, list) {\n      if (iterator.call(context, value, index, list)) results[results.length] = value;\n    });\n    return results;\n  };\n\n  // Return all the elements for which a truth test fails.\n  _.reject = function(obj, iterator, context) {\n    return _.filter(obj, function(value, index, list) {\n      return !iterator.call(context, value, index, list);\n    }, context);\n  };\n\n  // Determine whether all of the elements match a truth test.\n  // Delegates to **ECMAScript 5**\'s native `every` if available.\n  // Aliased as `all`.\n  _.every = _.all = function(obj, iterator, context) {\n    iterator || (iterator = _.identity);\n    var result = true;\n    if (obj == null) return result;\n    if (nativeEvery && obj.every === nativeEvery) return obj.every(iterator, context);\n    each(obj, function(value, index, list) {\n      if (!(result = result && iterator.call(context, value, index, list))) return breaker;\n    });\n    return !!result;\n  };\n\n  // Determine if at least one element in the object matches a truth test.\n  // Delegates to **ECMAScript 5**\'s native `some` if available.\n  // Aliased as `any`.\n  var any = _.some = _.any = function(obj, iterator, context) {\n    iterator || (iterator = _.identity);\n    var result = false;\n    if (obj == null) return result;\n    if (nativeSome && obj.some === nativeSome) return obj.some(iterator, context);\n    each(obj, function(value, index, list) {\n      if (result || (result = iterator.call(context, value, index, list))) return breaker;\n    });\n    return !!result;\n  };\n\n  // Determine if the array or object contains a given value (using `===`).\n  // Aliased as `include`.\n  _.contains = _.include = function(obj, target) {\n    if (obj == null) return false;\n    if (nativeIndexOf && obj.indexOf === nativeIndexOf) return obj.indexOf(target) != -1;\n    return any(obj, function(value) {\n      return value === target;\n    });\n  };\n\n  // Invoke a method (with arguments) on every item in a collection.\n  _.invoke = function(obj, method) {\n    var args = slice.call(arguments, 2);\n    var isFunc = _.isFunction(method);\n    return _.map(obj, function(value) {\n      return (isFunc ? method : value[method]).apply(value, args);\n    });\n  };\n\n  // Convenience version of a common use case of `map`: fetching a property.\n  _.pluck = function(obj, key) {\n    return _.map(obj, function(value){ return value[key]; });\n  };\n\n  // Convenience version of a common use case of `filter`: selecting only objects\n  // containing specific `key:value` pairs.\n  _.where = function(obj, attrs, first) {\n    if (_.isEmpty(attrs)) return first ? null : [];\n    return _[first ? \'find\' : \'filter\'](obj, function(value) {\n      for (var key in attrs) {\n        if (attrs[key] !== value[key]) return false;\n      }\n      return true;\n    });\n  };\n\n  // Convenience version of a common use case of `find`: getting the first object\n  // containing specific `key:value` pairs.\n  _.findWhere = function(obj, attrs) {\n    return _.where(obj, attrs, true);\n  };\n\n  // Return the maximum element or (element-based computation).\n  // Can\'t optimize arrays of integers longer than 65,535 elements.\n  // See: https://bugs.webkit.org/show_bug.cgi?id=80797\n  _.max = function(obj, iterator, context) {\n    if (!iterator && _.isArray(obj) && obj[0] === +obj[0] && obj.length < 65535) {\n      return Math.max.apply(Math, obj);\n    }\n    if (!iterator && _.isEmpty(obj)) return -Infinity;\n    var result = {computed : -Infinity, value: -Infinity};\n    each(obj, function(value, index, list) {\n      var computed = iterator ? iterator.call(context, value, index, list) : value;\n      computed >= result.computed && (result = {value : value, computed : computed});\n    });\n    return result.value;\n  };\n\n  // Return the minimum element (or element-based computation).\n  _.min = function(obj, iterator, context) {\n    if (!iterator && _.isArray(obj) && obj[0] === +obj[0] && obj.length < 65535) {\n      return Math.min.apply(Math, obj);\n    }\n    if (!iterator && _.isEmpty(obj)) return Infinity;\n    var result = {computed : Infinity, value: Infinity};\n    each(obj, function(value, index, list) {\n      var computed = iterator ? iterator.call(context, value, index, list) : value;\n      computed < result.computed && (result = {value : value, computed : computed});\n    });\n    return result.value;\n  };\n\n  // Shuffle an array.\n  _.shuffle = function(obj) {\n    var rand;\n    var index = 0;\n    var shuffled = [];\n    each(obj, function(value) {\n      rand = _.random(index++);\n      shuffled[index - 1] = shuffled[rand];\n      shuffled[rand] = value;\n    });\n    return shuffled;\n  };\n\n  // An internal function to generate lookup iterators.\n  var lookupIterator = function(value) {\n    return _.isFunction(value) ? value : function(obj){ return obj[value]; };\n  };\n\n  // Sort the object\'s values by a criterion produced by an iterator.\n  _.sortBy = function(obj, value, context) {\n    var iterator = lookupIterator(value);\n    return _.pluck(_.map(obj, function(value, index, list) {\n      return {\n        value : value,\n        index : index,\n        criteria : iterator.call(context, value, index, list)\n      };\n    }).sort(function(left, right) {\n      var a = left.criteria;\n      var b = right.criteria;\n      if (a !== b) {\n        if (a > b || a === void 0) return 1;\n        if (a < b || b === void 0) return -1;\n      }\n      return left.index < right.index ? -1 : 1;\n    }), \'value\');\n  };\n\n  // An internal function used for aggregate "group by" operations.\n  var group = function(obj, value, context, behavior) {\n    var result = {};\n    var iterator = lookupIterator(value || _.identity);\n    each(obj, function(value, index) {\n      var key = iterator.call(context, value, index, obj);\n      behavior(result, key, value);\n    });\n    return result;\n  };\n\n  // Groups the object\'s values by a criterion. Pass either a string attribute\n  // to group by, or a function that returns the criterion.\n  _.groupBy = function(obj, value, context) {\n    return group(obj, value, context, function(result, key, value) {\n      (_.has(result, key) ? result[key] : (result[key] = [])).push(value);\n    });\n  };\n\n  // Counts instances of an object that group by a certain criterion. Pass\n  // either a string attribute to count by, or a function that returns the\n  // criterion.\n  _.countBy = function(obj, value, context) {\n    return group(obj, value, context, function(result, key) {\n      if (!_.has(result, key)) result[key] = 0;\n      result[key]++;\n    });\n  };\n\n  // Use a comparator function to figure out the smallest index at which\n  // an object should be inserted so as to maintain order. Uses binary search.\n  _.sortedIndex = function(array, obj, iterator, context) {\n    iterator = iterator == null ? _.identity : lookupIterator(iterator);\n    var value = iterator.call(context, obj);\n    var low = 0, high = array.length;\n    while (low < high) {\n      var mid = (low + high) >>> 1;\n      iterator.call(context, array[mid]) < value ? low = mid + 1 : high = mid;\n    }\n    return low;\n  };\n\n  // Safely convert anything iterable into a real, live array.\n  _.toArray = function(obj) {\n    if (!obj) return [];\n    if (_.isArray(obj)) return slice.call(obj);\n    if (obj.length === +obj.length) return _.map(obj, _.identity);\n    return _.values(obj);\n  };\n\n  // Return the number of elements in an object.\n  _.size = function(obj) {\n    if (obj == null) return 0;\n    return (obj.length === +obj.length) ? obj.length : _.keys(obj).length;\n  };\n\n  // Array Functions\n  // ---------------\n\n  // Get the first element of an array. Passing **n** will return the first N\n  // values in the array. Aliased as `head` and `take`. The **guard** check\n  // allows it to work with `_.map`.\n  _.first = _.head = _.take = function(array, n, guard) {\n    if (array == null) return void 0;\n    return (n != null) && !guard ? slice.call(array, 0, n) : array[0];\n  };\n\n  // Returns everything but the last entry of the array. Especially useful on\n  // the arguments object. Passing **n** will return all the values in\n  // the array, excluding the last N. The **guard** check allows it to work with\n  // `_.map`.\n  _.initial = function(array, n, guard) {\n    return slice.call(array, 0, array.length - ((n == null) || guard ? 1 : n));\n  };\n\n  // Get the last element of an array. Passing **n** will return the last N\n  // values in the array. The **guard** check allows it to work with `_.map`.\n  _.last = function(array, n, guard) {\n    if (array == null) return void 0;\n    if ((n != null) && !guard) {\n      return slice.call(array, Math.max(array.length - n, 0));\n    } else {\n      return array[array.length - 1];\n    }\n  };\n\n  // Returns everything but the first entry of the array. Aliased as `tail` and `drop`.\n  // Especially useful on the arguments object. Passing an **n** will return\n  // the rest N values in the array. The **guard**\n  // check allows it to work with `_.map`.\n  _.rest = _.tail = _.drop = function(array, n, guard) {\n    return slice.call(array, (n == null) || guard ? 1 : n);\n  };\n\n  // Trim out all falsy values from an array.\n  _.compact = function(array) {\n    return _.filter(array, _.identity);\n  };\n\n  // Internal implementation of a recursive `flatten` function.\n  var flatten = function(input, shallow, output) {\n    each(input, function(value) {\n      if (_.isArray(value)) {\n        shallow ? push.apply(output, value) : flatten(value, shallow, output);\n      } else {\n        output.push(value);\n      }\n    });\n    return output;\n  };\n\n  // Return a completely flattened version of an array.\n  _.flatten = function(array, shallow) {\n    return flatten(array, shallow, []);\n  };\n\n  // Return a version of the array that does not contain the specified value(s).\n  _.without = function(array) {\n    return _.difference(array, slice.call(arguments, 1));\n  };\n\n  // Produce a duplicate-free version of the array. If the array has already\n  // been sorted, you have the option of using a faster algorithm.\n  // Aliased as `unique`.\n  _.uniq = _.unique = function(array, isSorted, iterator, context) {\n    if (_.isFunction(isSorted)) {\n      context = iterator;\n      iterator = isSorted;\n      isSorted = false;\n    }\n    var initial = iterator ? _.map(array, iterator, context) : array;\n    var results = [];\n    var seen = [];\n    each(initial, function(value, index) {\n      if (isSorted ? (!index || seen[seen.length - 1] !== value) : !_.contains(seen, value)) {\n        seen.push(value);\n        results.push(array[index]);\n      }\n    });\n    return results;\n  };\n\n  // Produce an array that contains the union: each distinct element from all of\n  // the passed-in arrays.\n  _.union = function() {\n    return _.uniq(concat.apply(ArrayProto, arguments));\n  };\n\n  // Produce an array that contains every item shared between all the\n  // passed-in arrays.\n  _.intersection = function(array) {\n    var rest = slice.call(arguments, 1);\n    return _.filter(_.uniq(array), function(item) {\n      return _.every(rest, function(other) {\n        return _.indexOf(other, item) >= 0;\n      });\n    });\n  };\n\n  // Take the difference between one array and a number of other arrays.\n  // Only the elements present in just the first array will remain.\n  _.difference = function(array) {\n    var rest = concat.apply(ArrayProto, slice.call(arguments, 1));\n    return _.filter(array, function(value){ return !_.contains(rest, value); });\n  };\n\n  // Zip together multiple lists into a single array -- elements that share\n  // an index go together.\n  _.zip = function() {\n    var args = slice.call(arguments);\n    var length = _.max(_.pluck(args, \'length\'));\n    var results = new Array(length);\n    for (var i = 0; i < length; i++) {\n      results[i] = _.pluck(args, "" + i);\n    }\n    return results;\n  };\n\n  // Converts lists into objects. Pass either a single array of `[key, value]`\n  // pairs, or two parallel arrays of the same length -- one of keys, and one of\n  // the corresponding values.\n  _.object = function(list, values) {\n    if (list == null) return {};\n    var result = {};\n    for (var i = 0, l = list.length; i < l; i++) {\n      if (values) {\n        result[list[i]] = values[i];\n      } else {\n        result[list[i][0]] = list[i][1];\n      }\n    }\n    return result;\n  };\n\n  // If the browser doesn\'t supply us with indexOf (I\'m looking at you, **MSIE**),\n  // we need this function. Return the position of the first occurrence of an\n  // item in an array, or -1 if the item is not included in the array.\n  // Delegates to **ECMAScript 5**\'s native `indexOf` if available.\n  // If the array is large and already in sort order, pass `true`\n  // for **isSorted** to use binary search.\n  _.indexOf = function(array, item, isSorted) {\n    if (array == null) return -1;\n    var i = 0, l = array.length;\n    if (isSorted) {\n      if (typeof isSorted == \'number\') {\n        i = (isSorted < 0 ? Math.max(0, l + isSorted) : isSorted);\n      } else {\n        i = _.sortedIndex(array, item);\n        return array[i] === item ? i : -1;\n      }\n    }\n    if (nativeIndexOf && array.indexOf === nativeIndexOf) return array.indexOf(item, isSorted);\n    for (; i < l; i++) if (array[i] === item) return i;\n    return -1;\n  };\n\n  // Delegates to **ECMAScript 5**\'s native `lastIndexOf` if available.\n  _.lastIndexOf = function(array, item, from) {\n    if (array == null) return -1;\n    var hasIndex = from != null;\n    if (nativeLastIndexOf && array.lastIndexOf === nativeLastIndexOf) {\n      return hasIndex ? array.lastIndexOf(item, from) : array.lastIndexOf(item);\n    }\n    var i = (hasIndex ? from : array.length);\n    while (i--) if (array[i] === item) return i;\n    return -1;\n  };\n\n  // Generate an integer Array containing an arithmetic progression. A port of\n  // the native Python `range()` function. See\n  // [the Python documentation](http://docs.python.org/library/functions.html#range).\n  _.range = function(start, stop, step) {\n    if (arguments.length <= 1) {\n      stop = start || 0;\n      start = 0;\n    }\n    step = arguments[2] || 1;\n\n    var len = Math.max(Math.ceil((stop - start) / step), 0);\n    var idx = 0;\n    var range = new Array(len);\n\n    while(idx < len) {\n      range[idx++] = start;\n      start += step;\n    }\n\n    return range;\n  };\n\n  // Function (ahem) Functions\n  // ------------------\n\n  // Create a function bound to a given object (assigning `this`, and arguments,\n  // optionally). Delegates to **ECMAScript 5**\'s native `Function.bind` if\n  // available.\n  _.bind = function(func, context) {\n    if (func.bind === nativeBind && nativeBind) return nativeBind.apply(func, slice.call(arguments, 1));\n    var args = slice.call(arguments, 2);\n    return function() {\n      return func.apply(context, args.concat(slice.call(arguments)));\n    };\n  };\n\n  // Partially apply a function by creating a version that has had some of its\n  // arguments pre-filled, without changing its dynamic `this` context.\n  _.partial = function(func) {\n    var args = slice.call(arguments, 1);\n    return function() {\n      return func.apply(this, args.concat(slice.call(arguments)));\n    };\n  };\n\n  // Bind all of an object\'s methods to that object. Useful for ensuring that\n  // all callbacks defined on an object belong to it.\n  _.bindAll = function(obj) {\n    var funcs = slice.call(arguments, 1);\n    if (funcs.length === 0) funcs = _.functions(obj);\n    each(funcs, function(f) { obj[f] = _.bind(obj[f], obj); });\n    return obj;\n  };\n\n  // Memoize an expensive function by storing its results.\n  _.memoize = function(func, hasher) {\n    var memo = {};\n    hasher || (hasher = _.identity);\n    return function() {\n      var key = hasher.apply(this, arguments);\n      return _.has(memo, key) ? memo[key] : (memo[key] = func.apply(this, arguments));\n    };\n  };\n\n  // Delays a function for the given number of milliseconds, and then calls\n  // it with the arguments supplied.\n  _.delay = function(func, wait) {\n    var args = slice.call(arguments, 2);\n    return setTimeout(function(){ return func.apply(null, args); }, wait);\n  };\n\n  // Defers a function, scheduling it to run after the current call stack has\n  // cleared.\n  _.defer = function(func) {\n    return _.delay.apply(_, [func, 1].concat(slice.call(arguments, 1)));\n  };\n\n  // Returns a function, that, when invoked, will only be triggered at most once\n  // during a given window of time.\n  _.throttle = function(func, wait) {\n    var context, args, timeout, result;\n    var previous = 0;\n    var later = function() {\n      previous = new Date;\n      timeout = null;\n      result = func.apply(context, args);\n    };\n    return function() {\n      var now = new Date;\n      var remaining = wait - (now - previous);\n      context = this;\n      args = arguments;\n      if (remaining <= 0) {\n        clearTimeout(timeout);\n        timeout = null;\n        previous = now;\n        result = func.apply(context, args);\n      } else if (!timeout) {\n        timeout = setTimeout(later, remaining);\n      }\n      return result;\n    };\n  };\n\n  // Returns a function, that, as long as it continues to be invoked, will not\n  // be triggered. The function will be called after it stops being called for\n  // N milliseconds. If `immediate` is passed, trigger the function on the\n  // leading edge, instead of the trailing.\n  _.debounce = function(func, wait, immediate) {\n    var timeout, result;\n    return function() {\n      var context = this, args = arguments;\n      var later = function() {\n        timeout = null;\n        if (!immediate) result = func.apply(context, args);\n      };\n      var callNow = immediate && !timeout;\n      clearTimeout(timeout);\n      timeout = setTimeout(later, wait);\n      if (callNow) result = func.apply(context, args);\n      return result;\n    };\n  };\n\n  // Returns a function that will be executed at most one time, no matter how\n  // often you call it. Useful for lazy initialization.\n  _.once = function(func) {\n    var ran = false, memo;\n    return function() {\n      if (ran) return memo;\n      ran = true;\n      memo = func.apply(this, arguments);\n      func = null;\n      return memo;\n    };\n  };\n\n  // Returns the first function passed as an argument to the second,\n  // allowing you to adjust arguments, run code before and after, and\n  // conditionally execute the original function.\n  _.wrap = function(func, wrapper) {\n    return function() {\n      var args = [func];\n      push.apply(args, arguments);\n      return wrapper.apply(this, args);\n    };\n  };\n\n  // Returns a function that is the composition of a list of functions, each\n  // consuming the return value of the function that follows.\n  _.compose = function() {\n    var funcs = arguments;\n    return function() {\n      var args = arguments;\n      for (var i = funcs.length - 1; i >= 0; i--) {\n        args = [funcs[i].apply(this, args)];\n      }\n      return args[0];\n    };\n  };\n\n  // Returns a function that will only be executed after being called N times.\n  _.after = function(times, func) {\n    if (times <= 0) return func();\n    return function() {\n      if (--times < 1) {\n        return func.apply(this, arguments);\n      }\n    };\n  };\n\n  // Object Functions\n  // ----------------\n\n  // Retrieve the names of an object\'s properties.\n  // Delegates to **ECMAScript 5**\'s native `Object.keys`\n  _.keys = nativeKeys || function(obj) {\n    if (obj !== Object(obj)) throw new TypeError(\'Invalid object\');\n    var keys = [];\n    for (var key in obj) if (_.has(obj, key)) keys[keys.length] = key;\n    return keys;\n  };\n\n  // Retrieve the values of an object\'s properties.\n  _.values = function(obj) {\n    var values = [];\n    for (var key in obj) if (_.has(obj, key)) values.push(obj[key]);\n    return values;\n  };\n\n  // Convert an object into a list of `[key, value]` pairs.\n  _.pairs = function(obj) {\n    var pairs = [];\n    for (var key in obj) if (_.has(obj, key)) pairs.push([key, obj[key]]);\n    return pairs;\n  };\n\n  // Invert the keys and values of an object. The values must be serializable.\n  _.invert = function(obj) {\n    var result = {};\n    for (var key in obj) if (_.has(obj, key)) result[obj[key]] = key;\n    return result;\n  };\n\n  // Return a sorted list of the function names available on the object.\n  // Aliased as `methods`\n  _.functions = _.methods = function(obj) {\n    var names = [];\n    for (var key in obj) {\n      if (_.isFunction(obj[key])) names.push(key);\n    }\n    return names.sort();\n  };\n\n  // Extend a given object with all the properties in passed-in object(s).\n  _.extend = function(obj) {\n    each(slice.call(arguments, 1), function(source) {\n      if (source) {\n        for (var prop in source) {\n          obj[prop] = source[prop];\n        }\n      }\n    });\n    return obj;\n  };\n\n  // Return a copy of the object only containing the whitelisted properties.\n  _.pick = function(obj) {\n    var copy = {};\n    var keys = concat.apply(ArrayProto, slice.call(arguments, 1));\n    each(keys, function(key) {\n      if (key in obj) copy[key] = obj[key];\n    });\n    return copy;\n  };\n\n   // Return a copy of the object without the blacklisted properties.\n  _.omit = function(obj) {\n    var copy = {};\n    var keys = concat.apply(ArrayProto, slice.call(arguments, 1));\n    for (var key in obj) {\n      if (!_.contains(keys, key)) copy[key] = obj[key];\n    }\n    return copy;\n  };\n\n  // Fill in a given object with default properties.\n  _.defaults = function(obj) {\n    each(slice.call(arguments, 1), function(source) {\n      if (source) {\n        for (var prop in source) {\n          if (obj[prop] == null) obj[prop] = source[prop];\n        }\n      }\n    });\n    return obj;\n  };\n\n  // Create a (shallow-cloned) duplicate of an object.\n  _.clone = function(obj) {\n    if (!_.isObject(obj)) return obj;\n    return _.isArray(obj) ? obj.slice() : _.extend({}, obj);\n  };\n\n  // Invokes interceptor with the obj, and then returns obj.\n  // The primary purpose of this method is to "tap into" a method chain, in\n  // order to perform operations on intermediate results within the chain.\n  _.tap = function(obj, interceptor) {\n    interceptor(obj);\n    return obj;\n  };\n\n  // Internal recursive comparison function for `isEqual`.\n  var eq = function(a, b, aStack, bStack) {\n    // Identical objects are equal. `0 === -0`, but they aren\'t identical.\n    // See the Harmony `egal` proposal: http://wiki.ecmascript.org/doku.php?id=harmony:egal.\n    if (a === b) return a !== 0 || 1 / a == 1 / b;\n    // A strict comparison is necessary because `null == undefined`.\n    if (a == null || b == null) return a === b;\n    // Unwrap any wrapped objects.\n    if (a instanceof _) a = a._wrapped;\n    if (b instanceof _) b = b._wrapped;\n    // Compare `[[Class]]` names.\n    var className = toString.call(a);\n    if (className != toString.call(b)) return false;\n    switch (className) {\n      // Strings, numbers, dates, and booleans are compared by value.\n      case \'[object String]\':\n        // Primitives and their corresponding object wrappers are equivalent; thus, `"5"` is\n        // equivalent to `new String("5")`.\n        return a == String(b);\n      case \'[object Number]\':\n        // `NaN`s are equivalent, but non-reflexive. An `egal` comparison is performed for\n        // other numeric values.\n        return a != +a ? b != +b : (a == 0 ? 1 / a == 1 / b : a == +b);\n      case \'[object Date]\':\n      case \'[object Boolean]\':\n        // Coerce dates and booleans to numeric primitive values. Dates are compared by their\n        // millisecond representations. Note that invalid dates with millisecond representations\n        // of `NaN` are not equivalent.\n        return +a == +b;\n      // RegExps are compared by their source patterns and flags.\n      case \'[object RegExp]\':\n        return a.source == b.source &&\n               a.global == b.global &&\n               a.multiline == b.multiline &&\n               a.ignoreCase == b.ignoreCase;\n    }\n    if (typeof a != \'object\' || typeof b != \'object\') return false;\n    // Assume equality for cyclic structures. The algorithm for detecting cyclic\n    // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.\n    var length = aStack.length;\n    while (length--) {\n      // Linear search. Performance is inversely proportional to the number of\n      // unique nested structures.\n      if (aStack[length] == a) return bStack[length] == b;\n    }\n    // Add the first object to the stack of traversed objects.\n    aStack.push(a);\n    bStack.push(b);\n    var size = 0, result = true;\n    // Recursively compare objects and arrays.\n    if (className == \'[object Array]\') {\n      // Compare array lengths to determine if a deep comparison is necessary.\n      size = a.length;\n      result = size == b.length;\n      if (result) {\n        // Deep compare the contents, ignoring non-numeric properties.\n        while (size--) {\n          if (!(result = eq(a[size], b[size], aStack, bStack))) break;\n        }\n      }\n    } else {\n      // Objects with different constructors are not equivalent, but `Object`s\n      // from different frames are.\n      var aCtor = a.constructor, bCtor = b.constructor;\n      if (aCtor !== bCtor && !(_.isFunction(aCtor) && (aCtor instanceof aCtor) &&\n                               _.isFunction(bCtor) && (bCtor instanceof bCtor))) {\n        return false;\n      }\n      // Deep compare objects.\n      for (var key in a) {\n        if (_.has(a, key)) {\n          // Count the expected number of properties.\n          size++;\n          // Deep compare each member.\n          if (!(result = _.has(b, key) && eq(a[key], b[key], aStack, bStack))) break;\n        }\n      }\n      // Ensure that both objects contain the same number of properties.\n      if (result) {\n        for (key in b) {\n          if (_.has(b, key) && !(size--)) break;\n        }\n        result = !size;\n      }\n    }\n    // Remove the first object from the stack of traversed objects.\n    aStack.pop();\n    bStack.pop();\n    return result;\n  };\n\n  // Perform a deep comparison to check if two objects are equal.\n  _.isEqual = function(a, b) {\n    return eq(a, b, [], []);\n  };\n\n  // Is a given array, string, or object empty?\n  // An "empty" object has no enumerable own-properties.\n  _.isEmpty = function(obj) {\n    if (obj == null) return true;\n    if (_.isArray(obj) || _.isString(obj)) return obj.length === 0;\n    for (var key in obj) if (_.has(obj, key)) return false;\n    return true;\n  };\n\n  // Is a given value a DOM element?\n  _.isElement = function(obj) {\n    return !!(obj && obj.nodeType === 1);\n  };\n\n  // Is a given value an array?\n  // Delegates to ECMA5\'s native Array.isArray\n  _.isArray = nativeIsArray || function(obj) {\n    return toString.call(obj) == \'[object Array]\';\n  };\n\n  // Is a given variable an object?\n  _.isObject = function(obj) {\n    return obj === Object(obj);\n  };\n\n  // Add some isType methods: isArguments, isFunction, isString, isNumber, isDate, isRegExp.\n  each([\'Arguments\', \'Function\', \'String\', \'Number\', \'Date\', \'RegExp\'], function(name) {\n    _[\'is\' + name] = function(obj) {\n      return toString.call(obj) == \'[object \' + name + \']\';\n    };\n  });\n\n  // Define a fallback version of the method in browsers (ahem, IE), where\n  // there isn\'t any inspectable "Arguments" type.\n  if (!_.isArguments(arguments)) {\n    _.isArguments = function(obj) {\n      return !!(obj && _.has(obj, \'callee\'));\n    };\n  }\n\n  // Optimize `isFunction` if appropriate.\n  if (typeof (/./) !== \'function\') {\n    _.isFunction = function(obj) {\n      return typeof obj === \'function\';\n    };\n  }\n\n  // Is a given object a finite number?\n  _.isFinite = function(obj) {\n    return isFinite(obj) && !isNaN(parseFloat(obj));\n  };\n\n  // Is the given value `NaN`? (NaN is the only number which does not equal itself).\n  _.isNaN = function(obj) {\n    return _.isNumber(obj) && obj != +obj;\n  };\n\n  // Is a given value a boolean?\n  _.isBoolean = function(obj) {\n    return obj === true || obj === false || toString.call(obj) == \'[object Boolean]\';\n  };\n\n  // Is a given value equal to null?\n  _.isNull = function(obj) {\n    return obj === null;\n  };\n\n  // Is a given variable undefined?\n  _.isUndefined = function(obj) {\n    return obj === void 0;\n  };\n\n  // Shortcut function for checking if an object has a given property directly\n  // on itself (in other words, not on a prototype).\n  _.has = function(obj, key) {\n    return hasOwnProperty.call(obj, key);\n  };\n\n  // Utility Functions\n  // -----------------\n\n  // Run Underscore.js in *noConflict* mode, returning the `_` variable to its\n  // previous owner. Returns a reference to the Underscore object.\n  _.noConflict = function() {\n    root._ = previousUnderscore;\n    return this;\n  };\n\n  // Keep the identity function around for default iterators.\n  _.identity = function(value) {\n    return value;\n  };\n\n  // Run a function **n** times.\n  _.times = function(n, iterator, context) {\n    var accum = Array(n);\n    for (var i = 0; i < n; i++) accum[i] = iterator.call(context, i);\n    return accum;\n  };\n\n  // Return a random integer between min and max (inclusive).\n  _.random = function(min, max) {\n    if (max == null) {\n      max = min;\n      min = 0;\n    }\n    return min + Math.floor(Math.random() * (max - min + 1));\n  };\n\n  // List of HTML entities for escaping.\n  var entityMap = {\n    escape: {\n      \'&\': \'&amp;\',\n      \'<\': \'&lt;\',\n      \'>\': \'&gt;\',\n      \'"\': \'&quot;\',\n      "\'": \'&#x27;\',\n      \'/\': \'&#x2F;\'\n    }\n  };\n  entityMap.unescape = _.invert(entityMap.escape);\n\n  // Regexes containing the keys and values listed immediately above.\n  var entityRegexes = {\n    escape:   new RegExp(\'[\' + _.keys(entityMap.escape).join(\'\') + \']\', \'g\'),\n    unescape: new RegExp(\'(\' + _.keys(entityMap.unescape).join(\'|\') + \')\', \'g\')\n  };\n\n  // Functions for escaping and unescaping strings to/from HTML interpolation.\n  _.each([\'escape\', \'unescape\'], function(method) {\n    _[method] = function(string) {\n      if (string == null) return \'\';\n      return (\'\' + string).replace(entityRegexes[method], function(match) {\n        return entityMap[method][match];\n      });\n    };\n  });\n\n  // If the value of the named property is a function then invoke it;\n  // otherwise, return it.\n  _.result = function(object, property) {\n    if (object == null) return null;\n    var value = object[property];\n    return _.isFunction(value) ? value.call(object) : value;\n  };\n\n  // Add your own custom functions to the Underscore object.\n  _.mixin = function(obj) {\n    each(_.functions(obj), function(name){\n      var func = _[name] = obj[name];\n      _.prototype[name] = function() {\n        var args = [this._wrapped];\n        push.apply(args, arguments);\n        return result.call(this, func.apply(_, args));\n      };\n    });\n  };\n\n  // Generate a unique integer id (unique within the entire client session).\n  // Useful for temporary DOM ids.\n  var idCounter = 0;\n  _.uniqueId = function(prefix) {\n    var id = ++idCounter + \'\';\n    return prefix ? prefix + id : id;\n  };\n\n  // By default, Underscore uses ERB-style template delimiters, change the\n  // following template settings to use alternative delimiters.\n  _.templateSettings = {\n    evaluate    : /<%([\\s\\S]+?)%>/g,\n    interpolate : /<%=([\\s\\S]+?)%>/g,\n    escape      : /<%-([\\s\\S]+?)%>/g\n  };\n\n  // When customizing `templateSettings`, if you don\'t want to define an\n  // interpolation, evaluation or escaping regex, we need one that is\n  // guaranteed not to match.\n  var noMatch = /(.)^/;\n\n  // Certain characters need to be escaped so that they can be put into a\n  // string literal.\n  var escapes = {\n    "\'":      "\'",\n    \'\\\\\':     \'\\\\\',\n    \'\\r\':     \'r\',\n    \'\\n\':     \'n\',\n    \'\\t\':     \'t\',\n    \'\\u2028\': \'u2028\',\n    \'\\u2029\': \'u2029\'\n  };\n\n  var escaper = /\\\\|\'|\\r|\\n|\\t|\\u2028|\\u2029/g;\n\n  // JavaScript micro-templating, similar to John Resig\'s implementation.\n  // Underscore templating handles arbitrary delimiters, preserves whitespace,\n  // and correctly escapes quotes within interpolated code.\n  _.template = function(text, data, settings) {\n    var render;\n    settings = _.defaults({}, settings, _.templateSettings);\n\n    // Combine delimiters into one regular expression via alternation.\n    var matcher = new RegExp([\n      (settings.escape || noMatch).source,\n      (settings.interpolate || noMatch).source,\n      (settings.evaluate || noMatch).source\n    ].join(\'|\') + \'|$\', \'g\');\n\n    // Compile the template source, escaping string literals appropriately.\n    var index = 0;\n    var source = "__p+=\'";\n    text.replace(matcher, function(match, escape, interpolate, evaluate, offset) {\n      source += text.slice(index, offset)\n        .replace(escaper, function(match) { return \'\\\\\' + escapes[match]; });\n\n      if (escape) {\n        source += "\'+\\n((__t=(" + escape + "))==null?\'\':_.escape(__t))+\\n\'";\n      }\n      if (interpolate) {\n        source += "\'+\\n((__t=(" + interpolate + "))==null?\'\':__t)+\\n\'";\n      }\n      if (evaluate) {\n        source += "\';\\n" + evaluate + "\\n__p+=\'";\n      }\n      index = offset + match.length;\n      return match;\n    });\n    source += "\';\\n";\n\n    // If a variable is not specified, place data values in local scope.\n    if (!settings.variable) source = \'with(obj||{}){\\n\' + source + \'}\\n\';\n\n    source = "var __t,__p=\'\',__j=Array.prototype.join," +\n      "print=function(){__p+=__j.call(arguments,\'\');};\\n" +\n      source + "return __p;\\n";\n\n    try {\n      render = new Function(settings.variable || \'obj\', \'_\', source);\n    } catch (e) {\n      e.source = source;\n      throw e;\n    }\n\n    if (data) return render(data, _);\n    var template = function(data) {\n      return render.call(this, data, _);\n    };\n\n    // Provide the compiled function source as a convenience for precompilation.\n    template.source = \'function(\' + (settings.variable || \'obj\') + \'){\\n\' + source + \'}\';\n\n    return template;\n  };\n\n  // Add a "chain" function, which will delegate to the wrapper.\n  _.chain = function(obj) {\n    return _(obj).chain();\n  };\n\n  // OOP\n  // ---------------\n  // If Underscore is called as a function, it returns a wrapped object that\n  // can be used OO-style. This wrapper holds altered versions of all the\n  // underscore functions. Wrapped objects may be chained.\n\n  // Helper function to continue chaining intermediate results.\n  var result = function(obj) {\n    return this._chain ? _(obj).chain() : obj;\n  };\n\n  // Add all of the Underscore functions to the wrapper object.\n  _.mixin(_);\n\n  // Add all mutator Array functions to the wrapper.\n  each([\'pop\', \'push\', \'reverse\', \'shift\', \'sort\', \'splice\', \'unshift\'], function(name) {\n    var method = ArrayProto[name];\n    _.prototype[name] = function() {\n      var obj = this._wrapped;\n      method.apply(obj, arguments);\n      if ((name == \'shift\' || name == \'splice\') && obj.length === 0) delete obj[0];\n      return result.call(this, obj);\n    };\n  });\n\n  // Add all accessor Array functions to the wrapper.\n  each([\'concat\', \'join\', \'slice\'], function(name) {\n    var method = ArrayProto[name];\n    _.prototype[name] = function() {\n      return result.call(this, method.apply(this._wrapped, arguments));\n    };\n  });\n\n  _.extend(_.prototype, {\n\n    // Start chaining a wrapped Underscore object.\n    chain: function() {\n      this._chain = true;\n      return this;\n    },\n\n    // Extracts the result from a wrapped and chained object.\n    value: function() {\n      return this._wrapped;\n    }\n\n  });\n\n}).call(this);\n\n/*global _: false, $: false, localStorage: false, process: true,\n  XMLHttpRequest: false, XDomainRequest: false, exports: false,\n  require: false */\n(function(root) {\n  root.Parse = root.Parse || {};\n  /**\n   * Contains all Parse API classes and functions.\n   * @name Parse\n   * @namespace\n   *\n   * Contains all Parse API classes and functions.\n   */\n  var Parse = root.Parse;\n\n  // Import Parse\'s local copy of underscore.\n  if (typeof(exports) !== "undefined" && exports._) {\n    // We\'re running in Node.js.  Pull in the dependencies.\n    Parse._ = exports._.noConflict();\n    Parse.localStorage = require(\'localStorage\');\n    Parse.XMLHttpRequest = require(\'xmlhttprequest\').XMLHttpRequest;\n    exports.Parse = Parse;\n  } else {\n    Parse._ = _.noConflict();\n    if (typeof(localStorage) !== "undefined") {\n      Parse.localStorage = localStorage;\n    }\n    if (typeof(XMLHttpRequest) !== "undefined") {\n      Parse.XMLHttpRequest = XMLHttpRequest;\n    }\n  }\n\n  // If jQuery or Zepto has been included, grab a reference to it.\n  if (typeof($) !== "undefined") {\n    Parse.$ = $;\n  }\n\n  // Helpers\n  // -------\n\n  // Shared empty constructor function to aid in prototype-chain creation.\n  var EmptyConstructor = function() {};\n\n\n  // Helper function to correctly set up the prototype chain, for subclasses.\n  // Similar to `goog.inherits`, but uses a hash of prototype properties and\n  // class properties to be extended.\n  var inherits = function(parent, protoProps, staticProps) {\n    var child;\n\n    // The constructor function for the new subclass is either defined by you\n    // (the "constructor" property in your `extend` definition), or defaulted\n    // by us to simply call the parent\'s constructor.\n    if (protoProps && protoProps.hasOwnProperty(\'constructor\')) {\n      child = protoProps.constructor;\n    } else {\n      /** @ignore */\n      child = function(){ parent.apply(this, arguments); };\n    }\n\n    // Inherit class (static) properties from parent.\n    Parse._.extend(child, parent);\n\n    // Set the prototype chain to inherit from `parent`, without calling\n    // `parent`\'s constructor function.\n    EmptyConstructor.prototype = parent.prototype;\n    child.prototype = new EmptyConstructor();\n\n    // Add prototype properties (instance properties) to the subclass,\n    // if supplied.\n    if (protoProps) {\n      Parse._.extend(child.prototype, protoProps);\n    }\n\n    // Add static properties to the constructor function, if supplied.\n    if (staticProps) {\n      Parse._.extend(child, staticProps);\n    }\n\n    // Correctly set child\'s `prototype.constructor`.\n    child.prototype.constructor = child;\n\n    // Set a convenience property in case the parent\'s prototype is\n    // needed later.\n    child.__super__ = parent.prototype;\n\n    return child;\n  };\n\n  // Set the server for Parse to talk to.\n  Parse.serverURL = "https://api.parse.com";\n\n  // Check whether we are running in Node.js.\n  if (typeof(process) !== "undefined" &&\n      process.versions &&\n      process.versions.node) {\n    Parse._isNode = true;\n  }\n\n  /**\n   * Call this method first to set up your authentication tokens for Parse.\n   * You can get your keys from the Data Browser on parse.com.\n   * @param {String} applicationId Your Parse Application ID.\n   * @param {String} javaScriptKey Your Parse JavaScript Key.\n   * @param {String} masterKey (optional) Your Parse Master Key. (Node.js only!)\n   */\n  Parse.initialize = function(applicationId, javaScriptKey, masterKey) {\n    if (masterKey) {\n      throw "Parse.initialize() was passed a Master Key, which is only " +\n        "allowed from within Node.js.";\n    }\n    Parse._initialize(applicationId, javaScriptKey);\n  };\n\n  /**\n   * Call this method first to set up master authentication tokens for Parse.\n   * This method is for Parse\'s own private use.\n   * @param {String} applicationId Your Parse Application ID.\n   * @param {String} javaScriptKey Your Parse JavaScript Key.\n   * @param {String} masterKey Your Parse Master Key.\n   */\n  Parse._initialize = function(applicationId, javaScriptKey, masterKey) {\n    Parse.applicationId = applicationId;\n    Parse.javaScriptKey = javaScriptKey;\n    Parse.masterKey = masterKey;\n    Parse._useMasterKey = false;\n  };\n\n  // If we\'re running in node.js, allow using the master key.\n  if (Parse._isNode) {\n    Parse.initialize = Parse._initialize;\n\n    Parse.Cloud = Parse.Cloud || {};\n    /**\n     * Switches the Parse SDK to using the Master key.  The Master key grants\n     * priveleged access to the data in Parse and can be used to bypass ACLs and\n     * other restrictions that are applied to the client SDKs.\n     * <p><strong><em>Available in Cloud Code and Node.js only.</em></strong>\n     * </p>\n     */\n    Parse.Cloud.useMasterKey = function() {\n      Parse._useMasterKey = true;\n    };\n  }\n\n  /**\n   * Returns prefix for localStorage keys used by this instance of Parse.\n   * @param {String} path The relative suffix to append to it.\n   *     null or undefined is treated as the empty string.\n   * @return {String} The full key name.\n   */\n  Parse._getParsePath = function(path) {\n    if (!Parse.applicationId) {\n      throw "You need to call Parse.initialize before using Parse.";\n    }\n    if (!path) {\n      path = "";\n    }\n    if (!Parse._.isString(path)) {\n      throw "Tried to get a localStorage path that wasn\'t a String.";\n    }\n    if (path[0] === "/") {\n      path = path.substring(1);\n    }\n    return "Parse/" + Parse.applicationId + "/" + path;\n  };\n\n  /**\n   * Returns the unique string for this app on this machine.\n   * Gets reset when localStorage is cleared.\n   */\n  Parse._installationId = null;\n  Parse._getInstallationId = function() {\n    // See if it\'s cached in RAM.\n    if (Parse._installationId) {\n      return Parse._installationId;\n    }\n\n    // Try to get it from localStorage.\n    var path = Parse._getParsePath("installationId");\n    Parse._installationId = Parse.localStorage.getItem(path);\n\n    if (!Parse._installationId || Parse._installationId === "") {\n      // It wasn\'t in localStorage, so create a new one.\n      var hexOctet = function() {\n        return Math.floor((1+Math.random())*0x10000).toString(16).substring(1);\n      };\n      Parse._installationId = (\n        hexOctet() + hexOctet() + "-" +\n        hexOctet() + "-" +\n        hexOctet() + "-" +\n        hexOctet() + "-" +\n        hexOctet() + hexOctet() + hexOctet());\n      Parse.localStorage.setItem(path, Parse._installationId);\n    }\n\n    return Parse._installationId;\n  };\n\n  Parse._parseDate = function(iso8601) {\n    var regexp = new RegExp(\n      "^([0-9]{1,4})-([0-9]{1,2})-([0-9]{1,2})" + "T" +\n      "([0-9]{1,2}):([0-9]{1,2}):([0-9]{1,2})" +\n      "(.([0-9]+))?" + "Z$");\n    var match = regexp.exec(iso8601);\n    if (!match) {\n      var date = new Date(iso8601);\n      return date.getTime() === NaN ? null : date;\n    }\n\n    var year = match[1] || 0;\n    var month = (match[2] || 1) - 1;\n    var day = match[3] || 0;\n    var hour = match[4] || 0;\n    var minute = match[5] || 0;\n    var second = match[6] || 0;\n    var milli = match[8] || 0;\n\n    return new Date(Date.UTC(year, month, day, hour, minute, second, milli));\n  };\n\n  Parse._ajaxIE8 = function(method, url, data) {\n    var promise = new Parse.Promise();\n    var xdr = new XDomainRequest();\n    xdr.onload = function() {\n      var response;\n      try {\n        response = JSON.parse(xdr.responseText);\n      } catch (e) {\n        promise.reject(e);\n      }\n      if (response) {\n        promise.resolve(response);\n      }\n    };\n    xdr.onerror = xdr.ontimeout = function() {\n      // Let\'s fake a real error message.\n      var fakeResponse = {\n        responseText: JSON.stringify({\n          code: Parse.Error.X_DOMAIN_REQUEST,\n          error: "IE\'s XDomainRequest does not supply error info."\n        })\n      };\n      promise.reject(fakeResponse);\n    };\n    xdr.onprogress = function() {};\n    xdr.open(method, url);\n    xdr.send(data);\n    return promise;\n  };\n\n  Parse._useXDomainRequest = function() {\n    if (typeof(XDomainRequest) !== "undefined") {\n      // We\'re in IE 8+.\n      if (\'withCredentials\' in new XMLHttpRequest()) {\n        // We\'re in IE 10+.\n        return false;\n      }\n      return true;\n    }\n    return false;\n  };\n\n\n  Parse._ajax = function(method, url, data, success, error) {\n    var options = {\n      success: success,\n      error: error\n    };\n\n    if (Parse._useXDomainRequest()) {\n      return Parse._ajaxIE8(method, url, data)._thenRunCallbacks(options);\n    }\n\n    var promise = new Parse.Promise();\n    var handled = false;\n\n    var xhr = new Parse.XMLHttpRequest();\n    xhr.onreadystatechange = function() {\n      if (xhr.readyState === 4) {\n        if (handled) {\n          return;\n        }\n        handled = true;\n\n        if (xhr.status >= 200 && xhr.status < 300) {\n          var response;\n          try {\n            response = JSON.parse(xhr.responseText);\n          } catch (e) {\n            promise.reject(e);\n          }\n          if (response) {\n            promise.resolve(response, xhr.status, xhr);\n          }\n        } else {\n          promise.reject(xhr);\n        }\n      }\n    };\n    xhr.open(method, url, true);\n    xhr.setRequestHeader("Content-Type", "text/plain");  // avoid pre-flight.\n    if (Parse._isNode) {\n      // Add a special user agent just for request from node.js.\n      xhr.setRequestHeader("User-Agent",\n                           "Parse/" + Parse.VERSION +\n                           " (NodeJS " + process.versions.node + ")");\n    }\n    xhr.send(data);\n    return promise._thenRunCallbacks(options);\n  };\n\n  // A self-propagating extend function.\n  Parse._extend = function(protoProps, classProps) {\n    var child = inherits(this, protoProps, classProps);\n    child.extend = this.extend;\n    return child;\n  };\n\n  /**\n   * Options:\n   *   route: is classes, users, login, etc.\n   *   objectId: null if there is no associated objectId.\n   *   method: the http method for the REST API.\n   *   dataObject: the payload as an object, or null if there is none.\n   *   useMasterKey: overrides whether to use the master key if set.\n   * @ignore\n   */\n  Parse._request = function(options) {\n    var route = options.route;\n    var className = options.className;\n    var objectId = options.objectId;\n    var method = options.method;\n    var useMasterKey = options.useMasterKey;\n    var sessionToken = options.sessionToken;\n    var dataObject = options.data;\n\n    if (!Parse.applicationId) {\n      throw "You must specify your applicationId using Parse.initialize.";\n    }\n\n    if (!Parse.javaScriptKey && !Parse.masterKey) {\n      throw "You must specify a key using Parse.initialize.";\n    }\n\n\n    if (!sessionToken) {\n      // Use the current user session token if none was provided.\n      var currentUser = Parse.User.current();\n      if (currentUser && currentUser._sessionToken) {\n        sessionToken = currentUser._sessionToken;\n      }\n    }\n\n\n    if (route !== "batch" &&\n        route !== "classes" &&\n        route !== "events" &&\n        route !== "files" &&\n        route !== "functions" &&\n        route !== "login" &&\n        route !== "push" &&\n        route !== "requestPasswordReset" &&\n        route !== "rest_verify_analytics" &&\n        route !== "users" &&\n        route !== "jobs") {\n      throw "Bad route: \'" + route + "\'.";\n    }\n\n    var url = Parse.serverURL;\n    if (url.charAt(url.length - 1) !== "/") {\n      url += "/";\n    }\n    url += "1/" + route;\n    if (className) {\n      url += "/" + className;\n    }\n    if (objectId) {\n      url += "/" + objectId;\n    }\n\n    dataObject = Parse._.clone(dataObject || {});\n    if (method !== "POST") {\n      dataObject._method = method;\n      method = "POST";\n    }\n\n    if (Parse._.isUndefined(useMasterKey)) {\n      useMasterKey = Parse._useMasterKey;\n    }\n\n    dataObject._ApplicationId = Parse.applicationId;\n    if (!useMasterKey) {\n      dataObject._JavaScriptKey = Parse.javaScriptKey;\n    } else {\n      dataObject._MasterKey = Parse.masterKey;\n    }\n\n    dataObject._ClientVersion = Parse.VERSION;\n    dataObject._InstallationId = Parse._getInstallationId();\n    if (sessionToken) {\n      dataObject._SessionToken = sessionToken;\n    }\n    var data = JSON.stringify(dataObject);\n\n    return Parse._ajax(method, url, data).then(null, function(response) {\n      // Transform the error into an instance of Parse.Error by trying to parse\n      // the error string as JSON.\n      var error;\n      if (response && response.responseText) {\n        try {\n          var errorJSON = JSON.parse(response.responseText);\n          error = new Parse.Error(errorJSON.code, errorJSON.error);\n        } catch (e) {\n          // If we fail to parse the error text, that\'s okay.\n          error = new Parse.Error(\n              Parse.Error.INVALID_JSON,\n              "Received an error with invalid JSON from Parse: " +\n                  response.responseText);\n        }\n      } else {\n        error = new Parse.Error(\n            Parse.Error.CONNECTION_FAILED,\n            "XMLHttpRequest failed: " + JSON.stringify(response));\n      }\n      // By explicitly returning a rejected Promise, this will work with\n      // either jQuery or Promises/A semantics.\n      return Parse.Promise.error(error);\n    });\n  };\n\n  // Helper function to get a value from a Backbone object as a property\n  // or as a function.\n  Parse._getValue = function(object, prop) {\n    if (!(object && object[prop])) {\n      return null;\n    }\n    return Parse._.isFunction(object[prop]) ? object[prop]() : object[prop];\n  };\n\n  /**\n   * Converts a value in a Parse Object into the appropriate representation.\n   * This is the JS equivalent of Java\'s Parse.maybeReferenceAndEncode(Object)\n   * if seenObjects is falsey. Otherwise any Parse.Objects not in\n   * seenObjects will be fully embedded rather than encoded\n   * as a pointer.  This array will be used to prevent going into an infinite\n   * loop because we have circular references.  If seenObjects\n   * is set, then none of the Parse Objects that are serialized can be dirty.\n   */\n  Parse._encode = function(value, seenObjects, disallowObjects) {\n    var _ = Parse._;\n    if (value instanceof Parse.Object) {\n      if (disallowObjects) {\n        throw "Parse.Objects not allowed here";\n      }\n      if (!seenObjects || _.include(seenObjects, value) || !value._hasData) {\n        return value._toPointer();\n      }\n      if (!value.dirty()) {\n        seenObjects = seenObjects.concat(value);\n        return Parse._encode(value._toFullJSON(seenObjects),\n                             seenObjects,\n                             disallowObjects);\n      }\n      throw "Tried to save an object with a pointer to a new, unsaved object.";\n    }\n    if (value instanceof Parse.ACL) {\n      return value.toJSON();\n    }\n    if (_.isDate(value)) {\n      return { "__type": "Date", "iso": value.toJSON() };\n    }\n    if (value instanceof Parse.GeoPoint) {\n      return value.toJSON();\n    }\n    if (_.isArray(value)) {\n      return _.map(value, function(x) {\n        return Parse._encode(x, seenObjects, disallowObjects);\n      });\n    }\n    if (_.isRegExp(value)) {\n      return value.source;\n    }\n    if (value instanceof Parse.Relation) {\n      return value.toJSON();\n    }\n    if (value instanceof Parse.Op) {\n      return value.toJSON();\n    }\n    if (value instanceof Parse.File) {\n      if (!value.url()) {\n        throw "Tried to save an object containing an unsaved file.";\n      }\n      return {\n        __type: "File",\n        name: value.name(),\n        url: value.url()\n      };\n    }\n    if (_.isObject(value)) {\n      var output = {};\n      Parse._objectEach(value, function(v, k) {\n        output[k] = Parse._encode(v, seenObjects, disallowObjects);\n      });\n      return output;\n    }\n    return value;\n  };\n\n  /**\n   * The inverse function of Parse._encode.\n   * TODO: make decode not mutate value.\n   */\n  Parse._decode = function(key, value) {\n    var _ = Parse._;\n    if (!_.isObject(value)) {\n      return value;\n    }\n    if (_.isArray(value)) {\n      Parse._arrayEach(value, function(v, k) {\n        value[k] = Parse._decode(k, v);\n      });\n      return value;\n    }\n    if (value instanceof Parse.Object) {\n      return value;\n    }\n    if (value instanceof Parse.File) {\n      return value;\n    }\n    if (value instanceof Parse.Op) {\n      return value;\n    }\n    if (value.__op) {\n      return Parse.Op._decode(value);\n    }\n    if (value.__type === "Pointer") {\n      var pointer = Parse.Object._create(value.className);\n      pointer._finishFetch({ objectId: value.objectId }, false);\n      return pointer;\n    }\n    if (value.__type === "Object") {\n      // It\'s an Object included in a query result.\n      var className = value.className;\n      delete value.__type;\n      delete value.className;\n      var object = Parse.Object._create(className);\n      object._finishFetch(value, true);\n      return object;\n    }\n    if (value.__type === "Date") {\n      return Parse._parseDate(value.iso);\n    }\n    if (value.__type === "GeoPoint") {\n      return new Parse.GeoPoint({\n        latitude: value.latitude,\n        longitude: value.longitude\n      });\n    }\n    if (key === "ACL") {\n      if (value instanceof Parse.ACL) {\n        return value;\n      }\n      return new Parse.ACL(value);\n    }\n    if (value.__type === "Relation") {\n      var relation = new Parse.Relation(null, key);\n      relation.targetClassName = value.className;\n      return relation;\n    }\n    if (value.__type === "File") {\n      var file = new Parse.File(value.name);\n      file._url = value.url;\n      return file;\n    }\n    Parse._objectEach(value, function(v, k) {\n      value[k] = Parse._decode(k, v);\n    });\n    return value;\n  };\n\n  Parse._arrayEach = Parse._.each;\n\n  /**\n   * Does a deep traversal of every item in object, calling func on every one.\n   * @param {Object} object The object or array to traverse deeply.\n   * @param {Function} func The function to call for every item. It will\n   *     be passed the item as an argument. If it returns a truthy value, that\n   *     value will replace the item in its parent container.\n   * @returns {} the result of calling func on the top-level object itself.\n   */\n  Parse._traverse = function(object, func, seen) {\n    if (object instanceof Parse.Object) {\n      seen = seen || [];\n      if (Parse._.indexOf(seen, object) >= 0) {\n        // We\'ve already visited this object in this call.\n        return;\n      }\n      seen.push(object);\n      Parse._traverse(object.attributes, func, seen);\n      return func(object);\n    }\n    if (object instanceof Parse.Relation || object instanceof Parse.File) {\n      // Nothing needs to be done, but we don\'t want to recurse into the\n      // object\'s parent infinitely, so we catch this case.\n      return func(object);\n    }\n    if (Parse._.isArray(object)) {\n      Parse._.each(object, function(child, index) {\n        var newChild = Parse._traverse(child, func, seen);\n        if (newChild) {\n          object[index] = newChild;\n        }\n      });\n      return func(object);\n    }\n    if (Parse._.isObject(object)) {\n      Parse._each(object, function(child, key) {\n        var newChild = Parse._traverse(child, func, seen);\n        if (newChild) {\n          object[key] = newChild;\n        }\n      });\n      return func(object);\n    }\n    return func(object);\n  };\n\n  /**\n   * This is like _.each, except:\n   * * it doesn\'t work for so-called array-like objects,\n   * * it does work for dictionaries with a "length" attribute.\n   */\n  Parse._objectEach = Parse._each = function(obj, callback) {\n    var _ = Parse._;\n    if (_.isObject(obj)) {\n      _.each(_.keys(obj), function(key) {\n        callback(obj[key], key);\n      });\n    } else {\n      _.each(obj, callback);\n    }\n  };\n\n  // Helper function to check null or undefined.\n  Parse._isNullOrUndefined = function(x) {\n    return Parse._.isNull(x) || Parse._.isUndefined(x);\n  };\n}(this));\n\n(function(root) {\n  root.Parse = root.Parse || {};\n  var Parse = root.Parse;\n  var _ = Parse._;\n\n  /**\n   * @namespace Provides an interface to Parse\'s logging and analytics backend.\n   */\n  Parse.Analytics = Parse.Analytics || {};\n\n  _.extend(Parse.Analytics, /** @lends Parse.Analytics */ {\n    /**\n     * Tracks the occurrence of a custom event with additional dimensions.\n     * Parse will store a data point at the time of invocation with the given\n     * event name.\n     *\n     * Dimensions will allow segmentation of the occurrences of this custom\n     * event. Keys and values should be {@code String}s, and will throw\n     * otherwise.\n     *\n     * To track a user signup along with additional metadata, consider the\n     * following:\n     * <pre>\n     * var dimensions = {\n     *  gender: \'m\',\n     *  source: \'web\',\n     *  dayType: \'weekend\'\n     * };\n     * Parse.Analytics.track(\'signup\', dimensions);\n     * </pre>\n     *\n     * There is a default limit of 4 dimensions per event tracked.\n     *\n     * @param {String} name The name of the custom event to report to Parse as\n     * having happened.\n     * @param {Object} dimensions The dictionary of information by which to\n     * segment this event.\n     * @return {Parse.Promise} A promise that is resolved when the round-trip\n     * to the server completes.\n     */\n    track: function(name, dimensions) {\n      name = name || \'\';\n      name = name.replace(/^\\s*/, \'\');\n      name = name.replace(/\\s*$/, \'\');\n      if (name.length === 0) {\n        throw \'A name for the custom event must be provided\';\n      }\n\n      _.each(dimensions, function(val, key) {\n        if (!_.isString(key) || !_.isString(val)) {\n          throw \'track() dimensions expects keys and values of type "string".\';\n        }\n      });\n\n      return Parse._request({\n        route: \'events\',\n        className: name,\n        method: \'POST\',\n        data: { dimensions: dimensions }\n      });\n    }\n  });\n}(this));\n\n(function(root) {\n  root.Parse = root.Parse || {};\n  var Parse = root.Parse;\n  var _ = Parse._;\n\n  /**\n   * Constructs a new Parse.Error object with the given code and message.\n   * @param {Number} code An error code constant from <code>Parse.Error</code>.\n   * @param {String} message A detailed description of the error.\n   * @class\n   *\n   * <p>Class used for all objects passed to error callbacks.</p>\n   */\n  Parse.Error = function(code, message) {\n    this.code = code;\n    this.message = message;\n  };\n\n  _.extend(Parse.Error, /** @lends Parse.Error */ {\n    /**\n     * Error code indicating some error other than those enumerated here.\n     * @constant\n     */\n    OTHER_CAUSE: -1,\n\n    /**\n     * Error code indicating that something has gone wrong with the server.\n     * If you get this error code, it is Parse\'s fault. Contact us at\n     * https://parse.com/help\n     * @constant\n     */\n    INTERNAL_SERVER_ERROR: 1,\n\n    /**\n     * Error code indicating the connection to the Parse servers failed.\n     * @constant\n     */\n    CONNECTION_FAILED: 100,\n\n    /**\n     * Error code indicating the specified object doesn\'t exist.\n     * @constant\n     */\n    OBJECT_NOT_FOUND: 101,\n\n    /**\n     * Error code indicating you tried to query with a datatype that doesn\'t\n     * support it, like exact matching an array or object.\n     * @constant\n     */\n    INVALID_QUERY: 102,\n\n    /**\n     * Error code indicating a missing or invalid classname. Classnames are\n     * case-sensitive. They must start with a letter, and a-zA-Z0-9_ are the\n     * only valid characters.\n     * @constant\n     */\n    INVALID_CLASS_NAME: 103,\n\n    /**\n     * Error code indicating an unspecified object id.\n     * @constant\n     */\n    MISSING_OBJECT_ID: 104,\n\n    /**\n     * Error code indicating an invalid key name. Keys are case-sensitive. They\n     * must start with a letter, and a-zA-Z0-9_ are the only valid characters.\n     * @constant\n     */\n    INVALID_KEY_NAME: 105,\n\n    /**\n     * Error code indicating a malformed pointer. You should not see this unless\n     * you have been mucking about changing internal Parse code.\n     * @constant\n     */\n    INVALID_POINTER: 106,\n\n    /**\n     * Error code indicating that badly formed JSON was received upstream. This\n     * either indicates you have done something unusual with modifying how\n     * things encode to JSON, or the network is failing badly.\n     * @constant\n     */\n    INVALID_JSON: 107,\n\n    /**\n     * Error code indicating that the feature you tried to access is only\n     * available internally for testing purposes.\n     * @constant\n     */\n    COMMAND_UNAVAILABLE: 108,\n\n    /**\n     * You must call Parse.initialize before using the Parse library.\n     * @constant\n     */\n    NOT_INITIALIZED: 109,\n\n    /**\n     * Error code indicating that a field was set to an inconsistent type.\n     * @constant\n     */\n    INCORRECT_TYPE: 111,\n\n    /**\n     * Error code indicating an invalid channel name. A channel name is either\n     * an empty string (the broadcast channel) or contains only a-zA-Z0-9_\n     * characters and starts with a letter.\n     * @constant\n     */\n    INVALID_CHANNEL_NAME: 112,\n\n    /**\n     * Error code indicating that push is misconfigured.\n     * @constant\n     */\n    PUSH_MISCONFIGURED: 115,\n\n    /**\n     * Error code indicating that the object is too large.\n     * @constant\n     */\n    OBJECT_TOO_LARGE: 116,\n\n    /**\n     * Error code indicating that the operation isn\'t allowed for clients.\n     * @constant\n     */\n    OPERATION_FORBIDDEN: 119,\n\n    /**\n     * Error code indicating the result was not found in the cache.\n     * @constant\n     */\n    CACHE_MISS: 120,\n\n    /**\n     * Error code indicating that an invalid key was used in a nested\n     * JSONObject.\n     * @constant\n     */\n    INVALID_NESTED_KEY: 121,\n\n    /**\n     * Error code indicating that an invalid filename was used for ParseFile.\n     * A valid file name contains only a-zA-Z0-9_. characters and is between 1\n     * and 128 characters.\n     * @constant\n     */\n    INVALID_FILE_NAME: 122,\n\n    /**\n     * Error code indicating an invalid ACL was provided.\n     * @constant\n     */\n    INVALID_ACL: 123,\n\n    /**\n     * Error code indicating that the request timed out on the server. Typically\n     * this indicates that the request is too expensive to run.\n     * @constant\n     */\n    TIMEOUT: 124,\n\n    /**\n     * Error code indicating that the email address was invalid.\n     * @constant\n     */\n    INVALID_EMAIL_ADDRESS: 125,\n\n    /**\n     * Error code indicating a missing content type.\n     * @constant\n     */\n    MISSING_CONTENT_TYPE: 126,\n\n    /**\n     * Error code indicating a missing content length.\n     * @constant\n     */\n    MISSING_CONTENT_LENGTH: 127,\n\n    /**\n     * Error code indicating an invalid content length.\n     * @constant\n     */\n    INVALID_CONTENT_LENGTH: 128,\n\n    /**\n     * Error code indicating a file that was too large.\n     * @constant\n     */\n    FILE_TOO_LARGE: 129,\n\n    /**\n     * Error code indicating an error saving a file.\n     * @constant\n     */\n    FILE_SAVE_ERROR: 130,\n\n    /**\n     * Error code indicating an error deleting a file.\n     * @constant\n     */\n    FILE_DELETE_ERROR: 153,\n\n    /**\n     * Error code indicating that a unique field was given a value that is\n     * already taken.\n     * @constant\n     */\n    DUPLICATE_VALUE: 137,\n\n    /**\n     * Error code indicating that a role\'s name is invalid.\n     * @constant\n     */\n    INVALID_ROLE_NAME: 139,\n\n    /**\n     * Error code indicating that an application quota was exceeded.  Upgrade to\n     * resolve.\n     * @constant\n     */\n    EXCEEDED_QUOTA: 140,\n\n    /**\n     * Error code indicating that a Cloud Code script failed.\n     * @constant\n     */\n    SCRIPT_FAILED: 141,\n\n    /**\n     * Error code indicating that a Cloud Code validation failed.\n     * @constant\n     */\n    VALIDATION_ERROR: 142,\n\n    /**\n     * Error code indicating that invalid image data was provided.\n     * @constant\n     */\n    INVALID_IMAGE_DATA: 150,\n\n    /**\n     * Error code indicating an unsaved file.\n     * @constant\n     */\n    UNSAVED_FILE_ERROR: 151,\n\n    /**\n     * Error code indicating an invalid push time.\n     */\n    INVALID_PUSH_TIME_ERROR: 152,\n\n    /**\n     * Error code indicating that the username is missing or empty.\n     * @constant\n     */\n    USERNAME_MISSING: 200,\n\n    /**\n     * Error code indicating that the password is missing or empty.\n     * @constant\n     */\n    PASSWORD_MISSING: 201,\n\n    /**\n     * Error code indicating that the username has already been taken.\n     * @constant\n     */\n    USERNAME_TAKEN: 202,\n\n    /**\n     * Error code indicating that the email has already been taken.\n     * @constant\n     */\n    EMAIL_TAKEN: 203,\n\n    /**\n     * Error code indicating that the email is missing, but must be specified.\n     * @constant\n     */\n    EMAIL_MISSING: 204,\n\n    /**\n     * Error code indicating that a user with the specified email was not found.\n     * @constant\n     */\n    EMAIL_NOT_FOUND: 205,\n\n    /**\n     * Error code indicating that a user object without a valid session could\n     * not be altered.\n     * @constant\n     */\n    SESSION_MISSING: 206,\n\n    /**\n     * Error code indicating that a user can only be created through signup.\n     * @constant\n     */\n    MUST_CREATE_USER_THROUGH_SIGNUP: 207,\n\n    /**\n     * Error code indicating that an an account being linked is already linked\n     * to another user.\n     * @constant\n     */\n    ACCOUNT_ALREADY_LINKED: 208,\n\n    /**\n     * Error code indicating that a user cannot be linked to an account because\n     * that account\'s id could not be found.\n     * @constant\n     */\n    LINKED_ID_MISSING: 250,\n\n    /**\n     * Error code indicating that a user with a linked (e.g. Facebook) account\n     * has an invalid session.\n     * @constant\n     */\n    INVALID_LINKED_SESSION: 251,\n\n    /**\n     * Error code indicating that a service being linked (e.g. Facebook or\n     * Twitter) is unsupported.\n     * @constant\n     */\n    UNSUPPORTED_SERVICE: 252,\n\n    /**\n     * Error code indicating that there were multiple errors. Aggregate errors\n     * have an "errors" property, which is an array of error objects with more\n     * detail about each error that occurred.\n     * @constant\n     */\n    AGGREGATE_ERROR: 600,\n\n    /**\n     * Error code indicating the client was unable to read an input file.\n     * @constant\n     */\n    FILE_READ_ERROR: 601,\n\n    /**\n     * Error code indicating a real error code is unavailable because\n     * we had to use an XDomainRequest object to allow CORS requests in\n     * Internet Explorer, which strips the body from HTTP responses that have\n     * a non-2XX status code.\n     * @constant\n     */\n    X_DOMAIN_REQUEST: 602\n  });\n\n}(this));\n\n/*global _: false */\n(function() {\n  var root = this;\n  var Parse = (root.Parse || (root.Parse = {}));\n  var eventSplitter = /\\s+/;\n  var slice = Array.prototype.slice;\n\n  /**\n   * @class\n   *\n   * <p>Parse.Events is a fork of Backbone\'s Events module, provided for your\n   * convenience.</p>\n   *\n   * <p>A module that can be mixed in to any object in order to provide\n   * it with custom events. You may bind callback functions to an event\n   * with `on`, or remove these functions with `off`.\n   * Triggering an event fires all callbacks in the order that `on` was\n   * called.\n   *\n   * <pre>\n   *     var object = {};\n   *     _.extend(object, Parse.Events);\n   *     object.on(\'expand\', function(){ alert(\'expanded\'); });\n   *     object.trigger(\'expand\');</pre></p>\n   *\n   * <p>For more information, see the\n   * <a href="http://documentcloud.github.com/backbone/#Events">Backbone\n   * documentation</a>.</p>\n   */\n  Parse.Events = {\n    /**\n     * Bind one or more space separated events, `events`, to a `callback`\n     * function. Passing `"all"` will bind the callback to all events fired.\n     */\n    on: function(events, callback, context) {\n\n      var calls, event, node, tail, list;\n      if (!callback) {\n        return this;\n      }\n      events = events.split(eventSplitter);\n      calls = this._callbacks || (this._callbacks = {});\n\n      // Create an immutable callback list, allowing traversal during\n      // modification.  The tail is an empty object that will always be used\n      // as the next node.\n      event = events.shift();\n      while (event) {\n        list = calls[event];\n        node = list ? list.tail : {};\n        node.next = tail = {};\n        node.context = context;\n        node.callback = callback;\n        calls[event] = {tail: tail, next: list ? list.next : node};\n        event = events.shift();\n      }\n\n      return this;\n    },\n\n    /**\n     * Remove one or many callbacks. If `context` is null, removes all callbacks\n     * with that function. If `callback` is null, removes all callbacks for the\n     * event. If `events` is null, removes all bound callbacks for all events.\n     */\n    off: function(events, callback, context) {\n      var event, calls, node, tail, cb, ctx;\n\n      // No events, or removing *all* events.\n      if (!(calls = this._callbacks)) {\n        return;\n      }\n      if (!(events || callback || context)) {\n        delete this._callbacks;\n        return this;\n      }\n\n      // Loop through the listed events and contexts, splicing them out of the\n      // linked list of callbacks if appropriate.\n      events = events ? events.split(eventSplitter) : _.keys(calls);\n      event = events.shift();\n      while (event) {\n        node = calls[event];\n        delete calls[event];\n        if (!node || !(callback || context)) {\n          continue;\n        }\n        // Create a new list, omitting the indicated callbacks.\n        tail = node.tail;\n        node = node.next;\n        while (node !== tail) {\n          cb = node.callback;\n          ctx = node.context;\n          if ((callback && cb !== callback) || (context && ctx !== context)) {\n            this.on(event, cb, ctx);\n          }\n          node = node.next;\n        }\n        event = events.shift();\n      }\n\n      return this;\n    },\n\n    /**\n     * Trigger one or many events, firing all bound callbacks. Callbacks are\n     * passed the same arguments as `trigger` is, apart from the event name\n     * (unless you\'re listening on `"all"`, which will cause your callback to\n     * receive the true name of the event as the first argument).\n     */\n    trigger: function(events) {\n      var event, node, calls, tail, args, all, rest;\n      if (!(calls = this._callbacks)) {\n        return this;\n      }\n      all = calls.all;\n      events = events.split(eventSplitter);\n      rest = slice.call(arguments, 1);\n\n      // For each event, walk through the linked list of callbacks twice,\n      // first to trigger the event, then to trigger any `"all"` callbacks.\n      event = events.shift();\n      while (event) {\n        node = calls[event];\n        if (node) {\n          tail = node.tail;\n          while ((node = node.next) !== tail) {\n            node.callback.apply(node.context || this, rest);\n          }\n        }\n        node = all;\n        if (node) {\n          tail = node.tail;\n          args = [event].concat(rest);\n          while ((node = node.next) !== tail) {\n            node.callback.apply(node.context || this, args);\n          }\n        }\n        event = events.shift();\n      }\n\n      return this;\n    }\n  };\n\n  /**\n   * @function\n   */\n  Parse.Events.bind = Parse.Events.on;\n\n  /**\n   * @function\n   */\n  Parse.Events.unbind = Parse.Events.off;\n}.call(this));\n\n\n/*global navigator: false */\n(function(root) {\n  root.Parse = root.Parse || {};\n  var Parse = root.Parse;\n  var _ = Parse._;\n\n  /**\n   * Creates a new GeoPoint with any of the following forms:<br>\n   *   <pre>\n   *   new GeoPoint(otherGeoPoint)\n   *   new GeoPoint(30, 30)\n   *   new GeoPoint([30, 30])\n   *   new GeoPoint({latitude: 30, longitude: 30})\n   *   new GeoPoint()  // defaults to (0, 0)\n   *   </pre>\n   * @class\n   *\n   * <p>Represents a latitude / longitude point that may be associated\n   * with a key in a ParseObject or used as a reference point for geo queries.\n   * This allows proximity-based queries on the key.</p>\n   *\n   * <p>Only one key in a class may contain a GeoPoint.</p>\n   *\n   * <p>Example:<pre>\n   *   var point = new Parse.GeoPoint(30.0, -20.0);\n   *   var object = new Parse.Object("PlaceObject");\n   *   object.set("location", point);\n   *   object.save();</pre></p>\n   */\n  Parse.GeoPoint = function(arg1, arg2) {\n    if (_.isArray(arg1)) {\n      Parse.GeoPoint._validate(arg1[0], arg1[1]);\n      this.latitude = arg1[0];\n      this.longitude = arg1[1];\n    } else if (_.isObject(arg1)) {\n      Parse.GeoPoint._validate(arg1.latitude, arg1.longitude);\n      this.latitude = arg1.latitude;\n      this.longitude = arg1.longitude;\n    } else if (_.isNumber(arg1) && _.isNumber(arg2)) {\n      Parse.GeoPoint._validate(arg1, arg2);\n      this.latitude = arg1;\n      this.longitude = arg2;\n    } else {\n      this.latitude = 0;\n      this.longitude = 0;\n    }\n\n    // Add properties so that anyone using Webkit or Mozilla will get an error\n    // if they try to set values that are out of bounds.\n    var self = this;\n    if (this.__defineGetter__ && this.__defineSetter__) {\n      // Use _latitude and _longitude to actually store the values, and add\n      // getters and setters for latitude and longitude.\n      this._latitude = this.latitude;\n      this._longitude = this.longitude;\n      this.__defineGetter__("latitude", function() {\n        return self._latitude;\n      });\n      this.__defineGetter__("longitude", function() {\n        return self._longitude;\n      });\n      this.__defineSetter__("latitude", function(val) {\n        Parse.GeoPoint._validate(val, self.longitude);\n        self._latitude = val;\n      });\n      this.__defineSetter__("longitude", function(val) {\n        Parse.GeoPoint._validate(self.latitude, val);\n        self._longitude = val;\n      });\n    }\n  };\n\n  /**\n   * @lends Parse.GeoPoint.prototype\n   * @property {float} latitude North-south portion of the coordinate, in range\n   *   [-90, 90].  Throws an exception if set out of range in a modern browser.\n   * @property {float} longitude East-west portion of the coordinate, in range\n   *   [-180, 180].  Throws if set out of range in a modern browser.\n   */\n\n  /**\n   * Throws an exception if the given lat-long is out of bounds.\n   */\n  Parse.GeoPoint._validate = function(latitude, longitude) {\n    if (latitude < -90.0) {\n      throw "Parse.GeoPoint latitude " + latitude + " < -90.0.";\n    }\n    if (latitude > 90.0) {\n      throw "Parse.GeoPoint latitude " + latitude + " > 90.0.";\n    }\n    if (longitude < -180.0) {\n      throw "Parse.GeoPoint longitude " + longitude + " < -180.0.";\n    }\n    if (longitude > 180.0) {\n      throw "Parse.GeoPoint longitude " + longitude + " > 180.0.";\n    }\n  };\n\n  /**\n   * Creates a GeoPoint with the user\'s current location, if available.\n   * Calls options.success with a new GeoPoint instance or calls options.error.\n   * @param {Object} options An object with success and error callbacks.\n   */\n  Parse.GeoPoint.current = function(options) {\n    var promise = new Parse.Promise();\n    navigator.geolocation.getCurrentPosition(function(location) {\n      promise.resolve(new Parse.GeoPoint({\n        latitude: location.coords.latitude,\n        longitude: location.coords.longitude\n      }));\n\n    }, function(error) {\n      promise.reject(error);\n    });\n\n    return promise._thenRunCallbacks(options);\n  };\n\n  Parse.GeoPoint.prototype = {\n    /**\n     * Returns a JSON representation of the GeoPoint, suitable for Parse.\n     * @return {Object}\n     */\n    toJSON: function() {\n      Parse.GeoPoint._validate(this.latitude, this.longitude);\n      return {\n        "__type": "GeoPoint",\n        latitude: this.latitude,\n        longitude: this.longitude\n      };\n    },\n\n    /**\n     * Returns the distance from this GeoPoint to another in radians.\n     * @param {Parse.GeoPoint} point the other Parse.GeoPoint.\n     * @return {Number}\n     */\n    radiansTo: function(point) {\n      var d2r = Math.PI / 180.0;\n      var lat1rad = this.latitude * d2r;\n      var long1rad = this.longitude * d2r;\n      var lat2rad = point.latitude * d2r;\n      var long2rad = point.longitude * d2r;\n      var deltaLat = lat1rad - lat2rad;\n      var deltaLong = long1rad - long2rad;\n      var sinDeltaLatDiv2 = Math.sin(deltaLat / 2);\n      var sinDeltaLongDiv2 = Math.sin(deltaLong / 2);\n      // Square of half the straight line chord distance between both points.\n      var a = ((sinDeltaLatDiv2 * sinDeltaLatDiv2) +\n               (Math.cos(lat1rad) * Math.cos(lat2rad) *\n                sinDeltaLongDiv2 * sinDeltaLongDiv2));\n      a = Math.min(1.0, a);\n      return 2 * Math.asin(Math.sqrt(a));\n    },\n\n    /**\n     * Returns the distance from this GeoPoint to another in kilometers.\n     * @param {Parse.GeoPoint} point the other Parse.GeoPoint.\n     * @return {Number}\n     */\n    kilometersTo: function(point) {\n      return this.radiansTo(point) * 6371.0;\n    },\n\n    /**\n     * Returns the distance from this GeoPoint to another in miles.\n     * @param {Parse.GeoPoint} point the other Parse.GeoPoint.\n     * @return {Number}\n     */\n    milesTo: function(point) {\n      return this.radiansTo(point) * 3958.8;\n    }\n  };\n}(this));\n\n/*global navigator: false */\n(function(root) {\n  root.Parse = root.Parse || {};\n  var Parse = root.Parse;\n  var _ = Parse._;\n\n  var PUBLIC_KEY = "*";\n\n  /**\n   * Creates a new ACL.\n   * If no argument is given, the ACL has no permissions for anyone.\n   * If the argument is a Parse.User, the ACL will have read and write\n   *   permission for only that user.\n   * If the argument is any other JSON object, that object will be interpretted\n   *   as a serialized ACL created with toJSON().\n   * @see Parse.Object#setACL\n   * @class\n   *\n   * <p>An ACL, or Access Control List can be added to any\n   * <code>Parse.Object</code> to restrict access to only a subset of users\n   * of your application.</p>\n   */\n  Parse.ACL = function(arg1) {\n    var self = this;\n    self.permissionsById = {};\n    if (_.isObject(arg1)) {\n      if (arg1 instanceof Parse.User) {\n        self.setReadAccess(arg1, true);\n        self.setWriteAccess(arg1, true);\n      } else {\n        if (_.isFunction(arg1)) {\n          throw "Parse.ACL() called with a function.  Did you forget ()?";\n        }\n        Parse._objectEach(arg1, function(accessList, userId) {\n          if (!_.isString(userId)) {\n            throw "Tried to create an ACL with an invalid userId.";\n          }\n          self.permissionsById[userId] = {};\n          Parse._objectEach(accessList, function(allowed, permission) {\n            if (permission !== "read" && permission !== "write") {\n              throw "Tried to create an ACL with an invalid permission type.";\n            }\n            if (!_.isBoolean(allowed)) {\n              throw "Tried to create an ACL with an invalid permission value.";\n            }\n            self.permissionsById[userId][permission] = allowed;\n          });\n        });\n      }\n    }\n  };\n\n  /**\n   * Returns a JSON-encoded version of the ACL.\n   * @return {Object}\n   */\n  Parse.ACL.prototype.toJSON = function() {\n    return _.clone(this.permissionsById);\n  };\n\n  Parse.ACL.prototype._setAccess = function(accessType, userId, allowed) {\n    if (userId instanceof Parse.User) {\n      userId = userId.id;\n    } else if (userId instanceof Parse.Role) {\n      userId = "role:" + userId.getName();\n    }\n    if (!_.isString(userId)) {\n      throw "userId must be a string.";\n    }\n    if (!_.isBoolean(allowed)) {\n      throw "allowed must be either true or false.";\n    }\n    var permissions = this.permissionsById[userId];\n    if (!permissions) {\n      if (!allowed) {\n        // The user already doesn\'t have this permission, so no action needed.\n        return;\n      } else {\n        permissions = {};\n        this.permissionsById[userId] = permissions;\n      }\n    }\n\n    if (allowed) {\n      this.permissionsById[userId][accessType] = true;\n    } else {\n      delete permissions[accessType];\n      if (_.isEmpty(permissions)) {\n        delete permissions[userId];\n      }\n    }\n  };\n\n  Parse.ACL.prototype._getAccess = function(accessType, userId) {\n    if (userId instanceof Parse.User) {\n      userId = userId.id;\n    } else if (userId instanceof Parse.Role) {\n      userId = "role:" + userId.getName();\n    }\n    var permissions = this.permissionsById[userId];\n    if (!permissions) {\n      return false;\n    }\n    return permissions[accessType] ? true : false;\n  };\n\n  /**\n   * Set whether the given user is allowed to read this object.\n   * @param userId An instance of Parse.User or its objectId.\n   * @param {Boolean} allowed Whether that user should have read access.\n   */\n  Parse.ACL.prototype.setReadAccess = function(userId, allowed) {\n    this._setAccess("read", userId, allowed);\n  };\n\n  /**\n   * Get whether the given user id is *explicitly* allowed to read this object.\n   * Even if this returns false, the user may still be able to access it if\n   * getPublicReadAccess returns true or a role that the user belongs to has\n   * write access.\n   * @param userId An instance of Parse.User or its objectId, or a Parse.Role.\n   * @return {Boolean}\n   */\n  Parse.ACL.prototype.getReadAccess = function(userId) {\n    return this._getAccess("read", userId);\n  };\n\n  /**\n   * Set whether the given user id is allowed to write this object.\n   * @param userId An instance of Parse.User or its objectId, or a Parse.Role..\n   * @param {Boolean} allowed Whether that user should have write access.\n   */\n  Parse.ACL.prototype.setWriteAccess = function(userId, allowed) {\n    this._setAccess("write", userId, allowed);\n  };\n\n  /**\n   * Get whether the given user id is *explicitly* allowed to write this object.\n   * Even if this returns false, the user may still be able to write it if\n   * getPublicWriteAccess returns true or a role that the user belongs to has\n   * write access.\n   * @param userId An instance of Parse.User or its objectId, or a Parse.Role.\n   * @return {Boolean}\n   */\n  Parse.ACL.prototype.getWriteAccess = function(userId) {\n    return this._getAccess("write", userId);\n  };\n\n  /**\n   * Set whether the public is allowed to read this object.\n   * @param {Boolean} allowed\n   */\n  Parse.ACL.prototype.setPublicReadAccess = function(allowed) {\n    this.setReadAccess(PUBLIC_KEY, allowed);\n  };\n\n  /**\n   * Get whether the public is allowed to read this object.\n   * @return {Boolean}\n   */\n  Parse.ACL.prototype.getPublicReadAccess = function() {\n    return this.getReadAccess(PUBLIC_KEY);\n  };\n\n  /**\n   * Set whether the public is allowed to write this object.\n   * @param {Boolean} allowed\n   */\n  Parse.ACL.prototype.setPublicWriteAccess = function(allowed) {\n    this.setWriteAccess(PUBLIC_KEY, allowed);\n  };\n\n  /**\n   * Get whether the public is allowed to write this object.\n   * @return {Boolean}\n   */\n  Parse.ACL.prototype.getPublicWriteAccess = function() {\n    return this.getWriteAccess(PUBLIC_KEY);\n  };\n\n  /**\n   * Get whether users belonging to the given role are allowed\n   * to read this object. Even if this returns false, the role may\n   * still be able to write it if a parent role has read access.\n   *\n   * @param role The name of the role, or a Parse.Role object.\n   * @return {Boolean} true if the role has read access. false otherwise.\n   * @throws {String} If role is neither a Parse.Role nor a String.\n   */\n  Parse.ACL.prototype.getRoleReadAccess = function(role) {\n    if (role instanceof Parse.Role) {\n      // Normalize to the String name\n      role = role.getName();\n    }\n    if (_.isString(role)) {\n      return this.getReadAccess("role:" + role);\n    }\n    throw "role must be a Parse.Role or a String";\n  };\n\n  /**\n   * Get whether users belonging to the given role are allowed\n   * to write this object. Even if this returns false, the role may\n   * still be able to write it if a parent role has write access.\n   *\n   * @param role The name of the role, or a Parse.Role object.\n   * @return {Boolean} true if the role has write access. false otherwise.\n   * @throws {String} If role is neither a Parse.Role nor a String.\n   */\n  Parse.ACL.prototype.getRoleWriteAccess = function(role) {\n    if (role instanceof Parse.Role) {\n      // Normalize to the String name\n      role = role.getName();\n    }\n    if (_.isString(role)) {\n      return this.getWriteAccess("role:" + role);\n    }\n    throw "role must be a Parse.Role or a String";\n  };\n\n  /**\n   * Set whether users belonging to the given role are allowed\n   * to read this object.\n   *\n   * @param role The name of the role, or a Parse.Role object.\n   * @param {Boolean} allowed Whether the given role can read this object.\n   * @throws {String} If role is neither a Parse.Role nor a String.\n   */\n  Parse.ACL.prototype.setRoleReadAccess = function(role, allowed) {\n    if (role instanceof Parse.Role) {\n      // Normalize to the String name\n      role = role.getName();\n    }\n    if (_.isString(role)) {\n      this.setReadAccess("role:" + role, allowed);\n      return;\n    }\n    throw "role must be a Parse.Role or a String";\n  };\n\n  /**\n   * Set whether users belonging to the given role are allowed\n   * to write this object.\n   *\n   * @param role The name of the role, or a Parse.Role object.\n   * @param {Boolean} allowed Whether the given role can write this object.\n   * @throws {String} If role is neither a Parse.Role nor a String.\n   */\n  Parse.ACL.prototype.setRoleWriteAccess = function(role, allowed) {\n    if (role instanceof Parse.Role) {\n      // Normalize to the String name\n      role = role.getName();\n    }\n    if (_.isString(role)) {\n      this.setWriteAccess("role:" + role, allowed);\n      return;\n    }\n    throw "role must be a Parse.Role or a String";\n  };\n\n}(this));\n\n(function(root) {\n  root.Parse = root.Parse || {};\n  var Parse = root.Parse;\n  var _ = Parse._;\n\n  /**\n   * @class\n   * A Parse.Op is an atomic operation that can be applied to a field in a\n   * Parse.Object. For example, calling <code>object.set("foo", "bar")</code>\n   * is an example of a Parse.Op.Set. Calling <code>object.unset("foo")</code>\n   * is a Parse.Op.Unset. These operations are stored in a Parse.Object and\n   * sent to the server as part of <code>object.save()</code> operations.\n   * Instances of Parse.Op should be immutable.\n   *\n   * You should not create subclasses of Parse.Op or instantiate Parse.Op\n   * directly.\n   */\n  Parse.Op = function() {\n    this._initialize.apply(this, arguments);\n  };\n\n  Parse.Op.prototype = {\n    _initialize: function() {}\n  };\n\n  _.extend(Parse.Op, {\n    /**\n     * To create a new Op, call Parse.Op._extend();\n     */\n    _extend: Parse._extend,\n\n    // A map of __op string to decoder function.\n    _opDecoderMap: {},\n\n    /**\n     * Registers a function to convert a json object with an __op field into an\n     * instance of a subclass of Parse.Op.\n     */\n    _registerDecoder: function(opName, decoder) {\n      Parse.Op._opDecoderMap[opName] = decoder;\n    },\n\n    /**\n     * Converts a json object into an instance of a subclass of Parse.Op.\n     */\n    _decode: function(json) {\n      var decoder = Parse.Op._opDecoderMap[json.__op];\n      if (decoder) {\n        return decoder(json);\n      } else {\n        return undefined;\n      }\n    }\n  });\n\n  /*\n   * Add a handler for Batch ops.\n   */\n  Parse.Op._registerDecoder("Batch", function(json) {\n    var op = null;\n    Parse._arrayEach(json.ops, function(nextOp) {\n      nextOp = Parse.Op._decode(nextOp);\n      op = nextOp._mergeWithPrevious(op);\n    });\n    return op;\n  });\n\n  /**\n   * @class\n   * A Set operation indicates that either the field was changed using\n   * Parse.Object.set, or it is a mutable container that was detected as being\n   * changed.\n   */\n  Parse.Op.Set = Parse.Op._extend(/** @lends Parse.Op.Set.prototype */ {\n    _initialize: function(value) {\n      this._value = value;\n    },\n\n    /**\n     * Returns the new value of this field after the set.\n     */\n    value: function() {\n      return this._value;\n    },\n\n    /**\n     * Returns a JSON version of the operation suitable for sending to Parse.\n     * @return {Object}\n     */\n    toJSON: function() {\n      return Parse._encode(this.value());\n    },\n\n    _mergeWithPrevious: function(previous) {\n      return this;\n    },\n\n    _estimate: function(oldValue) {\n      return this.value();\n    }\n  });\n\n  /**\n   * A sentinel value that is returned by Parse.Op.Unset._estimate to\n   * indicate the field should be deleted. Basically, if you find _UNSET as a\n   * value in your object, you should remove that key.\n   */\n  Parse.Op._UNSET = {};\n\n  /**\n   * @class\n   * An Unset operation indicates that this field has been deleted from the\n   * object.\n   */\n  Parse.Op.Unset = Parse.Op._extend(/** @lends Parse.Op.Unset.prototype */ {\n    /**\n     * Returns a JSON version of the operation suitable for sending to Parse.\n     * @return {Object}\n     */\n    toJSON: function() {\n      return { __op: "Delete" };\n    },\n\n    _mergeWithPrevious: function(previous) {\n      return this;\n    },\n\n    _estimate: function(oldValue) {\n      return Parse.Op._UNSET;\n    }\n  });\n\n  Parse.Op._registerDecoder("Delete", function(json) {\n    return new Parse.Op.Unset();\n  });\n\n  /**\n   * @class\n   * An Increment is an atomic operation where the numeric value for the field\n   * will be increased by a given amount.\n   */\n  Parse.Op.Increment = Parse.Op._extend(\n      /** @lends Parse.Op.Increment.prototype */ {\n\n    _initialize: function(amount) {\n      this._amount = amount;\n    },\n\n    /**\n     * Returns the amount to increment by.\n     * @return {Number} the amount to increment by.\n     */\n    amount: function() {\n      return this._amount;\n    },\n\n    /**\n     * Returns a JSON version of the operation suitable for sending to Parse.\n     * @return {Object}\n     */\n    toJSON: function() {\n      return { __op: "Increment", amount: this._amount };\n    },\n\n    _mergeWithPrevious: function(previous) {\n      if (!previous) {\n        return this;\n      } else if (previous instanceof Parse.Op.Unset) {\n        return new Parse.Op.Set(this.amount());\n      } else if (previous instanceof Parse.Op.Set) {\n        return new Parse.Op.Set(previous.value() + this.amount());\n      } else if (previous instanceof Parse.Op.Increment) {\n        return new Parse.Op.Increment(this.amount() + previous.amount());\n      } else {\n        throw "Op is invalid after previous op.";\n      }\n    },\n\n    _estimate: function(oldValue) {\n      if (!oldValue) {\n        return this.amount();\n      }\n      return oldValue + this.amount();\n    }\n  });\n\n  Parse.Op._registerDecoder("Increment", function(json) {\n    return new Parse.Op.Increment(json.amount);\n  });\n\n  /**\n   * @class\n   * Add is an atomic operation where the given objects will be appended to the\n   * array that is stored in this field.\n   */\n  Parse.Op.Add = Parse.Op._extend(/** @lends Parse.Op.Add.prototype */ {\n    _initialize: function(objects) {\n      this._objects = objects;\n    },\n\n    /**\n     * Returns the objects to be added to the array.\n     * @return {Array} The objects to be added to the array.\n     */\n    objects: function() {\n      return this._objects;\n    },\n\n    /**\n     * Returns a JSON version of the operation suitable for sending to Parse.\n     * @return {Object}\n     */\n    toJSON: function() {\n      return { __op: "Add", objects: Parse._encode(this.objects()) };\n    },\n\n    _mergeWithPrevious: function(previous) {\n      if (!previous) {\n        return this;\n      } else if (previous instanceof Parse.Op.Unset) {\n        return new Parse.Op.Set(this.objects());\n      } else if (previous instanceof Parse.Op.Set) {\n        return new Parse.Op.Set(this._estimate(previous.value()));\n      } else if (previous instanceof Parse.Op.Add) {\n        return new Parse.Op.Add(previous.objects().concat(this.objects()));\n      } else {\n        throw "Op is invalid after previous op.";\n      }\n    },\n\n    _estimate: function(oldValue) {\n      if (!oldValue) {\n        return _.clone(this.objects());\n      } else {\n        return oldValue.concat(this.objects());\n      }\n    }\n  });\n\n  Parse.Op._registerDecoder("Add", function(json) {\n    return new Parse.Op.Add(Parse._decode(undefined, json.objects));\n  });\n\n  /**\n   * @class\n   * AddUnique is an atomic operation where the given items will be appended to\n   * the array that is stored in this field only if they were not already\n   * present in the array.\n   */\n  Parse.Op.AddUnique = Parse.Op._extend(\n      /** @lends Parse.Op.AddUnique.prototype */ {\n\n    _initialize: function(objects) {\n      this._objects = _.uniq(objects);\n    },\n\n    /**\n     * Returns the objects to be added to the array.\n     * @return {Array} The objects to be added to the array.\n     */\n    objects: function() {\n      return this._objects;\n    },\n\n    /**\n     * Returns a JSON version of the operation suitable for sending to Parse.\n     * @return {Object}\n     */\n    toJSON: function() {\n      return { __op: "AddUnique", objects: Parse._encode(this.objects()) };\n    },\n\n    _mergeWithPrevious: function(previous) {\n      if (!previous) {\n        return this;\n      } else if (previous instanceof Parse.Op.Unset) {\n        return new Parse.Op.Set(this.objects());\n      } else if (previous instanceof Parse.Op.Set) {\n        return new Parse.Op.Set(this._estimate(previous.value()));\n      } else if (previous instanceof Parse.Op.AddUnique) {\n        return new Parse.Op.AddUnique(this._estimate(previous.objects()));\n      } else {\n        throw "Op is invalid after previous op.";\n      }\n    },\n\n    _estimate: function(oldValue) {\n      if (!oldValue) {\n        return _.clone(this.objects());\n      } else {\n        // We can\'t just take the _.uniq(_.union(...)) of oldValue and\n        // this.objects, because the uniqueness may not apply to oldValue\n        // (especially if the oldValue was set via .set())\n        var newValue = _.clone(oldValue);\n        Parse._arrayEach(this.objects(), function(obj) {\n          if (obj instanceof Parse.Object && obj.id) {\n            var matchingObj = _.find(newValue, function(anObj) {\n              return (anObj instanceof Parse.Object) && (anObj.id === obj.id);\n            });\n            if (!matchingObj) {\n              newValue.push(obj);\n            } else {\n              var index = _.indexOf(newValue, matchingObj);\n              newValue[index] = obj;\n            }\n          } else if (!_.contains(newValue, obj)) {\n            newValue.push(obj);\n          }\n        });\n        return newValue;\n      }\n    }\n  });\n\n  Parse.Op._registerDecoder("AddUnique", function(json) {\n    return new Parse.Op.AddUnique(Parse._decode(undefined, json.objects));\n  });\n\n  /**\n   * @class\n   * Remove is an atomic operation where the given objects will be removed from\n   * the array that is stored in this field.\n   */\n  Parse.Op.Remove = Parse.Op._extend(/** @lends Parse.Op.Remove.prototype */ {\n    _initialize: function(objects) {\n      this._objects = _.uniq(objects);\n    },\n\n    /**\n     * Returns the objects to be removed from the array.\n     * @return {Array} The objects to be removed from the array.\n     */\n    objects: function() {\n      return this._objects;\n    },\n\n    /**\n     * Returns a JSON version of the operation suitable for sending to Parse.\n     * @return {Object}\n     */\n    toJSON: function() {\n      return { __op: "Remove", objects: Parse._encode(this.objects()) };\n    },\n\n    _mergeWithPrevious: function(previous) {\n      if (!previous) {\n        return this;\n      } else if (previous instanceof Parse.Op.Unset) {\n        return previous;\n      } else if (previous instanceof Parse.Op.Set) {\n        return new Parse.Op.Set(this._estimate(previous.value()));\n      } else if (previous instanceof Parse.Op.Remove) {\n        return new Parse.Op.Remove(_.union(previous.objects(), this.objects()));\n      } else {\n        throw "Op is invalid after previous op.";\n      }\n    },\n\n    _estimate: function(oldValue) {\n      if (!oldValue) {\n        return [];\n      } else {\n        var newValue = _.difference(oldValue, this.objects());\n        // If there are saved Parse Objects being removed, also remove them.\n        Parse._arrayEach(this.objects(), function(obj) {\n          if (obj instanceof Parse.Object && obj.id) {\n            newValue = _.reject(newValue, function(other) {\n              return (other instanceof Parse.Object) && (other.id === obj.id);\n            });\n          }\n        });\n        return newValue;\n      }\n    }\n  });\n\n  Parse.Op._registerDecoder("Remove", function(json) {\n    return new Parse.Op.Remove(Parse._decode(undefined, json.objects));\n  });\n\n  /**\n   * @class\n   * A Relation operation indicates that the field is an instance of\n   * Parse.Relation, and objects are being added to, or removed from, that\n   * relation.\n   */\n  Parse.Op.Relation = Parse.Op._extend(\n      /** @lends Parse.Op.Relation.prototype */ {\n\n    _initialize: function(adds, removes) {\n      this._targetClassName = null;\n\n      var self = this;\n\n      var pointerToId = function(object) {\n        if (object instanceof Parse.Object) {\n          if (!object.id) {\n            throw "You can\'t add an unsaved Parse.Object to a relation.";\n          }\n          if (!self._targetClassName) {\n            self._targetClassName = object.className;\n          }\n          if (self._targetClassName !== object.className) {\n            throw "Tried to create a Parse.Relation with 2 different types: " +\n                  self._targetClassName + " and " + object.className + ".";\n          }\n          return object.id;\n        }\n        return object;\n      };\n\n      this.relationsToAdd = _.uniq(_.map(adds, pointerToId));\n      this.relationsToRemove = _.uniq(_.map(removes, pointerToId));\n    },\n\n    /**\n     * Returns an array of unfetched Parse.Object that are being added to the\n     * relation.\n     * @return {Array}\n     */\n    added: function() {\n      var self = this;\n      return _.map(this.relationsToAdd, function(objectId) {\n        var object = Parse.Object._create(self._targetClassName);\n        object.id = objectId;\n        return object;\n      });\n    },\n\n    /**\n     * Returns an array of unfetched Parse.Object that are being removed from\n     * the relation.\n     * @return {Array}\n     */\n    removed: function() {\n      var self = this;\n      return _.map(this.relationsToRemove, function(objectId) {\n        var object = Parse.Object._create(self._targetClassName);\n        object.id = objectId;\n        return object;\n      });\n    },\n\n    /**\n     * Returns a JSON version of the operation suitable for sending to Parse.\n     * @return {Object}\n     */\n    toJSON: function() {\n      var adds = null;\n      var removes = null;\n      var self = this;\n      var idToPointer = function(id) {\n        return { __type: \'Pointer\',\n                 className: self._targetClassName,\n                 objectId: id };\n      };\n      var pointers = null;\n      if (this.relationsToAdd.length > 0) {\n        pointers = _.map(this.relationsToAdd, idToPointer);\n        adds = { "__op": "AddRelation", "objects": pointers };\n      }\n\n      if (this.relationsToRemove.length > 0) {\n        pointers = _.map(this.relationsToRemove, idToPointer);\n        removes = { "__op": "RemoveRelation", "objects": pointers };\n      }\n\n      if (adds && removes) {\n        return { "__op": "Batch", "ops": [adds, removes]};\n      }\n\n      return adds || removes || {};\n    },\n\n    _mergeWithPrevious: function(previous) {\n      if (!previous) {\n        return this;\n      } else if (previous instanceof Parse.Op.Unset) {\n        throw "You can\'t modify a relation after deleting it.";\n      } else if (previous instanceof Parse.Op.Relation) {\n        if (previous._targetClassName &&\n            previous._targetClassName !== this._targetClassName) {\n          throw "Related object must be of class " + previous._targetClassName +\n              ", but " + this._targetClassName + " was passed in.";\n        }\n        var newAdd = _.union(_.difference(previous.relationsToAdd,\n                                          this.relationsToRemove),\n                             this.relationsToAdd);\n        var newRemove = _.union(_.difference(previous.relationsToRemove,\n                                             this.relationsToAdd),\n                                this.relationsToRemove);\n\n        var newRelation = new Parse.Op.Relation(newAdd, newRemove);\n        newRelation._targetClassName = this._targetClassName;\n        return newRelation;\n      } else {\n        throw "Op is invalid after previous op.";\n      }\n    },\n\n    _estimate: function(oldValue, object, key) {\n      if (!oldValue) {\n        var relation = new Parse.Relation(object, key);\n        relation.targetClassName = this._targetClassName;\n      } else if (oldValue instanceof Parse.Relation) {\n        if (this._targetClassName) {\n          if (oldValue.targetClassName) {\n            if (oldValue.targetClassName !== this._targetClassName) {\n              throw "Related object must be a " + oldValue.targetClassName +\n                  ", but a " + this._targetClassName + " was passed in.";\n            }\n          } else {\n            oldValue.targetClassName = this._targetClassName;\n          }\n        }\n        return oldValue;\n      } else {\n        throw "Op is invalid after previous op.";\n      }\n    }\n  });\n\n  Parse.Op._registerDecoder("AddRelation", function(json) {\n    return new Parse.Op.Relation(Parse._decode(undefined, json.objects), []);\n  });\n  Parse.Op._registerDecoder("RemoveRelation", function(json) {\n    return new Parse.Op.Relation([], Parse._decode(undefined, json.objects));\n  });\n\n}(this));\n\n(function(root) {\n  root.Parse = root.Parse || {};\n  var Parse = root.Parse;\n  var _ = Parse._;\n\n  /**\n   * Creates a new Relation for the given parent object and key. This\n   * constructor should rarely be used directly, but rather created by\n   * Parse.Object.relation.\n   * @param {Parse.Object} parent The parent of this relation.\n   * @param {String} key The key for this relation on the parent.\n   * @see Parse.Object#relation\n   * @class\n   *\n   * <p>\n   * A class that is used to access all of the children of a many-to-many\n   * relationship.  Each instance of Parse.Relation is associated with a\n   * particular parent object and key.\n   * </p>\n   */\n  Parse.Relation = function(parent, key) {\n    this.parent = parent;\n    this.key = key;\n    this.targetClassName = null;\n  };\n\n  Parse.Relation.prototype = {\n    /**\n     * Makes sure that this relation has the right parent and key.\n     */\n    _ensureParentAndKey: function(parent, key) {\n      this.parent = this.parent || parent;\n      this.key = this.key || key;\n      if (this.parent !== parent) {\n        throw "Internal Error. Relation retrieved from two different Objects.";\n      }\n      if (this.key !== key) {\n        throw "Internal Error. Relation retrieved from two different keys.";\n      }\n    },\n\n    /**\n     * Adds a Parse.Object or an array of Parse.Objects to the relation.\n     * @param {} objects The item or items to add.\n     */\n    add: function(objects) {\n      if (!_.isArray(objects)) {\n        objects = [objects];\n      }\n\n      var change = new Parse.Op.Relation(objects, []);\n      this.parent.set(this.key, change);\n      this.targetClassName = change._targetClassName;\n    },\n\n    /**\n     * Removes a Parse.Object or an array of Parse.Objects from this relation.\n     * @param {} objects The item or items to remove.\n     */\n    remove: function(objects) {\n      if (!_.isArray(objects)) {\n        objects = [objects];\n      }\n\n      var change = new Parse.Op.Relation([], objects);\n      this.parent.set(this.key, change);\n      this.targetClassName = change._targetClassName;\n    },\n\n    /**\n     * Returns a JSON version of the object suitable for saving to disk.\n     * @return {Object}\n     */\n    toJSON: function() {\n      return { "__type": "Relation", "className": this.targetClassName };\n    },\n\n    /**\n     * Returns a Parse.Query that is limited to objects in this\n     * relation.\n     * @return {Parse.Query}\n     */\n    query: function() {\n      var targetClass;\n      var query;\n      if (!this.targetClassName) {\n        targetClass = Parse.Object._getSubclass(this.parent.className);\n        query = new Parse.Query(targetClass);\n        query._extraOptions.redirectClassNameForKey = this.key;\n      } else {\n        targetClass = Parse.Object._getSubclass(this.targetClassName);\n        query = new Parse.Query(targetClass);\n      }\n      query._addCondition("$relatedTo", "object", this.parent._toPointer());\n      query._addCondition("$relatedTo", "key", this.key);\n\n      return query;\n    }\n  };\n}(this));\n\n(function(root) {\n  root.Parse = root.Parse || {};\n  var Parse = root.Parse;\n  var _ = Parse._;\n\n  /**\n   * A Promise is returned by async methods as a hook to provide callbacks to be\n   * called when the async task is fulfilled.\n   *\n   * <p>Typical usage would be like:<pre>\n   *    query.find().then(function(results) {\n   *      results[0].set("foo", "bar");\n   *      return results[0].saveAsync();\n   *    }).then(function(result) {\n   *      console.log("Updated " + result.id);\n   *    });\n   * </pre></p>\n   *\n   * @see Parse.Promise.prototype.then\n   * @class\n   */\n  Parse.Promise = function() {\n    this._resolved = false;\n    this._rejected = false;\n    this._resolvedCallbacks = [];\n    this._rejectedCallbacks = [];\n  };\n\n  _.extend(Parse.Promise, /** @lends Parse.Promise */ {\n\n    /**\n     * Returns true iff the given object fulfils the Promise interface.\n     * @return {Boolean}\n     */\n    is: function(promise) {\n      return promise && promise.then && _.isFunction(promise.then);\n    },\n\n    /**\n     * Returns a new promise that is resolved with a given value.\n     * @return {Parse.Promise} the new promise.\n     */\n    as: function() {\n      var promise = new Parse.Promise();\n      promise.resolve.apply(promise, arguments);\n      return promise;\n    },\n\n    /**\n     * Returns a new promise that is rejected with a given error.\n     * @return {Parse.Promise} the new promise.\n     */\n    error: function() {\n      var promise = new Parse.Promise();\n      promise.reject.apply(promise, arguments);\n      return promise;\n    },\n\n    /**\n     * Returns a new promise that is fulfilled when all of the input promises\n     * are resolved. If any promise in the list fails, then the returned promise\n     * will fail with the last error. If they all succeed, then the returned\n     * promise will succeed, with the results being the results of all the input\n     * promises. For example: <pre>\n     *   var p1 = Parse.Promise.as(1);\n     *   var p2 = Parse.Promise.as(2);\n     *   var p3 = Parse.Promise.as(3);\n     *\n     *   Parse.Promise.when(p1, p2, p3).then(function(r1, r2, r3) {\n     *     console.log(r1);  // prints 1\n     *     console.log(r2);  // prints 2\n     *     console.log(r3);  // prints 3\n     *   });</pre>\n     *\n     * The input promises can also be specified as an array: <pre>\n     *   var promises = [p1, p2, p3];\n     *   Parse.Promise.when(promises).then(function(r1, r2, r3) {\n     *     console.log(r1);  // prints 1\n     *     console.log(r2);  // prints 2\n     *     console.log(r3);  // prints 3\n     *   });\n     * </pre>\n     * @param {Array} promises a list of promises to wait for.\n     * @return {Parse.Promise} the new promise.\n     */\n    when: function(promises) {\n      // Allow passing in Promises as separate arguments instead of an Array.\n      var objects;\n      if (promises && Parse._isNullOrUndefined(promises.length)) {\n        objects = arguments;\n      } else {\n        objects = promises;\n      }\n\n      var total = objects.length;\n      var hadError = false;\n      var results = [];\n      var errors = [];\n      results.length = objects.length;\n      errors.length = objects.length;\n\n      if (total === 0) {\n        return Parse.Promise.as.apply(this, results);\n      }\n\n      var promise = new Parse.Promise();\n\n      var resolveOne = function() {\n        total = total - 1;\n        if (total === 0) {\n          if (hadError) {\n            promise.reject(errors);\n          } else {\n            promise.resolve.apply(promise, results);\n          }\n        }\n      };\n\n      Parse._arrayEach(objects, function(object, i) {\n        if (Parse.Promise.is(object)) {\n          object.then(function(result) {\n            results[i] = result;\n            resolveOne();\n          }, function(error) {\n            errors[i] = error;\n            hadError = true;\n            resolveOne();\n          });\n        } else {\n          results[i] = object;\n          resolveOne();\n        }\n      });\n\n      return promise;\n    },\n\n    /**\n     * Runs the given asyncFunction repeatedly, as long as the predicate\n     * function returns a truthy value. Stops repeating if asyncFunction returns\n     * a rejected promise.\n     * @param {Function} predicate should return false when ready to stop.\n     * @param {Function} asyncFunction should return a Promise.\n     */\n    _continueWhile: function(predicate, asyncFunction) {\n      if (predicate()) {\n        return asyncFunction().then(function() {\n          return Parse.Promise._continueWhile(predicate, asyncFunction);\n        });\n      }\n      return Parse.Promise.as();\n    }\n  });\n\n  _.extend(Parse.Promise.prototype, /** @lends Parse.Promise.prototype */ {\n\n    /**\n     * Marks this promise as fulfilled, firing any callbacks waiting on it.\n     * @param {Object} result the result to pass to the callbacks.\n     */\n    resolve: function(result) {\n      if (this._resolved || this._rejected) {\n        throw "A promise was resolved even though it had already been " +\n          (this._resolved ? "resolved" : "rejected") + ".";\n      }\n      this._resolved = true;\n      this._result = arguments;\n      var results = arguments;\n      Parse._arrayEach(this._resolvedCallbacks, function(resolvedCallback) {\n        resolvedCallback.apply(this, results);\n      });\n      this._resolvedCallbacks = [];\n      this._rejectedCallbacks = [];\n    },\n\n    /**\n     * Marks this promise as fulfilled, firing any callbacks waiting on it.\n     * @param {Object} error the error to pass to the callbacks.\n     */\n    reject: function(error) {\n      if (this._resolved || this._rejected) {\n        throw "A promise was rejected even though it had already been " +\n          (this._resolved ? "resolved" : "rejected") + ".";\n      }\n      this._rejected = true;\n      this._error = error;\n      Parse._arrayEach(this._rejectedCallbacks, function(rejectedCallback) {\n        rejectedCallback(error);\n      });\n      this._resolvedCallbacks = [];\n      this._rejectedCallbacks = [];\n    },\n\n    /**\n     * Adds callbacks to be called when this promise is fulfilled. Returns a new\n     * Promise that will be fulfilled when the callback is complete. It allows\n     * chaining. If the callback itself returns a Promise, then the one returned\n     * by "then" will not be fulfilled until that one returned by the callback\n     * is fulfilled.\n     * @param {Function} resolvedCallback Function that is called when this\n     * Promise is resolved. Once the callback is complete, then the Promise\n     * returned by "then" will also be fulfilled.\n     * @param {Function} rejectedCallback Function that is called when this\n     * Promise is rejected with an error. Once the callback is complete, then\n     * the promise returned by "then" with be resolved successfully. If\n     * rejectedCallback is null, or it returns a rejected Promise, then the\n     * Promise returned by "then" will be rejected with that error.\n     * @return {Parse.Promise} A new Promise that will be fulfilled after this\n     * Promise is fulfilled and either callback has completed. If the callback\n     * returned a Promise, then this Promise will not be fulfilled until that\n     * one is.\n     */\n    then: function(resolvedCallback, rejectedCallback) {\n      var promise = new Parse.Promise();\n\n      var wrappedResolvedCallback = function() {\n        var result = arguments;\n        if (resolvedCallback) {\n          result = [resolvedCallback.apply(this, result)];\n        }\n        if (result.length === 1 && Parse.Promise.is(result[0])) {\n          result[0].then(function() {\n            promise.resolve.apply(promise, arguments);\n          }, function(error) {\n            promise.reject(error);\n          });\n        } else {\n          promise.resolve.apply(promise, result);\n        }\n      };\n\n      var wrappedRejectedCallback = function(error) {\n        var result = [];\n        if (rejectedCallback) {\n          result = [rejectedCallback(error)];\n          if (result.length === 1 && Parse.Promise.is(result[0])) {\n            result[0].then(function() {\n              promise.resolve.apply(promise, arguments);\n            }, function(error) {\n              promise.reject(error);\n            });\n          } else {\n            // A Promises/A+ compliant implementation would call:\n            // promise.resolve.apply(promise, result);\n            promise.reject(result[0]);\n          }\n        } else {\n          promise.reject(error);\n        }\n      };\n\n      if (this._resolved) {\n        wrappedResolvedCallback.apply(this, this._result);\n      } else if (this._rejected) {\n        wrappedRejectedCallback(this._error);\n      } else {\n        this._resolvedCallbacks.push(wrappedResolvedCallback);\n        this._rejectedCallbacks.push(wrappedRejectedCallback);\n      }\n\n      return promise;\n    },\n\n    /**\n     * Add handlers to be called when the promise\n     * is either resolved or rejected\n     */\n    always: function(callback) {\n      return this.then(callback, callback);\n    },\n\n    /**\n     * Add handlers to be called when the Promise object is resolved\n     */\n    done: function(callback) {\n      return this.then(callback);\n    },\n\n    /**\n     * Add handlers to be called when the Promise object is rejected\n     */\n    fail: function(callback) {\n      return this.then(null, callback);\n    },\n\n    /**\n     * Run the given callbacks after this promise is fulfilled.\n     * @param optionsOrCallback {} A Backbone-style options callback, or a\n     * callback function. If this is an options object and contains a "model"\n     * attributes, that will be passed to error callbacks as the first argument.\n     * @param model {} If truthy, this will be passed as the first result of\n     * error callbacks. This is for Backbone-compatability.\n     * @return {Parse.Promise} A promise that will be resolved after the\n     * callbacks are run, with the same result as this.\n     */\n    _thenRunCallbacks: function(optionsOrCallback, model) {\n      var options;\n      if (_.isFunction(optionsOrCallback)) {\n        var callback = optionsOrCallback;\n        options = {\n          success: function(result) {\n            callback(result, null);\n          },\n          error: function(error) {\n            callback(null, error);\n          }\n        };\n      } else {\n        options = _.clone(optionsOrCallback);\n      }\n      options = options || {};\n\n      return this.then(function(result) {\n        if (options.success) {\n          options.success.apply(this, arguments);\n        } else if (model) {\n          // When there\'s no callback, a sync event should be triggered.\n          model.trigger(\'sync\', model, result, options);\n        }\n        return Parse.Promise.as.apply(Parse.Promise, arguments);\n      }, function(error) {\n        if (options.error) {\n          if (!_.isUndefined(model)) {\n            options.error(model, error);\n          } else {\n            options.error(error);\n          }\n        } else if (model) {\n          // When there\'s no error callback, an error event should be triggered.\n          model.trigger(\'error\', model, error, options);\n        }\n        // By explicitly returning a rejected Promise, this will work with\n        // either jQuery or Promises/A semantics.\n        return Parse.Promise.error(error);\n      });\n    },\n\n    /**\n     * Adds a callback function that should be called regardless of whether\n     * this promise failed or succeeded. The callback will be given either the\n     * array of results for its first argument, or the error as its second,\n     * depending on whether this Promise was rejected or resolved. Returns a\n     * new Promise, like "then" would.\n     * @param {Function} continuation the callback.\n     */\n    _continueWith: function(continuation) {\n      return this.then(function() {\n        return continuation(arguments, null);\n      }, function(error) {\n        return continuation(null, error);\n      });\n    }\n\n  });\n\n}(this));\n\n/*jshint bitwise:false *//*global FileReader: true, File: true */\n(function(root) {\n  root.Parse = root.Parse || {};\n  var Parse = root.Parse;\n  var _ = Parse._;\n\n  var b64Digit = function(number) {\n    if (number < 26) {\n      return String.fromCharCode(65 + number);\n    }\n    if (number < 52) {\n      return String.fromCharCode(97 + (number - 26));\n    }\n    if (number < 62) {\n      return String.fromCharCode(48 + (number - 52));\n    }\n    if (number === 62) {\n      return "+";\n    }\n    if (number === 63) {\n      return "/";\n    }\n    throw "Tried to encode large digit " + number + " in base64.";\n  };\n\n  var encodeBase64 = function(array) {\n    var chunks = [];\n    chunks.length = Math.ceil(array.length / 3);\n    _.times(chunks.length, function(i) {\n      var b1 = array[i * 3];\n      var b2 = array[i * 3 + 1] || 0;\n      var b3 = array[i * 3 + 2] || 0;\n\n      var has2 = (i * 3 + 1) < array.length;\n      var has3 = (i * 3 + 2) < array.length;\n\n      chunks[i] = [\n        b64Digit((b1 >> 2) & 0x3F),\n        b64Digit(((b1 << 4) & 0x30) | ((b2 >> 4) & 0x0F)),\n        has2 ? b64Digit(((b2 << 2) & 0x3C) | ((b3 >> 6) & 0x03)) : "=",\n        has3 ? b64Digit(b3 & 0x3F) : "="\n      ].join("");\n    });\n    return chunks.join("");\n  };\n\n\n  // A list of file extensions to mime types as found here:\n  // http://stackoverflow.com/questions/58510/using-net-how-can-you-find-the-\n  //     mime-type-of-a-file-based-on-the-file-signature\n  var mimeTypes = {\n    ai: "application/postscript",\n    aif: "audio/x-aiff",\n    aifc: "audio/x-aiff",\n    aiff: "audio/x-aiff",\n    asc: "text/plain",\n    atom: "application/atom+xml",\n    au: "audio/basic",\n    avi: "video/x-msvideo",\n    bcpio: "application/x-bcpio",\n    bin: "application/octet-stream",\n    bmp: "image/bmp",\n    cdf: "application/x-netcdf",\n    cgm: "image/cgm",\n    "class": "application/octet-stream",\n    cpio: "application/x-cpio",\n    cpt: "application/mac-compactpro",\n    csh: "application/x-csh",\n    css: "text/css",\n    dcr: "application/x-director",\n    dif: "video/x-dv",\n    dir: "application/x-director",\n    djv: "image/vnd.djvu",\n    djvu: "image/vnd.djvu",\n    dll: "application/octet-stream",\n    dmg: "application/octet-stream",\n    dms: "application/octet-stream",\n    doc: "application/msword",\n    docx: "application/vnd.openxmlformats-officedocument.wordprocessingml." +\n          "document",\n    dotx: "application/vnd.openxmlformats-officedocument.wordprocessingml." +\n          "template",\n    docm: "application/vnd.ms-word.document.macroEnabled.12",\n    dotm: "application/vnd.ms-word.template.macroEnabled.12",\n    dtd: "application/xml-dtd",\n    dv: "video/x-dv",\n    dvi: "application/x-dvi",\n    dxr: "application/x-director",\n    eps: "application/postscript",\n    etx: "text/x-setext",\n    exe: "application/octet-stream",\n    ez: "application/andrew-inset",\n    gif: "image/gif",\n    gram: "application/srgs",\n    grxml: "application/srgs+xml",\n    gtar: "application/x-gtar",\n    hdf: "application/x-hdf",\n    hqx: "application/mac-binhex40",\n    htm: "text/html",\n    html: "text/html",\n    ice: "x-conference/x-cooltalk",\n    ico: "image/x-icon",\n    ics: "text/calendar",\n    ief: "image/ief",\n    ifb: "text/calendar",\n    iges: "model/iges",\n    igs: "model/iges",\n    jnlp: "application/x-java-jnlp-file",\n    jp2: "image/jp2",\n    jpe: "image/jpeg",\n    jpeg: "image/jpeg",\n    jpg: "image/jpeg",\n    js: "application/x-javascript",\n    kar: "audio/midi",\n    latex: "application/x-latex",\n    lha: "application/octet-stream",\n    lzh: "application/octet-stream",\n    m3u: "audio/x-mpegurl",\n    m4a: "audio/mp4a-latm",\n    m4b: "audio/mp4a-latm",\n    m4p: "audio/mp4a-latm",\n    m4u: "video/vnd.mpegurl",\n    m4v: "video/x-m4v",\n    mac: "image/x-macpaint",\n    man: "application/x-troff-man",\n    mathml: "application/mathml+xml",\n    me: "application/x-troff-me",\n    mesh: "model/mesh",\n    mid: "audio/midi",\n    midi: "audio/midi",\n    mif: "application/vnd.mif",\n    mov: "video/quicktime",\n    movie: "video/x-sgi-movie",\n    mp2: "audio/mpeg",\n    mp3: "audio/mpeg",\n    mp4: "video/mp4",\n    mpe: "video/mpeg",\n    mpeg: "video/mpeg",\n    mpg: "video/mpeg",\n    mpga: "audio/mpeg",\n    ms: "application/x-troff-ms",\n    msh: "model/mesh",\n    mxu: "video/vnd.mpegurl",\n    nc: "application/x-netcdf",\n    oda: "application/oda",\n    ogg: "application/ogg",\n    pbm: "image/x-portable-bitmap",\n    pct: "image/pict",\n    pdb: "chemical/x-pdb",\n    pdf: "application/pdf",\n    pgm: "image/x-portable-graymap",\n    pgn: "application/x-chess-pgn",\n    pic: "image/pict",\n    pict: "image/pict",\n    png: "image/png",\n    pnm: "image/x-portable-anymap",\n    pnt: "image/x-macpaint",\n    pntg: "image/x-macpaint",\n    ppm: "image/x-portable-pixmap",\n    ppt: "application/vnd.ms-powerpoint",\n    pptx: "application/vnd.openxmlformats-officedocument.presentationml." +\n          "presentation",\n    potx: "application/vnd.openxmlformats-officedocument.presentationml." +\n          "template",\n    ppsx: "application/vnd.openxmlformats-officedocument.presentationml." +\n          "slideshow",\n    ppam: "application/vnd.ms-powerpoint.addin.macroEnabled.12",\n    pptm: "application/vnd.ms-powerpoint.presentation.macroEnabled.12",\n    potm: "application/vnd.ms-powerpoint.template.macroEnabled.12",\n    ppsm: "application/vnd.ms-powerpoint.slideshow.macroEnabled.12",\n    ps: "application/postscript",\n    qt: "video/quicktime",\n    qti: "image/x-quicktime",\n    qtif: "image/x-quicktime",\n    ra: "audio/x-pn-realaudio",\n    ram: "audio/x-pn-realaudio",\n    ras: "image/x-cmu-raster",\n    rdf: "application/rdf+xml",\n    rgb: "image/x-rgb",\n    rm: "application/vnd.rn-realmedia",\n    roff: "application/x-troff",\n    rtf: "text/rtf",\n    rtx: "text/richtext",\n    sgm: "text/sgml",\n    sgml: "text/sgml",\n    sh: "application/x-sh",\n    shar: "application/x-shar",\n    silo: "model/mesh",\n    sit: "application/x-stuffit",\n    skd: "application/x-koan",\n    skm: "application/x-koan",\n    skp: "application/x-koan",\n    skt: "application/x-koan",\n    smi: "application/smil",\n    smil: "application/smil",\n    snd: "audio/basic",\n    so: "application/octet-stream",\n    spl: "application/x-futuresplash",\n    src: "application/x-wais-source",\n    sv4cpio: "application/x-sv4cpio",\n    sv4crc: "application/x-sv4crc",\n    svg: "image/svg+xml",\n    swf: "application/x-shockwave-flash",\n    t: "application/x-troff",\n    tar: "application/x-tar",\n    tcl: "application/x-tcl",\n    tex: "application/x-tex",\n    texi: "application/x-texinfo",\n    texinfo: "application/x-texinfo",\n    tif: "image/tiff",\n    tiff: "image/tiff",\n    tr: "application/x-troff",\n    tsv: "text/tab-separated-values",\n    txt: "text/plain",\n    ustar: "application/x-ustar",\n    vcd: "application/x-cdlink",\n    vrml: "model/vrml",\n    vxml: "application/voicexml+xml",\n    wav: "audio/x-wav",\n    wbmp: "image/vnd.wap.wbmp",\n    wbmxl: "application/vnd.wap.wbxml",\n    wml: "text/vnd.wap.wml",\n    wmlc: "application/vnd.wap.wmlc",\n    wmls: "text/vnd.wap.wmlscript",\n    wmlsc: "application/vnd.wap.wmlscriptc",\n    wrl: "model/vrml",\n    xbm: "image/x-xbitmap",\n    xht: "application/xhtml+xml",\n    xhtml: "application/xhtml+xml",\n    xls: "application/vnd.ms-excel",\n    xml: "application/xml",\n    xpm: "image/x-xpixmap",\n    xsl: "application/xml",\n    xlsx: "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",\n    xltx: "application/vnd.openxmlformats-officedocument.spreadsheetml." +\n          "template",\n    xlsm: "application/vnd.ms-excel.sheet.macroEnabled.12",\n    xltm: "application/vnd.ms-excel.template.macroEnabled.12",\n    xlam: "application/vnd.ms-excel.addin.macroEnabled.12",\n    xlsb: "application/vnd.ms-excel.sheet.binary.macroEnabled.12",\n    xslt: "application/xslt+xml",\n    xul: "application/vnd.mozilla.xul+xml",\n    xwd: "image/x-xwindowdump",\n    xyz: "chemical/x-xyz",\n    zip: "application/zip"\n  };\n\n  /**\n   * Reads a File using a FileReader.\n   * @param file {File} the File to read.\n   * @param type {String} (optional) the mimetype to override with.\n   * @return {Parse.Promise} A Promise that will be fulfilled with a\n   *     base64-encoded string of the data and its mime type.\n   */\n  var readAsync = function(file, type) {\n    var promise = new Parse.Promise();\n\n    if (typeof(FileReader) === "undefined") {\n      return Parse.Promise.error(new Parse.Error(\n          Parse.Error.FILE_READ_ERROR,\n          "Attempted to use a FileReader on an unsupported browser."));\n    }\n\n    var reader = new FileReader();\n    reader.onloadend = function() {\n      if (reader.readyState !== 2) {\n        promise.reject(new Parse.Error(\n            Parse.Error.FILE_READ_ERROR,\n            "Error reading file."));\n        return;\n      }\n\n      var dataURL = reader.result;\n      var matches = /^data:([^;]*);base64,(.*)$/.exec(dataURL);\n      if (!matches) {\n        promise.reject(new Parse.Error(\n            Parse.ERROR.FILE_READ_ERROR,\n            "Unable to interpret data URL: " + dataURL));\n        return;\n      }\n\n      promise.resolve(matches[2], type || matches[1]);\n    };\n    reader.readAsDataURL(file);\n    return promise;\n  };\n\n  /**\n   * A Parse.File is a local representation of a file that is saved to the Parse\n   * cloud.\n   * @class\n   * @param name {String} The file\'s name. This will be prefixed by a unique\n   *     value once the file has finished saving. The file name must begin with\n   *     an alphanumeric character, and consist of alphanumeric characters,\n   *     periods, spaces, underscores, or dashes.\n   * @param data {Array} The data for the file, as either:\n   *     1. an Array of byte value Numbers, or\n   *     2. an Object like { base64: "..." } with a base64-encoded String.\n   *     3. a File object selected with a file upload control. (3) only works\n   *        in Firefox 3.6+, Safari 6.0.2+, Chrome 7+, and IE 10+.\n   *        For example:<pre>\n   * var fileUploadControl = $("#profilePhotoFileUpload")[0];\n   * if (fileUploadControl.files.length > 0) {\n   *   var file = fileUploadControl.files[0];\n   *   var name = "photo.jpg";\n   *   var parseFile = new Parse.File(name, file);\n   *   parseFile.save().then(function() {\n   *     // The file has been saved to Parse.\n   *   }, function(error) {\n   *     // The file either could not be read, or could not be saved to Parse.\n   *   });\n   * }</pre>\n   * @param type {String} Optional Content-Type header to use for the file. If\n   *     this is omitted, the content type will be inferred from the name\'s\n   *     extension.\n   */\n  Parse.File = function(name, data, type) {\n    this._name = name;\n\n    // Guess the content type from the extension if we need to.\n    var extension = /\\.([^.]*)$/.exec(name);\n    if (extension) {\n      extension = extension[1].toLowerCase();\n    }\n    var guessedType = type || mimeTypes[extension] || "text/plain";\n\n    if (_.isArray(data)) {\n      this._source = Parse.Promise.as(encodeBase64(data), guessedType);\n    } else if (data && data.base64) {\n      // if it contains data uri, extract based64 and the type out of it.\n      /*jslint maxlen: 1000*/\n      var dataUriRegexp = /^data:([a-zA-Z]*\\/[a-zA-Z+.-]*);(charset=[a-zA-Z0-9\\-\\/\\s]*,)?base64,(\\S+)/;\n      /*jslint maxlen: 80*/\n\n      var matches = dataUriRegexp.exec(data.base64);\n      if (matches && matches.length > 0) {\n        // if data URI with charset, there will have 4 matches.\n        this._source = Parse.Promise.as(\n          (matches.length === 4 ? matches[3] : matches[2]), matches[1]\n        );\n      } else {\n        this._source = Parse.Promise.as(data.base64, guessedType);\n      }\n    } else if (typeof(File) !== "undefined" && data instanceof File) {\n      this._source = readAsync(data, type);\n    } else if (_.isString(data)) {\n      throw "Creating a Parse.File from a String is not yet supported.";\n    }\n  };\n\n  Parse.File.prototype = {\n\n    /**\n     * Gets the name of the file. Before save is called, this is the filename\n     * given by the user. After save is called, that name gets prefixed with a\n     * unique identifier.\n     */\n    name: function() {\n      return this._name;\n    },\n\n    /**\n     * Gets the url of the file. It is only available after you save the file or\n     * after you get the file from a Parse.Object.\n     * @return {String}\n     */\n    url: function() {\n      return this._url;\n    },\n\n    /**\n     * Saves the file to the Parse cloud.\n     * @param {Object} options A Backbone-style options object.\n     * @return {Parse.Promise} Promise that is resolved when the save finishes.\n     */\n    save: function(options) {\n      options= options || {};\n\n      var self = this;\n      if (!self._previousSave) {\n        self._previousSave = self._source.then(function(base64, type) {\n          var data = {\n            base64: base64,\n            _ContentType: type\n          };\n          return Parse._request({\n            route: "files",\n            className: self._name,\n            method: \'POST\',\n            data: data,\n            useMasterKey: options.useMasterKey\n          });\n\n        }).then(function(response) {\n          self._name = response.name;\n          self._url = response.url;\n          return self;\n        });\n      }\n      return self._previousSave._thenRunCallbacks(options);\n    }\n  };\n\n}(this));\n\n// Parse.Object is analogous to the Java ParseObject.\n// It also implements the same interface as a Backbone model.\n\n(function(root) {\n  root.Parse = root.Parse || {};\n  var Parse = root.Parse;\n  var _ = Parse._;\n\n  /**\n   * Creates a new model with defined attributes. A client id (cid) is\n   * automatically generated and assigned for you.\n   *\n   * <p>You won\'t normally call this method directly.  It is recommended that\n   * you use a subclass of <code>Parse.Object</code> instead, created by calling\n   * <code>extend</code>.</p>\n   *\n   * <p>However, if you don\'t want to use a subclass, or aren\'t sure which\n   * subclass is appropriate, you can use this form:<pre>\n   *     var object = new Parse.Object("ClassName");\n   * </pre>\n   * That is basically equivalent to:<pre>\n   *     var MyClass = Parse.Object.extend("ClassName");\n   *     var object = new MyClass();\n   * </pre></p>\n   *\n   * @param {Object} attributes The initial set of data to store in the object.\n   * @param {Object} options A set of Backbone-like options for creating the\n   *     object.  The only option currently supported is "collection".\n   * @see Parse.Object.extend\n   *\n   * @class\n   *\n   * <p>The fundamental unit of Parse data, which implements the Backbone Model\n   * interface.</p>\n   */\n  Parse.Object = function(attributes, options) {\n    // Allow new Parse.Object("ClassName") as a shortcut to _create.\n    if (_.isString(attributes)) {\n      return Parse.Object._create.apply(this, arguments);\n    }\n\n    attributes = attributes || {};\n    if (options && options.parse) {\n      attributes = this.parse(attributes);\n    }\n    var defaults = Parse._getValue(this, \'defaults\');\n    if (defaults) {\n      attributes = _.extend({}, defaults, attributes);\n    }\n    if (options && options.collection) {\n      this.collection = options.collection;\n    }\n\n    this._serverData = {};  // The last known data for this object from cloud.\n    this._opSetQueue = [{}];  // List of sets of changes to the data.\n    this.attributes = {};  // The best estimate of this\'s current data.\n\n    this._hashedJSON = {};  // Hash of values of containers at last save.\n    this._escapedAttributes = {};\n    this.cid = _.uniqueId(\'c\');\n    this.changed = {};\n    this._silent = {};\n    this._pending = {};\n    if (!this.set(attributes, {silent: true})) {\n      throw new Error("Can\'t create an invalid Parse.Object");\n    }\n    this.changed = {};\n    this._silent = {};\n    this._pending = {};\n    this._hasData = true;\n    this._previousAttributes = _.clone(this.attributes);\n    this.initialize.apply(this, arguments);\n  };\n\n  /**\n   * @lends Parse.Object.prototype\n   * @property {String} id The objectId of the Parse Object.\n   */\n\n  /**\n   * Saves the given list of Parse.Object.\n   * If any error is encountered, stops and calls the error handler.\n   *\n   * <pre>\n   *   Parse.Object.saveAll([object1, object2, ...], {\n   *     success: function(list) {\n   *       // All the objects were saved.\n   *     },\n   *     error: function(error) {\n   *       // An error occurred while saving one of the objects.\n   *     },\n   *   });\n   * </pre>\n   *\n   * @param {Array} list A list of <code>Parse.Object</code>.\n   * @param {Object} options A Backbone-style callback object.\n   * Valid options are:<ul>\n   *   <li>useMasterKey: In Cloud Code and Node only, causes the Master Key to\n   *     be used for this request.\n   * </ul>\n   */\n  Parse.Object.saveAll = function(list, options) {\n    options = options || {};\n    return Parse.Object._deepSaveAsync(list, {\n      useMasterKey: options.useMasterKey\n    })._thenRunCallbacks(options);\n  };\n\n  /**\n   * Destroy the given list of models on the server if it was already persisted.\n   * Optimistically removes each model from its collection, if it has one.\n   * If `wait: true` is passed, waits for the server to respond before removal.\n   *\n   * <p>Unlike saveAll, if an error occurs while deleting an individual model,\n   * this method will continue trying to delete the rest of the models if\n   * possible, except in the case of a fatal error like a connection error.\n   *\n   * <p>In particular, the Parse.Error object returned in the case of error may\n   * be one of two types:\n   *\n   * <ul>\n   *   <li>A Parse.Error.AGGREGATE_ERROR. This object\'s "errors" property is an\n   *       array of other Parse.Error objects. Each error object in this array\n   *       has an "object" property that references the object that could not be\n   *       deleted (for instance, because that object could not be found).</li>\n   *   <li>A non-aggregate Parse.Error. This indicates a serious error that\n   *       caused the delete operation to be aborted partway through (for\n   *       instance, a connection failure in the middle of the delete).</li>\n   * </ul>\n   *\n   * <pre>\n   *   Parse.Object.destroyAll([object1, object2, ...], {\n   *     success: function() {\n   *       // All the objects were deleted.\n   *     },\n   *     error: function(error) {\n   *       // An error occurred while deleting one or more of the objects.\n   *       // If this is an aggregate error, then we can inspect each error\n   *       // object individually to determine the reason why a particular\n   *       // object was not deleted.\n   *       if (error.code == Parse.Error.AGGREGATE_ERROR) {\n   *         for (var i = 0; i < error.errors.length; i++) {\n   *           console.log("Couldn\'t delete " + error.errors[i].object.id +\n   *             "due to " + error.errors[i].message);\n   *         }\n   *       } else {\n   *         console.log("Delete aborted because of " + error.message);\n   *       }\n   *     },\n   *   });\n   * </pre>\n   *\n   * @param {Array} list A list of <code>Parse.Object</code>.\n   * @param {Object} options A Backbone-style callback object.\n   * Valid options are:<ul>\n   *   <li>useMasterKey: In Cloud Code and Node only, causes the Master Key to\n   *     be used for this request.\n   * </ul>\n   */\n  Parse.Object.destroyAll = function(list, options) {\n    options = options || {};\n\n    var triggerDestroy = function(object) {\n      object.trigger(\'destroy\', object, object.collection, options);\n    };\n\n    var errors = [];\n    var destroyBatch = function(batch) {\n      var promise = Parse.Promise.as();\n\n      if (batch.length > 0) {\n        promise = promise.then(function() {\n          return Parse._request({\n            route: "batch",\n            method: "POST",\n            useMasterKey: options.useMasterKey,\n            data: {\n              requests: _.map(batch, function(object) {\n                return {\n                  method: "DELETE",\n                  path: "/1/classes/" + object.className + "/" + object.id\n                };\n              })\n            }\n          });\n        }).then(function(responses, status, xhr) {\n          Parse._arrayEach(batch, function(object, i) {\n            if (responses[i].success && options.wait) {\n              triggerDestroy(object);\n            } else if (responses[i].error) {\n              var error = new Parse.Error(responses[i].error.code,\n                                          responses[i].error.error);\n              error.object = object;\n\n              errors.push(error);\n            }\n          });\n        });\n      }\n\n      return promise;\n    };\n\n    var promise = Parse.Promise.as();\n    var batch = [];\n    Parse._arrayEach(list, function(object, i) {\n      if (!object.id || !options.wait) {\n        triggerDestroy(object);\n      }\n\n      if (object.id) {\n        batch.push(object);\n      }\n\n      if (batch.length === 20 || i+1 === list.length) {\n        var thisBatch = batch;\n        batch = [];\n\n        promise = promise.then(function() {\n          return destroyBatch(thisBatch);\n        });\n      }\n    });\n\n    return promise.then(function() {\n      if (errors.length === 0) {\n        return true;\n      } else {\n        var error = new Parse.Error(Parse.Error.AGGREGATE_ERROR,\n                                    "Error deleting an object in destroyAll");\n        error.errors = errors;\n\n        return Parse.Promise.error(error);\n      }\n    })._thenRunCallbacks(options);\n  };\n\n  /**\n   * Fetches the given list of Parse.Object.\n   * If any error is encountered, stops and calls the error handler.\n   *\n   * <pre>\n   *   Parse.Object.fetchAll([object1, object2, ...], {\n   *     success: function(list) {\n   *       // All the objects were fetched.\n   *     },\n   *     error: function(error) {\n   *       // An error occurred while fetching one of the objects.\n   *     },\n   *   });\n   * </pre>\n   *\n   * @param {Array} list A list of <code>Parse.Object</code>.\n   * @param {Object} options A Backbone-style callback object.\n   * Valid options are:<ul>\n   *   <li>success: A Backbone-style success callback.\n   *   <li>error: An Backbone-style error callback.\n   * </ul>\n   */\n  Parse.Object.fetchAll = function(list, options) {\n    return Parse.Object._fetchAll(\n      list,\n      true\n    )._thenRunCallbacks(options);\n  };\n\n  /**\n   * Fetches the given list of Parse.Object if needed.\n   * If any error is encountered, stops and calls the error handler.\n   *\n   * <pre>\n   *   Parse.Object.fetchAllIfNeeded([object1, ...], {\n   *     success: function(list) {\n   *       // Objects were fetched and updated.\n   *     },\n   *     error: function(error) {\n   *       // An error occurred while fetching one of the objects.\n   *     },\n   *   });\n   * </pre>\n   *\n   * @param {Array} list A list of <code>Parse.Object</code>.\n   * @param {Object} options A Backbone-style callback object.\n   * Valid options are:<ul>\n   *   <li>success: A Backbone-style success callback.\n   *   <li>error: An Backbone-style error callback.\n   * </ul>\n   */\n  Parse.Object.fetchAllIfNeeded = function(list, options) {\n    return Parse.Object._fetchAll(\n      list,\n      false\n    )._thenRunCallbacks(options);\n  };\n\n  // Attach all inheritable methods to the Parse.Object prototype.\n  _.extend(Parse.Object.prototype, Parse.Events,\n           /** @lends Parse.Object.prototype */ {\n    _existed: false,\n\n    /**\n     * Initialize is an empty function by default. Override it with your own\n     * initialization logic.\n     */\n    initialize: function(){},\n\n    /**\n     * Returns a JSON version of the object suitable for saving to Parse.\n     * @return {Object}\n     */\n    toJSON: function() {\n      var json = this._toFullJSON();\n      Parse._arrayEach(["__type", "className"],\n                       function(key) { delete json[key]; });\n      return json;\n    },\n\n    _toFullJSON: function(seenObjects) {\n      var json = _.clone(this.attributes);\n      Parse._objectEach(json, function(val, key) {\n        json[key] = Parse._encode(val, seenObjects);\n      });\n      Parse._objectEach(this._operations, function(val, key) {\n        json[key] = val;\n      });\n\n      if (_.has(this, "id")) {\n        json.objectId = this.id;\n      }\n      if (_.has(this, "createdAt")) {\n        if (_.isDate(this.createdAt)) {\n          json.createdAt = this.createdAt.toJSON();\n        } else {\n          json.createdAt = this.createdAt;\n        }\n      }\n\n      if (_.has(this, "updatedAt")) {\n        if (_.isDate(this.updatedAt)) {\n          json.updatedAt = this.updatedAt.toJSON();\n        } else {\n          json.updatedAt = this.updatedAt;\n        }\n      }\n      json.__type = "Object";\n      json.className = this.className;\n      return json;\n    },\n\n    /**\n     * Updates _hashedJSON to reflect the current state of this object.\n     * Adds any changed hash values to the set of pending changes.\n     */\n    _refreshCache: function() {\n      var self = this;\n      if (self._refreshingCache) {\n        return;\n      }\n      self._refreshingCache = true;\n      Parse._objectEach(this.attributes, function(value, key) {\n        if (value instanceof Parse.Object) {\n          value._refreshCache();\n        } else if (_.isObject(value)) {\n          if (self._resetCacheForKey(key)) {\n            self.set(key, new Parse.Op.Set(value), { silent: true });\n          }\n        }\n      });\n      delete self._refreshingCache;\n    },\n\n    /**\n     * Returns true if this object has been modified since its last\n     * save/refresh.  If an attribute is specified, it returns true only if that\n     * particular attribute has been modified since the last save/refresh.\n     * @param {String} attr An attribute name (optional).\n     * @return {Boolean}\n     */\n    dirty: function(attr) {\n      this._refreshCache();\n\n      var currentChanges = _.last(this._opSetQueue);\n\n      if (attr) {\n        return (currentChanges[attr] ? true : false);\n      }\n      if (!this.id) {\n        return true;\n      }\n      if (_.keys(currentChanges).length > 0) {\n        return true;\n      }\n      return false;\n    },\n\n    /**\n     * Returns an array of keys that have been modified since last save/refresh\n     * @return {Array of string}\n     */\n    dirtyKeys: function() {\n      return _.keys(_.last(this._opSetQueue));\n    },\n\n    /**\n     * Gets a Pointer referencing this Object.\n     */\n    _toPointer: function() {\n      if (!this.id) {\n        throw new Error("Can\'t serialize an unsaved Parse.Object");\n      }\n      return { __type: "Pointer",\n               className: this.className,\n               objectId: this.id };\n    },\n\n    /**\n     * Gets the value of an attribute.\n     * @param {String} attr The string name of an attribute.\n     */\n    get: function(attr) {\n      return this.attributes[attr];\n    },\n\n    /**\n     * Gets a relation on the given class for the attribute.\n     * @param String attr The attribute to get the relation for.\n     */\n    relation: function(attr) {\n      var value = this.get(attr);\n      if (value) {\n        if (!(value instanceof Parse.Relation)) {\n          throw "Called relation() on non-relation field " + attr;\n        }\n        value._ensureParentAndKey(this, attr);\n        return value;\n      } else {\n        return new Parse.Relation(this, attr);\n      }\n    },\n\n    /**\n     * Gets the HTML-escaped value of an attribute.\n     */\n    escape: function(attr) {\n      var html = this._escapedAttributes[attr];\n      if (html) {\n        return html;\n      }\n      var val = this.attributes[attr];\n      var escaped;\n      if (Parse._isNullOrUndefined(val)) {\n        escaped = \'\';\n      } else {\n        escaped = _.escape(val.toString());\n      }\n      this._escapedAttributes[attr] = escaped;\n      return escaped;\n    },\n\n    /**\n     * Returns <code>true</code> if the attribute contains a value that is not\n     * null or undefined.\n     * @param {String} attr The string name of the attribute.\n     * @return {Boolean}\n     */\n    has: function(attr) {\n      return !Parse._isNullOrUndefined(this.attributes[attr]);\n    },\n\n    /**\n     * Pulls "special" fields like objectId, createdAt, etc. out of attrs\n     * and puts them on "this" directly.  Removes them from attrs.\n     * @param attrs - A dictionary with the data for this Parse.Object.\n     */\n    _mergeMagicFields: function(attrs) {\n      // Check for changes of magic fields.\n      var model = this;\n      var specialFields = ["id", "objectId", "createdAt", "updatedAt"];\n      Parse._arrayEach(specialFields, function(attr) {\n        if (attrs[attr]) {\n          if (attr === "objectId") {\n            model.id = attrs[attr];\n          } else if ((attr === "createdAt" || attr === "updatedAt") &&\n                     !_.isDate(attrs[attr])) {\n            model[attr] = Parse._parseDate(attrs[attr]);\n          } else {\n            model[attr] = attrs[attr];\n          }\n          delete attrs[attr];\n        }\n      });\n    },\n\n    /**\n     * Copies the given serverData to "this", refreshes attributes, and\n     * clears pending changes;\n     */\n    _copyServerData: function(serverData) {\n      // Copy server data\n      var tempServerData = {};\n      Parse._objectEach(serverData, function(value, key) {\n        tempServerData[key] = Parse._decode(key, value);\n      });\n      this._serverData = tempServerData;\n\n      // Refresh the attributes.\n      this._rebuildAllEstimatedData();\n\n\n      // Clear out any changes the user might have made previously.\n      this._refreshCache();\n      this._opSetQueue = [{}];\n\n      // Refresh the attributes again.\n      this._rebuildAllEstimatedData();\n    },\n\n    /**\n     * Merges another object\'s attributes into this object.\n     */\n    _mergeFromObject: function(other) {\n      if (!other) {\n        return;\n      }\n\n      // This does the inverse of _mergeMagicFields.\n      this.id = other.id;\n      this.createdAt = other.createdAt;\n      this.updatedAt = other.updatedAt;\n\n      this._copyServerData(other._serverData);\n\n      this._hasData = true;\n    },\n\n    /**\n     * Returns the json to be sent to the server.\n     */\n    _startSave: function() {\n      this._opSetQueue.push({});\n    },\n\n    /**\n     * Called when a save fails because of an error. Any changes that were part\n     * of the save need to be merged with changes made after the save. This\n     * might throw an exception is you do conflicting operations. For example,\n     * if you do:\n     *   object.set("foo", "bar");\n     *   object.set("invalid field name", "baz");\n     *   object.save();\n     *   object.increment("foo");\n     * then this will throw when the save fails and the client tries to merge\n     * "bar" with the +1.\n     */\n    _cancelSave: function() {\n      var self = this;\n      var failedChanges = _.first(this._opSetQueue);\n      this._opSetQueue = _.rest(this._opSetQueue);\n      var nextChanges = _.first(this._opSetQueue);\n      Parse._objectEach(failedChanges, function(op, key) {\n        var op1 = failedChanges[key];\n        var op2 = nextChanges[key];\n        if (op1 && op2) {\n          nextChanges[key] = op2._mergeWithPrevious(op1);\n        } else if (op1) {\n          nextChanges[key] = op1;\n        }\n      });\n      this._saving = this._saving - 1;\n    },\n\n    /**\n     * Called when a save completes successfully. This merges the changes that\n     * were saved into the known server data, and overrides it with any data\n     * sent directly from the server.\n     */\n    _finishSave: function(serverData) {\n      // Grab a copy of any object referenced by this object. These instances\n      // may have already been fetched, and we don\'t want to lose their data.\n      // Note that doing it like this means we will unify separate copies of the\n      // same object, but that\'s a risk we have to take.\n      var fetchedObjects = {};\n      Parse._traverse(this.attributes, function(object) {\n        if (object instanceof Parse.Object && object.id && object._hasData) {\n          fetchedObjects[object.id] = object;\n        }\n      });\n\n      var savedChanges = _.first(this._opSetQueue);\n      this._opSetQueue = _.rest(this._opSetQueue);\n      this._applyOpSet(savedChanges, this._serverData);\n      this._mergeMagicFields(serverData);\n      var self = this;\n      Parse._objectEach(serverData, function(value, key) {\n        self._serverData[key] = Parse._decode(key, value);\n\n        // Look for any objects that might have become unfetched and fix them\n        // by replacing their values with the previously observed values.\n        var fetched = Parse._traverse(self._serverData[key], function(object) {\n          if (object instanceof Parse.Object && fetchedObjects[object.id]) {\n            return fetchedObjects[object.id];\n          }\n        });\n        if (fetched) {\n          self._serverData[key] = fetched;\n        }\n      });\n      this._rebuildAllEstimatedData();\n      this._saving = this._saving - 1;\n    },\n\n    /**\n     * Called when a fetch or login is complete to set the known server data to\n     * the given object.\n     */\n    _finishFetch: function(serverData, hasData) {\n\n      this._opSetQueue = [{}];\n\n      // Bring in all the new server data.\n      this._mergeMagicFields(serverData);\n      this._copyServerData(serverData);\n\n      this._hasData = hasData;\n    },\n\n    /**\n     * Applies the set of Parse.Op in opSet to the object target.\n     */\n    _applyOpSet: function(opSet, target) {\n      var self = this;\n      Parse._objectEach(opSet, function(change, key) {\n        target[key] = change._estimate(target[key], self, key);\n        if (target[key] === Parse.Op._UNSET) {\n          delete target[key];\n        }\n      });\n    },\n\n    /**\n     * Replaces the cached value for key with the current value.\n     * Returns true if the new value is different than the old value.\n     */\n    _resetCacheForKey: function(key) {\n      var value = this.attributes[key];\n      if (_.isObject(value) &&\n          !(value instanceof Parse.Object) &&\n          !(value instanceof Parse.File)) {\n        value = value.toJSON ? value.toJSON() : value;\n        var json = JSON.stringify(value);\n        if (this._hashedJSON[key] !== json) {\n          this._hashedJSON[key] = json;\n          return true;\n        }\n      }\n      return false;\n    },\n\n    /**\n     * Populates attributes[key] by starting with the last known data from the\n     * server, and applying all of the local changes that have been made to that\n     * key since then.\n     */\n    _rebuildEstimatedDataForKey: function(key) {\n      var self = this;\n      delete this.attributes[key];\n      if (this._serverData[key]) {\n        this.attributes[key] = this._serverData[key];\n      }\n      Parse._arrayEach(this._opSetQueue, function(opSet) {\n        var op = opSet[key];\n        if (op) {\n          self.attributes[key] = op._estimate(self.attributes[key], self, key);\n          if (self.attributes[key] === Parse.Op._UNSET) {\n            delete self.attributes[key];\n          } else {\n            self._resetCacheForKey(key);\n          }\n        }\n      });\n    },\n\n    /**\n     * Populates attributes by starting with the last known data from the\n     * server, and applying all of the local changes that have been made since\n     * then.\n     */\n    _rebuildAllEstimatedData: function() {\n      var self = this;\n\n      var previousAttributes = _.clone(this.attributes);\n\n      this.attributes = _.clone(this._serverData);\n      Parse._arrayEach(this._opSetQueue, function(opSet) {\n        self._applyOpSet(opSet, self.attributes);\n        Parse._objectEach(opSet, function(op, key) {\n          self._resetCacheForKey(key);\n        });\n      });\n\n      // Trigger change events for anything that changed because of the fetch.\n      Parse._objectEach(previousAttributes, function(oldValue, key) {\n        if (self.attributes[key] !== oldValue) {\n          self.trigger(\'change:\' + key, self, self.attributes[key], {});\n        }\n      });\n      Parse._objectEach(this.attributes, function(newValue, key) {\n        if (!_.has(previousAttributes, key)) {\n          self.trigger(\'change:\' + key, self, newValue, {});\n        }\n      });\n    },\n\n    /**\n     * Sets a hash of model attributes on the object, firing\n     * <code>"change"</code> unless you choose to silence it.\n     *\n     * <p>You can call it with an object containing keys and values, or with one\n     * key and value.  For example:<pre>\n     *   gameTurn.set({\n     *     player: player1,\n     *     diceRoll: 2\n     *   }, {\n     *     error: function(gameTurnAgain, error) {\n     *       // The set failed validation.\n     *     }\n     *   });\n     *\n     *   game.set("currentPlayer", player2, {\n     *     error: function(gameTurnAgain, error) {\n     *       // The set failed validation.\n     *     }\n     *   });\n     *\n     *   game.set("finished", true);</pre></p>\n     *\n     * @param {String} key The key to set.\n     * @param {} value The value to give it.\n     * @param {Object} options A set of Backbone-like options for the set.\n     *     The only supported options are <code>silent</code>,\n     *     <code>error</code>, and <code>promise</code>.\n     * @return {Boolean} true if the set succeeded.\n     * @see Parse.Object#validate\n     * @see Parse.Error\n     */\n    set: function(key, value, options) {\n      var attrs, attr;\n      if (_.isObject(key) || Parse._isNullOrUndefined(key)) {\n        attrs = key;\n        Parse._objectEach(attrs, function(v, k) {\n          attrs[k] = Parse._decode(k, v);\n        });\n        options = value;\n      } else {\n        attrs = {};\n        attrs[key] = Parse._decode(key, value);\n      }\n\n      // Extract attributes and options.\n      options = options || {};\n      if (!attrs) {\n        return this;\n      }\n      if (attrs instanceof Parse.Object) {\n        attrs = attrs.attributes;\n      }\n\n      // If the unset option is used, every attribute should be a Unset.\n      if (options.unset) {\n        Parse._objectEach(attrs, function(unused_value, key) {\n          attrs[key] = new Parse.Op.Unset();\n        });\n      }\n\n      // Apply all the attributes to get the estimated values.\n      var dataToValidate = _.clone(attrs);\n      var self = this;\n      Parse._objectEach(dataToValidate, function(value, key) {\n        if (value instanceof Parse.Op) {\n          dataToValidate[key] = value._estimate(self.attributes[key],\n                                                self, key);\n          if (dataToValidate[key] === Parse.Op._UNSET) {\n            delete dataToValidate[key];\n          }\n        }\n      });\n\n      // Run validation.\n      if (!this._validate(attrs, options)) {\n        return false;\n      }\n\n      this._mergeMagicFields(attrs);\n\n      options.changes = {};\n      var escaped = this._escapedAttributes;\n      var prev = this._previousAttributes || {};\n\n      // Update attributes.\n      Parse._arrayEach(_.keys(attrs), function(attr) {\n        var val = attrs[attr];\n\n        // If this is a relation object we need to set the parent correctly,\n        // since the location where it was parsed does not have access to\n        // this object.\n        if (val instanceof Parse.Relation) {\n          val.parent = self;\n        }\n\n        if (!(val instanceof Parse.Op)) {\n          val = new Parse.Op.Set(val);\n        }\n\n        // See if this change will actually have any effect.\n        var isRealChange = true;\n        if (val instanceof Parse.Op.Set &&\n            _.isEqual(self.attributes[attr], val.value)) {\n          isRealChange = false;\n        }\n\n        if (isRealChange) {\n          delete escaped[attr];\n          if (options.silent) {\n            self._silent[attr] = true;\n          } else {\n            options.changes[attr] = true;\n          }\n        }\n\n        var currentChanges = _.last(self._opSetQueue);\n        currentChanges[attr] = val._mergeWithPrevious(currentChanges[attr]);\n        self._rebuildEstimatedDataForKey(attr);\n\n        if (isRealChange) {\n          self.changed[attr] = self.attributes[attr];\n          if (!options.silent) {\n            self._pending[attr] = true;\n          }\n        } else {\n          delete self.changed[attr];\n          delete self._pending[attr];\n        }\n      });\n\n      if (!options.silent) {\n        this.change(options);\n      }\n      return this;\n    },\n\n    /**\n     * Remove an attribute from the model, firing <code>"change"</code> unless\n     * you choose to silence it. This is a noop if the attribute doesn\'t\n     * exist.\n     */\n    unset: function(attr, options) {\n      options = options || {};\n      options.unset = true;\n      return this.set(attr, null, options);\n    },\n\n    /**\n     * Atomically increments the value of the given attribute the next time the\n     * object is saved. If no amount is specified, 1 is used by default.\n     *\n     * @param attr {String} The key.\n     * @param amount {Number} The amount to increment by.\n     */\n    increment: function(attr, amount) {\n      if (_.isUndefined(amount) || _.isNull(amount)) {\n        amount = 1;\n      }\n      return this.set(attr, new Parse.Op.Increment(amount));\n    },\n\n    /**\n     * Atomically add an object to the end of the array associated with a given\n     * key.\n     * @param attr {String} The key.\n     * @param item {} The item to add.\n     */\n    add: function(attr, item) {\n      return this.set(attr, new Parse.Op.Add([item]));\n    },\n\n    /**\n     * Atomically add an object to the array associated with a given key, only\n     * if it is not already present in the array. The position of the insert is\n     * not guaranteed.\n     *\n     * @param attr {String} The key.\n     * @param item {} The object to add.\n     */\n    addUnique: function(attr, item) {\n      return this.set(attr, new Parse.Op.AddUnique([item]));\n    },\n\n    /**\n     * Atomically remove all instances of an object from the array associated\n     * with a given key.\n     *\n     * @param attr {String} The key.\n     * @param item {} The object to remove.\n     */\n    remove: function(attr, item) {\n      return this.set(attr, new Parse.Op.Remove([item]));\n    },\n\n    /**\n     * Returns an instance of a subclass of Parse.Op describing what kind of\n     * modification has been performed on this field since the last time it was\n     * saved. For example, after calling object.increment("x"), calling\n     * object.op("x") would return an instance of Parse.Op.Increment.\n     *\n     * @param attr {String} The key.\n     * @returns {Parse.Op} The operation, or undefined if none.\n     */\n    op: function(attr) {\n      return _.last(this._opSetQueue)[attr];\n    },\n\n    /**\n     * Clear all attributes on the model, firing <code>"change"</code> unless\n     * you choose to silence it.\n     */\n    clear: function(options) {\n      options = options || {};\n      options.unset = true;\n      var keysToClear = _.extend(this.attributes, this._operations);\n      return this.set(keysToClear, options);\n    },\n\n    /**\n     * Returns a JSON-encoded set of operations to be sent with the next save\n     * request.\n     */\n    _getSaveJSON: function() {\n      var json = _.clone(_.first(this._opSetQueue));\n      Parse._objectEach(json, function(op, key) {\n        json[key] = op.toJSON();\n      });\n      return json;\n    },\n\n    /**\n     * Returns true if this object can be serialized for saving.\n     */\n    _canBeSerialized: function() {\n      return Parse.Object._canBeSerializedAsValue(this.attributes);\n    },\n\n    /**\n     * Fetch the model from the server. If the server\'s representation of the\n     * model differs from its current attributes, they will be overriden,\n     * triggering a <code>"change"</code> event.\n     *\n     * @param {Object} options A Backbone-style callback object.\n     * Valid options are:<ul>\n     *   <li>success: A Backbone-style success callback.\n     *   <li>error: An Backbone-style error callback.\n     *   <li>useMasterKey: In Cloud Code and Node only, causes the Master Key to\n     *     be used for this request.\n     * </ul>\n     * @return {Parse.Promise} A promise that is fulfilled when the fetch\n     *     completes.\n     */\n    fetch: function(options) {\n      var self = this;\n      options = options || {};\n      var request = Parse._request({\n        method: \'GET\',\n        route: "classes",\n        className: this.className,\n        objectId: this.id,\n        useMasterKey: options.useMasterKey\n      });\n      return request.then(function(response, status, xhr) {\n        self._finishFetch(self.parse(response, status, xhr), true);\n        return self;\n      })._thenRunCallbacks(options, this);\n    },\n\n    /**\n     * Set a hash of model attributes, and save the model to the server.\n     * updatedAt will be updated when the request returns.\n     * You can either call it as:<pre>\n     *   object.save();</pre>\n     * or<pre>\n     *   object.save(null, options);</pre>\n     * or<pre>\n     *   object.save(attrs, options);</pre>\n     * or<pre>\n     *   object.save(key, value, options);</pre>\n     *\n     * For example, <pre>\n     *   gameTurn.save({\n     *     player: "Jake Cutter",\n     *     diceRoll: 2\n     *   }, {\n     *     success: function(gameTurnAgain) {\n     *       // The save was successful.\n     *     },\n     *     error: function(gameTurnAgain, error) {\n     *       // The save failed.  Error is an instance of Parse.Error.\n     *     }\n     *   });</pre>\n     * or with promises:<pre>\n     *   gameTurn.save({\n     *     player: "Jake Cutter",\n     *     diceRoll: 2\n     *   }).then(function(gameTurnAgain) {\n     *     // The save was successful.\n     *   }, function(error) {\n     *     // The save failed.  Error is an instance of Parse.Error.\n     *   });</pre>\n     *\n     * @param {Object} options A Backbone-style callback object.\n     * Valid options are:<ul>\n     *   <li>wait: Set to true to wait for the server to confirm a successful\n     *   save before modifying the attributes on the object.\n     *   <li>silent: Set to true to avoid firing the `set` event.\n     *   <li>success: A Backbone-style success callback.\n     *   <li>error: An Backbone-style error callback.\n     *   <li>useMasterKey: In Cloud Code and Node only, causes the Master Key to\n     *     be used for this request.\n     * </ul>\n     * @return {Parse.Promise} A promise that is fulfilled when the save\n     *     completes.\n     * @see Parse.Error\n     */\n    save: function(arg1, arg2, arg3) {\n      var i, attrs, current, options, saved;\n      if (_.isObject(arg1) || Parse._isNullOrUndefined(arg1)) {\n        attrs = arg1;\n        options = arg2;\n      } else {\n        attrs = {};\n        attrs[arg1] = arg2;\n        options = arg3;\n      }\n\n      // Make save({ success: function() {} }) work.\n      if (!options && attrs) {\n        var extra_keys = _.reject(attrs, function(value, key) {\n          return _.include(["success", "error", "wait"], key);\n        });\n        if (extra_keys.length === 0) {\n          var all_functions = true;\n          if (_.has(attrs, "success") && !_.isFunction(attrs.success)) {\n            all_functions = false;\n          }\n          if (_.has(attrs, "error") && !_.isFunction(attrs.error)) {\n            all_functions = false;\n          }\n          if (all_functions) {\n            // This attrs object looks like it\'s really an options object,\n            // and there\'s no other options object, so let\'s just use it.\n            return this.save(null, attrs);\n          }\n        }\n      }\n\n      options = _.clone(options) || {};\n      if (options.wait) {\n        current = _.clone(this.attributes);\n      }\n\n      var setOptions = _.clone(options) || {};\n      if (setOptions.wait) {\n        setOptions.silent = true;\n      }\n      var setError;\n      setOptions.error = function(model, error) {\n        setError = error;\n      };\n      if (attrs && !this.set(attrs, setOptions)) {\n        return Parse.Promise.error(setError)._thenRunCallbacks(options, this);\n      }\n\n      var model = this;\n\n      // If there is any unsaved child, save it first.\n      model._refreshCache();\n\n\n\n      var unsavedChildren = [];\n      var unsavedFiles = [];\n      Parse.Object._findUnsavedChildren(model.attributes,\n                                        unsavedChildren,\n                                        unsavedFiles);\n      if (unsavedChildren.length + unsavedFiles.length > 0) {\n        return Parse.Object._deepSaveAsync(this.attributes, {\n          useMasterKey: options.useMasterKey\n        }).then(function() {\n          return model.save(null, options);\n        }, function(error) {\n          return Parse.Promise.error(error)._thenRunCallbacks(options, model);\n        });\n      }\n\n      this._startSave();\n      this._saving = (this._saving || 0) + 1;\n\n      this._allPreviousSaves = this._allPreviousSaves || Parse.Promise.as();\n      this._allPreviousSaves = this._allPreviousSaves._continueWith(function() {\n        var method = model.id ? \'PUT\' : \'POST\';\n\n        var json = model._getSaveJSON();\n\n        var route = "classes";\n        var className = model.className;\n        if (model.className === "_User" && !model.id) {\n          // Special-case user sign-up.\n          route = "users";\n          className = null;\n        }\n        var request = Parse._request({\n          route: route,\n          className: className,\n          objectId: model.id,\n          method: method,\n          useMasterKey: options.useMasterKey,\n          data: json\n        });\n\n        request = request.then(function(resp, status, xhr) {\n          var serverAttrs = model.parse(resp, status, xhr);\n          if (options.wait) {\n            serverAttrs = _.extend(attrs || {}, serverAttrs);\n          }\n          model._finishSave(serverAttrs);\n          if (options.wait) {\n            model.set(current, setOptions);\n          }\n          return model;\n\n        }, function(error) {\n          model._cancelSave();\n          return Parse.Promise.error(error);\n\n        })._thenRunCallbacks(options, model);\n\n        return request;\n      });\n      return this._allPreviousSaves;\n    },\n\n    /**\n     * Destroy this model on the server if it was already persisted.\n     * Optimistically removes the model from its collection, if it has one.\n     * If `wait: true` is passed, waits for the server to respond\n     * before removal.\n     *\n     * @param {Object} options A Backbone-style callback object.\n     * Valid options are:<ul>\n     *   <li>wait: Set to true to wait for the server to confirm successful\n     *   deletion of the object before triggering the `destroy` event.\n     *   <li>success: A Backbone-style success callback\n     *   <li>error: An Backbone-style error callback.\n     *   <li>useMasterKey: In Cloud Code and Node only, causes the Master Key to\n     *     be used for this request.\n     * </ul>\n     * @return {Parse.Promise} A promise that is fulfilled when the destroy\n     *     completes.\n     */\n    destroy: function(options) {\n      options = options || {};\n      var model = this;\n\n      var triggerDestroy = function() {\n        model.trigger(\'destroy\', model, model.collection, options);\n      };\n\n      if (!this.id) {\n        return triggerDestroy();\n      }\n\n      if (!options.wait) {\n        triggerDestroy();\n      }\n\n      var request = Parse._request({\n        route: "classes",\n        className: this.className,\n        objectId: this.id,\n        method: \'DELETE\',\n        useMasterKey: options.useMasterKey\n      });\n      return request.then(function() {\n        if (options.wait) {\n          triggerDestroy();\n        }\n        return model;\n      })._thenRunCallbacks(options, this);\n    },\n\n    /**\n     * Converts a response into the hash of attributes to be set on the model.\n     * @ignore\n     */\n    parse: function(resp, status, xhr) {\n      var output = _.clone(resp);\n      _(["createdAt", "updatedAt"]).each(function(key) {\n        if (output[key]) {\n          output[key] = Parse._parseDate(output[key]);\n        }\n      });\n      if (!output.updatedAt) {\n        output.updatedAt = output.createdAt;\n      }\n      if (status) {\n        this._existed = (status !== 201);\n      }\n      return output;\n    },\n\n    /**\n     * Creates a new model with identical attributes to this one.\n     * @return {Parse.Object}\n     */\n    clone: function() {\n      return new this.constructor(this.attributes);\n    },\n\n    /**\n     * Returns true if this object has never been saved to Parse.\n     * @return {Boolean}\n     */\n    isNew: function() {\n      return !this.id;\n    },\n\n    /**\n     * Call this method to manually fire a `"change"` event for this model and\n     * a `"change:attribute"` event for each changed attribute.\n     * Calling this will cause all objects observing the model to update.\n     */\n    change: function(options) {\n      options = options || {};\n      var changing = this._changing;\n      this._changing = true;\n\n      // Silent changes become pending changes.\n      var self = this;\n      Parse._objectEach(this._silent, function(attr) {\n        self._pending[attr] = true;\n      });\n\n      // Silent changes are triggered.\n      var changes = _.extend({}, options.changes, this._silent);\n      this._silent = {};\n      Parse._objectEach(changes, function(unused_value, attr) {\n        self.trigger(\'change:\' + attr, self, self.get(attr), options);\n      });\n      if (changing) {\n        return this;\n      }\n\n      // This is to get around lint not letting us make a function in a loop.\n      var deleteChanged = function(value, attr) {\n        if (!self._pending[attr] && !self._silent[attr]) {\n          delete self.changed[attr];\n        }\n      };\n\n      // Continue firing `"change"` events while there are pending changes.\n      while (!_.isEmpty(this._pending)) {\n        this._pending = {};\n        this.trigger(\'change\', this, options);\n        // Pending and silent changes still remain.\n        Parse._objectEach(this.changed, deleteChanged);\n        self._previousAttributes = _.clone(this.attributes);\n      }\n\n      this._changing = false;\n      return this;\n    },\n\n    /**\n     * Returns true if this object was created by the Parse server when the\n     * object might have already been there (e.g. in the case of a Facebook\n     * login)\n     */\n    existed: function() {\n      return this._existed;\n    },\n\n    /**\n     * Determine if the model has changed since the last <code>"change"</code>\n     * event.  If you specify an attribute name, determine if that attribute\n     * has changed.\n     * @param {String} attr Optional attribute name\n     * @return {Boolean}\n     */\n    hasChanged: function(attr) {\n      if (!arguments.length) {\n        return !_.isEmpty(this.changed);\n      }\n      return this.changed && _.has(this.changed, attr);\n    },\n\n    /**\n     * Returns an object containing all the attributes that have changed, or\n     * false if there are no changed attributes. Useful for determining what\n     * parts of a view need to be updated and/or what attributes need to be\n     * persisted to the server. Unset attributes will be set to undefined.\n     * You can also pass an attributes object to diff against the model,\n     * determining if there *would be* a change.\n     */\n    changedAttributes: function(diff) {\n      if (!diff) {\n        return this.hasChanged() ? _.clone(this.changed) : false;\n      }\n      var changed = {};\n      var old = this._previousAttributes;\n      Parse._objectEach(diff, function(diffVal, attr) {\n        if (!_.isEqual(old[attr], diffVal)) {\n          changed[attr] = diffVal;\n        }\n      });\n      return changed;\n    },\n\n    /**\n     * Gets the previous value of an attribute, recorded at the time the last\n     * <code>"change"</code> event was fired.\n     * @param {String} attr Name of the attribute to get.\n     */\n    previous: function(attr) {\n      if (!arguments.length || !this._previousAttributes) {\n        return null;\n      }\n      return this._previousAttributes[attr];\n    },\n\n    /**\n     * Gets all of the attributes of the model at the time of the previous\n     * <code>"change"</code> event.\n     * @return {Object}\n     */\n    previousAttributes: function() {\n      return _.clone(this._previousAttributes);\n    },\n\n    /**\n     * Checks if the model is currently in a valid state. It\'s only possible to\n     * get into an *invalid* state if you\'re using silent changes.\n     * @return {Boolean}\n     */\n    isValid: function() {\n      return !this.validate(this.attributes);\n    },\n\n    /**\n     * You should not call this function directly unless you subclass\n     * <code>Parse.Object</code>, in which case you can override this method\n     * to provide additional validation on <code>set</code> and\n     * <code>save</code>.  Your implementation should return\n     *\n     * @param {Object} attrs The current data to validate.\n     * @param {Object} options A Backbone-like options object.\n     * @return {} False if the data is valid.  An error object otherwise.\n     * @see Parse.Object#set\n     */\n    validate: function(attrs, options) {\n      if (_.has(attrs, "ACL") && !(attrs.ACL instanceof Parse.ACL)) {\n        return new Parse.Error(Parse.Error.OTHER_CAUSE,\n                               "ACL must be a Parse.ACL.");\n      }\n      var correct = true;\n      Parse._objectEach(attrs, function(unused_value, key) {\n        if (!(/^[A-Za-z][0-9A-Za-z_]*$/).test(key)) {\n          correct = false;\n        }\n      });\n      if (!correct) {\n        return new Parse.Error(Parse.Error.INVALID_KEY_NAME);\n      }\n      return false;\n    },\n\n    /**\n     * Run validation against a set of incoming attributes, returning `true`\n     * if all is well. If a specific `error` callback has been passed,\n     * call that instead of firing the general `"error"` event.\n     */\n    _validate: function(attrs, options) {\n      if (options.silent || !this.validate) {\n        return true;\n      }\n      attrs = _.extend({}, this.attributes, attrs);\n      var error = this.validate(attrs, options);\n      if (!error) {\n        return true;\n      }\n      if (options && options.error) {\n        options.error(this, error, options);\n      } else {\n        this.trigger(\'error\', this, error, options);\n      }\n      return false;\n    },\n\n    /**\n     * Returns the ACL for this object.\n     * @returns {Parse.ACL} An instance of Parse.ACL.\n     * @see Parse.Object#get\n     */\n    getACL: function() {\n      return this.get("ACL");\n    },\n\n    /**\n     * Sets the ACL to be used for this object.\n     * @param {Parse.ACL} acl An instance of Parse.ACL.\n     * @param {Object} options Optional Backbone-like options object to be\n     *     passed in to set.\n     * @return {Boolean} Whether the set passed validation.\n     * @see Parse.Object#set\n     */\n    setACL: function(acl, options) {\n      return this.set("ACL", acl, options);\n    }\n\n  });\n\n  /**\n   * Returns the appropriate subclass for making new instances of the given\n   * className string.\n   */\n  Parse.Object._getSubclass = function(className) {\n    if (!_.isString(className)) {\n      throw "Parse.Object._getSubclass requires a string argument.";\n    }\n    var ObjectClass = Parse.Object._classMap[className];\n    if (!ObjectClass) {\n      ObjectClass = Parse.Object.extend(className);\n      Parse.Object._classMap[className] = ObjectClass;\n    }\n    return ObjectClass;\n  };\n\n  /**\n   * Creates an instance of a subclass of Parse.Object for the given classname.\n   */\n  Parse.Object._create = function(className, attributes, options) {\n    var ObjectClass = Parse.Object._getSubclass(className);\n    return new ObjectClass(attributes, options);\n  };\n\n  /**\n   * Returns a list of object ids given a list of objects.\n   */\n  Parse.Object._toObjectIdArray = function(list, omitObjectsWithData) {\n    if (list.length === 0) {\n      return Parse.Promise.as(list);\n    }\n\n    var error;\n    var className = list[0].className;\n    var objectIds = [];\n    for (var i = 0; i < list.length; i++) {\n      var object = list[i];\n      if (className !== object.className) {\n        error = new Parse.Error(Parse.Error.INVALID_CLASS_NAME,\n                                "All objects should be of the same class");\n        return Parse.Promise.error(error);\n      } else if (!object.id) {\n        error = new Parse.Error(Parse.Error.MISSING_OBJECT_ID,\n                                "All objects must have an ID");\n        return Parse.Promise.error(error);\n      } else if (omitObjectsWithData && object._hasData) {\n        continue;\n      }\n      objectIds.push(object.id);\n    }\n\n    return Parse.Promise.as(objectIds);\n  };\n\n  /**\n   * Updates a list of objects with fetched results.\n   */\n  Parse.Object._updateWithFetchedResults = function(list, fetched, forceFetch) {\n    var fetchedObjectsById = {};\n    Parse._arrayEach(fetched, function(object, i) {\n      fetchedObjectsById[object.id] = object;\n    });\n\n    for (var i = 0; i < list.length; i++) {\n      var object = list[i];\n      var fetchedObject = fetchedObjectsById[object.id];\n      if (!fetchedObject && forceFetch) {\n        var error = new Parse.Error(Parse.Error.OBJECT_NOT_FOUND,\n                                "All objects must exist on the server");\n        return Parse.Promise.error(error);\n      }\n\n      object._mergeFromObject(fetchedObject);\n    }\n\n    return Parse.Promise.as(list);\n  };\n\n  /**\n   * Fetches the objects given in list.  The forceFetch option will fetch all\n   * objects if true and ignore objects with data if false.\n   */\n  Parse.Object._fetchAll = function(list, forceFetch) {\n    if (list.length === 0) {\n      return Parse.Promise.as(list);\n    }\n\n    var omitObjectsWithData = !forceFetch;\n    return Parse.Object._toObjectIdArray(\n      list,\n      omitObjectsWithData\n    ).then(function(objectIds) {\n      var className = list[0].className;\n      var query = new Parse.Query(className);\n      query.containedIn("objectId", objectIds);\n      query.limit = objectIds.length;\n      return query.find();\n    }).then(function(results) {\n      return Parse.Object._updateWithFetchedResults(\n        list,\n        results,\n        forceFetch\n      );\n    });\n  };\n\n  // Set up a map of className to class so that we can create new instances of\n  // Parse Objects from JSON automatically.\n  Parse.Object._classMap = {};\n\n  Parse.Object._extend = Parse._extend;\n\n  /**\n   * Creates a new subclass of Parse.Object for the given Parse class name.\n   *\n   * <p>Every extension of a Parse class will inherit from the most recent\n   * previous extension of that class. When a Parse.Object is automatically\n   * created by parsing JSON, it will use the most recent extension of that\n   * class.</p>\n   *\n   * <p>You should call either:<pre>\n   *     var MyClass = Parse.Object.extend("MyClass", {\n   *         <i>Instance methods</i>,\n   *         initialize: function(attrs, options) {\n   *             this.someInstanceProperty = [],\n   *             <i>Other instance properties</i>\n   *         }\n   *     }, {\n   *         <i>Class properties</i>\n   *     });</pre>\n   * or, for Backbone compatibility:<pre>\n   *     var MyClass = Parse.Object.extend({\n   *         className: "MyClass",\n   *         <i>Instance methods</i>,\n   *         initialize: function(attrs, options) {\n   *             this.someInstanceProperty = [],\n   *             <i>Other instance properties</i>\n   *         }\n   *     }, {\n   *         <i>Class properties</i>\n   *     });</pre></p>\n   *\n   * @param {String} className The name of the Parse class backing this model.\n   * @param {Object} protoProps Instance properties to add to instances of the\n   *     class returned from this method.\n   * @param {Object} classProps Class properties to add the class returned from\n   *     this method.\n   * @return {Class} A new subclass of Parse.Object.\n   */\n  Parse.Object.extend = function(className, protoProps, classProps) {\n    // Handle the case with only two args.\n    if (!_.isString(className)) {\n      if (className && _.has(className, "className")) {\n        return Parse.Object.extend(className.className, className, protoProps);\n      } else {\n        throw new Error(\n            "Parse.Object.extend\'s first argument should be the className.");\n      }\n    }\n\n    // If someone tries to subclass "User", coerce it to the right type.\n    if (className === "User" && Parse.User._performUserRewrite) {\n      className = "_User";\n    }\n    protoProps = protoProps || {};\n    protoProps.className = className;\n\n    var NewClassObject = null;\n    if (_.has(Parse.Object._classMap, className)) {\n      var OldClassObject = Parse.Object._classMap[className];\n      // This new subclass has been told to extend both from "this" and from\n      // OldClassObject. This is multiple inheritance, which isn\'t supported.\n      // For now, let\'s just pick one.\n      NewClassObject = OldClassObject._extend(protoProps, classProps);\n    } else {\n      NewClassObject = this._extend(protoProps, classProps);\n    }\n    // Extending a subclass should reuse the classname automatically.\n    NewClassObject.extend = function(arg0) {\n      if (_.isString(arg0) || (arg0 && _.has(arg0, "className"))) {\n        return Parse.Object.extend.apply(NewClassObject, arguments);\n      }\n      var newArguments = [className].concat(Parse._.toArray(arguments));\n      return Parse.Object.extend.apply(NewClassObject, newArguments);\n    };\n    Parse.Object._classMap[className] = NewClassObject;\n    return NewClassObject;\n  };\n\n  Parse.Object._findUnsavedChildren = function(object, children, files) {\n    Parse._traverse(object, function(object) {\n      if (object instanceof Parse.Object) {\n        object._refreshCache();\n        if (object.dirty()) {\n          children.push(object);\n        }\n        return;\n      }\n\n      if (object instanceof Parse.File) {\n        if (!object.url()) {\n          files.push(object);\n        }\n        return;\n      }\n    });\n  };\n\n  Parse.Object._canBeSerializedAsValue = function(object) {\n\n    if (object instanceof Parse.Object) {\n      return !!object.id;\n    }\n    if (object instanceof Parse.File) {\n      // Don\'t recurse indefinitely into files.\n      return true;\n    }\n\n    var canBeSerializedAsValue = true;\n\n    if (_.isArray(object)) {\n      Parse._arrayEach(object, function(child) {\n        if (!Parse.Object._canBeSerializedAsValue(child)) {\n          canBeSerializedAsValue = false;\n        }\n      });\n    } else if (_.isObject(object)) {\n      Parse._objectEach(object, function(child) {\n        if (!Parse.Object._canBeSerializedAsValue(child)) {\n          canBeSerializedAsValue = false;\n        }\n      });\n    }\n    return canBeSerializedAsValue;\n  };\n\n  /**\n   * @param {Object} object The root object.\n   * @param {Object} options: The only valid option is useMasterKey.\n   */\n  Parse.Object._deepSaveAsync = function(object, options) {\n    var unsavedChildren = [];\n    var unsavedFiles = [];\n    Parse.Object._findUnsavedChildren(object, unsavedChildren, unsavedFiles);\n\n    var promise = Parse.Promise.as();\n    _.each(unsavedFiles, function(file) {\n      promise = promise.then(function() {\n        return file.save(options);\n      });\n    });\n\n    var objects = _.uniq(unsavedChildren);\n    var remaining = _.uniq(objects);\n\n    return promise.then(function() {\n      return Parse.Promise._continueWhile(function() {\n        return remaining.length > 0;\n      }, function() {\n\n        // Gather up all the objects that can be saved in this batch.\n        var batch = [];\n        var newRemaining = [];\n        Parse._arrayEach(remaining, function(object) {\n          // Limit batches to 20 objects.\n          if (batch.length > 20) {\n            newRemaining.push(object);\n            return;\n          }\n\n          if (object._canBeSerialized()) {\n            batch.push(object);\n          } else {\n            newRemaining.push(object);\n          }\n        });\n        remaining = newRemaining;\n\n        // If we can\'t save any objects, there must be a circular reference.\n        if (batch.length === 0) {\n          return Parse.Promise.error(\n            new Parse.Error(Parse.Error.OTHER_CAUSE,\n                            "Tried to save a batch with a cycle."));\n        }\n\n        // Reserve a spot in every object\'s save queue.\n        var readyToStart = Parse.Promise.when(_.map(batch, function(object) {\n          return object._allPreviousSaves || Parse.Promise.as();\n        }));\n        var batchFinished = new Parse.Promise();\n        Parse._arrayEach(batch, function(object) {\n          object._allPreviousSaves = batchFinished;\n        });\n\n        // Save a single batch, whether previous saves succeeded or failed.\n        return readyToStart._continueWith(function() {\n          return Parse._request({\n            route: "batch",\n            method: "POST",\n            useMasterKey: options.useMasterKey,\n            data: {\n              requests: _.map(batch, function(object) {\n                var json = object._getSaveJSON();\n                var method = "POST";\n\n                var path = "/1/classes/" + object.className;\n                if (object.id) {\n                  path = path + "/" + object.id;\n                  method = "PUT";\n                }\n\n                object._startSave();\n\n                return {\n                  method: method,\n                  path: path,\n                  body: json\n                };\n              })\n            }\n          }).then(function(response, status, xhr) {\n            var error;\n            Parse._arrayEach(batch, function(object, i) {\n              if (response[i].success) {\n                object._finishSave(\n                  object.parse(response[i].success, status, xhr));\n              } else {\n                error = error || response[i].error;\n                object._cancelSave();\n              }\n            });\n            if (error) {\n              return Parse.Promise.error(\n                new Parse.Error(error.code, error.error));\n            }\n\n          }).then(function(results) {\n            batchFinished.resolve(results);\n            return results;\n          }, function(error) {\n            batchFinished.reject(error);\n            return Parse.Promise.error(error);\n          });\n        });\n      });\n    }).then(function() {\n      return object;\n    });\n  };\n\n}(this));\n\n(function(root) {\n  root.Parse = root.Parse || {};\n  var Parse = root.Parse;\n  var _ = Parse._;\n\n  /**\n   * Represents a Role on the Parse server. Roles represent groupings of\n   * Users for the purposes of granting permissions (e.g. specifying an ACL\n   * for an Object). Roles are specified by their sets of child users and\n   * child roles, all of which are granted any permissions that the parent\n   * role has.\n   *\n   * <p>Roles must have a name (which cannot be changed after creation of the\n   * role), and must specify an ACL.</p>\n   * @class\n   * A Parse.Role is a local representation of a role persisted to the Parse\n   * cloud.\n   */\n  Parse.Role = Parse.Object.extend("_Role", /** @lends Parse.Role.prototype */ {\n    // Instance Methods\n\n    /**\n     * Constructs a new ParseRole with the given name and ACL.\n     *\n     * @param {String} name The name of the Role to create.\n     * @param {Parse.ACL} acl The ACL for this role. Roles must have an ACL.\n     */\n    constructor: function(name, acl) {\n      if (_.isString(name) && (acl instanceof Parse.ACL)) {\n        Parse.Object.prototype.constructor.call(this, null, null);\n        this.setName(name);\n        this.setACL(acl);\n      } else {\n        Parse.Object.prototype.constructor.call(this, name, acl);\n      }\n    },\n\n    /**\n     * Gets the name of the role.  You can alternatively call role.get("name")\n     *\n     * @return {String} the name of the role.\n     */\n    getName: function() {\n      return this.get("name");\n    },\n\n    /**\n     * Sets the name for a role. This value must be set before the role has\n     * been saved to the server, and cannot be set once the role has been\n     * saved.\n     *\n     * <p>\n     *   A role\'s name can only contain alphanumeric characters, _, -, and\n     *   spaces.\n     * </p>\n     *\n     * <p>This is equivalent to calling role.set("name", name)</p>\n     *\n     * @param {String} name The name of the role.\n     * @param {Object} options Standard options object with success and error\n     *     callbacks.\n     */\n    setName: function(name, options) {\n      return this.set("name", name, options);\n    },\n\n    /**\n     * Gets the Parse.Relation for the Parse.Users that are direct\n     * children of this role. These users are granted any privileges that this\n     * role has been granted (e.g. read or write access through ACLs). You can\n     * add or remove users from the role through this relation.\n     *\n     * <p>This is equivalent to calling role.relation("users")</p>\n     *\n     * @return {Parse.Relation} the relation for the users belonging to this\n     *     role.\n     */\n    getUsers: function() {\n      return this.relation("users");\n    },\n\n    /**\n     * Gets the Parse.Relation for the Parse.Roles that are direct\n     * children of this role. These roles\' users are granted any privileges that\n     * this role has been granted (e.g. read or write access through ACLs). You\n     * can add or remove child roles from this role through this relation.\n     *\n     * <p>This is equivalent to calling role.relation("roles")</p>\n     *\n     * @return {Parse.Relation} the relation for the roles belonging to this\n     *     role.\n     */\n    getRoles: function() {\n      return this.relation("roles");\n    },\n\n    /**\n     * @ignore\n     */\n    validate: function(attrs, options) {\n      if ("name" in attrs && attrs.name !== this.getName()) {\n        var newName = attrs.name;\n        if (this.id && this.id !== attrs.objectId) {\n          // Check to see if the objectId being set matches this.id.\n          // This happens during a fetch -- the id is set before calling fetch.\n          // Let the name be set in this case.\n          return new Parse.Error(Parse.Error.OTHER_CAUSE,\n              "A role\'s name can only be set before it has been saved.");\n        }\n        if (!_.isString(newName)) {\n          return new Parse.Error(Parse.Error.OTHER_CAUSE,\n              "A role\'s name must be a String.");\n        }\n        if (!(/^[0-9a-zA-Z\\-_ ]+$/).test(newName)) {\n          return new Parse.Error(Parse.Error.OTHER_CAUSE,\n              "A role\'s name can only contain alphanumeric characters, _," +\n              " -, and spaces.");\n        }\n      }\n      if (Parse.Object.prototype.validate) {\n        return Parse.Object.prototype.validate.call(this, attrs, options);\n      }\n      return false;\n    }\n  });\n}(this));\n\n\n/*global _: false */\n(function(root) {\n  root.Parse = root.Parse || {};\n  var Parse = root.Parse;\n  var _ = Parse._;\n\n  /**\n   * Creates a new instance with the given models and options.  Typically, you\n   * will not call this method directly, but will instead make a subclass using\n   * <code>Parse.Collection.extend</code>.\n   *\n   * @param {Array} models An array of instances of <code>Parse.Object</code>.\n   *\n   * @param {Object} options An optional object with Backbone-style options.\n   * Valid options are:<ul>\n   *   <li>model: The Parse.Object subclass that this collection contains.\n   *   <li>query: An instance of Parse.Query to use when fetching items.\n   *   <li>comparator: A string property name or function to sort by.\n   * </ul>\n   *\n   * @see Parse.Collection.extend\n   *\n   * @class\n   *\n   * <p>Provides a standard collection class for our sets of models, ordered\n   * or unordered.  For more information, see the\n   * <a href="http://documentcloud.github.com/backbone/#Collection">Backbone\n   * documentation</a>.</p>\n   */\n  Parse.Collection = function(models, options) {\n    options = options || {};\n    if (options.comparator) {\n      this.comparator = options.comparator;\n    }\n    if (options.model) {\n      this.model = options.model;\n    }\n    if (options.query) {\n      this.query = options.query;\n    }\n    this._reset();\n    this.initialize.apply(this, arguments);\n    if (models) {\n      this.reset(models, {silent: true, parse: options.parse});\n    }\n  };\n\n  // Define the Collection\'s inheritable methods.\n  _.extend(Parse.Collection.prototype, Parse.Events,\n      /** @lends Parse.Collection.prototype */ {\n\n    // The default model for a collection is just a Parse.Object.\n    // This should be overridden in most cases.\n\n    model: Parse.Object,\n\n    /**\n     * Initialize is an empty function by default. Override it with your own\n     * initialization logic.\n     */\n    initialize: function(){},\n\n    /**\n     * The JSON representation of a Collection is an array of the\n     * models\' attributes.\n     */\n    toJSON: function() {\n      return this.map(function(model){ return model.toJSON(); });\n    },\n\n    /**\n     * Add a model, or list of models to the set. Pass **silent** to avoid\n     * firing the `add` event for every new model.\n     *\n     * @param {Array} models An array of instances of <code>Parse.Object</code>.\n     *\n     * @param {Object} options An optional object with Backbone-style options.\n     * Valid options are:<ul>\n     *   <li>at: The index at which to add the models.\n     *   <li>silent: Set to true to avoid firing the `add` event for every new\n     *   model.\n     * </ul>\n     */\n    add: function(models, options) {\n      var i, index, length, model, cid, id, cids = {}, ids = {};\n      options = options || {};\n      models = _.isArray(models) ? models.slice() : [models];\n\n      // Begin by turning bare objects into model references, and preventing\n      // invalid models or duplicate models from being added.\n      for (i = 0, length = models.length; i < length; i++) {\n        models[i] = this._prepareModel(models[i], options);\n        model = models[i];\n        if (!model) {\n          throw new Error("Can\'t add an invalid model to a collection");\n        }\n        cid = model.cid;\n        if (cids[cid] || this._byCid[cid]) {\n          throw new Error("Duplicate cid: can\'t add the same model " +\n                          "to a collection twice");\n        }\n        id = model.id;\n        if (!Parse._isNullOrUndefined(id) && (ids[id] || this._byId[id])) {\n          throw new Error("Duplicate id: can\'t add the same model " +\n                          "to a collection twice");\n        }\n        ids[id] = model;\n        cids[cid] = model;\n      }\n\n      // Listen to added models\' events, and index models for lookup by\n      // `id` and by `cid`.\n      for (i = 0; i < length; i++) {\n        (model = models[i]).on(\'all\', this._onModelEvent, this);\n        this._byCid[model.cid] = model;\n        if (model.id) {\n          this._byId[model.id] = model;\n        }\n      }\n\n      // Insert models into the collection, re-sorting if needed, and triggering\n      // `add` events unless silenced.\n      this.length += length;\n      index = Parse._isNullOrUndefined(options.at) ?\n          this.models.length : options.at;\n      this.models.splice.apply(this.models, [index, 0].concat(models));\n      if (this.comparator) {\n        this.sort({silent: true});\n      }\n      if (options.silent) {\n        return this;\n      }\n      for (i = 0, length = this.models.length; i < length; i++) {\n        model = this.models[i];\n        if (cids[model.cid]) {\n          options.index = i;\n          model.trigger(\'add\', model, this, options);\n        }\n      }\n      return this;\n    },\n\n    /**\n     * Remove a model, or a list of models from the set. Pass silent to avoid\n     * firing the <code>remove</code> event for every model removed.\n     *\n     * @param {Array} models The model or list of models to remove from the\n     *   collection.\n     * @param {Object} options An optional object with Backbone-style options.\n     * Valid options are: <ul>\n     *   <li>silent: Set to true to avoid firing the `remove` event.\n     * </ul>\n     */\n    remove: function(models, options) {\n      var i, l, index, model;\n      options = options || {};\n      models = _.isArray(models) ? models.slice() : [models];\n      for (i = 0, l = models.length; i < l; i++) {\n        model = this.getByCid(models[i]) || this.get(models[i]);\n        if (!model) {\n          continue;\n        }\n        delete this._byId[model.id];\n        delete this._byCid[model.cid];\n        index = this.indexOf(model);\n        this.models.splice(index, 1);\n        this.length--;\n        if (!options.silent) {\n          options.index = index;\n          model.trigger(\'remove\', model, this, options);\n        }\n        this._removeReference(model);\n      }\n      return this;\n    },\n\n    /**\n     * Gets a model from the set by id.\n     * @param {String} id The Parse objectId identifying the Parse.Object to\n     * fetch from this collection.\n     */\n    get: function(id) {\n      return id && this._byId[id.id || id];\n    },\n\n    /**\n     * Gets a model from the set by client id.\n     * @param {} cid The Backbone collection id identifying the Parse.Object to\n     * fetch from this collection.\n     */\n    getByCid: function(cid) {\n      return cid && this._byCid[cid.cid || cid];\n    },\n\n    /**\n     * Gets the model at the given index.\n     *\n     * @param {Number} index The index of the model to return.\n     */\n    at: function(index) {\n      return this.models[index];\n    },\n\n    /**\n     * Forces the collection to re-sort itself. You don\'t need to call this\n     * under normal circumstances, as the set will maintain sort order as each\n     * item is added.\n     * @param {Object} options An optional object with Backbone-style options.\n     * Valid options are: <ul>\n     *   <li>silent: Set to true to avoid firing the `reset` event.\n     * </ul>\n     */\n    sort: function(options) {\n      options = options || {};\n      if (!this.comparator) {\n        throw new Error(\'Cannot sort a set without a comparator\');\n      }\n      var boundComparator = _.bind(this.comparator, this);\n      if (this.comparator.length === 1) {\n        this.models = this.sortBy(boundComparator);\n      } else {\n        this.models.sort(boundComparator);\n      }\n      if (!options.silent) {\n        this.trigger(\'reset\', this, options);\n      }\n      return this;\n    },\n\n    /**\n     * Plucks an attribute from each model in the collection.\n     * @param {String} attr The attribute to return from each model in the\n     * collection.\n     */\n    pluck: function(attr) {\n      return _.map(this.models, function(model){ return model.get(attr); });\n    },\n\n    /**\n     * When you have more items than you want to add or remove individually,\n     * you can reset the entire set with a new list of models, without firing\n     * any `add` or `remove` events. Fires `reset` when finished.\n     *\n     * @param {Array} models The model or list of models to remove from the\n     *   collection.\n     * @param {Object} options An optional object with Backbone-style options.\n     * Valid options are: <ul>\n     *   <li>silent: Set to true to avoid firing the `reset` event.\n     * </ul>\n     */\n    reset: function(models, options) {\n      var self = this;\n      models = models || [];\n      options = options || {};\n      Parse._arrayEach(this.models, function(model) {\n        self._removeReference(model);\n      });\n      this._reset();\n      this.add(models, {silent: true, parse: options.parse});\n      if (!options.silent) {\n        this.trigger(\'reset\', this, options);\n      }\n      return this;\n    },\n\n    /**\n     * Fetches the default set of models for this collection, resetting the\n     * collection when they arrive. If `add: true` is passed, appends the\n     * models to the collection instead of resetting.\n     *\n     * @param {Object} options An optional object with Backbone-style options.\n     * Valid options are:<ul>\n     *   <li>silent: Set to true to avoid firing `add` or `reset` events for\n     *   models fetched by this fetch.\n     *   <li>success: A Backbone-style success callback.\n     *   <li>error: An Backbone-style error callback.\n     *   <li>useMasterKey: In Cloud Code and Node only, uses the Master Key for\n     *       this request.\n     * </ul>\n     */\n    fetch: function(options) {\n      options = _.clone(options) || {};\n      if (options.parse === undefined) {\n        options.parse = true;\n      }\n      var collection = this;\n      var query = this.query || new Parse.Query(this.model);\n      return query.find({\n        useMasterKey: options.useMasterKey\n      }).then(function(results) {\n        if (options.add) {\n          collection.add(results, options);\n        } else {\n          collection.reset(results, options);\n        }\n        return collection;\n      })._thenRunCallbacks(options, this);\n    },\n\n    /**\n     * Creates a new instance of a model in this collection. Add the model to\n     * the collection immediately, unless `wait: true` is passed, in which case\n     * we wait for the server to agree.\n     *\n     * @param {Parse.Object} model The new model to create and add to the\n     *   collection.\n     * @param {Object} options An optional object with Backbone-style options.\n     * Valid options are:<ul>\n     *   <li>wait: Set to true to wait for the server to confirm creation of the\n     *       model before adding it to the collection.\n     *   <li>silent: Set to true to avoid firing an `add` event.\n     *   <li>success: A Backbone-style success callback.\n     *   <li>error: An Backbone-style error callback.\n     *   <li>useMasterKey: In Cloud Code and Node only, uses the Master Key for\n     *       this request.\n     * </ul>\n     */\n    create: function(model, options) {\n      var coll = this;\n      options = options ? _.clone(options) : {};\n      model = this._prepareModel(model, options);\n      if (!model) {\n        return false;\n      }\n      if (!options.wait) {\n        coll.add(model, options);\n      }\n      var success = options.success;\n      options.success = function(nextModel, resp, xhr) {\n        if (options.wait) {\n          coll.add(nextModel, options);\n        }\n        if (success) {\n          success(nextModel, resp);\n        } else {\n          nextModel.trigger(\'sync\', model, resp, options);\n        }\n      };\n      model.save(null, options);\n      return model;\n    },\n\n    /**\n     * Converts a response into a list of models to be added to the collection.\n     * The default implementation is just to pass it through.\n     * @ignore\n     */\n    parse: function(resp, xhr) {\n      return resp;\n    },\n\n    /**\n     * Proxy to _\'s chain. Can\'t be proxied the same way the rest of the\n     * underscore methods are proxied because it relies on the underscore\n     * constructor.\n     */\n    chain: function() {\n      return _(this.models).chain();\n    },\n\n    /**\n     * Reset all internal state. Called when the collection is reset.\n     */\n    _reset: function(options) {\n      this.length = 0;\n      this.models = [];\n      this._byId  = {};\n      this._byCid = {};\n    },\n\n    /**\n     * Prepare a model or hash of attributes to be added to this collection.\n     */\n    _prepareModel: function(model, options) {\n      if (!(model instanceof Parse.Object)) {\n        var attrs = model;\n        options.collection = this;\n        model = new this.model(attrs, options);\n        if (!model._validate(model.attributes, options)) {\n          model = false;\n        }\n      } else if (!model.collection) {\n        model.collection = this;\n      }\n      return model;\n    },\n\n    /**\n     * Internal method to remove a model\'s ties to a collection.\n     */\n    _removeReference: function(model) {\n      if (this === model.collection) {\n        delete model.collection;\n      }\n      model.off(\'all\', this._onModelEvent, this);\n    },\n\n    /**\n     * Internal method called every time a model in the set fires an event.\n     * Sets need to update their indexes when models change ids. All other\n     * events simply proxy through. "add" and "remove" events that originate\n     * in other collections are ignored.\n     */\n    _onModelEvent: function(ev, model, collection, options) {\n      if ((ev === \'add\' || ev === \'remove\') && collection !== this) {\n        return;\n      }\n      if (ev === \'destroy\') {\n        this.remove(model, options);\n      }\n      if (model && ev === \'change:objectId\') {\n        delete this._byId[model.previous("objectId")];\n        this._byId[model.id] = model;\n      }\n      this.trigger.apply(this, arguments);\n    }\n\n  });\n\n  // Underscore methods that we want to implement on the Collection.\n  var methods = [\'forEach\', \'each\', \'map\', \'reduce\', \'reduceRight\', \'find\',\n    \'detect\', \'filter\', \'select\', \'reject\', \'every\', \'all\', \'some\', \'any\',\n    \'include\', \'contains\', \'invoke\', \'max\', \'min\', \'sortBy\', \'sortedIndex\',\n    \'toArray\', \'size\', \'first\', \'initial\', \'rest\', \'last\', \'without\', \'indexOf\',\n    \'shuffle\', \'lastIndexOf\', \'isEmpty\', \'groupBy\'];\n\n  // Mix in each Underscore method as a proxy to `Collection#models`.\n  Parse._arrayEach(methods, function(method) {\n    Parse.Collection.prototype[method] = function() {\n      return _[method].apply(_, [this.models].concat(_.toArray(arguments)));\n    };\n  });\n\n  /**\n   * Creates a new subclass of <code>Parse.Collection</code>.  For example,<pre>\n   *   var MyCollection = Parse.Collection.extend({\n   *     // Instance properties\n   *\n   *     model: MyClass,\n   *     query: MyQuery,\n   *\n   *     getFirst: function() {\n   *       return this.at(0);\n   *     }\n   *   }, {\n   *     // Class properties\n   *\n   *     makeOne: function() {\n   *       return new MyCollection();\n   *     }\n   *   });\n   *\n   *   var collection = new MyCollection();\n   * </pre>\n   *\n   * @function\n   * @param {Object} instanceProps Instance properties for the collection.\n   * @param {Object} classProps Class properies for the collection.\n   * @return {Class} A new subclass of <code>Parse.Collection</code>.\n   */\n  Parse.Collection.extend = Parse._extend;\n\n}(this));\n\n/*global _: false, document: false */\n(function(root) {\n  root.Parse = root.Parse || {};\n  var Parse = root.Parse;\n  var _ = Parse._;\n\n  /**\n   * Creating a Parse.View creates its initial element outside of the DOM,\n   * if an existing element is not provided...\n   * @class\n   *\n   * <p>A fork of Backbone.View, provided for your convenience.  If you use this\n   * class, you must also include jQuery, or another library that provides a\n   * jQuery-compatible $ function.  For more information, see the\n   * <a href="http://documentcloud.github.com/backbone/#View">Backbone\n   * documentation</a>.</p>\n   * <p><strong><em>Available in the client SDK only.</em></strong></p>\n   */\n  Parse.View = function(options) {\n    this.cid = _.uniqueId(\'view\');\n    this._configure(options || {});\n    this._ensureElement();\n    this.initialize.apply(this, arguments);\n    this.delegateEvents();\n  };\n\n  // Cached regex to split keys for `delegate`.\n  var eventSplitter = /^(\\S+)\\s*(.*)$/;\n\n  // List of view options to be merged as properties.\n\n  var viewOptions = [\'model\', \'collection\', \'el\', \'id\', \'attributes\',\n                     \'className\', \'tagName\'];\n\n  // Set up all inheritable **Parse.View** properties and methods.\n  _.extend(Parse.View.prototype, Parse.Events,\n           /** @lends Parse.View.prototype */ {\n\n    // The default `tagName` of a View\'s element is `"div"`.\n    tagName: \'div\',\n\n    /**\n     * jQuery delegate for element lookup, scoped to DOM elements within the\n     * current view. This should be prefered to global lookups where possible.\n     */\n    $: function(selector) {\n      return this.$el.find(selector);\n    },\n\n    /**\n     * Initialize is an empty function by default. Override it with your own\n     * initialization logic.\n     */\n    initialize: function(){},\n\n    /**\n     * The core function that your view should override, in order\n     * to populate its element (`this.el`), with the appropriate HTML. The\n     * convention is for **render** to always return `this`.\n     */\n    render: function() {\n      return this;\n    },\n\n    /**\n     * Remove this view from the DOM. Note that the view isn\'t present in the\n     * DOM by default, so calling this method may be a no-op.\n     */\n    remove: function() {\n      this.$el.remove();\n      return this;\n    },\n\n    /**\n     * For small amounts of DOM Elements, where a full-blown template isn\'t\n     * needed, use **make** to manufacture elements, one at a time.\n     * <pre>\n     *     var el = this.make(\'li\', {\'class\': \'row\'},\n     *                        this.model.escape(\'title\'));</pre>\n     */\n    make: function(tagName, attributes, content) {\n      var el = document.createElement(tagName);\n      if (attributes) {\n        Parse.$(el).attr(attributes);\n      }\n      if (content) {\n        Parse.$(el).html(content);\n      }\n      return el;\n    },\n\n    /**\n     * Changes the view\'s element (`this.el` property), including event\n     * re-delegation.\n     */\n    setElement: function(element, delegate) {\n      this.$el = Parse.$(element);\n      this.el = this.$el[0];\n      if (delegate !== false) {\n        this.delegateEvents();\n      }\n      return this;\n    },\n\n    /**\n     * Set callbacks.  <code>this.events</code> is a hash of\n     * <pre>\n     * *{"event selector": "callback"}*\n     *\n     *     {\n     *       \'mousedown .title\':  \'edit\',\n     *       \'click .button\':     \'save\'\n     *       \'click .open\':       function(e) { ... }\n     *     }\n     * </pre>\n     * pairs. Callbacks will be bound to the view, with `this` set properly.\n     * Uses event delegation for efficiency.\n     * Omitting the selector binds the event to `this.el`.\n     * This only works for delegate-able events: not `focus`, `blur`, and\n     * not `change`, `submit`, and `reset` in Internet Explorer.\n     */\n    delegateEvents: function(events) {\n      events = events || Parse._getValue(this, \'events\');\n      if (!events) {\n        return;\n      }\n      this.undelegateEvents();\n      var self = this;\n      Parse._objectEach(events, function(method, key) {\n        if (!_.isFunction(method)) {\n          method = self[events[key]];\n        }\n        if (!method) {\n          throw new Error(\'Event "\' + events[key] + \'" does not exist\');\n        }\n        var match = key.match(eventSplitter);\n        var eventName = match[1], selector = match[2];\n        method = _.bind(method, self);\n        eventName += \'.delegateEvents\' + self.cid;\n        if (selector === \'\') {\n          self.$el.bind(eventName, method);\n        } else {\n          self.$el.delegate(selector, eventName, method);\n        }\n      });\n    },\n\n    /**\n     * Clears all callbacks previously bound to the view with `delegateEvents`.\n     * You usually don\'t need to use this, but may wish to if you have multiple\n     * Backbone views attached to the same DOM element.\n     */\n    undelegateEvents: function() {\n      this.$el.unbind(\'.delegateEvents\' + this.cid);\n    },\n\n    /**\n     * Performs the initial configuration of a View with a set of options.\n     * Keys with special meaning *(model, collection, id, className)*, are\n     * attached directly to the view.\n     */\n    _configure: function(options) {\n      if (this.options) {\n        options = _.extend({}, this.options, options);\n      }\n      var self = this;\n      _.each(viewOptions, function(attr) {\n        if (options[attr]) {\n          self[attr] = options[attr];\n        }\n      });\n      this.options = options;\n    },\n\n    /**\n     * Ensure that the View has a DOM element to render into.\n     * If `this.el` is a string, pass it through `$()`, take the first\n     * matching element, and re-assign it to `el`. Otherwise, create\n     * an element from the `id`, `className` and `tagName` properties.\n     */\n    _ensureElement: function() {\n      if (!this.el) {\n        var attrs = Parse._getValue(this, \'attributes\') || {};\n        if (this.id) {\n          attrs.id = this.id;\n        }\n        if (this.className) {\n          attrs[\'class\'] = this.className;\n        }\n        this.setElement(this.make(this.tagName, attrs), false);\n      } else {\n        this.setElement(this.el, false);\n      }\n    }\n\n  });\n\n  /**\n   * @function\n   * @param {Object} instanceProps Instance properties for the view.\n   * @param {Object} classProps Class properies for the view.\n   * @return {Class} A new subclass of <code>Parse.View</code>.\n   */\n  Parse.View.extend = Parse._extend;\n\n}(this));\n\n(function(root) {\n  root.Parse = root.Parse || {};\n  var Parse = root.Parse;\n  var _ = Parse._;\n\n  /**\n   * @class\n   *\n   * <p>A Parse.User object is a local representation of a user persisted to the\n   * Parse cloud. This class is a subclass of a Parse.Object, and retains the\n   * same functionality of a Parse.Object, but also extends it with various\n   * user specific methods, like authentication, signing up, and validation of\n   * uniqueness.</p>\n   */\n  Parse.User = Parse.Object.extend("_User", /** @lends Parse.User.prototype */ {\n    // Instance Variables\n    _isCurrentUser: false,\n\n\n    // Instance Methods\n\n    /**\n     * Merges another object\'s attributes into this object.\n     */\n    _mergeFromObject: function(other) {\n      if (other.getSessionToken()) {\n        this._sessionToken = other.getSessionToken();\n      }\n      Parse.User.__super__._mergeFromObject.call(this, other);\n    },\n\n    /**\n     * Internal method to handle special fields in a _User response.\n     */\n    _mergeMagicFields: function(attrs) {\n      if (attrs.sessionToken) {\n        this._sessionToken = attrs.sessionToken;\n        delete attrs.sessionToken;\n      }\n      Parse.User.__super__._mergeMagicFields.call(this, attrs);\n    },\n\n    /**\n     * Removes null values from authData (which exist temporarily for\n     * unlinking)\n     */\n    _cleanupAuthData: function() {\n      if (!this.isCurrent()) {\n        return;\n      }\n      var authData = this.get(\'authData\');\n      if (!authData) {\n        return;\n      }\n      Parse._objectEach(this.get(\'authData\'), function(value, key) {\n        if (!authData[key]) {\n          delete authData[key];\n        }\n      });\n    },\n\n    /**\n     * Synchronizes authData for all providers.\n     */\n    _synchronizeAllAuthData: function() {\n      var authData = this.get(\'authData\');\n      if (!authData) {\n        return;\n      }\n\n      var self = this;\n      Parse._objectEach(this.get(\'authData\'), function(value, key) {\n        self._synchronizeAuthData(key);\n      });\n    },\n\n    /**\n     * Synchronizes auth data for a provider (e.g. puts the access token in the\n     * right place to be used by the Facebook SDK).\n     */\n    _synchronizeAuthData: function(provider) {\n      if (!this.isCurrent()) {\n        return;\n      }\n      var authType;\n      if (_.isString(provider)) {\n        authType = provider;\n        provider = Parse.User._authProviders[authType];\n      } else {\n        authType = provider.getAuthType();\n      }\n      var authData = this.get(\'authData\');\n      if (!authData || !provider) {\n        return;\n      }\n      var success = provider.restoreAuthentication(authData[authType]);\n      if (!success) {\n        this._unlinkFrom(provider);\n      }\n    },\n\n    _handleSaveResult: function(makeCurrent) {\n      // Clean up and synchronize the authData object, removing any unset values\n      if (makeCurrent) {\n        this._isCurrentUser = true;\n      }\n      this._cleanupAuthData();\n      this._synchronizeAllAuthData();\n      // Don\'t keep the password around.\n      delete this._serverData.password;\n      this._rebuildEstimatedDataForKey("password");\n      this._refreshCache();\n      if (makeCurrent || this.isCurrent()) {\n        Parse.User._saveCurrentUser(this);\n      }\n    },\n\n    /**\n     * Unlike in the Android/iOS SDKs, logInWith is unnecessary, since you can\n     * call linkWith on the user (even if it doesn\'t exist yet on the server).\n     */\n    _linkWith: function(provider, options) {\n      var authType;\n      if (_.isString(provider)) {\n        authType = provider;\n        provider = Parse.User._authProviders[provider];\n      } else {\n        authType = provider.getAuthType();\n      }\n      if (_.has(options, \'authData\')) {\n        var authData = this.get(\'authData\') || {};\n        authData[authType] = options.authData;\n        this.set(\'authData\', authData);\n\n        // Overridden so that the user can be made the current user.\n        var newOptions = _.clone(options) || {};\n        newOptions.success = function(model) {\n          model._handleSaveResult(true);\n          if (options.success) {\n            options.success.apply(this, arguments);\n          }\n        };\n        return this.save({\'authData\': authData}, newOptions);\n      } else {\n        var self = this;\n        var promise = new Parse.Promise();\n        provider.authenticate({\n          success: function(provider, result) {\n            self._linkWith(provider, {\n              authData: result,\n              success: options.success,\n              error: options.error\n            }).then(function() {\n              promise.resolve(self);\n            });\n          },\n          error: function(provider, error) {\n            if (options.error) {\n              options.error(self, error);\n            }\n            promise.reject(error);\n          }\n        });\n        return promise;\n      }\n    },\n\n    /**\n     * Unlinks a user from a service.\n     */\n    _unlinkFrom: function(provider, options) {\n      var authType;\n      if (_.isString(provider)) {\n        authType = provider;\n        provider = Parse.User._authProviders[provider];\n      } else {\n        authType = provider.getAuthType();\n      }\n      var newOptions = _.clone(options);\n      var self = this;\n      newOptions.authData = null;\n      newOptions.success = function(model) {\n        self._synchronizeAuthData(provider);\n        if (options.success) {\n          options.success.apply(this, arguments);\n        }\n      };\n      return this._linkWith(provider, newOptions);\n    },\n\n    /**\n     * Checks whether a user is linked to a service.\n     */\n    _isLinked: function(provider) {\n      var authType;\n      if (_.isString(provider)) {\n        authType = provider;\n      } else {\n        authType = provider.getAuthType();\n      }\n      var authData = this.get(\'authData\') || {};\n      return !!authData[authType];\n    },\n\n    /**\n     * Deauthenticates all providers.\n     */\n    _logOutWithAll: function() {\n      var authData = this.get(\'authData\');\n      if (!authData) {\n        return;\n      }\n      var self = this;\n      Parse._objectEach(this.get(\'authData\'), function(value, key) {\n        self._logOutWith(key);\n      });\n    },\n\n    /**\n     * Deauthenticates a single provider (e.g. removing access tokens from the\n     * Facebook SDK).\n     */\n    _logOutWith: function(provider) {\n      if (!this.isCurrent()) {\n        return;\n      }\n      if (_.isString(provider)) {\n        provider = Parse.User._authProviders[provider];\n      }\n      if (provider && provider.deauthenticate) {\n        provider.deauthenticate();\n      }\n    },\n\n    /**\n     * Signs up a new user. You should call this instead of save for\n     * new Parse.Users. This will create a new Parse.User on the server, and\n     * also persist the session on disk so that you can access the user using\n     * <code>current</code>.\n     *\n     * <p>A username and password must be set before calling signUp.</p>\n     *\n     * <p>Calls options.success or options.error on completion.</p>\n     *\n     * @param {Object} attrs Extra fields to set on the new user, or null.\n     * @param {Object} options A Backbone-style options object.\n     * @return {Parse.Promise} A promise that is fulfilled when the signup\n     *     finishes.\n     * @see Parse.User.signUp\n     */\n    signUp: function(attrs, options) {\n      var error;\n      options = options || {};\n\n      var username = (attrs && attrs.username) || this.get("username");\n      if (!username || (username === "")) {\n        error = new Parse.Error(\n            Parse.Error.OTHER_CAUSE,\n            "Cannot sign up user with an empty name.");\n        if (options && options.error) {\n          options.error(this, error);\n        }\n        return Parse.Promise.error(error);\n      }\n\n      var password = (attrs && attrs.password) || this.get("password");\n      if (!password || (password === "")) {\n        error = new Parse.Error(\n            Parse.Error.OTHER_CAUSE,\n            "Cannot sign up user with an empty password.");\n        if (options && options.error) {\n          options.error(this, error);\n        }\n        return Parse.Promise.error(error);\n      }\n\n      // Overridden so that the user can be made the current user.\n      var newOptions = _.clone(options);\n      newOptions.success = function(model) {\n        model._handleSaveResult(true);\n        if (options.success) {\n          options.success.apply(this, arguments);\n        }\n      };\n      return this.save(attrs, newOptions);\n    },\n\n    /**\n     * Logs in a Parse.User. On success, this saves the session to localStorage,\n     * so you can retrieve the currently logged in user using\n     * <code>current</code>.\n     *\n     * <p>A username and password must be set before calling logIn.</p>\n     *\n     * <p>Calls options.success or options.error on completion.</p>\n     *\n     * @param {Object} options A Backbone-style options object.\n     * @see Parse.User.logIn\n     * @return {Parse.Promise} A promise that is fulfilled with the user when\n     *     the login is complete.\n     */\n    logIn: function(options) {\n      var model = this;\n      options = options || {};\n      var request = Parse._request({\n        route: "login",\n        method: "GET",\n        useMasterKey: options.useMasterKey,\n        data: this.toJSON()\n      });\n      return request.then(function(resp, status, xhr) {\n        var serverAttrs = model.parse(resp, status, xhr);\n        model._finishFetch(serverAttrs);\n        model._handleSaveResult(true);\n        return model;\n      })._thenRunCallbacks(options, this);\n    },\n\n    /**\n     * @see Parse.Object#save\n     */\n    save: function(arg1, arg2, arg3) {\n      var i, attrs, current, options, saved;\n      if (_.isObject(arg1) || _.isNull(arg1) || _.isUndefined(arg1)) {\n        attrs = arg1;\n        options = arg2;\n      } else {\n        attrs = {};\n        attrs[arg1] = arg2;\n        options = arg3;\n      }\n      options = options || {};\n\n      var newOptions = _.clone(options);\n      newOptions.success = function(model) {\n        model._handleSaveResult(false);\n        if (options.success) {\n          options.success.apply(this, arguments);\n        }\n      };\n      return Parse.Object.prototype.save.call(this, attrs, newOptions);\n    },\n\n    /**\n     * @see Parse.Object#fetch\n     */\n    fetch: function(options) {\n      var newOptions = options ? _.clone(options) : {};\n      newOptions.success = function(model) {\n        model._handleSaveResult(false);\n        if (options && options.success) {\n          options.success.apply(this, arguments);\n        }\n      };\n      return Parse.Object.prototype.fetch.call(this, newOptions);\n    },\n\n    /**\n     * Returns true if <code>current</code> would return this user.\n     * @see Parse.User#current\n     */\n    isCurrent: function() {\n      return this._isCurrentUser;\n    },\n\n    /**\n     * Returns get("username").\n     * @return {String}\n     * @see Parse.Object#get\n     */\n    getUsername: function() {\n      return this.get("username");\n    },\n\n    /**\n     * Calls set("username", username, options) and returns the result.\n     * @param {String} username\n     * @param {Object} options A Backbone-style options object.\n     * @return {Boolean}\n     * @see Parse.Object.set\n     */\n    setUsername: function(username, options) {\n      return this.set("username", username, options);\n    },\n\n    /**\n     * Calls set("password", password, options) and returns the result.\n     * @param {String} password\n     * @param {Object} options A Backbone-style options object.\n     * @return {Boolean}\n     * @see Parse.Object.set\n     */\n    setPassword: function(password, options) {\n      return this.set("password", password, options);\n    },\n\n    /**\n     * Returns get("email").\n     * @return {String}\n     * @see Parse.Object#get\n     */\n    getEmail: function() {\n      return this.get("email");\n    },\n\n    /**\n     * Calls set("email", email, options) and returns the result.\n     * @param {String} email\n     * @param {Object} options A Backbone-style options object.\n     * @return {Boolean}\n     * @see Parse.Object.set\n     */\n    setEmail: function(email, options) {\n      return this.set("email", email, options);\n    },\n\n    /**\n     * Checks whether this user is the current user and has been authenticated.\n     * @return (Boolean) whether this user is the current user and is logged in.\n     */\n    authenticated: function() {\n      return !!this._sessionToken &&\n          (Parse.User.current() && Parse.User.current().id === this.id);\n    },\n\n    /**\n     * Returns the session token for this user, if the user has been logged in,\n     * or if it is the result of a query with the master key. Otherwise, returns\n     * undefined.\n     * @return {String} the session token, or undefined\n     */\n    getSessionToken: function() {\n      return this._sessionToken;\n    }\n\n  }, /** @lends Parse.User */ {\n    // Class Variables\n\n    // The currently logged-in user.\n    _currentUser: null,\n\n    // Whether currentUser is known to match the serialized version on disk.\n    // This is useful for saving a localstorage check if you try to load\n    // _currentUser frequently while there is none stored.\n    _currentUserMatchesDisk: false,\n\n    // The localStorage key suffix that the current user is stored under.\n    _CURRENT_USER_KEY: "currentUser",\n\n    // The mapping of auth provider names to actual providers\n    _authProviders: {},\n\n    // Whether to rewrite className User to _User\n    _performUserRewrite: true,\n\n\n    // Class Methods\n\n    /**\n     * Signs up a new user with a username (or email) and password.\n     * This will create a new Parse.User on the server, and also persist the\n     * session in localStorage so that you can access the user using\n     * {@link #current}.\n     *\n     * <p>Calls options.success or options.error on completion.</p>\n     *\n     * @param {String} username The username (or email) to sign up with.\n     * @param {String} password The password to sign up with.\n     * @param {Object} attrs Extra fields to set on the new user.\n     * @param {Object} options A Backbone-style options object.\n     * @return {Parse.Promise} A promise that is fulfilled with the user when\n     *     the signup completes.\n     * @see Parse.User#signUp\n     */\n    signUp: function(username, password, attrs, options) {\n      attrs = attrs || {};\n      attrs.username = username;\n      attrs.password = password;\n      var user = Parse.Object._create("_User");\n      return user.signUp(attrs, options);\n    },\n\n    /**\n     * Logs in a user with a username (or email) and password. On success, this\n     * saves the session to disk, so you can retrieve the currently logged in\n     * user using <code>current</code>.\n     *\n     * <p>Calls options.success or options.error on completion.</p>\n     *\n     * @param {String} username The username (or email) to log in with.\n     * @param {String} password The password to log in with.\n     * @param {Object} options A Backbone-style options object.\n     * @return {Parse.Promise} A promise that is fulfilled with the user when\n     *     the login completes.\n     * @see Parse.User#logIn\n     */\n    logIn: function(username, password, options) {\n      var user = Parse.Object._create("_User");\n      user._finishFetch({ username: username, password: password });\n      return user.logIn(options);\n    },\n\n    /**\n     * Logs in a user with a session token. On success, this saves the session\n     * to disk, so you can retrieve the currently logged in user using\n     * <code>current</code>.\n     *\n     * <p>Calls options.success or options.error on completion.</p>\n     *\n     * @param {String} sessionToken The sessionToken to log in with.\n     * @param {Object} options A Backbone-style options object.\n     * @return {Parse.Promise} A promise that is fulfilled with the user when\n     *     the login completes.\n     */\n    become: function(sessionToken, options) {\n      options = options || {};\n\n      var user = Parse.Object._create("_User");\n      return Parse._request({\n        route: "users",\n        className: "me",\n        method: "GET",\n        useMasterKey: options.useMasterKey,\n        sessionToken: sessionToken\n      }).then(function(resp, status, xhr) {\n        var serverAttrs = user.parse(resp, status, xhr);\n        user._finishFetch(serverAttrs);\n        user._handleSaveResult(true);\n        return user;\n\n      })._thenRunCallbacks(options, user);\n    },\n\n    /**\n     * Logs out the currently logged in user session. This will remove the\n     * session from disk, log out of linked services, and future calls to\n     * <code>current</code> will return <code>null</code>.\n     */\n    logOut: function() {\n      if (Parse.User._currentUser !== null) {\n        Parse.User._currentUser._logOutWithAll();\n        Parse.User._currentUser._isCurrentUser = false;\n      }\n      Parse.User._currentUserMatchesDisk = true;\n      Parse.User._currentUser = null;\n      Parse.localStorage.removeItem(\n          Parse._getParsePath(Parse.User._CURRENT_USER_KEY));\n    },\n\n    /**\n     * Requests a password reset email to be sent to the specified email address\n     * associated with the user account. This email allows the user to securely\n     * reset their password on the Parse site.\n     *\n     * <p>Calls options.success or options.error on completion.</p>\n     *\n     * @param {String} email The email address associated with the user that\n     *     forgot their password.\n     * @param {Object} options A Backbone-style options object.\n     */\n    requestPasswordReset: function(email, options) {\n      options = options || {};\n      var request = Parse._request({\n        route: "requestPasswordReset",\n        method: "POST",\n        useMasterKey: options.useMasterKey,\n        data: { email: email }\n      });\n      return request._thenRunCallbacks(options);\n    },\n\n    /**\n     * Retrieves the currently logged in ParseUser with a valid session,\n     * either from memory or localStorage, if necessary.\n     * @return {Parse.Object} The currently logged in Parse.User.\n     */\n    current: function() {\n      if (Parse.User._currentUser) {\n        return Parse.User._currentUser;\n      }\n\n      if (Parse.User._currentUserMatchesDisk) {\n\n        return Parse.User._currentUser;\n      }\n\n      // Load the user from local storage.\n      Parse.User._currentUserMatchesDisk = true;\n\n      var userData = Parse.localStorage.getItem(Parse._getParsePath(\n          Parse.User._CURRENT_USER_KEY));\n      if (!userData) {\n\n        return null;\n      }\n      Parse.User._currentUser = Parse.Object._create("_User");\n      Parse.User._currentUser._isCurrentUser = true;\n\n      var json = JSON.parse(userData);\n      Parse.User._currentUser.id = json._id;\n      delete json._id;\n      Parse.User._currentUser._sessionToken = json._sessionToken;\n      delete json._sessionToken;\n      Parse.User._currentUser._finishFetch(json);\n\n      Parse.User._currentUser._synchronizeAllAuthData();\n      Parse.User._currentUser._refreshCache();\n      Parse.User._currentUser._opSetQueue = [{}];\n      return Parse.User._currentUser;\n    },\n\n    /**\n     * Allow someone to define a custom User class without className\n     * being rewritten to _User. The default behavior is to rewrite\n     * User to _User for legacy reasons. This allows developers to\n     * override that behavior.\n     *\n     * @param {Boolean} isAllowed Whether or not to allow custom User class\n     */\n    allowCustomUserClass: function(isAllowed) {\n      this._performUserRewrite = !isAllowed;\n    },\n\n    /**\n     * Persists a user as currentUser to localStorage, and into the singleton.\n     */\n    _saveCurrentUser: function(user) {\n      if (Parse.User._currentUser !== user) {\n        Parse.User.logOut();\n      }\n      user._isCurrentUser = true;\n      Parse.User._currentUser = user;\n      Parse.User._currentUserMatchesDisk = true;\n\n      var json = user.toJSON();\n      json._id = user.id;\n      json._sessionToken = user._sessionToken;\n      Parse.localStorage.setItem(\n          Parse._getParsePath(Parse.User._CURRENT_USER_KEY),\n          JSON.stringify(json));\n    },\n\n    _registerAuthenticationProvider: function(provider) {\n      Parse.User._authProviders[provider.getAuthType()] = provider;\n      // Synchronize the current user with the auth provider.\n      if (Parse.User.current()) {\n        Parse.User.current()._synchronizeAuthData(provider.getAuthType());\n      }\n    },\n\n    _logInWith: function(provider, options) {\n      var user = Parse.Object._create("_User");\n      return user._linkWith(provider, options);\n    }\n\n  });\n}(this));\n\n\n// Parse.Query is a way to create a list of Parse.Objects.\n(function(root) {\n  root.Parse = root.Parse || {};\n  var Parse = root.Parse;\n  var _ = Parse._;\n\n  /**\n   * Creates a new parse Parse.Query for the given Parse.Object subclass.\n   * @param objectClass -\n   *   An instance of a subclass of Parse.Object, or a Parse className string.\n   * @class\n   *\n   * <p>Parse.Query defines a query that is used to fetch Parse.Objects. The\n   * most common use case is finding all objects that match a query through the\n   * <code>find</code> method. For example, this sample code fetches all objects\n   * of class <code>MyClass</code>. It calls a different function depending on\n   * whether the fetch succeeded or not.\n   *\n   * <pre>\n   * var query = new Parse.Query(MyClass);\n   * query.find({\n   *   success: function(results) {\n   *     // results is an array of Parse.Object.\n   *   },\n   *\n   *   error: function(error) {\n   *     // error is an instance of Parse.Error.\n   *   }\n   * });</pre></p>\n   *\n   * <p>A Parse.Query can also be used to retrieve a single object whose id is\n   * known, through the get method. For example, this sample code fetches an\n   * object of class <code>MyClass</code> and id <code>myId</code>. It calls a\n   * different function depending on whether the fetch succeeded or not.\n   *\n   * <pre>\n   * var query = new Parse.Query(MyClass);\n   * query.get(myId, {\n   *   success: function(object) {\n   *     // object is an instance of Parse.Object.\n   *   },\n   *\n   *   error: function(object, error) {\n   *     // error is an instance of Parse.Error.\n   *   }\n   * });</pre></p>\n   *\n   * <p>A Parse.Query can also be used to count the number of objects that match\n   * the query without retrieving all of those objects. For example, this\n   * sample code counts the number of objects of the class <code>MyClass</code>\n   * <pre>\n   * var query = new Parse.Query(MyClass);\n   * query.count({\n   *   success: function(number) {\n   *     // There are number instances of MyClass.\n   *   },\n   *\n   *   error: function(error) {\n   *     // error is an instance of Parse.Error.\n   *   }\n   * });</pre></p>\n   */\n  Parse.Query = function(objectClass) {\n    if (_.isString(objectClass)) {\n      objectClass = Parse.Object._getSubclass(objectClass);\n    }\n\n    this.objectClass = objectClass;\n\n    this.className = objectClass.prototype.className;\n\n    this._where = {};\n    this._include = [];\n    this._limit = -1; // negative limit means, do not send a limit\n    this._skip = 0;\n    this._extraOptions = {};\n  };\n\n  /**\n   * Constructs a Parse.Query that is the OR of the passed in queries.  For\n   * example:\n   * <pre>var compoundQuery = Parse.Query.or(query1, query2, query3);</pre>\n   *\n   * will create a compoundQuery that is an or of the query1, query2, and\n   * query3.\n   * @param {...Parse.Query} var_args The list of queries to OR.\n   * @return {Parse.Query} The query that is the OR of the passed in queries.\n   */\n  Parse.Query.or = function() {\n    var queries = _.toArray(arguments);\n    var className = null;\n    Parse._arrayEach(queries, function(q) {\n      if (_.isNull(className)) {\n        className = q.className;\n      }\n\n      if (className !== q.className) {\n        throw "All queries must be for the same class";\n      }\n    });\n    var query = new Parse.Query(className);\n    query._orQuery(queries);\n    return query;\n  };\n\n  Parse.Query.prototype = {\n    /**\n     * Constructs a Parse.Object whose id is already known by fetching data from\n     * the server.  Either options.success or options.error is called when the\n     * find completes.\n     *\n     * @param {String} objectId The id of the object to be fetched.\n     * @param {Object} options A Backbone-style options object.\n     * Valid options are:<ul>\n     *   <li>success: A Backbone-style success callback\n     *   <li>error: An Backbone-style error callback.\n     *   <li>useMasterKey: In Cloud Code and Node only, causes the Master Key to\n     *     be used for this request.\n     * </ul>\n     */\n    get: function(objectId, options) {\n      var self = this;\n      self.equalTo(\'objectId\', objectId);\n\n      var firstOptions = {};\n      if (options && _.has(options, \'useMasterKey\')) {\n        firstOptions = { useMasterKey: options.useMasterKey };\n      }\n\n      return self.first(firstOptions).then(function(response) {\n        if (response) {\n          return response;\n        }\n\n        var errorObject = new Parse.Error(Parse.Error.OBJECT_NOT_FOUND,\n                                          "Object not found.");\n        return Parse.Promise.error(errorObject);\n\n      })._thenRunCallbacks(options, null);\n    },\n\n    /**\n     * Returns a JSON representation of this query.\n     * @return {Object} The JSON representation of the query.\n     */\n    toJSON: function() {\n      var params = {\n        where: this._where\n      };\n\n      if (this._include.length > 0) {\n        params.include = this._include.join(",");\n      }\n      if (this._select) {\n        params.keys = this._select.join(",");\n      }\n      if (this._limit >= 0) {\n        params.limit = this._limit;\n      }\n      if (this._skip > 0) {\n        params.skip = this._skip;\n      }\n      if (this._order !== undefined) {\n        params.order = this._order.join(",");\n      }\n\n      Parse._objectEach(this._extraOptions, function(v, k) {\n        params[k] = v;\n      });\n\n      return params;\n    },\n\n    /**\n     * Retrieves a list of ParseObjects that satisfy this query.\n     * Either options.success or options.error is called when the find\n     * completes.\n     *\n     * @param {Object} options A Backbone-style options object. Valid options\n     * are:<ul>\n     *   <li>success: Function to call when the find completes successfully.\n     *   <li>error: Function to call when the find fails.\n     *   <li>useMasterKey: In Cloud Code and Node only, causes the Master Key to\n     *     be used for this request.\n     * </ul>\n     *\n     * @return {Parse.Promise} A promise that is resolved with the results when\n     * the query completes.\n     */\n    find: function(options) {\n      var self = this;\n      options = options || {};\n\n      var request = Parse._request({\n        route: "classes",\n        className: this.className,\n        method: "GET",\n        useMasterKey: options.useMasterKey,\n        data: this.toJSON()\n      });\n\n      return request.then(function(response) {\n        return _.map(response.results, function(json) {\n          var obj;\n          if (response.className) {\n            obj = new Parse.Object(response.className);\n          } else {\n            obj = new self.objectClass();\n          }\n          obj._finishFetch(json, true);\n          return obj;\n        });\n      })._thenRunCallbacks(options);\n    },\n\n    /**\n     * Counts the number of objects that match this query.\n     * Either options.success or options.error is called when the count\n     * completes.\n     *\n     * @param {Object} options A Backbone-style options object. Valid options\n     * are:<ul>\n     *   <li>success: Function to call when the count completes successfully.\n     *   <li>error: Function to call when the find fails.\n     *   <li>useMasterKey: In Cloud Code and Node only, causes the Master Key to\n     *     be used for this request.\n     * </ul>\n     *\n     * @return {Parse.Promise} A promise that is resolved with the count when\n     * the query completes.\n     */\n    count: function(options) {\n      var self = this;\n      options = options || {};\n\n      var params = this.toJSON();\n      params.limit = 0;\n      params.count = 1;\n      var request = Parse._request({\n        route: "classes",\n        className: self.className,\n        method: "GET",\n        useMasterKey: options.useMasterKey,\n        data: params\n      });\n\n      return request.then(function(response) {\n        return response.count;\n      })._thenRunCallbacks(options);\n    },\n\n    /**\n     * Retrieves at most one Parse.Object that satisfies this query.\n     *\n     * Either options.success or options.error is called when it completes.\n     * success is passed the object if there is one. otherwise, undefined.\n     *\n     * @param {Object} options A Backbone-style options object. Valid options\n     * are:<ul>\n     *   <li>success: Function to call when the find completes successfully.\n     *   <li>error: Function to call when the find fails.\n     *   <li>useMasterKey: In Cloud Code and Node only, causes the Master Key to\n     *     be used for this request.\n     * </ul>\n     *\n     * @return {Parse.Promise} A promise that is resolved with the object when\n     * the query completes.\n     */\n    first: function(options) {\n      var self = this;\n      options = options || {};\n\n      var params = this.toJSON();\n      params.limit = 1;\n      var request = Parse._request({\n        route: "classes",\n        className: this.className,\n        method: "GET",\n        useMasterKey: options.useMasterKey,\n        data: params\n      });\n\n      return request.then(function(response) {\n        return _.map(response.results, function(json) {\n          var obj = new self.objectClass();\n          obj._finishFetch(json, true);\n          return obj;\n        })[0];\n      })._thenRunCallbacks(options);\n    },\n\n    /**\n     * Returns a new instance of Parse.Collection backed by this query.\n     * @param {Array} items An array of instances of <code>Parse.Object</code>\n     *     with which to start this Collection.\n     * @param {Object} options An optional object with Backbone-style options.\n     * Valid options are:<ul>\n     *   <li>model: The Parse.Object subclass that this collection contains.\n     *   <li>query: An instance of Parse.Query to use when fetching items.\n     *   <li>comparator: A string property name or function to sort by.\n     * </ul>\n     * @return {Parse.Collection}\n     */\n    collection: function(items, options) {\n      options = options || {};\n      return new Parse.Collection(items, _.extend(options, {\n        model: this.objectClass,\n        query: this\n      }));\n    },\n\n    /**\n     * Sets the number of results to skip before returning any results.\n     * This is useful for pagination.\n     * Default is to skip zero results.\n     * @param {Number} n the number of results to skip.\n     * @return {Parse.Query} Returns the query, so you can chain this call.\n     */\n    skip: function(n) {\n      this._skip = n;\n      return this;\n    },\n\n    /**\n     * Sets the limit of the number of results to return. The default limit is\n     * 100, with a maximum of 1000 results being returned at a time.\n     * @param {Number} n the number of results to limit to.\n     * @return {Parse.Query} Returns the query, so you can chain this call.\n     */\n    limit: function(n) {\n      this._limit = n;\n      return this;\n    },\n\n    /**\n     * Add a constraint to the query that requires a particular key\'s value to\n     * be equal to the provided value.\n     * @param {String} key The key to check.\n     * @param value The value that the Parse.Object must contain.\n     * @return {Parse.Query} Returns the query, so you can chain this call.\n     */\n    equalTo: function(key, value) {\n      if (_.isUndefined(value)) {\n        return this.doesNotExist(key);\n      }\n\n      this._where[key] = Parse._encode(value);\n      return this;\n    },\n\n    /**\n     * Helper for condition queries\n     */\n    _addCondition: function(key, condition, value) {\n      // Check if we already have a condition\n      if (!this._where[key]) {\n        this._where[key] = {};\n      }\n      this._where[key][condition] = Parse._encode(value);\n      return this;\n    },\n\n    /**\n     * Add a constraint to the query that requires a particular key\'s value to\n     * be not equal to the provided value.\n     * @param {String} key The key to check.\n     * @param value The value that must not be equalled.\n     * @return {Parse.Query} Returns the query, so you can chain this call.\n     */\n    notEqualTo: function(key, value) {\n      this._addCondition(key, "$ne", value);\n      return this;\n    },\n\n    /**\n     * Add a constraint to the query that requires a particular key\'s value to\n     * be less than the provided value.\n     * @param {String} key The key to check.\n     * @param value The value that provides an upper bound.\n     * @return {Parse.Query} Returns the query, so you can chain this call.\n     */\n    lessThan: function(key, value) {\n      this._addCondition(key, "$lt", value);\n      return this;\n    },\n\n    /**\n     * Add a constraint to the query that requires a particular key\'s value to\n     * be greater than the provided value.\n     * @param {String} key The key to check.\n     * @param value The value that provides an lower bound.\n     * @return {Parse.Query} Returns the query, so you can chain this call.\n     */\n    greaterThan: function(key, value) {\n      this._addCondition(key, "$gt", value);\n      return this;\n    },\n\n    /**\n     * Add a constraint to the query that requires a particular key\'s value to\n     * be less than or equal to the provided value.\n     * @param {String} key The key to check.\n     * @param value The value that provides an upper bound.\n     * @return {Parse.Query} Returns the query, so you can chain this call.\n     */\n    lessThanOrEqualTo: function(key, value) {\n      this._addCondition(key, "$lte", value);\n      return this;\n    },\n\n    /**\n     * Add a constraint to the query that requires a particular key\'s value to\n     * be greater than or equal to the provided value.\n     * @param {String} key The key to check.\n     * @param value The value that provides an lower bound.\n     * @return {Parse.Query} Returns the query, so you can chain this call.\n     */\n    greaterThanOrEqualTo: function(key, value) {\n      this._addCondition(key, "$gte", value);\n      return this;\n    },\n\n    /**\n     * Add a constraint to the query that requires a particular key\'s value to\n     * be contained in the provided list of values.\n     * @param {String} key The key to check.\n     * @param {Array} values The values that will match.\n     * @return {Parse.Query} Returns the query, so you can chain this call.\n     */\n    containedIn: function(key, values) {\n      this._addCondition(key, "$in", values);\n      return this;\n    },\n\n    /**\n     * Add a constraint to the query that requires a particular key\'s value to\n     * not be contained in the provided list of values.\n     * @param {String} key The key to check.\n     * @param {Array} values The values that will not match.\n     * @return {Parse.Query} Returns the query, so you can chain this call.\n     */\n    notContainedIn: function(key, values) {\n      this._addCondition(key, "$nin", values);\n      return this;\n    },\n\n    /**\n     * Add a constraint to the query that requires a particular key\'s value to\n     * contain each one of the provided list of values.\n     * @param {String} key The key to check.  This key\'s value must be an array.\n     * @param {Array} values The values that will match.\n     * @return {Parse.Query} Returns the query, so you can chain this call.\n     */\n    containsAll: function(key, values) {\n      this._addCondition(key, "$all", values);\n      return this;\n    },\n\n\n    /**\n     * Add a constraint for finding objects that contain the given key.\n     * @param {String} key The key that should exist.\n     * @return {Parse.Query} Returns the query, so you can chain this call.\n     */\n    exists: function(key) {\n      this._addCondition(key, "$exists", true);\n      return this;\n    },\n\n    /**\n     * Add a constraint for finding objects that do not contain a given key.\n     * @param {String} key The key that should not exist\n     * @return {Parse.Query} Returns the query, so you can chain this call.\n     */\n    doesNotExist: function(key) {\n      this._addCondition(key, "$exists", false);\n      return this;\n    },\n\n    /**\n     * Add a regular expression constraint for finding string values that match\n     * the provided regular expression.\n     * This may be slow for large datasets.\n     * @param {String} key The key that the string to match is stored in.\n     * @param {RegExp} regex The regular expression pattern to match.\n     * @return {Parse.Query} Returns the query, so you can chain this call.\n     */\n    matches: function(key, regex, modifiers) {\n      this._addCondition(key, "$regex", regex);\n      if (!modifiers) { modifiers = ""; }\n      // Javascript regex options support mig as inline options but store them\n      // as properties of the object. We support mi & should migrate them to\n      // modifiers\n      if (regex.ignoreCase) { modifiers += \'i\'; }\n      if (regex.multiline) { modifiers += \'m\'; }\n\n      if (modifiers && modifiers.length) {\n        this._addCondition(key, "$options", modifiers);\n      }\n      return this;\n    },\n\n    /**\n     * Add a constraint that requires that a key\'s value matches a Parse.Query\n     * constraint.\n     * @param {String} key The key that the contains the object to match the\n     *                     query.\n     * @param {Parse.Query} query The query that should match.\n     * @return {Parse.Query} Returns the query, so you can chain this call.\n     */\n    matchesQuery: function(key, query) {\n      var queryJSON = query.toJSON();\n      queryJSON.className = query.className;\n      this._addCondition(key, "$inQuery", queryJSON);\n      return this;\n    },\n\n   /**\n     * Add a constraint that requires that a key\'s value not matches a\n     * Parse.Query constraint.\n     * @param {String} key The key that the contains the object to match the\n     *                     query.\n     * @param {Parse.Query} query The query that should not match.\n     * @return {Parse.Query} Returns the query, so you can chain this call.\n     */\n    doesNotMatchQuery: function(key, query) {\n      var queryJSON = query.toJSON();\n      queryJSON.className = query.className;\n      this._addCondition(key, "$notInQuery", queryJSON);\n      return this;\n    },\n\n\n    /**\n     * Add a constraint that requires that a key\'s value matches a value in\n     * an object returned by a different Parse.Query.\n     * @param {String} key The key that contains the value that is being\n     *                     matched.\n     * @param {String} queryKey The key in the objects returned by the query to\n     *                          match against.\n     * @param {Parse.Query} query The query to run.\n     * @return {Parse.Query} Returns the query, so you can chain this call.\n     */\n    matchesKeyInQuery: function(key, queryKey, query) {\n      var queryJSON = query.toJSON();\n      queryJSON.className = query.className;\n      this._addCondition(key, "$select",\n                         { key: queryKey, query: queryJSON });\n      return this;\n    },\n\n    /**\n     * Add a constraint that requires that a key\'s value not match a value in\n     * an object returned by a different Parse.Query.\n     * @param {String} key The key that contains the value that is being\n     *                     excluded.\n     * @param {String} queryKey The key in the objects returned by the query to\n     *                          match against.\n     * @param {Parse.Query} query The query to run.\n     * @return {Parse.Query} Returns the query, so you can chain this call.\n     */\n    doesNotMatchKeyInQuery: function(key, queryKey, query) {\n      var queryJSON = query.toJSON();\n      queryJSON.className = query.className;\n      this._addCondition(key, "$dontSelect",\n                         { key: queryKey, query: queryJSON });\n      return this;\n    },\n\n    /**\n     * Add constraint that at least one of the passed in queries matches.\n     * @param {Array} queries\n     * @return {Parse.Query} Returns the query, so you can chain this call.\n     */\n    _orQuery: function(queries) {\n      var queryJSON = _.map(queries, function(q) {\n        return q.toJSON().where;\n      });\n\n      this._where.$or = queryJSON;\n      return this;\n    },\n\n    /**\n     * Converts a string into a regex that matches it.\n     * Surrounding with \\Q .. \\E does this, we just need to escape \\E\'s in\n     * the text separately.\n     */\n    _quote: function(s) {\n      return "\\\\Q" + s.replace("\\\\E", "\\\\E\\\\\\\\E\\\\Q") + "\\\\E";\n    },\n\n    /**\n     * Add a constraint for finding string values that contain a provided\n     * string.  This may be slow for large datasets.\n     * @param {String} key The key that the string to match is stored in.\n     * @param {String} substring The substring that the value must contain.\n     * @return {Parse.Query} Returns the query, so you can chain this call.\n     */\n    contains: function(key, value) {\n      this._addCondition(key, "$regex", this._quote(value));\n      return this;\n    },\n\n    /**\n     * Add a constraint for finding string values that start with a provided\n     * string.  This query will use the backend index, so it will be fast even\n     * for large datasets.\n     * @param {String} key The key that the string to match is stored in.\n     * @param {String} prefix The substring that the value must start with.\n     * @return {Parse.Query} Returns the query, so you can chain this call.\n     */\n    startsWith: function(key, value) {\n      this._addCondition(key, "$regex", "^" + this._quote(value));\n      return this;\n    },\n\n    /**\n     * Add a constraint for finding string values that end with a provided\n     * string.  This will be slow for large datasets.\n     * @param {String} key The key that the string to match is stored in.\n     * @param {String} suffix The substring that the value must end with.\n     * @return {Parse.Query} Returns the query, so you can chain this call.\n     */\n    endsWith: function(key, value) {\n      this._addCondition(key, "$regex", this._quote(value) + "$");\n      return this;\n    },\n\n    /**\n     * Sorts the results in ascending order by the given key.\n     *\n     * @param {(String|String[]|...String} key The key to order by, which is a\n     * string of comma separated values, or an Array of keys, or multiple keys.\n     * @return {Parse.Query} Returns the query, so you can chain this call.\n     */\n    ascending: function() {\n      this._order = [];\n      return this.addAscending.apply(this, arguments);\n    },\n\n    /**\n     * Sorts the results in ascending order by the given key,\n     * but can also add secondary sort descriptors without overwriting _order.\n     *\n     * @param {(String|String[]|...String} key The key to order by, which is a\n     * string of comma separated values, or an Array of keys, or multiple keys.\n     * @return {Parse.Query} Returns the query, so you can chain this call.\n     */\n    addAscending: function(key) {\n      var self = this;\n      if (!this._order) {\n        this._order = [];\n      }\n      Parse._arrayEach(arguments, function(key) {\n        if (Array.isArray(key)) {\n          key = key.join();\n        }\n        self._order = self._order.concat(key.replace(/\\s/g, "").split(","));\n      });\n      return this;\n    },\n\n    /**\n     * Sorts the results in descending order by the given key.\n     *\n     * @param {(String|String[]|...String} key The key to order by, which is a\n     * string of comma separated values, or an Array of keys, or multiple keys.\n     * @return {Parse.Query} Returns the query, so you can chain this call.\n     */\n    descending: function(key) {\n      this._order = [];\n      return this.addDescending.apply(this, arguments);\n    },\n\n    /**\n     * Sorts the results in descending order by the given key,\n     * but can also add secondary sort descriptors without overwriting _order.\n     *\n     * @param {(String|String[]|...String} key The key to order by, which is a\n     * string of comma separated values, or an Array of keys, or multiple keys.\n     * @return {Parse.Query} Returns the query, so you can chain this call.\n     */\n    addDescending: function(key) {\n      var self = this;\n      if (!this._order) {\n        this._order = [];\n      }\n      Parse._arrayEach(arguments, function(key) {\n        if (Array.isArray(key)) {\n          key = key.join();\n        }\n        self._order = self._order.concat(\n          _.map(key.replace(/\\s/g, "").split(","),\n            function(k) { return "-" + k; }));\n      });\n      return this;\n    },\n\n    /**\n     * Add a proximity based constraint for finding objects with key point\n     * values near the point given.\n     * @param {String} key The key that the Parse.GeoPoint is stored in.\n     * @param {Parse.GeoPoint} point The reference Parse.GeoPoint that is used.\n     * @return {Parse.Query} Returns the query, so you can chain this call.\n     */\n    near: function(key, point) {\n      if (!(point instanceof Parse.GeoPoint)) {\n        // Try to cast it to a GeoPoint, so that near("loc", [20,30]) works.\n        point = new Parse.GeoPoint(point);\n      }\n      this._addCondition(key, "$nearSphere", point);\n      return this;\n    },\n\n    /**\n     * Add a proximity based constraint for finding objects with key point\n     * values near the point given and within the maximum distance given.\n     * @param {String} key The key that the Parse.GeoPoint is stored in.\n     * @param {Parse.GeoPoint} point The reference Parse.GeoPoint that is used.\n     * @param {Number} maxDistance Maximum distance (in radians) of results to\n     *   return.\n     * @return {Parse.Query} Returns the query, so you can chain this call.\n     */\n    withinRadians: function(key, point, distance) {\n      this.near(key, point);\n      this._addCondition(key, "$maxDistance", distance);\n      return this;\n    },\n\n    /**\n     * Add a proximity based constraint for finding objects with key point\n     * values near the point given and within the maximum distance given.\n     * Radius of earth used is 3958.8 miles.\n     * @param {String} key The key that the Parse.GeoPoint is stored in.\n     * @param {Parse.GeoPoint} point The reference Parse.GeoPoint that is used.\n     * @param {Number} maxDistance Maximum distance (in miles) of results to\n     *     return.\n     * @return {Parse.Query} Returns the query, so you can chain this call.\n     */\n    withinMiles: function(key, point, distance) {\n      return this.withinRadians(key, point, distance / 3958.8);\n    },\n\n    /**\n     * Add a proximity based constraint for finding objects with key point\n     * values near the point given and within the maximum distance given.\n     * Radius of earth used is 6371.0 kilometers.\n     * @param {String} key The key that the Parse.GeoPoint is stored in.\n     * @param {Parse.GeoPoint} point The reference Parse.GeoPoint that is used.\n     * @param {Number} maxDistance Maximum distance (in kilometers) of results\n     *     to return.\n     * @return {Parse.Query} Returns the query, so you can chain this call.\n     */\n    withinKilometers: function(key, point, distance) {\n      return this.withinRadians(key, point, distance / 6371.0);\n    },\n\n    /**\n     * Add a constraint to the query that requires a particular key\'s\n     * coordinates be contained within a given rectangular geographic bounding\n     * box.\n     * @param {String} key The key to be constrained.\n     * @param {Parse.GeoPoint} southwest\n     *     The lower-left inclusive corner of the box.\n     * @param {Parse.GeoPoint} northeast\n     *     The upper-right inclusive corner of the box.\n     * @return {Parse.Query} Returns the query, so you can chain this call.\n     */\n    withinGeoBox: function(key, southwest, northeast) {\n      if (!(southwest instanceof Parse.GeoPoint)) {\n        southwest = new Parse.GeoPoint(southwest);\n      }\n      if (!(northeast instanceof Parse.GeoPoint)) {\n        northeast = new Parse.GeoPoint(northeast);\n      }\n      this._addCondition(key, \'$within\', { \'$box\': [southwest, northeast] });\n      return this;\n    },\n\n    /**\n     * Include nested Parse.Objects for the provided key.  You can use dot\n     * notation to specify which fields in the included object are also fetch.\n     * @param {String} key The name of the key to include.\n     * @return {Parse.Query} Returns the query, so you can chain this call.\n     */\n    include: function() {\n      var self = this;\n      Parse._arrayEach(arguments, function(key) {\n        if (_.isArray(key)) {\n          self._include = self._include.concat(key);\n        } else {\n          self._include.push(key);\n        }\n      });\n      return this;\n    },\n\n    /**\n     * Restrict the fields of the returned Parse.Objects to include only the\n     * provided keys.  If this is called multiple times, then all of the keys\n     * specified in each of the calls will be included.\n     * @param {Array} keys The names of the keys to include.\n     * @return {Parse.Query} Returns the query, so you can chain this call.\n     */\n    select: function() {\n      var self = this;\n      this._select = this._select || [];\n      Parse._arrayEach(arguments, function(key) {\n        if (_.isArray(key)) {\n          self._select = self._select.concat(key);\n        } else {\n          self._select.push(key);\n        }\n      });\n      return this;\n    },\n\n    /**\n     * Iterates over each result of a query, calling a callback for each one. If\n     * the callback returns a promise, the iteration will not continue until\n     * that promise has been fulfilled. If the callback returns a rejected\n     * promise, then iteration will stop with that error. The items are\n     * processed in an unspecified order. The query may not have any sort order,\n     * and may not use limit or skip.\n     * @param {Function} callback Callback that will be called with each result\n     *     of the query.\n     * @param {Object} options An optional Backbone-like options object with\n     *     success and error callbacks that will be invoked once the iteration\n     *     has finished.\n     * @return {Parse.Promise} A promise that will be fulfilled once the\n     *     iteration has completed.\n     */\n    each: function(callback, options) {\n      options = options || {};\n\n      if (this._order || this._skip || (this._limit >= 0)) {\n        var error =\n          "Cannot iterate on a query with sort, skip, or limit.";\n        return Parse.Promise.error(error)._thenRunCallbacks(options);\n      }\n\n      var promise = new Parse.Promise();\n\n      var query = new Parse.Query(this.objectClass);\n      // We can override the batch size from the options.\n      // This is undocumented, but useful for testing.\n      query._limit = options.batchSize || 100;\n      query._where = _.clone(this._where);\n      query._include = _.clone(this._include);\n\n      query.ascending(\'objectId\');\n\n      var finished = false;\n      return Parse.Promise._continueWhile(function() {\n        return !finished;\n\n      }, function() {\n        return query.find().then(function(results) {\n          var callbacksDone = Parse.Promise.as();\n          Parse._.each(results, function(result) {\n            callbacksDone = callbacksDone.then(function() {\n              return callback(result);\n            });\n          });\n\n          return callbacksDone.then(function() {\n            if (results.length >= query._limit) {\n              query.greaterThan("objectId", results[results.length - 1].id);\n            } else {\n              finished = true;\n            }\n          });\n        });\n      })._thenRunCallbacks(options);\n    }\n  };\n\n}(this));\n\n/*global FB: false , console: false*/\n(function(root) {\n  root.Parse = root.Parse || {};\n  var Parse = root.Parse;\n  var _ = Parse._;\n\n  var PUBLIC_KEY = "*";\n\n  var initialized = false;\n  var requestedPermissions;\n  var initOptions;\n  var provider = {\n    authenticate: function(options) {\n      var self = this;\n      FB.login(function(response) {\n        if (response.authResponse) {\n          if (options.success) {\n            options.success(self, {\n              id: response.authResponse.userID,\n              access_token: response.authResponse.accessToken,\n              expiration_date: new Date(response.authResponse.expiresIn * 1000 +\n                  (new Date()).getTime()).toJSON()\n            });\n          }\n        } else {\n          if (options.error) {\n            options.error(self, response);\n          }\n        }\n      }, {\n        scope: requestedPermissions\n      });\n    },\n    restoreAuthentication: function(authData) {\n      if (authData) {\n        var authResponse = {\n          userID: authData.id,\n          accessToken: authData.access_token,\n          expiresIn: (Parse._parseDate(authData.expiration_date).getTime() -\n              (new Date()).getTime()) / 1000\n        };\n        var newOptions = _.clone(initOptions);\n        newOptions.authResponse = authResponse;\n\n        // Suppress checks for login status from the browser.\n        newOptions.status = false;\n\n        // If the user doesn\'t match the one known by the FB SDK, log out.\n        // Most of the time, the users will match -- it\'s only in cases where\n        // the FB SDK knows of a different user than the one being restored\n        // from a Parse User that logged in with username/password.\n        var existingResponse = FB.getAuthResponse();\n        if (existingResponse &&\n            existingResponse.userID !== authResponse.userID) {\n          FB.logout();\n        }\n\n        FB.init(newOptions);\n      }\n      return true;\n    },\n    getAuthType: function() {\n      return "facebook";\n    },\n    deauthenticate: function() {\n      this.restoreAuthentication(null);\n    }\n  };\n\n  /**\n   * Provides a set of utilities for using Parse with Facebook.\n   * @namespace\n   * Provides a set of utilities for using Parse with Facebook.\n   */\n  Parse.FacebookUtils = {\n    /**\n     * Initializes Parse Facebook integration.  Call this function after you\n     * have loaded the Facebook Javascript SDK with the same parameters\n     * as you would pass to<code>\n     * <a href=\n     * "https://developers.facebook.com/docs/reference/javascript/FB.init/">\n     * FB.init()</a></code>.  Parse.FacebookUtils will invoke FB.init() for you\n     * with these arguments.\n     *\n     * @param {Object} options Facebook options argument as described here:\n     *   <a href=\n     *   "https://developers.facebook.com/docs/reference/javascript/FB.init/">\n     *   FB.init()</a>. The status flag will be coerced to \'false\' because it\n     *   interferes with Parse Facebook integration. Call FB.getLoginStatus()\n     *   explicitly if this behavior is required by your application.\n     */\n    init: function(options) {\n      if (typeof(FB) === \'undefined\') {\n        throw "The Facebook JavaScript SDK must be loaded before calling init.";\n      }\n      initOptions = _.clone(options) || {};\n      if (initOptions.status && typeof(console) !== "undefined") {\n        var warn = console.warn || console.log || function() {};\n        warn.call(console, "The \'status\' flag passed into" +\n          " FB.init, when set to true, can interfere with Parse Facebook" +\n          " integration, so it has been suppressed. Please call" +\n          " FB.getLoginStatus() explicitly if you require this behavior.");\n      }\n      initOptions.status = false;\n      FB.init(initOptions);\n      Parse.User._registerAuthenticationProvider(provider);\n      initialized = true;\n    },\n\n    /**\n     * Gets whether the user has their account linked to Facebook.\n     *\n     * @param {Parse.User} user User to check for a facebook link.\n     *     The user must be logged in on this device.\n     * @return {Boolean} <code>true</code> if the user has their account\n     *     linked to Facebook.\n     */\n    isLinked: function(user) {\n      return user._isLinked("facebook");\n    },\n\n    /**\n     * Logs in a user using Facebook. This method delegates to the Facebook\n     * SDK to authenticate the user, and then automatically logs in (or\n     * creates, in the case where it is a new user) a Parse.User.\n     *\n     * @param {String, Object} permissions The permissions required for Facebook\n     *    log in.  This is a comma-separated string of permissions.\n     *    Alternatively, supply a Facebook authData object as described in our\n     *    REST API docs if you want to handle getting facebook auth tokens\n     *    yourself.\n     * @param {Object} options Standard options object with success and error\n     *    callbacks.\n     */\n    logIn: function(permissions, options) {\n      if (!permissions || _.isString(permissions)) {\n        if (!initialized) {\n          throw "You must initialize FacebookUtils before calling logIn.";\n        }\n        requestedPermissions = permissions;\n        return Parse.User._logInWith("facebook", options);\n      } else {\n        var newOptions = _.clone(options) || {};\n        newOptions.authData = permissions;\n        return Parse.User._logInWith("facebook", newOptions);\n      }\n    },\n\n    /**\n     * Links Facebook to an existing PFUser. This method delegates to the\n     * Facebook SDK to authenticate the user, and then automatically links\n     * the account to the Parse.User.\n     *\n     * @param {Parse.User} user User to link to Facebook. This must be the\n     *     current user.\n     * @param {String, Object} permissions The permissions required for Facebook\n     *    log in.  This is a comma-separated string of permissions.\n     *    Alternatively, supply a Facebook authData object as described in our\n     *    REST API docs if you want to handle getting facebook auth tokens\n     *    yourself.\n     * @param {Object} options Standard options object with success and error\n     *    callbacks.\n     */\n    link: function(user, permissions, options) {\n      if (!permissions || _.isString(permissions)) {\n        if (!initialized) {\n          throw "You must initialize FacebookUtils before calling link.";\n        }\n        requestedPermissions = permissions;\n        return user._linkWith("facebook", options);\n      } else {\n        var newOptions = _.clone(options) || {};\n        newOptions.authData = permissions;\n        return user._linkWith("facebook", newOptions);\n      }\n    },\n\n    /**\n     * Unlinks the Parse.User from a Facebook account.\n     *\n     * @param {Parse.User} user User to unlink from Facebook. This must be the\n     *     current user.\n     * @param {Object} options Standard options object with success and error\n     *    callbacks.\n     */\n    unlink: function(user, options) {\n      if (!initialized) {\n        throw "You must initialize FacebookUtils before calling unlink.";\n      }\n      return user._unlinkFrom("facebook", options);\n    }\n  };\n\n}(this));\n\n/*global _: false, document: false, window: false, navigator: false */\n(function(root) {\n  root.Parse = root.Parse || {};\n  var Parse = root.Parse;\n  var _ = Parse._;\n\n  /**\n   * History serves as a global router (per frame) to handle hashchange\n   * events or pushState, match the appropriate route, and trigger\n   * callbacks. You shouldn\'t ever have to create one of these yourself\n   *  you should use the reference to <code>Parse.history</code>\n   * that will be created for you automatically if you make use of\n   * Routers with routes.\n   * @class\n   *\n   * <p>A fork of Backbone.History, provided for your convenience.  If you\n   * use this class, you must also include jQuery, or another library\n   * that provides a jQuery-compatible $ function.  For more information,\n   * see the <a href="http://documentcloud.github.com/backbone/#History">\n   * Backbone documentation</a>.</p>\n   * <p><strong><em>Available in the client SDK only.</em></strong></p>\n   */\n  Parse.History = function() {\n    this.handlers = [];\n    _.bindAll(this, \'checkUrl\');\n  };\n\n  // Cached regex for cleaning leading hashes and slashes .\n  var routeStripper = /^[#\\/]/;\n\n  // Cached regex for detecting MSIE.\n  var isExplorer = /msie [\\w.]+/;\n\n  // Has the history handling already been started?\n  Parse.History.started = false;\n\n  // Set up all inheritable **Parse.History** properties and methods.\n  _.extend(Parse.History.prototype, Parse.Events,\n           /** @lends Parse.History.prototype */ {\n\n    // The default interval to poll for hash changes, if necessary, is\n    // twenty times a second.\n    interval: 50,\n\n    // Gets the true hash value. Cannot use location.hash directly due to bug\n    // in Firefox where location.hash will always be decoded.\n    getHash: function(windowOverride) {\n      var loc = windowOverride ? windowOverride.location : window.location;\n      var match = loc.href.match(/#(.*)$/);\n      return match ? match[1] : \'\';\n    },\n\n    // Get the cross-browser normalized URL fragment, either from the URL,\n    // the hash, or the override.\n    getFragment: function(fragment, forcePushState) {\n      if (Parse._isNullOrUndefined(fragment)) {\n        if (this._hasPushState || forcePushState) {\n          fragment = window.location.pathname;\n          var search = window.location.search;\n          if (search) {\n            fragment += search;\n          }\n        } else {\n          fragment = this.getHash();\n        }\n      }\n      if (!fragment.indexOf(this.options.root)) {\n        fragment = fragment.substr(this.options.root.length);\n      }\n      return fragment.replace(routeStripper, \'\');\n    },\n\n    /**\n     * Start the hash change handling, returning `true` if the current\n     * URL matches an existing route, and `false` otherwise.\n     */\n    start: function(options) {\n      if (Parse.History.started) {\n        throw new Error("Parse.history has already been started");\n      }\n      Parse.History.started = true;\n\n      // Figure out the initial configuration. Do we need an iframe?\n      // Is pushState desired ... is it available?\n      this.options = _.extend({}, {root: \'/\'}, this.options, options);\n      this._wantsHashChange = this.options.hashChange !== false;\n      this._wantsPushState = !!this.options.pushState;\n      this._hasPushState = !!(this.options.pushState &&\n                              window.history &&\n                              window.history.pushState);\n      var fragment = this.getFragment();\n      var docMode = document.documentMode;\n      var oldIE = (isExplorer.exec(navigator.userAgent.toLowerCase()) &&\n                   (!docMode || docMode <= 7));\n\n      if (oldIE) {\n        this.iframe = Parse.$(\'<iframe src="javascript:0" tabindex="-1" />\')\n                      .hide().appendTo(\'body\')[0].contentWindow;\n        this.navigate(fragment);\n      }\n\n      // Depending on whether we\'re using pushState or hashes, and whether\n      // \'onhashchange\' is supported, determine how we check the URL state.\n      if (this._hasPushState) {\n        Parse.$(window).bind(\'popstate\', this.checkUrl);\n      } else if (this._wantsHashChange &&\n                 (\'onhashchange\' in window) &&\n                 !oldIE) {\n        Parse.$(window).bind(\'hashchange\', this.checkUrl);\n      } else if (this._wantsHashChange) {\n        this._checkUrlInterval = window.setInterval(this.checkUrl,\n                                                    this.interval);\n      }\n\n      // Determine if we need to change the base url, for a pushState link\n      // opened by a non-pushState browser.\n      this.fragment = fragment;\n      var loc = window.location;\n      var atRoot  = loc.pathname === this.options.root;\n\n      // If we\'ve started off with a route from a `pushState`-enabled browser,\n      // but we\'re currently in a browser that doesn\'t support it...\n      if (this._wantsHashChange &&\n          this._wantsPushState &&\n          !this._hasPushState &&\n          !atRoot) {\n        this.fragment = this.getFragment(null, true);\n        window.location.replace(this.options.root + \'#\' + this.fragment);\n        // Return immediately as browser will do redirect to new url\n        return true;\n\n      // Or if we\'ve started out with a hash-based route, but we\'re currently\n      // in a browser where it could be `pushState`-based instead...\n      } else if (this._wantsPushState &&\n                 this._hasPushState &&\n                 atRoot &&\n                 loc.hash) {\n        this.fragment = this.getHash().replace(routeStripper, \'\');\n        window.history.replaceState({}, document.title,\n            loc.protocol + \'//\' + loc.host + this.options.root + this.fragment);\n      }\n\n      if (!this.options.silent) {\n        return this.loadUrl();\n      }\n    },\n\n    // Disable Parse.history, perhaps temporarily. Not useful in a real app,\n    // but possibly useful for unit testing Routers.\n    stop: function() {\n      Parse.$(window).unbind(\'popstate\', this.checkUrl)\n                     .unbind(\'hashchange\', this.checkUrl);\n      window.clearInterval(this._checkUrlInterval);\n      Parse.History.started = false;\n    },\n\n    // Add a route to be tested when the fragment changes. Routes added later\n    // may override previous routes.\n    route: function(route, callback) {\n      this.handlers.unshift({route: route, callback: callback});\n    },\n\n    // Checks the current URL to see if it has changed, and if it has,\n    // calls `loadUrl`, normalizing across the hidden iframe.\n    checkUrl: function(e) {\n      var current = this.getFragment();\n      if (current === this.fragment && this.iframe) {\n        current = this.getFragment(this.getHash(this.iframe));\n      }\n      if (current === this.fragment) {\n        return false;\n      }\n      if (this.iframe) {\n        this.navigate(current);\n      }\n      if (!this.loadUrl()) {\n        this.loadUrl(this.getHash());\n      }\n    },\n\n    // Attempt to load the current URL fragment. If a route succeeds with a\n    // match, returns `true`. If no defined routes matches the fragment,\n    // returns `false`.\n    loadUrl: function(fragmentOverride) {\n      var fragment = this.fragment = this.getFragment(fragmentOverride);\n      var matched = _.any(this.handlers, function(handler) {\n        if (handler.route.test(fragment)) {\n          handler.callback(fragment);\n          return true;\n        }\n      });\n      return matched;\n    },\n\n    // Save a fragment into the hash history, or replace the URL state if the\n    // \'replace\' option is passed. You are responsible for properly URL-encoding\n    // the fragment in advance.\n    //\n    // The options object can contain `trigger: true` if you wish to have the\n    // route callback be fired (not usually desirable), or `replace: true`, if\n    // you wish to modify the current URL without adding an entry to the\n    // history.\n    navigate: function(fragment, options) {\n      if (!Parse.History.started) {\n        return false;\n      }\n      if (!options || options === true) {\n        options = {trigger: options};\n      }\n      var frag = (fragment || \'\').replace(routeStripper, \'\');\n      if (this.fragment === frag) {\n        return;\n      }\n\n      // If pushState is available, we use it to set the fragment as a real URL.\n      if (this._hasPushState) {\n        if (frag.indexOf(this.options.root) !== 0) {\n          frag = this.options.root + frag;\n        }\n        this.fragment = frag;\n        var replaceOrPush = options.replace ? \'replaceState\' : \'pushState\';\n        window.history[replaceOrPush]({}, document.title, frag);\n\n      // If hash changes haven\'t been explicitly disabled, update the hash\n      // fragment to store history.\n      } else if (this._wantsHashChange) {\n        this.fragment = frag;\n        this._updateHash(window.location, frag, options.replace);\n        if (this.iframe &&\n            (frag !== this.getFragment(this.getHash(this.iframe)))) {\n          // Opening and closing the iframe tricks IE7 and earlier\n          // to push a history entry on hash-tag change.\n          // When replace is true, we don\'t want this.\n          if (!options.replace) {\n            this.iframe.document.open().close();\n          }\n          this._updateHash(this.iframe.location, frag, options.replace);\n        }\n\n      // If you\'ve told us that you explicitly don\'t want fallback hashchange-\n      // based history, then `navigate` becomes a page refresh.\n      } else {\n        window.location.assign(this.options.root + fragment);\n      }\n      if (options.trigger) {\n        this.loadUrl(fragment);\n      }\n    },\n\n    // Update the hash location, either replacing the current entry, or adding\n    // a new one to the browser history.\n    _updateHash: function(location, fragment, replace) {\n      if (replace) {\n        var s = location.toString().replace(/(javascript:|#).*$/, \'\');\n        location.replace(s + \'#\' + fragment);\n      } else {\n        location.hash = fragment;\n      }\n    }\n  });\n}(this));\n\n/*global _: false*/\n(function(root) {\n  root.Parse = root.Parse || {};\n  var Parse = root.Parse;\n  var _ = Parse._;\n\n  /**\n   * Routers map faux-URLs to actions, and fire events when routes are\n   * matched. Creating a new one sets its `routes` hash, if not set statically.\n   * @class\n   *\n   * <p>A fork of Backbone.Router, provided for your convenience.\n   * For more information, see the\n   * <a href="http://documentcloud.github.com/backbone/#Router">Backbone\n   * documentation</a>.</p>\n   * <p><strong><em>Available in the client SDK only.</em></strong></p>\n   */\n  Parse.Router = function(options) {\n    options = options || {};\n    if (options.routes) {\n      this.routes = options.routes;\n    }\n    this._bindRoutes();\n    this.initialize.apply(this, arguments);\n  };\n\n  // Cached regular expressions for matching named param parts and splatted\n  // parts of route strings.\n  var namedParam    = /:\\w+/g;\n  var splatParam    = /\\*\\w+/g;\n  var escapeRegExp  = /[\\-\\[\\]{}()+?.,\\\\\\^\\$\\|#\\s]/g;\n\n  // Set up all inheritable **Parse.Router** properties and methods.\n  _.extend(Parse.Router.prototype, Parse.Events,\n           /** @lends Parse.Router.prototype */ {\n\n    /**\n     * Initialize is an empty function by default. Override it with your own\n     * initialization logic.\n     */\n    initialize: function(){},\n\n    /**\n     * Manually bind a single named route to a callback. For example:\n     *\n     * <pre>this.route(\'search/:query/p:num\', \'search\', function(query, num) {\n     *       ...\n     *     });</pre>\n     */\n    route: function(route, name, callback) {\n      Parse.history = Parse.history || new Parse.History();\n      if (!_.isRegExp(route)) {\n        route = this._routeToRegExp(route);\n      }\n      if (!callback) {\n        callback = this[name];\n      }\n      Parse.history.route(route, _.bind(function(fragment) {\n        var args = this._extractParameters(route, fragment);\n        if (callback) {\n          callback.apply(this, args);\n        }\n        this.trigger.apply(this, [\'route:\' + name].concat(args));\n        Parse.history.trigger(\'route\', this, name, args);\n      }, this));\n      return this;\n    },\n\n    /**\n     * Whenever you reach a point in your application that you\'d\n     * like to save as a URL, call navigate in order to update the\n     * URL. If you wish to also call the route function, set the\n     * trigger option to true. To update the URL without creating\n     * an entry in the browser\'s history, set the replace option\n     * to true.\n     */\n    navigate: function(fragment, options) {\n      Parse.history.navigate(fragment, options);\n    },\n\n    // Bind all defined routes to `Parse.history`. We have to reverse the\n    // order of the routes here to support behavior where the most general\n    // routes can be defined at the bottom of the route map.\n    _bindRoutes: function() {\n      if (!this.routes) {\n        return;\n      }\n      var routes = [];\n      for (var route in this.routes) {\n        if (this.routes.hasOwnProperty(route)) {\n          routes.unshift([route, this.routes[route]]);\n        }\n      }\n      for (var i = 0, l = routes.length; i < l; i++) {\n        this.route(routes[i][0], routes[i][1], this[routes[i][1]]);\n      }\n    },\n\n    // Convert a route string into a regular expression, suitable for matching\n    // against the current location hash.\n    _routeToRegExp: function(route) {\n      route = route.replace(escapeRegExp, \'\\\\$&\')\n                   .replace(namedParam, \'([^\\/]+)\')\n                   .replace(splatParam, \'(.*?)\');\n      return new RegExp(\'^\' + route + \'$\');\n    },\n\n    // Given a route, and a URL fragment that it matches, return the array of\n    // extracted parameters.\n    _extractParameters: function(route, fragment) {\n      return route.exec(fragment).slice(1);\n    }\n  });\n\n  /**\n   * @function\n   * @param {Object} instanceProps Instance properties for the router.\n   * @param {Object} classProps Class properies for the router.\n   * @return {Class} A new subclass of <code>Parse.Router</code>.\n   */\n  Parse.Router.extend = Parse._extend;\n}(this));\n(function(root) {\n  root.Parse = root.Parse || {};\n  var Parse = root.Parse;\n  var _ = Parse._;\n\n  /**\n   * @namespace Contains functions for calling and declaring\n   * <a href="/docs/cloud_code_guide#functions">cloud functions</a>.\n   * <p><strong><em>\n   *   Some functions are only available from Cloud Code.\n   * </em></strong></p>\n   */\n  Parse.Cloud = Parse.Cloud || {};\n\n  _.extend(Parse.Cloud, /** @lends Parse.Cloud */ {\n    /**\n     * Makes a call to a cloud function.\n     * @param {String} name The function name.\n     * @param {Object} data The parameters to send to the cloud function.\n     * @param {Object} options A Backbone-style options object\n     * options.success, if set, should be a function to handle a successful\n     * call to a cloud function.  options.error should be a function that\n     * handles an error running the cloud function.  Both functions are\n     * optional.  Both functions take a single argument.\n     * @return {Parse.Promise} A promise that will be resolved with the result\n     * of the function.\n     */\n    run: function(name, data, options) {\n      options = options || {};\n\n      var request = Parse._request({\n        route: "functions",\n        className: name,\n        method: \'POST\',\n        useMasterKey: options.useMasterKey,\n        data: Parse._encode(data, null, true)\n      });\n\n      return request.then(function(resp) {\n        return Parse._decode(null, resp).result;\n      })._thenRunCallbacks(options);\n    }\n  });\n}(this));\n\n(function(root) {\n  root.Parse = root.Parse || {};\n  var Parse = root.Parse;\n\n  Parse.Installation = Parse.Object.extend("_Installation");\n\n  /**\n   * Contains functions to deal with Push in Parse\n   * @name Parse.Push\n   * @namespace\n   */\n  Parse.Push = Parse.Push || {};\n\n  /**\n   * Sends a push notification.\n   * @param {Object} data -  The data of the push notification.  Valid fields\n   * are:\n   *   <ol>\n   *     <li>channels - An Array of channels to push to.</li>\n   *     <li>push_time - A Date object for when to send the push.</li>\n   *     <li>expiration_time -  A Date object for when to expire\n   *         the push.</li>\n   *     <li>expiration_interval - The seconds from now to expire the push.</li>\n   *     <li>where - A Parse.Query over Parse.Installation that is used to match\n   *         a set of installations to push to.</li>\n   *     <li>data - The data to send as part of the push</li>\n   *   <ol>\n   * @param {Object} options An object that has an optional success function,\n   * that takes no arguments and will be called on a successful push, and\n   * an error function that takes a Parse.Error and will be called if the push\n   * failed.\n   */\n  Parse.Push.send = function(data, options) {\n    options = options || {};\n\n    if (data.where) {\n      data.where = data.where.toJSON().where;\n    }\n\n    if (data.push_time) {\n      data.push_time = data.push_time.toJSON();\n    }\n\n    if (data.expiration_time) {\n      data.expiration_time = data.expiration_time.toJSON();\n    }\n\n    if (data.expiration_time && data.expiration_interval) {\n      throw "Both expiration_time and expiration_interval can\'t be set";\n    }\n\n    var request = Parse._request({\n      route: \'push\',\n      method: \'POST\',\n      data: data,\n      useMasterKey: options.useMasterKey\n    });\n    return request._thenRunCallbacks(options);\n  };\n}(this));\n'
},function(e,n,t){t(8)(t(39))},function(e,n,t){t(8)(t(40))},function(e,n,t){t(8)(t(41))},function(e,n,t){t(8)(t(42))},function(e,n,t){t(8)(t(43))}]);
/*
//@ sourceMappingURL=bundle-1e5a23625277e12e4e1d.js.map
*/