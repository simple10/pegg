{"version":3,"file":"bundle-1e5a23625277e12e4e1d.js","sources":["bundle-1e5a23625277e12e4e1d.js","webpack/bootstrap 1e5a23625277e12e4e1d","./src/app.coffee","./bower_components/famous/core/Transform.js","./bower_components/famous/core/Surface.js","./bower_components/famous/core/Modifier.js","./bower_components/famous/core/View.js","./bower_components/famous/core/EventHandler.js","./bower_components/famous/transitions/Transitionable.js","./bower_components/famous/utilities/Utility.js","./~/style-loader/addStyle.js","./bower_components/famous/core/Engine.js","./bower_components/famous/core/Entity.js","./bower_components/famous/core/OptionsManager.js","./bower_components/famous/core/RenderNode.js","./bower_components/famous/modifiers/StateModifier.js","./bower_components/famous/surfaces/ImageSurface.js","./bower_components/famous/transitions/TransitionableTransform.js","./bower_components/famous/utilities/Timer.js","./src/app/models/Question.coffee","./src/app/models/Question.coffee*","./bower_components/famous-polyfills/classList.js","./bower_components/famous-polyfills/functionPrototypeBind.js","./bower_components/famous-polyfills/requestAnimationFrame.js","./bower_components/famous/core/Context.js","./bower_components/famous/core/ElementAllocator.js","./bower_components/famous/core/EventEmitter.js","./bower_components/famous/core/SpecParser.js","./bower_components/famous/transitions/Easing.js","./bower_components/famous/transitions/MultipleTransition.js","./bower_components/famous/transitions/TweenTransition.js","./bower_components/famous/views/HeaderFooterLayout.js","./src/app/collections/Questions.coffee","./src/app/collections/Questions.coffee*","./src/app/views/AppView.coffee","./src/app/views/AppView.coffee*","./src/app/views/CardView.coffee","./src/app/views/CardView.coffee*","./src/app/views/HeaderView.coffee","./src/app/views/HeaderView.coffee*","./src/app/views/MenuView.coffee","./src/app/views/MenuView.coffee*","./src/app/widgets/FpsMeter.coffee","./src/app/widgets/FpsMeter.coffee*","./src/app/widgets/Mascot.coffee","./src/app/widgets/Mascot.coffee*","./src/config.coffee","./src/config/public.coffee","./src/lib/parse.coffee","./bower_components/famous/core/famous.css","./src/css/app.scss ./~/sass-loader?outputStyle=expanded&includePaths[]=./bower_components/","./src/css/card.scss ./~/sass-loader?outputStyle=expanded&includePaths[]=./bower_components/","./src/css/header.scss ./~/sass-loader?outputStyle=expanded&includePaths[]=./bower_components/","./src/css/widgets/fpsmeter.scss ./~/sass-loader?outputStyle=expanded&includePaths[]=./bower_components/","./~/script-loader/addScript.js","./src/lib/parse-1.2.18_fixed-parsedate.js ./~/script-loader","./src/lib/parse-1.2.18_fixed-parsedate.js ./~/script-loader/~/raw-loader","./bower_components/famous/core/famous.css*","./src/css/app.scss","./src/css/card.scss","./src/css/header.scss","./src/css/widgets/fpsmeter.scss"],"names":["modules","__webpack_require__","moduleId","installedModules","exports","module","id","loaded","call","m","c","p","AppView","Engine","FpsMeter","Mascot","mainContext","createContext","setPerspective","add","__WEBPACK_AMD_DEFINE_RESULT__","require","_normSquared","v","length","_norm","Math","sqrt","_sign","n","Transform","precision","identity","multiply4x4","a","b","multiply","thenMove","t","moveThen","t0","t1","t2","translate","x","y","z","undefined","thenScale","s","scale","rotateX","theta","cosTheta","cos","sinTheta","sin","rotateY","rotateZ","rotate","phi","psi","cosPhi","sinPhi","cosPsi","sinPsi","result","rotateAxis","verTheta","xxV","xyV","xzV","yyV","yzV","zzV","xs","ys","zs","aboutOrigin","skew","tan","perspective","focusZ","getTranslate","inverse","c0","c1","c2","c4","c5","c6","c8","c9","c10","detM","invD","transpose","interpret","M","sgn","xNorm","mult","Infinity","Q1","MQ1","x2","sgn2","x2Norm","v2","mult2","Q2","Q","R","remover","atan2","asin","abs","PI","average","M1","M2","specM1","specM2","specAvg","i","build","spec","scaleMatrix","skewMatrix","rotateMatrix","equals","notEquals","normalizeRotation","rotation","slice","inFront","behind","Surface","options","this","properties","content","classList","size","_classesDirty","_stylesDirty","_sizeDirty","_contentDirty","_dirtyClasses","_matrix","_opacity","_origin","_size","eventForwarder","event","emit","type","bind","eventHandler","EventHandler","bindThis","Entity","register","setOptions","_currTarget","_addEventListeners","target","listeners","addEventListener","_removeEventListeners","removeEventListener","_cleanupClasses","remove","_applyStyles","style","_cleanupStyles","_formatCSSTransform","round","devicePixelRatio","_formatCSSOrigin","origin","toFixed","_xyNotEquals","usePrefix","document","body","webkitTransform","window","prototype","elementType","elementClass","on","fn","removeListener","handled","stopPropagation","pipe","unpipe","render","setProperties","getProperties","addClass","className","indexOf","push","removeClass","splice","setClasses","removal","getClassList","setContent","getContent","setSize","classes","_setMatrix","navigator","userAgent","toLowerCase","element","matrix","zIndex","transform","_setOrigin","webkitTransformOrigin","transformOrigin","_setInvisible","opacity","setup","allocator","allocate","Array","display","commit","context","origSize","aaMatrix","width","height","deploy","cleanup","recall","deallocate","Node","hasChildNodes","removeChild","firstChild","appendChild","innerHTML","df","createDocumentFragment","getSize","actual","Modifier","_transformGetter","_opacityGetter","_originGetter","_sizeGetter","_legacyStates","_output","transformFrom","opacityFrom","originFrom","sizeFrom","_update","Transitionable","TransitionableTransform","Function","Object","get","setTransform","transition","callback","set","setOpacity","setOrigin","halt","getTransform","getFinalTransform","getFinal","getOpacity","getOrigin","modify","View","_node","RenderNode","_eventInput","_eventOutput","setInputHandler","setOutputHandler","create","constructor","DEFAULT_OPTIONS","_optionsManager","OptionsManager","getOptions","value","patch","apply","arguments","_add","EventEmitter","downstream","downstreamFn","upstream","upstreamListeners","object","handler","trigger","subscribe","unsubscribe","addListener","downstreamCtx","index","upstreamListener","source","start","currentAction","actionQueue","callbackQueue","state","velocity","_callback","_engineInstance","_currentMethod","_loadNext","shift","method","endValue","transitionMethods","TweenTransition","SUPPORTS_MULTIPLE","MultipleTransition","reset","registerMethod","name","engineClass","unregisterMethod","endState","action","startState","startVelocity","delay","duration","curve","timestamp","getVelocity","isActive","Utility","Direction","X","Y","Z","after","count","counter","loadURL","url","xhr","XMLHttpRequest","onreadystatechange","readyState","responseText","open","send","createDocumentFragmentFromHTML","html","createElement","cssCode","styleElement","styleSheet","cssText","createTextNode","head","getElementsByTagName","loop","runLoop","step","requestAnimationFrame","loopEnabled","handleResize","contexts","frameTime","frameTimeLimit","Context","nextTickQueue","deferQueue","lastTime","Date","now","eventForwarders","containerType","containerClass","fpsCap","optionsManager","MAX_DEFER_FRAME_TIME","currentTime","update","preventDefault","getFPS","setFPSCap","fps","floor","el","Element","Error","registerContext","nextTick","defer","data","entities","entity","unregister","_value","eventOutput","_createEventOutput","manager","myState","k","hasOwnProperty","key","identifier","originalValue","_object","_child","_hasMultipleChildren","_isRenderable","_isModifier","_resultCache","_prevResults","_childResult","_applyCommit","cacheStorage","SpecParser","parse","keys","childNode","commitParams","commitResult","child","prevKeys","children","StateModifier","_transformState","_opacityState","_originState","_sizeState","_modifier","_hasOrigin","_hasSize","ImageSurface","_imageUrl","imageUrl","src","_final","_build","setTranslate","setScale","setRotate","eulerAngles","setSkew","skewAngles","components","setDefaultTransition","setDefault","addTimerFunction","FamousEngine","_event","setTimeout","getTime","setInterval","numTicks","clear","every","initial","debounce","func","wait","timeout","ctx","args","last","performance","Question","__hasProp","__extends","parent","ctor","__super__","_super","defaults","question","mood","Parse","view","classListProp","protoProp","elemCtrProto","HTMLElement","objCtr","strTrim","String","trim","replace","arrIndexOf","item","len","DOMEx","message","code","DOMException","checkTokenAndGetIndex","token","test","ClassList","elem","trimmedClasses","split","_updateClassName","toString","classListProto","classListGetter","contains","toggle","join","defineProperty","classListPropDesc","enumerable","configurable","ex","number","__defineGetter__","self","oThis","TypeError","aArgs","fToBind","fNOP","fBound","concat","webkitRequestAnimationFrame","mozRequestAnimationFrame","oRequestAnimationFrame","msRequestAnimationFrame","_getElementSize","clientWidth","clientHeight","container","_allocator","ElementAllocator","_perspectiveState","_perspective","_nodeContext","_originZeroZero","getAllocator","obj","migrate","contextParameters","webkitPerspective","getPerspective","detachedNodes","nodeCount","oldContainer","DocumentFragment","nodeStore","pop","nodeType","nodeName","getNodeCount","_owner","handlers","owner","_vecInContext","_instance","_parseSpec","parentContext","sizeContext","originAdjust","nextSizeContext","parentSize","Easing","inQuad","outQuad","inOutQuad","inCubic","outCubic","inOutCubic","inQuart","outQuart","inOutQuart","inQuint","outQuint","inOutQuint","inSine","outSine","inOutSine","inExpo","pow","outExpo","inOutExpo","inCirc","outCirc","inOutCirc","inElastic","outElastic","inOutElastic","inBack","outBack","inOutBack","inBounce","outBounce","inOutBounce","_instances","_allCallback","_startTime","_startValue","_updateTime","_endValue","_curve","_duration","_active","_interpolate","_clone","_normalize","defaultTransition","speed","getCurve","_calculateVelocity","current","eps","_calculateState","end","Curves","linear","easeIn","easeOut","easeInOut","easeOutBounce","spring","registeredCurves","registerCurve","curveName","unregisterCurve","getCurves","startValue","variance","_startVelocity","timeSinceStart","customCurve","v1","HeaderFooterLayout","_entityId","header","footer","_resolveNodeSize","node","defaultSize","nodeSize","direction","_outputTransform","offset","DIRECTION_X","_finalSize","directionSize","DIRECTION_Y","headerSize","footerSize","defaultHeaderSize","defaultFooterSize","contentSize","Questions","model","Collection","CardView","HeaderView","MenuView","__bind","me","toggleMenu","page","initHeader","initMenu","initContent","menu","menuOpen","menuPosition","modifier","closeMenu","openMenu","_this","StateModifer","flip","init","depth","borderRadius","mainNode","addSurface","params","surface","side","currentSide","initEvents","title","cssPrefix","background","logo","Timer","toggleState","tick","initTime","currTime","filterStrength","updateFrequency","perf","perfNow","webkitNow","thisFrameTime","stop","interval","stateModifier","fadeOut","public","appId","jsKey","facebook","gatekeeper","server","upload","s3bucket","aviary","apiKey","Config","initialize","execScript","eval"],"mappings":"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","sourcesContent":["/******/ (function(modules) { // webpackBootstrap\n/******/ \t\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/ \t\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/ \t\t\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/ \t\t\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/ \t\t\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/ \t\n/******/ \t\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/ \t\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/ \t\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"dist/\";\n/******/ \t\n/******/ \t\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar AppView, Engine, FpsMeter, Mascot, mainContext;\n\t\n\t__webpack_require__(48);\n\t\n\t__webpack_require__(47);\n\t\n\t__webpack_require__(19);\n\t\n\t__webpack_require__(18);\n\t\n\t__webpack_require__(20);\n\t\n\tEngine = __webpack_require__(9);\n\t\n\tAppView = __webpack_require__(30);\n\t\n\tFpsMeter = __webpack_require__(34);\n\t\n\tMascot = __webpack_require__(35);\n\t\n\tmainContext = Engine.createContext();\n\t\n\tmainContext.setPerspective(2000);\n\t\n\tmainContext.add(new AppView);\n\t\n\tmainContext.add(new FpsMeter);\n\n\n/***/ },\n/* 1 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_RESULT__;/* This Source Code Form is subject to the terms of the Mozilla Public\n\t * License, v. 2.0. If a copy of the MPL was not distributed with this\n\t * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n\t *\n\t * Owner: mark@famo.us\n\t * @license MPL 2.0\n\t * @copyright Famous Industries, Inc. 2014\n\t */\n\t\n\t!(__WEBPACK_AMD_DEFINE_RESULT__ = (function(require, exports, module) {\n\t\n\t    /**\n\t     *  A high-performance static matrix math library used to calculate\n\t     *    affine transforms on surfaces and other renderables.\n\t     *    Famo.us uses 4x4 matrices corresponding directly to\n\t     *    WebKit matrices (column-major order).\n\t     *\n\t     *    The internal \"type\" of a Matrix is a 16-long float array in\n\t     *    row-major order, with:\n\t     *    elements [0],[1],[2],[4],[5],[6],[8],[9],[10] forming the 3x3\n\t     *          transformation matrix;\n\t     *    elements [12], [13], [14] corresponding to the t_x, t_y, t_z\n\t     *           translation;\n\t     *    elements [3], [7], [11] set to 0;\n\t     *    element [15] set to 1.\n\t     *    All methods are static.\n\t     *\n\t     * @static\n\t     *\n\t     * @class Transform\n\t     */\n\t    var Transform = {};\n\t\n\t    // WARNING: these matrices correspond to WebKit matrices, which are\n\t    //    transposed from their math counterparts\n\t    Transform.precision = 1e-6;\n\t    Transform.identity = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];\n\t\n\t    /**\n\t     * Multiply two or more Transform matrix types to return a Transform matrix.\n\t     *\n\t     * @method multiply4x4\n\t     * @static\n\t     * @param {Transform} a left matrix\n\t     * @param {Transform} b right matrix\n\t     * @return {Transform} the resulting matrix\n\t     */\n\t    Transform.multiply4x4 = function multiply4x4(a, b) {\n\t        return [\n\t            a[0] * b[0] + a[4] * b[1] + a[8] * b[2] + a[12] * b[3],\n\t            a[1] * b[0] + a[5] * b[1] + a[9] * b[2] + a[13] * b[3],\n\t            a[2] * b[0] + a[6] * b[1] + a[10] * b[2] + a[14] * b[3],\n\t            a[3] * b[0] + a[7] * b[1] + a[11] * b[2] + a[15] * b[3],\n\t            a[0] * b[4] + a[4] * b[5] + a[8] * b[6] + a[12] * b[7],\n\t            a[1] * b[4] + a[5] * b[5] + a[9] * b[6] + a[13] * b[7],\n\t            a[2] * b[4] + a[6] * b[5] + a[10] * b[6] + a[14] * b[7],\n\t            a[3] * b[4] + a[7] * b[5] + a[11] * b[6] + a[15] * b[7],\n\t            a[0] * b[8] + a[4] * b[9] + a[8] * b[10] + a[12] * b[11],\n\t            a[1] * b[8] + a[5] * b[9] + a[9] * b[10] + a[13] * b[11],\n\t            a[2] * b[8] + a[6] * b[9] + a[10] * b[10] + a[14] * b[11],\n\t            a[3] * b[8] + a[7] * b[9] + a[11] * b[10] + a[15] * b[11],\n\t            a[0] * b[12] + a[4] * b[13] + a[8] * b[14] + a[12] * b[15],\n\t            a[1] * b[12] + a[5] * b[13] + a[9] * b[14] + a[13] * b[15],\n\t            a[2] * b[12] + a[6] * b[13] + a[10] * b[14] + a[14] * b[15],\n\t            a[3] * b[12] + a[7] * b[13] + a[11] * b[14] + a[15] * b[15]\n\t        ];\n\t    };\n\t\n\t    /**\n\t     * Fast-multiply two or more Transform matrix types to return a\n\t     *    Matrix, assuming bottom row on each is [0 0 0 1].\n\t     *\n\t     * @method multiply\n\t     * @static\n\t     * @param {Transform} a left matrix\n\t     * @param {Transform} b right matrix\n\t     * @return {Transform} the resulting matrix\n\t     */\n\t    Transform.multiply = function multiply(a, b) {\n\t        return [\n\t            a[0] * b[0] + a[4] * b[1] + a[8] * b[2],\n\t            a[1] * b[0] + a[5] * b[1] + a[9] * b[2],\n\t            a[2] * b[0] + a[6] * b[1] + a[10] * b[2],\n\t            0,\n\t            a[0] * b[4] + a[4] * b[5] + a[8] * b[6],\n\t            a[1] * b[4] + a[5] * b[5] + a[9] * b[6],\n\t            a[2] * b[4] + a[6] * b[5] + a[10] * b[6],\n\t            0,\n\t            a[0] * b[8] + a[4] * b[9] + a[8] * b[10],\n\t            a[1] * b[8] + a[5] * b[9] + a[9] * b[10],\n\t            a[2] * b[8] + a[6] * b[9] + a[10] * b[10],\n\t            0,\n\t            a[0] * b[12] + a[4] * b[13] + a[8] * b[14] + a[12],\n\t            a[1] * b[12] + a[5] * b[13] + a[9] * b[14] + a[13],\n\t            a[2] * b[12] + a[6] * b[13] + a[10] * b[14] + a[14],\n\t            1\n\t        ];\n\t    };\n\t\n\t    /**\n\t     * Return a Transform translated by additional amounts in each\n\t     *    dimension. This is equivalent to the result of\n\t     *\n\t     *    Matrix.multiply(Matrix.translate(t[0], t[1], t[2]), m).\n\t     *\n\t     * @method thenMove\n\t     * @static\n\t     * @param {Transform} m a matrix\n\t     * @param {Array.Number} t floats delta vector of length 2 or 3\n\t     * @return {Transform} the resulting translated matrix\n\t     */\n\t    Transform.thenMove = function thenMove(m, t) {\n\t        if (!t[2]) t[2] = 0;\n\t        return [m[0], m[1], m[2], 0, m[4], m[5], m[6], 0, m[8], m[9], m[10], 0, m[12] + t[0], m[13] + t[1], m[14] + t[2], 1];\n\t    };\n\t\n\t    /**\n\t     * Return a Transform atrix which represents the result of a transform matrix\n\t     *    applied after a move. This is faster than the equivalent multiply.\n\t     *    This is equivalent to the result of:\n\t     *\n\t     *    Transform.multiply(m, Transform.translate(t[0], t[1], t[2])).\n\t     *\n\t     * @method moveThen\n\t     * @static\n\t     * @param {Array.Number} v vector representing initial movement\n\t     * @param {Transform} m matrix to apply afterwards\n\t     * @return {Transform} the resulting matrix\n\t     */\n\t    Transform.moveThen = function moveThen(v, m) {\n\t        if (!v[2]) v[2] = 0;\n\t        var t0 = v[0] * m[0] + v[1] * m[4] + v[2] * m[8];\n\t        var t1 = v[0] * m[1] + v[1] * m[5] + v[2] * m[9];\n\t        var t2 = v[0] * m[2] + v[1] * m[6] + v[2] * m[10];\n\t        return Transform.thenMove(m, [t0, t1, t2]);\n\t    };\n\t\n\t    /**\n\t     * Return a Transform which represents a translation by specified\n\t     *    amounts in each dimension.\n\t     *\n\t     * @method translate\n\t     * @static\n\t     * @param {Number} x x translation\n\t     * @param {Number} y y translation\n\t     * @param {Number} z z translation\n\t     * @return {Transform} the resulting matrix\n\t     */\n\t    Transform.translate = function translate(x, y, z) {\n\t        if (z === undefined) z = 0;\n\t        return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, x, y, z, 1];\n\t    };\n\t\n\t    /**\n\t     * Return a Transform scaled by a vector in each\n\t     *    dimension. This is a more performant equivalent to the result of\n\t     *\n\t     *    Transform.multiply(Transform.scale(s[0], s[1], s[2]), m).\n\t     *\n\t     * @method thenScale\n\t     * @static\n\t     * @param {Transform} m a matrix\n\t     * @param {Array.Number} s delta vector (array of floats &&\n\t     *    array.length == 3)\n\t     * @return {Transform} the resulting translated matrix\n\t     */\n\t    Transform.thenScale = function thenScale(m, s) {\n\t        return [\n\t            s[0] * m[0], s[1] * m[1], s[2] * m[2], 0,\n\t            s[0] * m[4], s[1] * m[5], s[2] * m[6], 0,\n\t            s[0] * m[8], s[1] * m[9], s[2] * m[10], 0,\n\t            s[0] * m[12], s[1] * m[13], s[2] * m[14], 1\n\t        ];\n\t    };\n\t\n\t    /**\n\t     * Return a Transform which represents a scale by specified amounts\n\t     *    in each dimension.\n\t     *\n\t     * @method scale\n\t     * @static\n\t     * @param {Number} x x scale factor\n\t     * @param {Number} y y scale factor\n\t     * @param {Number} z z scale factor\n\t     * @return {Transform} the resulting matrix\n\t     */\n\t    Transform.scale = function scale(x, y, z) {\n\t        if (z === undefined) z = 1;\n\t        return [x, 0, 0, 0, 0, y, 0, 0, 0, 0, z, 0, 0, 0, 0, 1];\n\t    };\n\t\n\t    /**\n\t     * Return a Transform which represents a clockwise\n\t     *    rotation around the x axis.\n\t     *\n\t     * @method rotateX\n\t     * @static\n\t     * @param {Number} theta radians\n\t     * @return {Transform} the resulting matrix\n\t     */\n\t    Transform.rotateX = function rotateX(theta) {\n\t        var cosTheta = Math.cos(theta);\n\t        var sinTheta = Math.sin(theta);\n\t        return [1, 0, 0, 0, 0, cosTheta, sinTheta, 0, 0, -sinTheta, cosTheta, 0, 0, 0, 0, 1];\n\t    };\n\t\n\t    /**\n\t     * Return a Transform which represents a clockwise\n\t     *    rotation around the y axis.\n\t     *\n\t     * @method rotateY\n\t     * @static\n\t     * @param {Number} theta radians\n\t     * @return {Transform} the resulting matrix\n\t     */\n\t    Transform.rotateY = function rotateY(theta) {\n\t        var cosTheta = Math.cos(theta);\n\t        var sinTheta = Math.sin(theta);\n\t        return [cosTheta, 0, -sinTheta, 0, 0, 1, 0, 0, sinTheta, 0, cosTheta, 0, 0, 0, 0, 1];\n\t    };\n\t\n\t    /**\n\t     * Return a Transform which represents a clockwise\n\t     *    rotation around the z axis.\n\t     *\n\t     * @method rotateZ\n\t     * @static\n\t     * @param {Number} theta radians\n\t     * @return {Transform} the resulting matrix\n\t     */\n\t    Transform.rotateZ = function rotateZ(theta) {\n\t        var cosTheta = Math.cos(theta);\n\t        var sinTheta = Math.sin(theta);\n\t        return [cosTheta, sinTheta, 0, 0, -sinTheta, cosTheta, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];\n\t    };\n\t\n\t    /**\n\t     * Return a Transform which represents composed clockwise\n\t     *    rotations along each of the axes. Equivalent to the result of\n\t     *    Matrix.multiply(rotateX(phi), rotateY(theta), rotateZ(psi)).\n\t     *\n\t     * @method rotate\n\t     * @static\n\t     * @param {Number} phi radians to rotate about the positive x axis\n\t     * @param {Number} theta radians to rotate about the positive y axis\n\t     * @param {Number} psi radians to rotate about the positive z axis\n\t     * @return {Transform} the resulting matrix\n\t     */\n\t    Transform.rotate = function rotate(phi, theta, psi) {\n\t        var cosPhi = Math.cos(phi);\n\t        var sinPhi = Math.sin(phi);\n\t        var cosTheta = Math.cos(theta);\n\t        var sinTheta = Math.sin(theta);\n\t        var cosPsi = Math.cos(psi);\n\t        var sinPsi = Math.sin(psi);\n\t        var result = [\n\t            cosTheta * cosPsi,\n\t            cosPhi * sinPsi + sinPhi * sinTheta * cosPsi,\n\t            sinPhi * sinPsi - cosPhi * sinTheta * cosPsi,\n\t            0,\n\t            -cosTheta * sinPsi,\n\t            cosPhi * cosPsi - sinPhi * sinTheta * sinPsi,\n\t            sinPhi * cosPsi + cosPhi * sinTheta * sinPsi,\n\t            0,\n\t            sinTheta,\n\t            -sinPhi * cosTheta,\n\t            cosPhi * cosTheta,\n\t            0,\n\t            0, 0, 0, 1\n\t        ];\n\t        return result;\n\t    };\n\t\n\t    /**\n\t     * Return a Transform which represents an axis-angle rotation\n\t     *\n\t     * @method rotateAxis\n\t     * @static\n\t     * @param {Array.Number} v unit vector representing the axis to rotate about\n\t     * @param {Number} theta radians to rotate clockwise about the axis\n\t     * @return {Transform} the resulting matrix\n\t     */\n\t    Transform.rotateAxis = function rotateAxis(v, theta) {\n\t        var sinTheta = Math.sin(theta);\n\t        var cosTheta = Math.cos(theta);\n\t        var verTheta = 1 - cosTheta; // versine of theta\n\t\n\t        var xxV = v[0] * v[0] * verTheta;\n\t        var xyV = v[0] * v[1] * verTheta;\n\t        var xzV = v[0] * v[2] * verTheta;\n\t        var yyV = v[1] * v[1] * verTheta;\n\t        var yzV = v[1] * v[2] * verTheta;\n\t        var zzV = v[2] * v[2] * verTheta;\n\t        var xs = v[0] * sinTheta;\n\t        var ys = v[1] * sinTheta;\n\t        var zs = v[2] * sinTheta;\n\t\n\t        var result = [\n\t            xxV + cosTheta, xyV + zs, xzV - ys, 0,\n\t            xyV - zs, yyV + cosTheta, yzV + xs, 0,\n\t            xzV + ys, yzV - xs, zzV + cosTheta, 0,\n\t            0, 0, 0, 1\n\t        ];\n\t        return result;\n\t    };\n\t\n\t    /**\n\t     * Return a Transform which represents a transform matrix applied about\n\t     * a separate origin point.\n\t     *\n\t     * @method aboutOrigin\n\t     * @static\n\t     * @param {Array.Number} v origin point to apply matrix\n\t     * @param {Transform} m matrix to apply\n\t     * @return {Transform} the resulting matrix\n\t     */\n\t    Transform.aboutOrigin = function aboutOrigin(v, m) {\n\t        var t0 = v[0] - (v[0] * m[0] + v[1] * m[4] + v[2] * m[8]);\n\t        var t1 = v[1] - (v[0] * m[1] + v[1] * m[5] + v[2] * m[9]);\n\t        var t2 = v[2] - (v[0] * m[2] + v[1] * m[6] + v[2] * m[10]);\n\t        return Transform.thenMove(m, [t0, t1, t2]);\n\t    };\n\t\n\t    /**\n\t     * Return a Transform representation of a skew transformation\n\t     *\n\t     * @method skew\n\t     * @static\n\t     * @param {Number} phi scale factor skew in the x axis\n\t     * @param {Number} theta scale factor skew in the y axis\n\t     * @param {Number} psi scale factor skew in the z axis\n\t     * @return {Transform} the resulting matrix\n\t     */\n\t    Transform.skew = function skew(phi, theta, psi) {\n\t        return [1, 0, 0, 0, Math.tan(psi), 1, 0, 0, Math.tan(theta), Math.tan(phi), 1, 0, 0, 0, 0, 1];\n\t    };\n\t\n\t    /**\n\t     * Returns a perspective Transform matrix\n\t     *\n\t     * @method perspective\n\t     * @static\n\t     * @param {Number} focusZ z position of focal point\n\t     * @return {Transform} the resulting matrix\n\t     */\n\t    Transform.perspective = function perspective(focusZ) {\n\t        return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, -1 / focusZ, 0, 0, 0, 1];\n\t    };\n\t\n\t    /**\n\t     * Return translation vector component of given Transform\n\t     *\n\t     * @method getTranslate\n\t     * @static\n\t     * @param {Transform} m matrix\n\t     * @return {Array.Number} the translation vector [t_x, t_y, t_z]\n\t     */\n\t    Transform.getTranslate = function getTranslate(m) {\n\t        return [m[12], m[13], m[14]];\n\t    };\n\t\n\t    /**\n\t     * Return inverse affine matrix for given Transform.\n\t     *   Note: This assumes m[3] = m[7] = m[11] = 0, and m[15] = 1.\n\t     *   Will provide incorrect results if not invertible or preconditions not met.\n\t     *\n\t     * @method inverse\n\t     * @static\n\t     * @param {Transform} m matrix\n\t     * @return {Transform} the resulting inverted matrix\n\t     */\n\t    Transform.inverse = function inverse(m) {\n\t        // only need to consider 3x3 section for affine\n\t        var c0 = m[5] * m[10] - m[6] * m[9];\n\t        var c1 = m[4] * m[10] - m[6] * m[8];\n\t        var c2 = m[4] * m[9] - m[5] * m[8];\n\t        var c4 = m[1] * m[10] - m[2] * m[9];\n\t        var c5 = m[0] * m[10] - m[2] * m[8];\n\t        var c6 = m[0] * m[9] - m[1] * m[8];\n\t        var c8 = m[1] * m[6] - m[2] * m[5];\n\t        var c9 = m[0] * m[6] - m[2] * m[4];\n\t        var c10 = m[0] * m[5] - m[1] * m[4];\n\t        var detM = m[0] * c0 - m[1] * c1 + m[2] * c2;\n\t        var invD = 1 / detM;\n\t        var result = [\n\t            invD * c0, -invD * c4, invD * c8, 0,\n\t            -invD * c1, invD * c5, -invD * c9, 0,\n\t            invD * c2, -invD * c6, invD * c10, 0,\n\t            0, 0, 0, 1\n\t        ];\n\t        result[12] = -m[12] * result[0] - m[13] * result[4] - m[14] * result[8];\n\t        result[13] = -m[12] * result[1] - m[13] * result[5] - m[14] * result[9];\n\t        result[14] = -m[12] * result[2] - m[13] * result[6] - m[14] * result[10];\n\t        return result;\n\t    };\n\t\n\t    /**\n\t     * Returns the transpose of a 4x4 matrix\n\t     *\n\t     * @method transpose\n\t     * @static\n\t     * @param {Transform} m matrix\n\t     * @return {Transform} the resulting transposed matrix\n\t     */\n\t    Transform.transpose = function transpose(m) {\n\t        return [m[0], m[4], m[8], m[12], m[1], m[5], m[9], m[13], m[2], m[6], m[10], m[14], m[3], m[7], m[11], m[15]];\n\t    };\n\t\n\t    function _normSquared(v) {\n\t        return (v.length === 2) ? v[0] * v[0] + v[1] * v[1] : v[0] * v[0] + v[1] * v[1] + v[2] * v[2];\n\t    }\n\t    function _norm(v) {\n\t        return Math.sqrt(_normSquared(v));\n\t    }\n\t    function _sign(n) {\n\t        return (n < 0) ? -1 : 1;\n\t    }\n\t\n\t    /**\n\t     * Decompose Transform into separate .translate, .rotate, .scale,\n\t     *    and .skew components.\n\t     *\n\t     * @method interpret\n\t     * @static\n\t     * @param {Transform} M tranform matrix\n\t     * @return {Object} matrix spec object with component matrices .translate,\n\t     *    .rotate, .scale, .skew\n\t     */\n\t    Transform.interpret = function interpret(M) {\n\t\n\t        // QR decomposition via Householder reflections\n\t        //FIRST ITERATION\n\t\n\t        //default Q1 to the identity matrix;\n\t        var x = [M[0], M[1], M[2]];                // first column vector\n\t        var sgn = _sign(x[0]);                     // sign of first component of x (for stability)\n\t        var xNorm = _norm(x);                      // norm of first column vector\n\t        var v = [x[0] + sgn * xNorm, x[1], x[2]];  // v = x + sign(x[0])|x|e1\n\t        var mult = 2 / _normSquared(v);            // mult = 2/v'v\n\t\n\t        //bail out if our Matrix is singular\n\t        if (mult >= Infinity) {\n\t            return {translate: Transform.getTranslate(M), rotate: [0, 0, 0], scale: [0, 0, 0], skew: [0, 0, 0]};\n\t        }\n\t\n\t        //evaluate Q1 = I - 2vv'/v'v\n\t        var Q1 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1];\n\t\n\t        //diagonals\n\t        Q1[0]  = 1 - mult * v[0] * v[0];    // 0,0 entry\n\t        Q1[5]  = 1 - mult * v[1] * v[1];    // 1,1 entry\n\t        Q1[10] = 1 - mult * v[2] * v[2];    // 2,2 entry\n\t\n\t        //upper diagonal\n\t        Q1[1] = -mult * v[0] * v[1];        // 0,1 entry\n\t        Q1[2] = -mult * v[0] * v[2];        // 0,2 entry\n\t        Q1[6] = -mult * v[1] * v[2];        // 1,2 entry\n\t\n\t        //lower diagonal\n\t        Q1[4] = Q1[1];                      // 1,0 entry\n\t        Q1[8] = Q1[2];                      // 2,0 entry\n\t        Q1[9] = Q1[6];                      // 2,1 entry\n\t\n\t        //reduce first column of M\n\t        var MQ1 = Transform.multiply(Q1, M);\n\t\n\t        //SECOND ITERATION on (1,1) minor\n\t        var x2 = [MQ1[5], MQ1[6]];\n\t        var sgn2 = _sign(x2[0]);                    // sign of first component of x (for stability)\n\t        var x2Norm = _norm(x2);                     // norm of first column vector\n\t        var v2 = [x2[0] + sgn2 * x2Norm, x2[1]];    // v = x + sign(x[0])|x|e1\n\t        var mult2 = 2 / _normSquared(v2);           // mult = 2/v'v\n\t\n\t        //evaluate Q2 = I - 2vv'/v'v\n\t        var Q2 = [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1];\n\t\n\t        //diagonal\n\t        Q2[5]  = 1 - mult2 * v2[0] * v2[0]; // 1,1 entry\n\t        Q2[10] = 1 - mult2 * v2[1] * v2[1]; // 2,2 entry\n\t\n\t        //off diagonals\n\t        Q2[6] = -mult2 * v2[0] * v2[1];     // 2,1 entry\n\t        Q2[9] = Q2[6];                      // 1,2 entry\n\t\n\t        //calc QR decomposition. Q = Q1*Q2, R = Q'*M\n\t        var Q = Transform.multiply(Q2, Q1);      //note: really Q transpose\n\t        var R = Transform.multiply(Q, M);\n\t\n\t        //remove negative scaling\n\t        var remover = Transform.scale(R[0] < 0 ? -1 : 1, R[5] < 0 ? -1 : 1, R[10] < 0 ? -1 : 1);\n\t        R = Transform.multiply(R, remover);\n\t        Q = Transform.multiply(remover, Q);\n\t\n\t        //decompose into rotate/scale/skew matrices\n\t        var result = {};\n\t        result.translate = Transform.getTranslate(M);\n\t        result.rotate = [Math.atan2(-Q[6], Q[10]), Math.asin(Q[2]), Math.atan2(-Q[1], Q[0])];\n\t        if (!result.rotate[0]) {\n\t            result.rotate[0] = 0;\n\t            result.rotate[2] = Math.atan2(Q[4], Q[5]);\n\t        }\n\t        result.scale = [R[0], R[5], R[10]];\n\t        result.skew = [Math.atan2(R[9], result.scale[2]), Math.atan2(R[8], result.scale[2]), Math.atan2(R[4], result.scale[0])];\n\t\n\t        //double rotation workaround\n\t        if (Math.abs(result.rotate[0]) + Math.abs(result.rotate[2]) > 1.5 * Math.PI) {\n\t            result.rotate[1] = Math.PI - result.rotate[1];\n\t            if (result.rotate[1] > Math.PI) result.rotate[1] -= 2 * Math.PI;\n\t            if (result.rotate[1] < -Math.PI) result.rotate[1] += 2 * Math.PI;\n\t            if (result.rotate[0] < 0) result.rotate[0] += Math.PI;\n\t            else result.rotate[0] -= Math.PI;\n\t            if (result.rotate[2] < 0) result.rotate[2] += Math.PI;\n\t            else result.rotate[2] -= Math.PI;\n\t        }\n\t\n\t        return result;\n\t    };\n\t\n\t    /**\n\t     * Weighted average between two matrices by averaging their\n\t     *     translation, rotation, scale, skew components.\n\t     *     f(M1,M2,t) = (1 - t) * M1 + t * M2\n\t     *\n\t     * @method average\n\t     * @static\n\t     * @param {Transform} M1 f(M1,M2,0) = M1\n\t     * @param {Transform} M2 f(M1,M2,1) = M2\n\t     * @param {Number} t\n\t     * @return {Transform} resulting matrix\n\t     */\n\t    Transform.average = function average(M1, M2, t) {\n\t        t = (t === undefined) ? 0.5 : t;\n\t        var specM1 = Transform.interpret(M1);\n\t        var specM2 = Transform.interpret(M2);\n\t\n\t        var specAvg = {\n\t            translate: [0, 0, 0],\n\t            rotate: [0, 0, 0],\n\t            scale: [0, 0, 0],\n\t            skew: [0, 0, 0]\n\t        };\n\t\n\t        for (var i = 0; i < 3; i++) {\n\t            specAvg.translate[i] = (1 - t) * specM1.translate[i] + t * specM2.translate[i];\n\t            specAvg.rotate[i] = (1 - t) * specM1.rotate[i] + t * specM2.rotate[i];\n\t            specAvg.scale[i] = (1 - t) * specM1.scale[i] + t * specM2.scale[i];\n\t            specAvg.skew[i] = (1 - t) * specM1.skew[i] + t * specM2.skew[i];\n\t        }\n\t        return Transform.build(specAvg);\n\t    };\n\t\n\t    /**\n\t     * Compose .translate, .rotate, .scale, .skew components into\n\t     * Transform matrix\n\t     *\n\t     * @method build\n\t     * @static\n\t     * @param {matrixSpec} spec object with component matrices .translate,\n\t     *    .rotate, .scale, .skew\n\t     * @return {Transform} composed martix\n\t     */\n\t    Transform.build = function build(spec) {\n\t        var scaleMatrix = Transform.scale(spec.scale[0], spec.scale[1], spec.scale[2]);\n\t        var skewMatrix = Transform.skew(spec.skew[0], spec.skew[1], spec.skew[2]);\n\t        var rotateMatrix = Transform.rotate(spec.rotate[0], spec.rotate[1], spec.rotate[2]);\n\t        return Transform.thenMove(Transform.multiply(Transform.multiply(rotateMatrix, skewMatrix), scaleMatrix), spec.translate);\n\t    };\n\t\n\t    /**\n\t     * Determine if two Transforms are component-wise equal\n\t     *   Warning: breaks on perspective Transforms\n\t     *\n\t     * @method equals\n\t     * @static\n\t     * @param {Transform} a matrix\n\t     * @param {Transform} b matrix\n\t     * @return {boolean}\n\t     */\n\t    Transform.equals = function equals(a, b) {\n\t        return !Transform.notEquals(a, b);\n\t    };\n\t\n\t    /**\n\t     * Determine if two Transforms are component-wise unequal\n\t     *   Warning: breaks on perspective Transforms\n\t     *\n\t     * @method notEquals\n\t     * @static\n\t     * @param {Transform} a matrix\n\t     * @param {Transform} b matrix\n\t     * @return {boolean}\n\t     */\n\t    Transform.notEquals = function notEquals(a, b) {\n\t        if (a === b) return false;\n\t        if (!(a && b)) return true;\n\t\n\t        // shortci\n\t        return !(a && b) ||\n\t            a[12] !== b[12] || a[13] !== b[13] || a[14] !== b[14] ||\n\t            a[0] !== b[0] || a[1] !== b[1] || a[2] !== b[2] ||\n\t            a[4] !== b[4] || a[5] !== b[5] || a[6] !== b[6] ||\n\t            a[8] !== b[8] || a[9] !== b[9] || a[10] !== b[10];\n\t    };\n\t\n\t    /**\n\t     * Constrain angle-trio components to range of [-pi, pi).\n\t     *\n\t     * @method normalizeRotation\n\t     * @static\n\t     * @param {Array.Number} rotation phi, theta, psi (array of floats\n\t     *    && array.length == 3)\n\t     * @return {Array.Number} new phi, theta, psi triplet\n\t     *    (array of floats && array.length == 3)\n\t     */\n\t    Transform.normalizeRotation = function normalizeRotation(rotation) {\n\t        var result = rotation.slice(0);\n\t        if (result[0] === Math.PI * 0.5 || result[0] === -Math.PI * 0.5) {\n\t            result[0] = -result[0];\n\t            result[1] = Math.PI - result[1];\n\t            result[2] -= Math.PI;\n\t        }\n\t        if (result[0] > Math.PI * 0.5) {\n\t            result[0] = result[0] - Math.PI;\n\t            result[1] = Math.PI - result[1];\n\t            result[2] -= Math.PI;\n\t        }\n\t        if (result[0] < -Math.PI * 0.5) {\n\t            result[0] = result[0] + Math.PI;\n\t            result[1] = -Math.PI - result[1];\n\t            result[2] -= Math.PI;\n\t        }\n\t        while (result[1] < -Math.PI) result[1] += 2 * Math.PI;\n\t        while (result[1] >= Math.PI) result[1] -= 2 * Math.PI;\n\t        while (result[2] < -Math.PI) result[2] += 2 * Math.PI;\n\t        while (result[2] >= Math.PI) result[2] -= 2 * Math.PI;\n\t        return result;\n\t    };\n\t\n\t    /**\n\t     * (Property) Array defining a translation forward in z by 1\n\t     *\n\t     * @property {array} inFront\n\t     * @static\n\t     * @final\n\t     */\n\t    Transform.inFront = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1e-3, 1];\n\t\n\t    /**\n\t     * (Property) Array defining a translation backwards in z by 1\n\t     *\n\t     * @property {array} behind\n\t     * @static\n\t     * @final\n\t     */\n\t    Transform.behind = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, -1e-3, 1];\n\t\n\t    module.exports = Transform;\n\t}.call(exports, __webpack_require__, exports, module)), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n\n/***/ },\n/* 2 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_RESULT__;/* This Source Code Form is subject to the terms of the Mozilla Public\n\t * License, v. 2.0. If a copy of the MPL was not distributed with this\n\t * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n\t *\n\t * Owner: mark@famo.us\n\t * @license MPL 2.0\n\t * @copyright Famous Industries, Inc. 2014\n\t */\n\t\n\t!(__WEBPACK_AMD_DEFINE_RESULT__ = (function(require, exports, module) {\n\t    var Entity = __webpack_require__(10);\n\t    var EventHandler = __webpack_require__(5);\n\t    var Transform = __webpack_require__(1);\n\t\n\t    var usePrefix = document.body.style.webkitTransform !== undefined;\n\t    var devicePixelRatio = window.devicePixelRatio || 1;\n\t\n\t    /**\n\t     * A base class for viewable content and event\n\t     *   targets inside a Famo.us application, containing a renderable document\n\t     *   fragment. Like an HTML div, it can accept internal markup,\n\t     *   properties, classes, and handle events.\n\t     *\n\t     * @class Surface\n\t     * @constructor\n\t     *\n\t     * @param {Object} [options] default option overrides\n\t     * @param {Array.Number} [options.size] [width, height] in pixels\n\t     * @param {Array.string} [options.classes] CSS classes to set on inner content\n\t     * @param {Array} [options.properties] string dictionary of HTML attributes to set on target div\n\t     * @param {string} [options.content] inner (HTML) content of surface\n\t     */\n\t    function Surface(options) {\n\t        this.options = {};\n\t\n\t        this.properties = {};\n\t        this.content = '';\n\t        this.classList = [];\n\t        this.size = null;\n\t\n\t        this._classesDirty = true;\n\t        this._stylesDirty = true;\n\t        this._sizeDirty = true;\n\t        this._contentDirty = true;\n\t\n\t        this._dirtyClasses = [];\n\t\n\t        this._matrix = null;\n\t        this._opacity = 1;\n\t        this._origin = null;\n\t        this._size = null;\n\t\n\t        /** @ignore */\n\t        this.eventForwarder = function eventForwarder(event) {\n\t            this.emit(event.type, event);\n\t        }.bind(this);\n\t        this.eventHandler = new EventHandler();\n\t        this.eventHandler.bindThis(this);\n\t\n\t        this.id = Entity.register(this);\n\t\n\t        if (options) this.setOptions(options);\n\t\n\t        this._currTarget = null;\n\t    }\n\t    Surface.prototype.elementType = 'div';\n\t    Surface.prototype.elementClass = 'famous-surface';\n\t\n\t    /**\n\t     * Bind a callback function to an event type handled by this object.\n\t     *\n\t     * @method \"on\"\n\t     *\n\t     * @param {string} type event type key (for example, 'click')\n\t     * @param {function(string, Object)} fn handler callback\n\t     * @return {EventHandler} this\n\t     */\n\t    Surface.prototype.on = function on(type, fn) {\n\t        if (this._currTarget) this._currTarget.addEventListener(type, this.eventForwarder);\n\t        this.eventHandler.on(type, fn);\n\t    };\n\t\n\t    /**\n\t     * Unbind an event by type and handler.\n\t     *   This undoes the work of \"on\"\n\t     *\n\t     * @method removeListener\n\t     * @param {string} type event type key (for example, 'click')\n\t     * @param {function(string, Object)} fn handler\n\t     */\n\t    Surface.prototype.removeListener = function removeListener(type, fn) {\n\t        this.eventHandler.removeListener(type, fn);\n\t    };\n\t\n\t    /**\n\t     * Trigger an event, sending to all downstream handlers\n\t     *   listening for provided 'type' key.\n\t     *\n\t     * @method emit\n\t     *\n\t     * @param {string} type event type key (for example, 'click')\n\t     * @param {Object} [event] event data\n\t     * @return {EventHandler} this\n\t     */\n\t    Surface.prototype.emit = function emit(type, event) {\n\t        if (event && !event.origin) event.origin = this;\n\t        var handled = this.eventHandler.emit(type, event);\n\t        if (handled && event && event.stopPropagation) event.stopPropagation();\n\t        return handled;\n\t    };\n\t\n\t    /**\n\t     * Add event handler object to set of downstream handlers.\n\t     *\n\t     * @method pipe\n\t     *\n\t     * @param {EventHandler} target event handler target object\n\t     * @return {EventHandler} passed event handler\n\t     */\n\t    Surface.prototype.pipe = function pipe(target) {\n\t        return this.eventHandler.pipe(target);\n\t    };\n\t\n\t    /**\n\t     * Remove handler object from set of downstream handlers.\n\t     *   Undoes work of \"pipe\"\n\t     *\n\t     * @method unpipe\n\t     *\n\t     * @param {EventHandler} target target handler object\n\t     * @return {EventHandler} provided target\n\t     */\n\t    Surface.prototype.unpipe = function unpipe(target) {\n\t        return this.eventHandler.unpipe(target);\n\t    };\n\t\n\t    /**\n\t     * Return spec for this surface. Note that for a base surface, this is\n\t     *    simply an id.\n\t     *\n\t     * @method render\n\t     * @private\n\t     * @return {Object} render spec for this surface (spec id)\n\t     */\n\t    Surface.prototype.render = function render() {\n\t        return this.id;\n\t    };\n\t\n\t    /**\n\t     * Set CSS-style properties on this Surface. Note that this will cause\n\t     *    dirtying and thus re-rendering, even if values do not change.\n\t     *\n\t     * @method setProperties\n\t     * @param {Object} properties property dictionary of \"key\" => \"value\"\n\t     */\n\t    Surface.prototype.setProperties = function setProperties(properties) {\n\t        for (var n in properties) {\n\t            this.properties[n] = properties[n];\n\t        }\n\t        this._stylesDirty = true;\n\t    };\n\t\n\t    /**\n\t     * Get CSS-style properties on this Surface.\n\t     *\n\t     * @method getProperties\n\t     *\n\t     * @return {Object} Dictionary of this Surface's properties.\n\t     */\n\t    Surface.prototype.getProperties = function getProperties() {\n\t        return this.properties;\n\t    };\n\t\n\t    /**\n\t     * Add CSS-style class to the list of classes on this Surface. Note\n\t     *   this will map directly to the HTML property of the actual\n\t     *   corresponding rendered <div>.\n\t     *\n\t     * @method addClass\n\t     * @param {string} className name of class to add\n\t     */\n\t    Surface.prototype.addClass = function addClass(className) {\n\t        if (this.classList.indexOf(className) < 0) {\n\t            this.classList.push(className);\n\t            this._classesDirty = true;\n\t        }\n\t    };\n\t\n\t    /**\n\t     * Remove CSS-style class from the list of classes on this Surface.\n\t     *   Note this will map directly to the HTML property of the actual\n\t     *   corresponding rendered <div>.\n\t     *\n\t     * @method removeClass\n\t     * @param {string} className name of class to remove\n\t     */\n\t    Surface.prototype.removeClass = function removeClass(className) {\n\t        var i = this.classList.indexOf(className);\n\t        if (i >= 0) {\n\t            this._dirtyClasses.push(this.classList.splice(i, 1)[0]);\n\t            this._classesDirty = true;\n\t        }\n\t    };\n\t\n\t    /**\n\t     * Reset class list to provided dictionary.\n\t     * @method setClasses\n\t     * @param {Array.string} classList\n\t     */\n\t    Surface.prototype.setClasses = function setClasses(classList) {\n\t        var i = 0;\n\t        var removal = [];\n\t        for (i = 0; i < this.classList.length; i++) {\n\t            if (classList.indexOf(this.classList[i]) < 0) removal.push(this.classList[i]);\n\t        }\n\t        for (i = 0; i < removal.length; i++) this.removeClass(removal[i]);\n\t        // duplicates are already checked by addClass()\n\t        for (i = 0; i < classList.length; i++) this.addClass(classList[i]);\n\t    };\n\t\n\t    /**\n\t     * Get array of CSS-style classes attached to this div.\n\t     *\n\t     * @method getClasslist\n\t     * @return {Array.string} array of class names\n\t     */\n\t    Surface.prototype.getClassList = function getClassList() {\n\t        return this.classList;\n\t    };\n\t\n\t    /**\n\t     * Set or overwrite inner (HTML) content of this surface. Note that this\n\t     *    causes a re-rendering if the content has changed.\n\t     *\n\t     * @method setContent\n\t     * @param {string} content HTML content\n\t     */\n\t    Surface.prototype.setContent = function setContent(content) {\n\t        if (this.content !== content) {\n\t            this.content = content;\n\t            this._contentDirty = true;\n\t        }\n\t    };\n\t\n\t    /**\n\t     * Return inner (HTML) content of this surface.\n\t     *\n\t     * @method getContent\n\t     *\n\t     * @return {string} inner (HTML) content\n\t     */\n\t    Surface.prototype.getContent = function getContent() {\n\t        return this.content;\n\t    };\n\t\n\t    /**\n\t     * Set options for this surface\n\t     *\n\t     * @method setOptions\n\t     * @param {Object} [options] overrides for default options.  See constructor.\n\t     */\n\t    Surface.prototype.setOptions = function setOptions(options) {\n\t        if (options.size) this.setSize(options.size);\n\t        if (options.classes) this.setClasses(options.classes);\n\t        if (options.properties) this.setProperties(options.properties);\n\t        if (options.content) this.setContent(options.content);\n\t    };\n\t\n\t    //  Attach Famous event handling to document events emanating from target\n\t    //    document element.  This occurs just after deployment to the document.\n\t    //    Calling this enables methods like #on and #pipe.\n\t    function _addEventListeners(target) {\n\t        for (var i in this.eventHandler.listeners) {\n\t            target.addEventListener(i, this.eventForwarder);\n\t        }\n\t    }\n\t\n\t    //  Detach Famous event handling from document events emanating from target\n\t    //  document element.  This occurs just before recall from the document.\n\t    function _removeEventListeners(target) {\n\t        for (var i in this.eventHandler.listeners) {\n\t            target.removeEventListener(i, this.eventForwarder);\n\t        }\n\t    }\n\t\n\t     //  Apply to document all changes from removeClass() since last setup().\n\t    function _cleanupClasses(target) {\n\t        for (var i = 0; i < this._dirtyClasses.length; i++) target.classList.remove(this._dirtyClasses[i]);\n\t        this._dirtyClasses = [];\n\t    }\n\t\n\t    // Apply values of all Famous-managed styles to the document element.\n\t    //  These will be deployed to the document on call to #setup().\n\t    function _applyStyles(target) {\n\t        for (var n in this.properties) {\n\t            target.style[n] = this.properties[n];\n\t        }\n\t    }\n\t\n\t    // Clear all Famous-managed styles from the document element.\n\t    // These will be deployed to the document on call to #setup().\n\t    function _cleanupStyles(target) {\n\t        for (var n in this.properties) {\n\t            target.style[n] = '';\n\t        }\n\t    }\n\t\n\t    /**\n\t     * Return a Matrix's webkit css representation to be used with the\n\t     *    CSS3 -webkit-transform style.\n\t     *    Example: -webkit-transform: matrix3d(1,0,0,0,0,1,0,0,0,0,1,0,716,243,0,1)\n\t     *\n\t     * @method _formatCSSTransform\n\t     * @private\n\t     * @param {FamousMatrix} m matrix\n\t     * @return {string} matrix3d CSS style representation of the transform\n\t     */\n\t    function _formatCSSTransform(m) {\n\t        m[12] = Math.round(m[12] * devicePixelRatio) / devicePixelRatio;\n\t        m[13] = Math.round(m[13] * devicePixelRatio) / devicePixelRatio;\n\t\n\t        var result = 'matrix3d(';\n\t        for (var i = 0; i < 15; i++) {\n\t            result += (m[i] < 0.000001 && m[i] > -0.000001) ? '0,' : m[i] + ',';\n\t        }\n\t        result += m[15] + ')';\n\t        return result;\n\t    }\n\t\n\t    /**\n\t     * Directly apply given FamousMatrix to the document element as the\n\t     *   appropriate webkit CSS style.\n\t     *\n\t     * @method setMatrix\n\t     *\n\t     * @static\n\t     * @private\n\t     * @param {Element} element document element\n\t     * @param {FamousMatrix} matrix\n\t     */\n\t\n\t    var _setMatrix;\n\t    if (navigator.userAgent.toLowerCase().indexOf('firefox') > -1) {\n\t        _setMatrix = function(element, matrix) {\n\t            element.style.zIndex = (matrix[14] * 1000000) | 0;    // fix for Firefox z-buffer issues\n\t            element.style.transform = _formatCSSTransform(matrix);\n\t        };\n\t    }\n\t    else if (usePrefix) {\n\t        _setMatrix = function(element, matrix) {\n\t            element.style.webkitTransform = _formatCSSTransform(matrix);\n\t        };\n\t    }\n\t    else {\n\t        _setMatrix = function(element, matrix) {\n\t            element.style.transform = _formatCSSTransform(matrix);\n\t        };\n\t    }\n\t\n\t    // format origin as CSS percentage string\n\t    function _formatCSSOrigin(origin) {\n\t        return (100 * origin[0]).toFixed(6) + '% ' + (100 * origin[1]).toFixed(6) + '%';\n\t    }\n\t\n\t     // Directly apply given origin coordinates to the document element as the\n\t     // appropriate webkit CSS style.\n\t    var _setOrigin = usePrefix ? function(element, origin) {\n\t        element.style.webkitTransformOrigin = _formatCSSOrigin(origin);\n\t    } : function(element, origin) {\n\t        element.style.transformOrigin = _formatCSSOrigin(origin);\n\t    };\n\t\n\t     // Shrink given document element until it is effectively invisible.\n\t    var _setInvisible = usePrefix ? function(element) {\n\t        element.style.webkitTransform = 'scale3d(0.0001,0.0001,1)';\n\t        element.style.opacity = 0;\n\t    } : function(element) {\n\t        element.style.transform = 'scale3d(0.0001,0.0001,1)';\n\t        element.style.opacity = 0;\n\t    };\n\t\n\t    function _xyNotEquals(a, b) {\n\t        return (a && b) ? (a[0] !== b[0] || a[1] !== b[1]) : a !== b;\n\t    }\n\t\n\t    /**\n\t     * One-time setup for an element to be ready for commits to document.\n\t     *\n\t     * @private\n\t     * @method setup\n\t     *\n\t     * @param {ElementAllocator} allocator document element pool for this context\n\t     */\n\t    Surface.prototype.setup = function setup(allocator) {\n\t        var target = allocator.allocate(this.elementType);\n\t        if (this.elementClass) {\n\t            if (this.elementClass instanceof Array) {\n\t                for (var i = 0; i < this.elementClass.length; i++) {\n\t                    target.classList.add(this.elementClass[i]);\n\t                }\n\t            }\n\t            else {\n\t                target.classList.add(this.elementClass);\n\t            }\n\t        }\n\t        target.style.display = '';\n\t        _addEventListeners.call(this, target);\n\t        _setOrigin(target, [0, 0]); // handled internally\n\t        this._currTarget = target;\n\t        this._stylesDirty = true;\n\t        this._classesDirty = true;\n\t        this._sizeDirty = true;\n\t        this._contentDirty = true;\n\t        this._matrix = null;\n\t        this._opacity = undefined;\n\t        this._origin = null;\n\t        this._size = null;\n\t    };\n\t\n\t    /**\n\t     * Apply changes from this component to the corresponding document element.\n\t     * This includes changes to classes, styles, size, content, opacity, origin,\n\t     * and matrix transforms.\n\t     *\n\t     * @private\n\t     * @method commit\n\t     * @param {Context} context commit context\n\t     */\n\t    Surface.prototype.commit = function commit(context) {\n\t        if (!this._currTarget) this.setup(context.allocator);\n\t        var target = this._currTarget;\n\t\n\t        var matrix = context.transform;\n\t        var opacity = context.opacity;\n\t        var origin = context.origin;\n\t        var size = context.size;\n\t\n\t        if (this.size) {\n\t            var origSize = size;\n\t            size = [this.size[0], this.size[1]];\n\t            if (size[0] === undefined && origSize[0]) size[0] = origSize[0];\n\t            if (size[1] === undefined && origSize[1]) size[1] = origSize[1];\n\t        }\n\t\n\t        if (_xyNotEquals(this._size, size)) {\n\t            this._size = [size[0], size[1]];\n\t            this._sizeDirty = true;\n\t        }\n\t\n\t        if (!matrix && this._matrix) {\n\t            this._matrix = null;\n\t            this._opacity = 0;\n\t            _setInvisible(target);\n\t            return;\n\t        }\n\t\n\t        if (this._opacity !== opacity) {\n\t            this._opacity = opacity;\n\t            target.style.opacity = (opacity >= 1) ? '0.999999' : opacity;\n\t        }\n\t\n\t        if (_xyNotEquals(this._origin, origin) || Transform.notEquals(this._matrix, matrix)) {\n\t            if (!matrix) matrix = Transform.identity;\n\t            this._matrix = matrix;\n\t            var aaMatrix = matrix;\n\t            if (origin) {\n\t                if (!this._origin) this._origin = [0, 0];\n\t                this._origin[0] = origin[0];\n\t                this._origin[1] = origin[1];\n\t                aaMatrix = Transform.moveThen([-this._size[0] * origin[0], -this._size[1] * origin[1], 0], matrix);\n\t            }\n\t            _setMatrix(target, aaMatrix);\n\t        }\n\t\n\t        if (!(this._classesDirty || this._stylesDirty || this._sizeDirty || this._contentDirty)) return;\n\t\n\t        if (this._classesDirty) {\n\t            _cleanupClasses.call(this, target);\n\t            var classList = this.getClassList();\n\t            for (var i = 0; i < classList.length; i++) target.classList.add(classList[i]);\n\t            this._classesDirty = false;\n\t        }\n\t        if (this._stylesDirty) {\n\t            _applyStyles.call(this, target);\n\t            this._stylesDirty = false;\n\t        }\n\t        if (this._sizeDirty) {\n\t            if (this._size) {\n\t                target.style.width = (this._size[0] !== true) ? this._size[0] + 'px' : '';\n\t                target.style.height = (this._size[1] !== true) ? this._size[1] + 'px' : '';\n\t            }\n\t            this._sizeDirty = false;\n\t        }\n\t        if (this._contentDirty) {\n\t            this.deploy(target);\n\t            this.eventHandler.emit('deploy');\n\t            this._contentDirty = false;\n\t        }\n\t    };\n\t\n\t    /**\n\t     *  Remove all Famous-relevant attributes from a document element.\n\t     *    This is called by SurfaceManager's detach().\n\t     *    This is in some sense the reverse of .deploy().\n\t     *\n\t     * @private\n\t     * @method cleanup\n\t     * @param {ElementAllocator} allocator\n\t     */\n\t    Surface.prototype.cleanup = function cleanup(allocator) {\n\t        var i = 0;\n\t        var target = this._currTarget;\n\t        this.eventHandler.emit('recall');\n\t        this.recall(target);\n\t        target.style.display = 'none';\n\t        target.style.width = '';\n\t        target.style.height = '';\n\t        this._size = null;\n\t        _cleanupStyles.call(this, target);\n\t        var classList = this.getClassList();\n\t        _cleanupClasses.call(this, target);\n\t        for (i = 0; i < classList.length; i++) target.classList.remove(classList[i]);\n\t        if (this.elementClass) {\n\t            if (this.elementClass instanceof Array) {\n\t                for (i = 0; i < this.elementClass.length; i++) {\n\t                    target.classList.remove(this.elementClass[i]);\n\t                }\n\t            }\n\t            else {\n\t                target.classList.remove(this.elementClass);\n\t            }\n\t        }\n\t        _removeEventListeners.call(this, target);\n\t        this._currTarget = null;\n\t        allocator.deallocate(target);\n\t        _setInvisible(target);\n\t    };\n\t\n\t    /**\n\t     * Place the document element that this component manages into the document.\n\t     *\n\t     * @private\n\t     * @method deploy\n\t     * @param {Node} target document parent of this container\n\t     */\n\t    Surface.prototype.deploy = function deploy(target) {\n\t        var content = this.getContent();\n\t        if (content instanceof Node) {\n\t            while (target.hasChildNodes()) target.removeChild(target.firstChild);\n\t            target.appendChild(content);\n\t        }\n\t        else target.innerHTML = content;\n\t    };\n\t\n\t    /**\n\t     * Remove any contained document content associated with this surface\n\t     *   from the actual document.\n\t     *\n\t     * @private\n\t     * @method recall\n\t     */\n\t    Surface.prototype.recall = function recall(target) {\n\t        var df = document.createDocumentFragment();\n\t        while (target.hasChildNodes()) df.appendChild(target.firstChild);\n\t        this.setContent(df);\n\t    };\n\t\n\t    /**\n\t     *  Get the x and y dimensions of the surface.\n\t     *\n\t     * @method getSize\n\t     * @param {boolean} actual return computed size rather than provided\n\t     * @return {Array.Number} [x,y] size of surface\n\t     */\n\t    Surface.prototype.getSize = function getSize(actual) {\n\t        return actual ? this._size : (this.size || this._size);\n\t    };\n\t\n\t    /**\n\t     * Set x and y dimensions of the surface.\n\t     *\n\t     * @method setSize\n\t     * @param {Array.Number} size as [width, height]\n\t     */\n\t    Surface.prototype.setSize = function setSize(size) {\n\t        this.size = size ? [size[0], size[1]] : null;\n\t        this._sizeDirty = true;\n\t    };\n\t\n\t    module.exports = Surface;\n\t}.call(exports, __webpack_require__, exports, module)), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n\n/***/ },\n/* 3 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_RESULT__;/* This Source Code Form is subject to the terms of the Mozilla Public\n\t * License, v. 2.0. If a copy of the MPL was not distributed with this\n\t * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n\t *\n\t * Owner: mark@famo.us\n\t * @license MPL 2.0\n\t * @copyright Famous Industries, Inc. 2014\n\t */\n\t\n\t!(__WEBPACK_AMD_DEFINE_RESULT__ = (function(require, exports, module) {\n\t    var Transform = __webpack_require__(1);\n\t\n\t    /* TODO: remove these dependencies when deprecation complete */\n\t    var Transitionable = __webpack_require__(6);\n\t    var TransitionableTransform = __webpack_require__(15);\n\t\n\t    /**\n\t     *\n\t     *  A collection of visual changes to be\n\t     *    applied to another renderable component. This collection includes a\n\t     *    transform matrix, an opacity constant, a size, an origin specifier.\n\t     *    Modifier objects can be added to any RenderNode or object\n\t     *    capable of displaying renderables.  The Modifier's children and descendants\n\t     *    are transformed by the amounts specified in the Modifier's properties.\n\t     *\n\t     * @class Modifier\n\t     * @constructor\n\t     * @param {Object} [options] overrides of default options\n\t     * @param {Transform} [options.transform] affine transformation matrix\n\t     * @param {Number} [options.opacity]\n\t     * @param {Array.Number} [options.origin] origin adjustment\n\t     * @param {Array.Number} [options.size] size to apply to descendants\n\t     */\n\t    function Modifier(options) {\n\t        this._transformGetter = null;\n\t        this._opacityGetter = null;\n\t        this._originGetter = null;\n\t        this._sizeGetter = null;\n\t\n\t        /* TODO: remove this when deprecation complete */\n\t        this._legacyStates = {};\n\t\n\t        this._output = {\n\t            transform: Transform.identity,\n\t            opacity: 1,\n\t            origin: null,\n\t            size: null,\n\t            target: null\n\t        };\n\t\n\t        if (options) {\n\t            if (options.transform) this.transformFrom(options.transform);\n\t            if (options.opacity !== undefined) this.opacityFrom(options.opacity);\n\t            if (options.origin) this.originFrom(options.origin);\n\t            if (options.size) this.sizeFrom(options.size);\n\t        }\n\t    }\n\t\n\t    /**\n\t     * Function, object, or static transform matrix which provides the transform.\n\t     *   This is evaluated on every tick of the engine.\n\t     *\n\t     * @method transformFrom\n\t     *\n\t     * @param {Object} transform transform provider object\n\t     * @return {Modifier} this\n\t     */\n\t    Modifier.prototype.transformFrom = function transformFrom(transform) {\n\t        if (transform instanceof Function) this._transformGetter = transform;\n\t        else if (transform instanceof Object && transform.get) this._transformGetter = transform.get.bind(transform);\n\t        else {\n\t            this._transformGetter = null;\n\t            this._output.transform = transform;\n\t        }\n\t        return this;\n\t    };\n\t\n\t    /**\n\t     * Set function, object, or number to provide opacity, in range [0,1].\n\t     *\n\t     * @method opacityFrom\n\t     *\n\t     * @param {Object} opacity provider object\n\t     * @return {Modifier} this\n\t     */\n\t    Modifier.prototype.opacityFrom = function opacityFrom(opacity) {\n\t        if (opacity instanceof Function) this._opacityGetter = opacity;\n\t        else if (opacity instanceof Object && opacity.get) this._opacityGetter = opacity.get.bind(opacity);\n\t        else {\n\t            this._opacityGetter = null;\n\t            this._output.opacity = opacity;\n\t        }\n\t        return this;\n\t    };\n\t\n\t    /**\n\t     * Set function, object, or numerical array to provide origin, as [x,y],\n\t     *   where x and y are in the range [0,1].\n\t     *\n\t     * @method originFrom\n\t     *\n\t     * @param {Object} origin provider object\n\t     * @return {Modifier} this\n\t     */\n\t\n\t    Modifier.prototype.originFrom = function originFrom(origin) {\n\t        if (origin instanceof Function) this._originGetter = origin;\n\t        else if (origin instanceof Object && origin.get) this._originGetter = origin.get.bind(origin);\n\t        else {\n\t            this._originGetter = null;\n\t            this._output.origin = origin;\n\t        }\n\t        return this;\n\t    };\n\t\n\t    /**\n\t     * Set function, object, or numerical array to provide size, as [width, height].\n\t     *\n\t     * @method sizeFrom\n\t     *\n\t     * @param {Object} size provider object\n\t     * @return {Modifier} this\n\t     */\n\t    Modifier.prototype.sizeFrom = function sizeFrom(size) {\n\t        if (size instanceof Function) this._sizeGetter = size;\n\t        else if (size instanceof Object && size.get) this._sizeGetter = size.get.bind(size);\n\t        else {\n\t            this._sizeGetter = null;\n\t            this._output.size = size;\n\t        }\n\t        return this;\n\t    };\n\t\n\t     /**\n\t     * Deprecated: Prefer transformFrom with static Transform, or use a TransitionableTransform.\n\t     * @deprecated\n\t     * @method setTransform\n\t     *\n\t     * @param {Transform} transform Transform to transition to\n\t     * @param {Transitionable} transition Valid transitionable object\n\t     * @param {Function} callback callback to call after transition completes\n\t     * @return {Modifier} this\n\t     */\n\t    Modifier.prototype.setTransform = function setTransform(transform, transition, callback) {\n\t        if (transition || this._legacyStates.transform) {\n\t            if (!this._legacyStates.transform) {\n\t                this._legacyStates.transform = new TransitionableTransform(this._output.transform);\n\t            }\n\t            if (!this._transformGetter) this.transformFrom(this._legacyStates.transform);\n\t\n\t            this._legacyStates.transform.set(transform, transition, callback);\n\t            return this;\n\t        }\n\t        else return this.transformFrom(transform);\n\t    };\n\t\n\t    /**\n\t     * Deprecated: Prefer opacityFrom with static opacity array, or use a Transitionable with that opacity.\n\t     * @deprecated\n\t     * @method setOpacity\n\t     *\n\t     * @param {Number} opacity Opacity value to transition to.\n\t     * @param {Transitionable} transition Valid transitionable object\n\t     * @param {Function} callback callback to call after transition completes\n\t     * @return {Modifier} this\n\t     */\n\t    Modifier.prototype.setOpacity = function setOpacity(opacity, transition, callback) {\n\t        if (transition || this._legacyStates.opacity) {\n\t            if (!this._legacyStates.opacity) {\n\t                this._legacyStates.opacity = new Transitionable(this._output.opacity);\n\t            }\n\t            if (!this._opacityGetter) this.opacityFrom(this._legacyStates.opacity);\n\t\n\t            return this._legacyStates.opacity.set(opacity, transition, callback);\n\t        }\n\t        else return this.opacityFrom(opacity);\n\t    };\n\t\n\t    /**\n\t     * Deprecated: Prefer originFrom with static origin array, or use a Transitionable with that origin.\n\t     * @deprecated\n\t     * @method setOrigin\n\t     *\n\t     * @param {Array.Number} origin two element array with values between 0 and 1.\n\t     * @param {Transitionable} transition Valid transitionable object\n\t     * @param {Function} callback callback to call after transition completes\n\t     * @return {Modifier} this\n\t     */\n\t    Modifier.prototype.setOrigin = function setOrigin(origin, transition, callback) {\n\t        /* TODO: remove this if statement when deprecation complete */\n\t        if (transition || this._legacyStates.origin) {\n\t\n\t            if (!this._legacyStates.origin) {\n\t                this._legacyStates.origin = new Transitionable(this._output.origin || [0, 0]);\n\t            }\n\t            if (!this._originGetter) this.originFrom(this._legacyStates.origin);\n\t\n\t            this._legacyStates.origin.set(origin, transition, callback);\n\t            return this;\n\t        }\n\t        else return this.originFrom(origin);\n\t    };\n\t\n\t    /**\n\t     * Deprecated: Prefer sizeFrom with static origin array, or use a Transitionable with that size.\n\t     * @deprecated\n\t     * @method setSize\n\t     * @param {Array.Number} size two element array of [width, height]\n\t     * @param {Transitionable} transition Valid transitionable object\n\t     * @param {Function} callback callback to call after transition completes\n\t     * @return {Modifier} this\n\t     */\n\t    Modifier.prototype.setSize = function setSize(size, transition, callback) {\n\t        if (size && (transition || this._legacyStates.size)) {\n\t            if (!this._legacyStates.size) {\n\t                this._legacyStates.size = new Transitionable(this._output.size || [0, 0]);\n\t            }\n\t            if (!this._sizeGetter) this.sizeFrom(this._legacyStates.size);\n\t\n\t            this._legacyStates.size.set(size, transition, callback);\n\t            return this;\n\t        }\n\t        else return this.sizeFrom(size);\n\t    };\n\t\n\t    /**\n\t     * Deprecated: Prefer to stop transform in your provider object.\n\t     * @deprecated\n\t     * @method halt\n\t     */\n\t    Modifier.prototype.halt = function halt() {\n\t        if (this._legacyStates.transform) this._legacyStates.transform.halt();\n\t        if (this._legacyStates.opacity) this._legacyStates.opacity.halt();\n\t        if (this._legacyStates.origin) this._legacyStates.origin.halt();\n\t        if (this._legacyStates.size) this._legacyStates.size.halt();\n\t        this._transformGetter = null;\n\t        this._opacityGetter = null;\n\t        this._originGetter = null;\n\t        this._sizeGetter = null;\n\t    };\n\t\n\t    /**\n\t     * Deprecated: Prefer to use your provided transform or output of your transform provider.\n\t     * @deprecated\n\t     * @method getTransform\n\t     * @return {Object} transform provider object\n\t     */\n\t    Modifier.prototype.getTransform = function getTransform() {\n\t        return this._transformGetter();\n\t    };\n\t\n\t    /**\n\t     * Deprecated: Prefer to determine the end state of your transform from your transform provider\n\t     * @deprecated\n\t     * @method getFinalTransform\n\t     * @return {Transform} transform matrix\n\t     */\n\t    Modifier.prototype.getFinalTransform = function getFinalTransform() {\n\t        return this._legacyStates.transform ? this._legacyStates.transform.getFinal() : this._output.transform;\n\t    };\n\t\n\t    /**\n\t     * Deprecated: Prefer to use your provided opacity or output of your opacity provider.\n\t     * @deprecated\n\t     * @method getOpacity\n\t     * @return {Object} opacity provider object\n\t     */\n\t    Modifier.prototype.getOpacity = function getOpacity() {\n\t        return this._opacityGetter();\n\t    };\n\t    /**\n\t     * Deprecated: Prefer to use your provided origin or output of your origin provider.\n\t     * @deprecated\n\t     * @method getOrigin\n\t     * @return {Object} origin provider object\n\t     */\n\t    Modifier.prototype.getOrigin = function getOrigin() {\n\t        return this._originGetter();\n\t    };\n\t\n\t    /**\n\t     * Deprecated: Prefer to use your provided size or output of your size provider.\n\t     * @deprecated\n\t     * @method getSize\n\t     * @return {Object} size provider object\n\t     */\n\t    Modifier.prototype.getSize = function getSize() {\n\t        return this._sizeGetter ? this._sizeGetter() : this._output.size;\n\t    };\n\t\n\t    // call providers on tick to receive render spec elements to apply\n\t    function _update() {\n\t        if (this._transformGetter) this._output.transform = this._transformGetter();\n\t        if (this._opacityGetter) this._output.opacity = this._opacityGetter();\n\t        if (this._originGetter) this._output.origin = this._originGetter();\n\t        if (this._sizeGetter) this._output.size = this._sizeGetter();\n\t    }\n\t\n\t    /**\n\t     * Return render spec for this Modifier, applying to the provided\n\t     *    target component.  This is similar to render() for Surfaces.\n\t     *\n\t     * @private\n\t     * @method modify\n\t     *\n\t     * @param {Object} target (already rendered) render spec to\n\t     *    which to apply the transform.\n\t     * @return {Object} render spec for this Modifier, including the\n\t     *    provided target\n\t     */\n\t    Modifier.prototype.modify = function modify(target) {\n\t        _update.call(this);\n\t        this._output.target = target;\n\t        return this._output;\n\t    };\n\t\n\t    module.exports = Modifier;\n\t}.call(exports, __webpack_require__, exports, module)), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n\n/***/ },\n/* 4 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_RESULT__;/* This Source Code Form is subject to the terms of the Mozilla Public\n\t * License, v. 2.0. If a copy of the MPL was not distributed with this\n\t * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n\t *\n\t * Owner: mark@famo.us\n\t * @license MPL 2.0\n\t * @copyright Famous Industries, Inc. 2014\n\t */\n\t\n\t!(__WEBPACK_AMD_DEFINE_RESULT__ = (function(require, exports, module) {\n\t    var EventHandler = __webpack_require__(5);\n\t    var OptionsManager = __webpack_require__(11);\n\t    var RenderNode = __webpack_require__(12);\n\t\n\t    /**\n\t     * Useful for quickly creating elements within applications\n\t     *   with large event systems.  Consists of a RenderNode paired with\n\t     *   an input EventHandler and an output EventHandler.\n\t     *   Meant to be extended by the developer.\n\t     *\n\t     * @class View\n\t     * @uses EventHandler\n\t     * @uses OptionsManager\n\t     * @uses RenderNode\n\t     * @constructor\n\t     */\n\t    function View(options) {\n\t        this._node = new RenderNode();\n\t\n\t        this._eventInput = new EventHandler();\n\t        this._eventOutput = new EventHandler();\n\t        EventHandler.setInputHandler(this, this._eventInput);\n\t        EventHandler.setOutputHandler(this, this._eventOutput);\n\t\n\t        this.options = Object.create(this.constructor.DEFAULT_OPTIONS || View.DEFAULT_OPTIONS);\n\t        this._optionsManager = new OptionsManager(this.options);\n\t\n\t        if (options) this.setOptions(options);\n\t    }\n\t\n\t    View.DEFAULT_OPTIONS = {}; // no defaults\n\t\n\t    /**\n\t     * Look up options value by key\n\t     * @method getOptions\n\t     *\n\t     * @param {string} key key\n\t     * @return {Object} associated object\n\t     */\n\t    View.prototype.getOptions = function getOptions() {\n\t        return this._optionsManager.value();\n\t    };\n\t\n\t    /*\n\t     *  Set internal options.\n\t     *  No defaults options are set in View.\n\t     *\n\t     *  @method setOptions\n\t     *  @param {Object} options\n\t     */\n\t    View.prototype.setOptions = function setOptions(options) {\n\t        this._optionsManager.patch(options);\n\t    };\n\t\n\t    /**\n\t     * Add a child renderable to the view.\n\t     *   Note: This is meant to be used by an inheriting class\n\t     *   rather than from outside the prototype chain.\n\t     *\n\t     * @method add\n\t     * @return {RenderNode}\n\t     * @protected\n\t     */\n\t    View.prototype.add = function add() {\n\t        return this._node.add.apply(this._node, arguments);\n\t    };\n\t\n\t    /**\n\t     * Alias for add\n\t     * @method _add\n\t     */\n\t    View.prototype._add = View.prototype.add;\n\t\n\t    /**\n\t     * Generate a render spec from the contents of this component.\n\t     *\n\t     * @private\n\t     * @method render\n\t     * @return {number} Render spec for this component\n\t     */\n\t    View.prototype.render = function render() {\n\t        return this._node.render();\n\t    };\n\t\n\t    /**\n\t     * Return size of contained element.\n\t     *\n\t     * @method getSize\n\t     * @return {Array.Number} [width, height]\n\t     */\n\t    View.prototype.getSize = function getSize() {\n\t        if (this._node && this._node.getSize) {\n\t            return this._node.getSize.apply(this._node, arguments) || this.options.size;\n\t        }\n\t        else return this.options.size;\n\t    };\n\t\n\t    module.exports = View;\n\t}.call(exports, __webpack_require__, exports, module)), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n\n/***/ },\n/* 5 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_RESULT__;/* This Source Code Form is subject to the terms of the Mozilla Public\n\t * License, v. 2.0. If a copy of the MPL was not distributed with this\n\t * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n\t *\n\t * Owner: mark@famo.us\n\t * @license MPL 2.0\n\t * @copyright Famous Industries, Inc. 2014\n\t */\n\t\n\t!(__WEBPACK_AMD_DEFINE_RESULT__ = (function(require, exports, module) {\n\t    var EventEmitter = __webpack_require__(23);\n\t\n\t    /**\n\t     * EventHandler forwards received events to a set of provided callback functions.\n\t     * It allows events to be captured, processed, and optionally piped through to other event handlers.\n\t     *\n\t     * @class EventHandler\n\t     * @extends EventEmitter\n\t     * @constructor\n\t     */\n\t    function EventHandler() {\n\t        EventEmitter.apply(this, arguments);\n\t\n\t        this.downstream = []; // downstream event handlers\n\t        this.downstreamFn = []; // downstream functions\n\t\n\t        this.upstream = []; // upstream event handlers\n\t        this.upstreamListeners = {}; // upstream listeners\n\t    }\n\t    EventHandler.prototype = Object.create(EventEmitter.prototype);\n\t    EventHandler.prototype.constructor = EventHandler;\n\t\n\t    /**\n\t     * Assign an event handler to receive an object's input events.\n\t     *\n\t     * @method setInputHandler\n\t     * @static\n\t     *\n\t     * @param {Object} object object to mix trigger, subscribe, and unsubscribe functions into\n\t     * @param {EventHandler} handler assigned event handler\n\t     */\n\t    EventHandler.setInputHandler = function setInputHandler(object, handler) {\n\t        object.trigger = handler.trigger.bind(handler);\n\t        if (handler.subscribe && handler.unsubscribe) {\n\t            object.subscribe = handler.subscribe.bind(handler);\n\t            object.unsubscribe = handler.unsubscribe.bind(handler);\n\t        }\n\t    };\n\t\n\t    /**\n\t     * Assign an event handler to receive an object's output events.\n\t     *\n\t     * @method setOutputHandler\n\t     * @static\n\t     *\n\t     * @param {Object} object object to mix pipe, unpipe, on, addListener, and removeListener functions into\n\t     * @param {EventHandler} handler assigned event handler\n\t     */\n\t    EventHandler.setOutputHandler = function setOutputHandler(object, handler) {\n\t        if (handler instanceof EventHandler) handler.bindThis(object);\n\t        object.pipe = handler.pipe.bind(handler);\n\t        object.unpipe = handler.unpipe.bind(handler);\n\t        object.on = handler.on.bind(handler);\n\t        object.addListener = handler.on;\n\t        object.removeListener = handler.removeListener.bind(handler);\n\t    };\n\t\n\t    /**\n\t     * Trigger an event, sending to all downstream handlers\n\t     *   listening for provided 'type' key.\n\t     *\n\t     * @method emit\n\t     *\n\t     * @param {string} type event type key (for example, 'click')\n\t     * @param {Object} event event data\n\t     * @return {EventHandler} this\n\t     */\n\t    EventHandler.prototype.emit = function emit(type, event) {\n\t        EventEmitter.prototype.emit.apply(this, arguments);\n\t        var i = 0;\n\t        for (i = 0; i < this.downstream.length; i++) {\n\t            if (this.downstream[i].trigger) this.downstream[i].trigger(type, event);\n\t        }\n\t        for (i = 0; i < this.downstreamFn.length; i++) {\n\t            this.downstreamFn[i](type, event);\n\t        }\n\t        return this;\n\t    };\n\t\n\t    /**\n\t     * Alias for emit\n\t     * @method addListener\n\t     */\n\t    EventHandler.prototype.trigger = EventHandler.prototype.emit;\n\t\n\t    /**\n\t     * Add event handler object to set of downstream handlers.\n\t     *\n\t     * @method pipe\n\t     *\n\t     * @param {EventHandler} target event handler target object\n\t     * @return {EventHandler} passed event handler\n\t     */\n\t    EventHandler.prototype.pipe = function pipe(target) {\n\t        if (target.subscribe instanceof Function) return target.subscribe(this);\n\t\n\t        var downstreamCtx = (target instanceof Function) ? this.downstreamFn : this.downstream;\n\t        var index = downstreamCtx.indexOf(target);\n\t        if (index < 0) downstreamCtx.push(target);\n\t\n\t        if (target instanceof Function) target('pipe', null);\n\t        else if (target.trigger) target.trigger('pipe', null);\n\t\n\t        return target;\n\t    };\n\t\n\t    /**\n\t     * Remove handler object from set of downstream handlers.\n\t     *   Undoes work of \"pipe\".\n\t     *\n\t     * @method unpipe\n\t     *\n\t     * @param {EventHandler} target target handler object\n\t     * @return {EventHandler} provided target\n\t     */\n\t    EventHandler.prototype.unpipe = function unpipe(target) {\n\t        if (target.unsubscribe instanceof Function) return target.unsubscribe(this);\n\t\n\t        var downstreamCtx = (target instanceof Function) ? this.downstreamFn : this.downstream;\n\t        var index = downstreamCtx.indexOf(target);\n\t        if (index >= 0) {\n\t            downstreamCtx.splice(index, 1);\n\t            if (target instanceof Function) target('unpipe', null);\n\t            else if (target.trigger) target.trigger('unpipe', null);\n\t            return target;\n\t        }\n\t        else return false;\n\t    };\n\t\n\t    /**\n\t     * Bind a callback function to an event type handled by this object.\n\t     *\n\t     * @method \"on\"\n\t     *\n\t     * @param {string} type event type key (for example, 'click')\n\t     * @param {function(string, Object)} handler callback\n\t     * @return {EventHandler} this\n\t     */\n\t    EventHandler.prototype.on = function on(type, handler) {\n\t        EventEmitter.prototype.on.apply(this, arguments);\n\t        if (!(type in this.upstreamListeners)) {\n\t            var upstreamListener = this.trigger.bind(this, type);\n\t            this.upstreamListeners[type] = upstreamListener;\n\t            for (var i = 0; i < this.upstream.length; i++) {\n\t                this.upstream[i].on(type, upstreamListener);\n\t            }\n\t        }\n\t        return this;\n\t    };\n\t\n\t    /**\n\t     * Alias for \"on\"\n\t     * @method addListener\n\t     */\n\t    EventHandler.prototype.addListener = EventHandler.prototype.on;\n\t\n\t    /**\n\t     * Listen for events from an upstream event handler.\n\t     *\n\t     * @method subscribe\n\t     *\n\t     * @param {EventEmitter} source source emitter object\n\t     * @return {EventHandler} this\n\t     */\n\t    EventHandler.prototype.subscribe = function subscribe(source) {\n\t        var index = this.upstream.indexOf(source);\n\t        if (index < 0) {\n\t            this.upstream.push(source);\n\t            for (var type in this.upstreamListeners) {\n\t                source.on(type, this.upstreamListeners[type]);\n\t            }\n\t        }\n\t        return this;\n\t    };\n\t\n\t    /**\n\t     * Stop listening to events from an upstream event handler.\n\t     *\n\t     * @method unsubscribe\n\t     *\n\t     * @param {EventEmitter} source source emitter object\n\t     * @return {EventHandler} this\n\t     */\n\t    EventHandler.prototype.unsubscribe = function unsubscribe(source) {\n\t        var index = this.upstream.indexOf(source);\n\t        if (index >= 0) {\n\t            this.upstream.splice(index, 1);\n\t            for (var type in this.upstreamListeners) {\n\t                source.removeListener(type, this.upstreamListeners[type]);\n\t            }\n\t        }\n\t        return this;\n\t    };\n\t\n\t    module.exports = EventHandler;\n\t}.call(exports, __webpack_require__, exports, module)), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n\n/***/ },\n/* 6 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_RESULT__;/* This Source Code Form is subject to the terms of the Mozilla Public\n\t * License, v. 2.0. If a copy of the MPL was not distributed with this\n\t * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n\t *\n\t * Owner: david@famo.us\n\t * @license MPL 2.0\n\t * @copyright Famous Industries, Inc. 2014\n\t */\n\t\n\t!(__WEBPACK_AMD_DEFINE_RESULT__ = (function(require, exports, module) {\n\t    var MultipleTransition = __webpack_require__(26);\n\t    var TweenTransition = __webpack_require__(27);\n\t\n\t    /**\n\t     * A state maintainer for a smooth transition between\n\t     *    numerically-specified states. Example numeric states include floats or\n\t     *    Transform objects.\n\t     *\n\t     * An initial state is set with the constructor or set(startState). A\n\t     *    corresponding end state and transition are set with set(endState,\n\t     *    transition). Subsequent calls to set(endState, transition) begin at\n\t     *    the last state. Calls to get(timestamp) provide the interpolated state\n\t     *    along the way.\n\t     *\n\t     * Note that there is no event loop here - calls to get() are the only way\n\t     *    to find state projected to the current (or provided) time and are\n\t     *    the only way to trigger callbacks. Usually this kind of object would\n\t     *    be part of the render() path of a visible component.\n\t     *\n\t     * @class Transitionable\n\t     * @constructor\n\t     * @param {number|Array.Number|Object.<number|string, number>} start\n\t     *    beginning state\n\t     */\n\t    function Transitionable(start) {\n\t        this.currentAction = null;\n\t        this.actionQueue = [];\n\t        this.callbackQueue = [];\n\t\n\t        this.state = 0;\n\t        this.velocity = undefined;\n\t        this._callback = undefined;\n\t        this._engineInstance = null;\n\t        this._currentMethod = null;\n\t\n\t        this.set(start);\n\t    }\n\t\n\t    var transitionMethods = {};\n\t\n\t    Transitionable.registerMethod = function registerMethod(name, engineClass) {\n\t        if (!(name in transitionMethods)) {\n\t            transitionMethods[name] = engineClass;\n\t            return true;\n\t        }\n\t        else return false;\n\t    };\n\t\n\t    Transitionable.unregisterMethod = function unregisterMethod(name) {\n\t        if (name in transitionMethods) {\n\t            delete transitionMethods[name];\n\t            return true;\n\t        }\n\t        else return false;\n\t    };\n\t\n\t    function _loadNext() {\n\t        if (this._callback) {\n\t            var callback = this._callback;\n\t            this._callback = undefined;\n\t            callback();\n\t        }\n\t        if (this.actionQueue.length <= 0) {\n\t            this.set(this.get()); // no update required\n\t            return;\n\t        }\n\t        this.currentAction = this.actionQueue.shift();\n\t        this._callback = this.callbackQueue.shift();\n\t\n\t        var method = null;\n\t        var endValue = this.currentAction[0];\n\t        var transition = this.currentAction[1];\n\t        if (transition instanceof Object && transition.method) {\n\t            method = transition.method;\n\t            if (typeof method === 'string') method = transitionMethods[method];\n\t        }\n\t        else {\n\t            method = TweenTransition;\n\t        }\n\t\n\t        if (this._currentMethod !== method) {\n\t            if (!(endValue instanceof Object) || method.SUPPORTS_MULTIPLE === true || endValue.length <= method.SUPPORTS_MULTIPLE) {\n\t                this._engineInstance = new method();\n\t            }\n\t            else {\n\t                this._engineInstance = new MultipleTransition(method);\n\t            }\n\t            this._currentMethod = method;\n\t        }\n\t\n\t        this._engineInstance.reset(this.state, this.velocity);\n\t        if (this.velocity !== undefined) transition.velocity = this.velocity;\n\t        this._engineInstance.set(endValue, transition, _loadNext.bind(this));\n\t    }\n\t\n\t    /**\n\t     * Add transition to end state to the queue of pending transitions. Special\n\t     *    Use: calling without a transition resets the object to that state with\n\t     *    no pending actions\n\t     *\n\t     * @method set\n\t     *\n\t     * @param {number|FamousMatrix|Array.Number|Object.<number, number>} endState\n\t     *    end state to which we interpolate\n\t     * @param {transition=} transition object of type {duration: number, curve:\n\t     *    f[0,1] -> [0,1] or name}. If transition is omitted, change will be\n\t     *    instantaneous.\n\t     * @param {function()=} callback Zero-argument function to call on observed\n\t     *    completion (t=1)\n\t     */\n\t    Transitionable.prototype.set = function set(endState, transition, callback) {\n\t        if (!transition) {\n\t            this.reset(endState);\n\t            if (callback) callback();\n\t            return this;\n\t        }\n\t\n\t        var action = [endState, transition];\n\t        this.actionQueue.push(action);\n\t        this.callbackQueue.push(callback);\n\t        if (!this.currentAction) _loadNext.call(this);\n\t        return this;\n\t    };\n\t\n\t    /**\n\t     * Cancel all transitions and reset to a stable state\n\t     *\n\t     * @method reset\n\t     *\n\t     * @param {number|Array.Number|Object.<number, number>} startState\n\t     *    stable state to set to\n\t     */\n\t    Transitionable.prototype.reset = function reset(startState, startVelocity) {\n\t        this._currentMethod = null;\n\t        this._engineInstance = null;\n\t        this.state = startState;\n\t        this.velocity = startVelocity;\n\t        this.currentAction = null;\n\t        this.actionQueue = [];\n\t        this.callbackQueue = [];\n\t    };\n\t\n\t    /**\n\t     * Add delay action to the pending action queue queue.\n\t     *\n\t     * @method delay\n\t     *\n\t     * @param {number} duration delay time (ms)\n\t     * @param {function} callback Zero-argument function to call on observed\n\t     *    completion (t=1)\n\t     */\n\t    Transitionable.prototype.delay = function delay(duration, callback) {\n\t        this.set(this._engineInstance.get(), {duration: duration,\n\t            curve: function() {\n\t                return 0;\n\t            }},\n\t            callback);\n\t    };\n\t\n\t    /**\n\t     * Get interpolated state of current action at provided time. If the last\n\t     *    action has completed, invoke its callback.\n\t     *\n\t     * @method get\n\t     *\n\t     * @param {number=} timestamp Evaluate the curve at a normalized version of this\n\t     *    time. If omitted, use current time. (Unix epoch time)\n\t     * @return {number|Object.<number|string, number>} beginning state\n\t     *    interpolated to this point in time.\n\t     */\n\t    Transitionable.prototype.get = function get(timestamp) {\n\t        if (this._engineInstance) {\n\t            if (this._engineInstance.getVelocity)\n\t                this.velocity = this._engineInstance.getVelocity();\n\t            this.state = this._engineInstance.get(timestamp);\n\t        }\n\t        return this.state;\n\t    };\n\t\n\t    /**\n\t     * Is there at least one action pending completion?\n\t     *\n\t     * @method isActive\n\t     *\n\t     * @return {boolean}\n\t     */\n\t    Transitionable.prototype.isActive = function isActive() {\n\t        return !!this.currentAction;\n\t    };\n\t\n\t    /**\n\t     * Halt transition at current state and erase all pending actions.\n\t     *\n\t     * @method halt\n\t     */\n\t    Transitionable.prototype.halt = function halt() {\n\t        this.set(this.get());\n\t    };\n\t\n\t    module.exports = Transitionable;\n\t}.call(exports, __webpack_require__, exports, module)), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n\n/***/ },\n/* 7 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_RESULT__;/* This Source Code Form is subject to the terms of the Mozilla Public\n\t * License, v. 2.0. If a copy of the MPL was not distributed with this\n\t * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n\t *\n\t * Owner: mark@famo.us\n\t * @license MPL 2.0\n\t * @copyright Famous Industries, Inc. 2014\n\t */\n\t\n\t!(__WEBPACK_AMD_DEFINE_RESULT__ = (function(require, exports, module) {\n\t    /**\n\t     * This namespace holds standalone functionality.\n\t     *  Currently includes name mapping for transition curves,\n\t     *  name mapping for origin pairs, and the after() function.\n\t     *\n\t     * @class Utility\n\t     * @static\n\t     */\n\t    var Utility = {};\n\t\n\t    /**\n\t     * Table of direction array positions\n\t     *\n\t     * @property {object} Direction\n\t     * @final\n\t     */\n\t    Utility.Direction = {\n\t        X: 0,\n\t        Y: 1,\n\t        Z: 2\n\t    };\n\t\n\t    /**\n\t     * Return wrapper around callback function. Once the wrapper is called N\n\t     *   times, invoke the callback function. Arguments and scope preserved.\n\t     *\n\t     * @method after\n\t     *\n\t     * @param {number} count number of calls before callback function invoked\n\t     * @param {Function} callback wrapped callback function\n\t     *\n\t     * @return {function} wrapped callback with coundown feature\n\t     */\n\t    Utility.after = function after(count, callback) {\n\t        var counter = count;\n\t        return function() {\n\t            counter--;\n\t            if (counter === 0) callback.apply(this, arguments);\n\t        };\n\t    };\n\t\n\t    /**\n\t     * Load a URL and return its contents in a callback\n\t     *\n\t     * @method loadURL\n\t     *\n\t     * @param {string} url URL of object\n\t     * @param {function} callback callback to dispatch with content\n\t     */\n\t    Utility.loadURL = function loadURL(url, callback) {\n\t        var xhr = new XMLHttpRequest();\n\t        xhr.onreadystatechange = function onreadystatechange() {\n\t            if (this.readyState === 4) {\n\t                if (callback) callback(this.responseText);\n\t            }\n\t        };\n\t        xhr.open('GET', url);\n\t        xhr.send();\n\t    };\n\t\n\t    /**\n\t     * Create a document fragment from a string of HTML\n\t     *\n\t     * @method createDocumentFragmentFromHTML\n\t     *\n\t     * @param {string} html HTML to convert to DocumentFragment\n\t     *\n\t     * @return {DocumentFragment} DocumentFragment representing input HTML\n\t     */\n\t    Utility.createDocumentFragmentFromHTML = function createDocumentFragmentFromHTML(html) {\n\t        var element = document.createElement('div');\n\t        element.innerHTML = html;\n\t        var result = document.createDocumentFragment();\n\t        while (element.hasChildNodes()) result.appendChild(element.firstChild);\n\t        return result;\n\t    };\n\t\n\t    module.exports = Utility;\n\t}.call(exports, __webpack_require__, exports, module)), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n\n/***/ },\n/* 8 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/*\r\n\t\tMIT License http://www.opensource.org/licenses/mit-license.php\r\n\t\tAuthor Tobias Koppers @sokra\r\n\t*/\r\n\tmodule.exports = function addStyle(cssCode) {\r\n\t\tif(false) {\r\n\t\t\tif(typeof document !== \"object\") throw new Error(\"The style-loader cannot be used in a non-browser environment\");\r\n\t\t}\r\n\t\tvar styleElement = document.createElement(\"style\");\r\n\t\tstyleElement.type = \"text/css\";\r\n\t\tif (styleElement.styleSheet) {\r\n\t\t\tstyleElement.styleSheet.cssText = cssCode;\r\n\t\t} else {\r\n\t\t\tstyleElement.appendChild(document.createTextNode(cssCode));\r\n\t\t}\r\n\t\tvar head = document.getElementsByTagName(\"head\")[0];\r\n\t\thead.appendChild(styleElement);\r\n\t\treturn function() {\r\n\t\t\thead.removeChild(styleElement);\r\n\t\t};\r\n\t}\n\n/***/ },\n/* 9 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_RESULT__;/* This Source Code Form is subject to the terms of the Mozilla Public\n\t * License, v. 2.0. If a copy of the MPL was not distributed with this\n\t * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n\t *\n\t * Owner: mark@famo.us\n\t * @license MPL 2.0\n\t * @copyright Famous Industries, Inc. 2014\n\t */\n\t\n\t!(__WEBPACK_AMD_DEFINE_RESULT__ = (function(require, exports, module) {\n\t\n\t    /**\n\t     * The singleton object initiated upon process\n\t     *   startup which manages all active Context instances, runs\n\t     *   the render dispatch loop, and acts as a listener and dispatcher\n\t     *   for events.  All methods are therefore static.\n\t     *\n\t     *   On static initialization, window.requestAnimationFrame is called with\n\t     *     the event loop function.\n\t     *\n\t     *   Note: Any window in which Engine runs will prevent default\n\t     *     scrolling behavior on the 'touchmove' event.\n\t     *\n\t     * @static\n\t     * @class Engine\n\t     */\n\t    var Context = __webpack_require__(21);\n\t    var EventHandler = __webpack_require__(5);\n\t    var OptionsManager = __webpack_require__(11);\n\t\n\t    var Engine = {};\n\t\n\t    var contexts = [];\n\t    var nextTickQueue = [];\n\t    var deferQueue = [];\n\t\n\t    var lastTime = Date.now();\n\t    var frameTime;\n\t    var frameTimeLimit;\n\t    var loopEnabled = true;\n\t    var eventForwarders = {};\n\t    var eventHandler = new EventHandler();\n\t\n\t    var options = {\n\t        containerType: 'div',\n\t        containerClass: 'famous-container',\n\t        fpsCap: undefined,\n\t        runLoop: true\n\t    };\n\t    var optionsManager = new OptionsManager(options);\n\t\n\t    /** @const */\n\t    var MAX_DEFER_FRAME_TIME = 10;\n\t\n\t    /**\n\t     * Inside requestAnimationFrame loop, step() is called, which:\n\t     *   calculates current FPS (throttling loop if it is over limit set in setFPSCap),\n\t     *   emits dataless 'prerender' event on start of loop,\n\t     *   calls in order any one-shot functions registered by nextTick on last loop,\n\t     *   calls Context.update on all Context objects registered,\n\t     *   and emits dataless 'postrender' event on end of loop.\n\t     *\n\t     * @static\n\t     * @private\n\t     * @method step\n\t     */\n\t    Engine.step = function step() {\n\t        var currentTime = Date.now();\n\t\n\t        // skip frame if we're over our framerate cap\n\t        if (frameTimeLimit && currentTime - lastTime < frameTimeLimit) return;\n\t\n\t        var i = 0;\n\t\n\t        frameTime = currentTime - lastTime;\n\t        lastTime = currentTime;\n\t\n\t        eventHandler.emit('prerender');\n\t\n\t        // empty the queue\n\t        for (i = 0; i < nextTickQueue.length; i++) nextTickQueue[i].call(this);\n\t        nextTickQueue.splice(0);\n\t\n\t        // limit total execution time for deferrable functions\n\t        while (deferQueue.length && (Date.now() - currentTime) < MAX_DEFER_FRAME_TIME) {\n\t            deferQueue.shift().call(this);\n\t        }\n\t\n\t        for (i = 0; i < contexts.length; i++) contexts[i].update();\n\t\n\t        eventHandler.emit('postrender');\n\t    };\n\t\n\t    // engage requestAnimationFrame\n\t    function loop() {\n\t        if (options.runLoop) {\n\t            Engine.step();\n\t            requestAnimationFrame(loop);\n\t        }\n\t        else loopEnabled = false;\n\t    }\n\t    requestAnimationFrame(loop);\n\t\n\t    //\n\t    // Upon main document window resize (unless on an \"input\" HTML element):\n\t    //   scroll to the top left corner of the window,\n\t    //   and for each managed Context: emit the 'resize' event and update its size.\n\t    // @param {Object=} event document event\n\t    //\n\t    function handleResize(event) {\n\t        for (var i = 0; i < contexts.length; i++) {\n\t            contexts[i].emit('resize');\n\t        }\n\t        eventHandler.emit('resize');\n\t    }\n\t    window.addEventListener('resize', handleResize, false);\n\t    handleResize();\n\t\n\t    // prevent scrolling via browser\n\t    window.addEventListener('touchmove', function(event) {\n\t        event.preventDefault();\n\t    }, true);\n\t\n\t    /**\n\t     * Add event handler object to set of downstream handlers.\n\t     *\n\t     * @method pipe\n\t     *\n\t     * @param {EventHandler} target event handler target object\n\t     * @return {EventHandler} passed event handler\n\t     */\n\t    Engine.pipe = function pipe(target) {\n\t        if (target.subscribe instanceof Function) return target.subscribe(Engine);\n\t        else return eventHandler.pipe(target);\n\t    };\n\t\n\t    /**\n\t     * Remove handler object from set of downstream handlers.\n\t     *   Undoes work of \"pipe\".\n\t     *\n\t     * @method unpipe\n\t     *\n\t     * @param {EventHandler} target target handler object\n\t     * @return {EventHandler} provided target\n\t     */\n\t    Engine.unpipe = function unpipe(target) {\n\t        if (target.unsubscribe instanceof Function) return target.unsubscribe(Engine);\n\t        else return eventHandler.unpipe(target);\n\t    };\n\t\n\t    /**\n\t     * Bind a callback function to an event type handled by this object.\n\t     *\n\t     * @static\n\t     * @method \"on\"\n\t     *\n\t     * @param {string} type event type key (for example, 'click')\n\t     * @param {function(string, Object)} handler callback\n\t     * @return {EventHandler} this\n\t     */\n\t    Engine.on = function on(type, handler) {\n\t        if (!(type in eventForwarders)) {\n\t            eventForwarders[type] = eventHandler.emit.bind(eventHandler, type);\n\t            document.body.addEventListener(type, eventForwarders[type]);\n\t        }\n\t        return eventHandler.on(type, handler);\n\t    };\n\t\n\t    /**\n\t     * Trigger an event, sending to all downstream handlers\n\t     *   listening for provided 'type' key.\n\t     *\n\t     * @method emit\n\t     *\n\t     * @param {string} type event type key (for example, 'click')\n\t     * @param {Object} event event data\n\t     * @return {EventHandler} this\n\t     */\n\t    Engine.emit = function emit(type, event) {\n\t        return eventHandler.emit(type, event);\n\t    };\n\t\n\t    /**\n\t     * Unbind an event by type and handler.\n\t     *   This undoes the work of \"on\".\n\t     *\n\t     * @static\n\t     * @method removeListener\n\t     *\n\t     * @param {string} type event type key (for example, 'click')\n\t     * @param {function} handler function object to remove\n\t     * @return {EventHandler} internal event handler object (for chaining)\n\t     */\n\t    Engine.removeListener = function removeListener(type, handler) {\n\t        return eventHandler.removeListener(type, handler);\n\t    };\n\t\n\t    /**\n\t     * Return the current calculated frames per second of the Engine.\n\t     *\n\t     * @static\n\t     * @method getFPS\n\t     *\n\t     * @return {Number} calculated fps\n\t     */\n\t    Engine.getFPS = function getFPS() {\n\t        return 1000 / frameTime;\n\t    };\n\t\n\t    /**\n\t     * Set the maximum fps at which the system should run. If internal render\n\t     *    loop is called at a greater frequency than this FPSCap, Engine will\n\t     *    throttle render and update until this rate is achieved.\n\t     *\n\t     * @static\n\t     * @method setFPSCap\n\t     *\n\t     * @param {Number} fps maximum frames per second\n\t     */\n\t    Engine.setFPSCap = function setFPSCap(fps) {\n\t        frameTimeLimit = Math.floor(1000 / fps);\n\t    };\n\t\n\t    /**\n\t     * Return engine options.\n\t     *\n\t     * @static\n\t     * @method getOptions\n\t     * @param {string} key\n\t     * @return {Object} engine options\n\t     */\n\t    Engine.getOptions = function getOptions() {\n\t        return optionsManager.getOptions.apply(optionsManager, arguments);\n\t    };\n\t\n\t    /**\n\t     * Set engine options\n\t     *\n\t     * @static\n\t     * @method setOptions\n\t     *\n\t     * @param {Object} [options] overrides of default options\n\t     * @param {Number} [options.fpsCap]  maximum fps at which the system should run\n\t     * @param {boolean} [options.runLoop=true] whether the run loop should continue\n\t     * @param {string} [options.containerType=\"div\"] type of container element.  Defaults to 'div'.\n\t     * @param {string} [options.containerClass=\"famous-container\"] type of container element.  Defaults to 'famous-container'.\n\t     */\n\t    Engine.setOptions = function setOptions(options) {\n\t        return optionsManager.setOptions.apply(optionsManager, arguments);\n\t    };\n\t\n\t    /**\n\t     * Creates a new Context for rendering and event handling with\n\t     *    provided document element as top of each tree. This will be tracked by the\n\t     *    process-wide Engine.\n\t     *\n\t     * @static\n\t     * @method createContext\n\t     *\n\t     * @param {Node} el will be top of Famo.us document element tree\n\t     * @return {Context} new Context within el\n\t     */\n\t    Engine.createContext = function createContext(el) {\n\t        if (el === undefined) {\n\t            el = document.createElement(options.containerType);\n\t            el.classList.add(options.containerClass);\n\t            document.body.appendChild(el);\n\t        }\n\t        else if (!(el instanceof Element)) {\n\t            el = document.createElement(options.containerType);\n\t            throw new Error('Tried to create context on non-existent element');\n\t        }\n\t        var context = new Context(el);\n\t        Engine.registerContext(context);\n\t        return context;\n\t    };\n\t\n\t    /**\n\t     * Registers an existing context to be updated within the run loop.\n\t     *\n\t     * @static\n\t     * @method registerContext\n\t     *\n\t     * @param {Context} context Context to register\n\t     * @return {FamousContext} provided context\n\t     */\n\t    Engine.registerContext = function registerContext(context) {\n\t        contexts.push(context);\n\t        return context;\n\t    };\n\t\n\t    /**\n\t     * Queue a function to be executed on the next tick of the\n\t     *    Engine.\n\t     *\n\t     * @static\n\t     * @method nextTick\n\t     *\n\t     * @param {function(Object)} fn function accepting window object\n\t     */\n\t    Engine.nextTick = function nextTick(fn) {\n\t        nextTickQueue.push(fn);\n\t    };\n\t\n\t    /**\n\t     * Queue a function to be executed sometime soon, at a time that is\n\t     *    unlikely to affect frame rate.\n\t     *\n\t     * @static\n\t     * @method defer\n\t     *\n\t     * @param {Function} fn\n\t     */\n\t    Engine.defer = function defer(fn) {\n\t        deferQueue.push(fn);\n\t    };\n\t\n\t    optionsManager.on('change', function(data) {\n\t        if (data.id === 'fpsCap') Engine.setFPSCap(data.value);\n\t        else if (data.id === 'runLoop') {\n\t            // kick off the loop only if it was stopped\n\t            if (!loopEnabled && data.value) {\n\t                loopEnabled = true;\n\t                requestAnimationFrame(loop);\n\t            }\n\t        }\n\t    });\n\t\n\t    module.exports = Engine;\n\t}.call(exports, __webpack_require__, exports, module)), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n\n/***/ },\n/* 10 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_RESULT__;/* This Source Code Form is subject to the terms of the Mozilla Public\n\t * License, v. 2.0. If a copy of the MPL was not distributed with this\n\t * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n\t *\n\t * Owner: mark@famo.us\n\t * @license MPL 2.0\n\t * @copyright Famous Industries, Inc. 2014\n\t */\n\t\n\t!(__WEBPACK_AMD_DEFINE_RESULT__ = (function(require, exports, module) {\n\t    /**\n\t     * A singleton that maintains a global registry of Surfaces.\n\t     *   Private.\n\t     *\n\t     * @private\n\t     * @static\n\t     * @class Entity\n\t     */\n\t\n\t    var entities = [];\n\t\n\t    /**\n\t     * Get entity from global index.\n\t     *\n\t     * @private\n\t     * @method get\n\t     * @param {Number} id entity reigstration id\n\t     * @return {Surface} entity in the global index\n\t     */\n\t    function get(id) {\n\t        return entities[id];\n\t    }\n\t\n\t    /**\n\t     * Overwrite entity in the global index\n\t     *\n\t     * @private\n\t     * @method set\n\t     * @param {Number} id entity reigstration id\n\t     * @return {Surface} entity to add to the global index\n\t     */\n\t    function set(id, entity) {\n\t        entities[id] = entity;\n\t    }\n\t\n\t    /**\n\t     * Add entity to global index\n\t     *\n\t     * @private\n\t     * @method register\n\t     * @param {Surface} entity to add to global index\n\t     * @return {Number} new id\n\t     */\n\t    function register(entity) {\n\t        var id = entities.length;\n\t        set(id, entity);\n\t        return id;\n\t    }\n\t\n\t    /**\n\t     * Remove entity from global index\n\t     *\n\t     * @private\n\t     * @method unregister\n\t     * @param {Number} id entity reigstration id\n\t     */\n\t    function unregister(id) {\n\t        set(id, null);\n\t    }\n\t\n\t    module.exports = {\n\t        register: register,\n\t        unregister: unregister,\n\t        get: get,\n\t        set: set\n\t    };\n\t}.call(exports, __webpack_require__, exports, module)), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n\n/***/ },\n/* 11 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_RESULT__;/* This Source Code Form is subject to the terms of the Mozilla Public\n\t * License, v. 2.0. If a copy of the MPL was not distributed with this\n\t * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n\t *\n\t * Owner: mark@famo.us\n\t * @license MPL 2.0\n\t * @copyright Famous Industries, Inc. 2014\n\t */\n\t\n\t!(__WEBPACK_AMD_DEFINE_RESULT__ = (function(require, exports, module) {\n\t    var EventHandler = __webpack_require__(5);\n\t\n\t    /**\n\t     *  A collection of methods for setting options which can be extended\n\t     *  onto other classes.\n\t     *\n\t     *\n\t     *  **** WARNING ****\n\t     *  You can only pass through objects that will compile into valid JSON.\n\t     *\n\t     *  Valid options:\n\t     *      Strings,\n\t     *      Arrays,\n\t     *      Objects,\n\t     *      Numbers,\n\t     *      Nested Objects,\n\t     *      Nested Arrays.\n\t     *\n\t     *    This excludes:\n\t     *        Document Fragments,\n\t     *        Functions\n\t     * @class OptionsManager\n\t     * @constructor\n\t     * @param {Object} value options dictionary\n\t     */\n\t    function OptionsManager(value) {\n\t        this._value = value;\n\t        this.eventOutput = null;\n\t    }\n\t\n\t    /**\n\t     * Create options manager from source dictionary with arguments overriden by patch dictionary.\n\t     *\n\t     * @static\n\t     * @method OptionsManager.patch\n\t     *\n\t     * @param {Object} source source arguments\n\t     * @param {...Object} data argument additions and overwrites\n\t     * @return {Object} source object\n\t     */\n\t    OptionsManager.patch = function patchObject(source, data) {\n\t        var manager = new OptionsManager(source);\n\t        for (var i = 1; i < arguments.length; i++) manager.patch(arguments[i]);\n\t        return source;\n\t    };\n\t\n\t    function _createEventOutput() {\n\t        this.eventOutput = new EventHandler();\n\t        this.eventOutput.bindThis(this);\n\t        EventHandler.setOutputHandler(this, this.eventOutput);\n\t    }\n\t\n\t    /**\n\t     * Create OptionsManager from source with arguments overriden by patches.\n\t     *   Triggers 'change' event on this object's event handler if the state of\n\t     *   the OptionsManager changes as a result.\n\t     *\n\t     * @method patch\n\t     *\n\t     * @param {...Object} arguments list of patch objects\n\t     * @return {OptionsManager} this\n\t     */\n\t    OptionsManager.prototype.patch = function patch() {\n\t        var myState = this._value;\n\t        for (var i = 0; i < arguments.length; i++) {\n\t            var data = arguments[i];\n\t            for (var k in data) {\n\t                if ((k in myState) && (data[k] && data[k].constructor === Object) && (myState[k] && myState[k].constructor === Object)) {\n\t                    if (!myState.hasOwnProperty(k)) myState[k] = Object.create(myState[k]);\n\t                    this.key(k).patch(data[k]);\n\t                    if (this.eventOutput) this.eventOutput.emit('change', {id: k, value: this.key(k).value()});\n\t                }\n\t                else this.set(k, data[k]);\n\t            }\n\t        }\n\t        return this;\n\t    };\n\t\n\t    /**\n\t     * Alias for patch\n\t     *\n\t     * @method setOptions\n\t     *\n\t     */\n\t    OptionsManager.prototype.setOptions = OptionsManager.prototype.patch;\n\t\n\t    /**\n\t     * Return OptionsManager based on sub-object retrieved by key\n\t     *\n\t     * @method key\n\t     *\n\t     * @param {string} identifier key\n\t     * @return {OptionsManager} new options manager with the value\n\t     */\n\t    OptionsManager.prototype.key = function key(identifier) {\n\t        var result = new OptionsManager(this._value[identifier]);\n\t        if (!(result._value instanceof Object) || result._value instanceof Array) result._value = {};\n\t        return result;\n\t    };\n\t\n\t    /**\n\t     * Look up value by key\n\t     * @method get\n\t     *\n\t     * @param {string} key key\n\t     * @return {Object} associated object\n\t     */\n\t    OptionsManager.prototype.get = function get(key) {\n\t        return this._value[key];\n\t    };\n\t\n\t    /**\n\t     * Alias for get\n\t     * @method getOptions\n\t     */\n\t    OptionsManager.prototype.getOptions = OptionsManager.prototype.get;\n\t\n\t    /**\n\t     * Set key to value.  Outputs 'change' event if a value is overwritten.\n\t     *\n\t     * @method set\n\t     *\n\t     * @param {string} key key string\n\t     * @param {Object} value value object\n\t     * @return {OptionsManager} new options manager based on the value object\n\t     */\n\t    OptionsManager.prototype.set = function set(key, value) {\n\t        var originalValue = this.get(key);\n\t        this._value[key] = value;\n\t        if (this.eventOutput && value !== originalValue) this.eventOutput.emit('change', {id: key, value: value});\n\t        return this;\n\t    };\n\t\n\t    /**\n\t     * Return entire object contents of this OptionsManager.\n\t     *\n\t     * @method value\n\t     *\n\t     * @return {Object} current state of options\n\t     */\n\t    OptionsManager.prototype.value = function value() {\n\t        return this._value;\n\t    };\n\t\n\t    /**\n\t     * Bind a callback function to an event type handled by this object.\n\t     *\n\t     * @method \"on\"\n\t     *\n\t     * @param {string} type event type key (for example, 'change')\n\t     * @param {function(string, Object)} handler callback\n\t     * @return {EventHandler} this\n\t     */\n\t    OptionsManager.prototype.on = function on() {\n\t        _createEventOutput.call(this);\n\t        return this.on.apply(this, arguments);\n\t    };\n\t\n\t    /**\n\t     * Unbind an event by type and handler.\n\t     *   This undoes the work of \"on\".\n\t     *\n\t     * @method removeListener\n\t     *\n\t     * @param {string} type event type key (for example, 'change')\n\t     * @param {function} handler function object to remove\n\t     * @return {EventHandler} internal event handler object (for chaining)\n\t     */\n\t    OptionsManager.prototype.removeListener = function removeListener() {\n\t        _createEventOutput.call(this);\n\t        return this.removeListener.apply(this, arguments);\n\t    };\n\t\n\t    /**\n\t     * Add event handler object to set of downstream handlers.\n\t     *\n\t     * @method pipe\n\t     *\n\t     * @param {EventHandler} target event handler target object\n\t     * @return {EventHandler} passed event handler\n\t     */\n\t    OptionsManager.prototype.pipe = function pipe() {\n\t        _createEventOutput.call(this);\n\t        return this.pipe.apply(this, arguments);\n\t    };\n\t\n\t    /**\n\t     * Remove handler object from set of downstream handlers.\n\t     * Undoes work of \"pipe\"\n\t     *\n\t     * @method unpipe\n\t     *\n\t     * @param {EventHandler} target target handler object\n\t     * @return {EventHandler} provided target\n\t     */\n\t    OptionsManager.prototype.unpipe = function unpipe() {\n\t        _createEventOutput.call(this);\n\t        return this.unpipe.apply(this, arguments);\n\t    };\n\t\n\t    module.exports = OptionsManager;\n\t}.call(exports, __webpack_require__, exports, module)), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n\n/***/ },\n/* 12 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_RESULT__;/* This Source Code Form is subject to the terms of the Mozilla Public\n\t * License, v. 2.0. If a copy of the MPL was not distributed with this\n\t * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n\t *\n\t * Owner: mark@famo.us\n\t * @license MPL 2.0\n\t * @copyright Famous Industries, Inc. 2014\n\t */\n\t\n\t!(__WEBPACK_AMD_DEFINE_RESULT__ = (function(require, exports, module) {\n\t    var Entity = __webpack_require__(10);\n\t    var SpecParser = __webpack_require__(24);\n\t\n\t    /**\n\t     * A wrapper for inserting a renderable component (like a Modifer or\n\t     *   Surface) into the render tree.\n\t     *\n\t     * @class RenderNode\n\t     * @constructor\n\t     *\n\t     * @param {Object} object Target renderable component\n\t     */\n\t    function RenderNode(object) {\n\t        this._object = null;\n\t        this._child = null;\n\t        this._hasMultipleChildren = false;\n\t        this._isRenderable = false;\n\t        this._isModifier = false;\n\t\n\t        this._resultCache = {};\n\t        this._prevResults = {};\n\t\n\t        this._childResult = null;\n\t\n\t        if (object) this.set(object);\n\t    }\n\t\n\t    /**\n\t     * Append a renderable to the list of this node's children.\n\t     *   This produces a new RenderNode in the tree.\n\t     *   Note: Does not double-wrap if child is a RenderNode already.\n\t     *\n\t     * @method add\n\t     * @param {Object} child renderable object\n\t     * @return {RenderNode} new render node wrapping child\n\t     */\n\t    RenderNode.prototype.add = function add(child) {\n\t        var childNode = (child instanceof RenderNode) ? child : new RenderNode(child);\n\t        if (this._child instanceof Array) this._child.push(childNode);\n\t        else if (this._child) {\n\t            this._child = [this._child, childNode];\n\t            this._hasMultipleChildren = true;\n\t            this._childResult = []; // to be used later\n\t        }\n\t        else this._child = childNode;\n\t\n\t        return childNode;\n\t    };\n\t\n\t    /**\n\t     * Return the single wrapped object.  Returns null if this node has multiple child nodes.\n\t     *\n\t     * @method get\n\t     *\n\t     * @return {Ojbect} contained renderable object\n\t     */\n\t    RenderNode.prototype.get = function get() {\n\t        return this._object || (this._hasMultipleChildren ? null : (this._child ? this._child.get() : null));\n\t    };\n\t\n\t    /**\n\t     * Overwrite the list of children to contain the single provided object\n\t     *\n\t     * @method set\n\t     * @param {Object} child renderable object\n\t     * @return {RenderNode} this render node, or child if it is a RenderNode\n\t     */\n\t    RenderNode.prototype.set = function set(child) {\n\t        this._childResult = null;\n\t        this._hasMultipleChildren = false;\n\t        this._isRenderable = child.render ? true : false;\n\t        this._isModifier = child.modify ? true : false;\n\t        this._object = child;\n\t        this._child = null;\n\t        if (child instanceof RenderNode) return child;\n\t        else return this;\n\t    };\n\t\n\t    /**\n\t     * Get render size of contained object.\n\t     *\n\t     * @method getSize\n\t     * @return {Array.Number} size of this or size of single child.\n\t     */\n\t    RenderNode.prototype.getSize = function getSize() {\n\t        var result = null;\n\t        var target = this.get();\n\t        if (target && target.getSize) result = target.getSize();\n\t        if (!result && this._child && this._child.getSize) result = this._child.getSize();\n\t        return result;\n\t    };\n\t\n\t    // apply results of rendering this subtree to the document\n\t    function _applyCommit(spec, context, cacheStorage) {\n\t        var result = SpecParser.parse(spec, context);\n\t        var keys = Object.keys(result);\n\t        for (var i = 0; i < keys.length; i++) {\n\t            var id = keys[i];\n\t            var childNode = Entity.get(id);\n\t            var commitParams = result[id];\n\t            commitParams.allocator = context.allocator;\n\t            var commitResult = childNode.commit(commitParams);\n\t            if (commitResult) _applyCommit(commitResult, context, cacheStorage);\n\t            else cacheStorage[id] = commitParams;\n\t        }\n\t    }\n\t\n\t    /**\n\t     * Commit the content change from this node to the document.\n\t     *\n\t     * @private\n\t     * @method commit\n\t     * @param {Context} context render context\n\t     */\n\t    RenderNode.prototype.commit = function commit(context) {\n\t        // free up some divs from the last loop\n\t        var prevKeys = Object.keys(this._prevResults);\n\t        for (var i = 0; i < prevKeys.length; i++) {\n\t            var id = prevKeys[i];\n\t            if (this._resultCache[id] === undefined) {\n\t                var object = Entity.get(id);\n\t                if (object.cleanup) object.cleanup(context.allocator);\n\t            }\n\t        }\n\t\n\t        this._prevResults = this._resultCache;\n\t        this._resultCache = {};\n\t        _applyCommit(this.render(), context, this._resultCache);\n\t    };\n\t\n\t    /**\n\t     * Generate a render spec from the contents of the wrapped component.\n\t     *\n\t     * @private\n\t     * @method render\n\t     *\n\t     * @return {Object} render specification for the component subtree\n\t     *    only under this node.\n\t     */\n\t    RenderNode.prototype.render = function render() {\n\t        if (this._isRenderable) return this._object.render();\n\t\n\t        var result = null;\n\t        if (this._hasMultipleChildren) {\n\t            result = this._childResult;\n\t            var children = this._child;\n\t            for (var i = 0; i < children.length; i++) {\n\t                result[i] = children[i].render();\n\t            }\n\t        }\n\t        else if (this._child) result = this._child.render();\n\t\n\t        return this._isModifier ? this._object.modify(result) : result;\n\t    };\n\t\n\t    module.exports = RenderNode;\n\t}.call(exports, __webpack_require__, exports, module)), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n\n/***/ },\n/* 13 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_RESULT__;/* This Source Code Form is subject to the terms of the Mozilla Public\n\t * License, v. 2.0. If a copy of the MPL was not distributed with this\n\t * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n\t *\n\t * Owner: mark@famo.us\n\t * @license MPL 2.0\n\t * @copyright Famous Industries, Inc. 2014\n\t */\n\t\n\t!(__WEBPACK_AMD_DEFINE_RESULT__ = (function(require, exports, module) {\n\t    var Modifier = __webpack_require__(3);\n\t    var Transform = __webpack_require__(1);\n\t    var Transitionable = __webpack_require__(6);\n\t    var TransitionableTransform = __webpack_require__(15);\n\t\n\t    /**\n\t     *  A collection of visual changes to be\n\t     *    applied to another renderable component, strongly coupled with the state that defines\n\t     *    those changes. This collection includes a\n\t     *    transform matrix, an opacity constant, a size, an origin specifier.\n\t     *    StateModifier objects can be added to any RenderNode or object\n\t     *    capable of displaying renderables.  The StateModifier's children and descendants\n\t     *    are transformed by the amounts specified in the modifier's properties.\n\t     *\n\t     * @class StateModifier\n\t     * @constructor\n\t     * @param {Object} [options] overrides of default options\n\t     * @param {Transform} [options.transform] affine transformation matrix\n\t     * @param {Number} [options.opacity]\n\t     * @param {Array.Number} [options.origin] origin adjustment\n\t     * @param {Array.Number} [options.size] size to apply to descendants\n\t     */\n\t    function StateModifier(options) {\n\t        this._transformState = new TransitionableTransform(Transform.identity);\n\t        this._opacityState = new Transitionable(1);\n\t        this._originState = new Transitionable([0, 0]);\n\t        this._sizeState = new Transitionable([0, 0]);\n\t\n\t        this._modifier = new Modifier({\n\t            transform: this._transformState,\n\t            opacity: this._opacityState,\n\t            origin: null,\n\t            size: null\n\t        });\n\t\n\t        this._hasOrigin = false;\n\t        this._hasSize = false;\n\t\n\t        if (options) {\n\t            if (options.transform) this.setTransform(options.transform);\n\t            if (options.opacity !== undefined) this.setOpacity(options.opacity);\n\t            if (options.origin) this.setOrigin(options.origin);\n\t            if (options.size) this.setSize(options.size);\n\t        }\n\t    }\n\t\n\t    /**\n\t     * Set the transform matrix of this modifier, either statically or\n\t     *   through a provided Transitionable.\n\t     *\n\t     * @method setTransform\n\t     *\n\t     * @param {Transform} transform Transform to transition to.\n\t     * @param {Transitionable} [transition] Valid transitionable object\n\t     * @param {Function} [callback] callback to call after transition completes\n\t     * @return {StateModifier} this\n\t     */\n\t    StateModifier.prototype.setTransform = function setTransform(transform, transition, callback) {\n\t        this._transformState.set(transform, transition, callback);\n\t        return this;\n\t    };\n\t\n\t    /**\n\t     * Set the opacity of this modifier, either statically or\n\t     *   through a provided Transitionable.\n\t     *\n\t     * @method setOpacity\n\t     *\n\t     * @param {Number} opacity Opacity value to transition to.\n\t     * @param {Transitionable} transition Valid transitionable object\n\t     * @param {Function} callback callback to call after transition completes\n\t     * @return {StateModifier} this\n\t     */\n\t    StateModifier.prototype.setOpacity = function setOpacity(opacity, transition, callback) {\n\t        this._opacityState.set(opacity, transition, callback);\n\t        return this;\n\t    };\n\t\n\t    /**\n\t     * Set the origin of this modifier, either statically or\n\t     *   through a provided Transitionable.\n\t     *\n\t     * @method setOrigin\n\t     *\n\t     * @param {Array.Number} origin two element array with values between 0 and 1.\n\t     * @param {Transitionable} transition Valid transitionable object\n\t     * @param {Function} callback callback to call after transition completes\n\t     * @return {StateModifier} this\n\t     */\n\t    StateModifier.prototype.setOrigin = function setOrigin(origin, transition, callback) {\n\t        if (origin === null) {\n\t            if (this._hasOrigin) {\n\t                this._modifier.originFrom(null);\n\t                this._hasOrigin = false;\n\t            }\n\t            return this;\n\t        }\n\t        else if (!this._hasOrigin) {\n\t            this._hasOrigin = true;\n\t            this._modifier.originFrom(this._originState);\n\t        }\n\t        this._originState.set(origin, transition, callback);\n\t        return this;\n\t    };\n\t\n\t    /**\n\t     * Set the size of this modifier, either statically or\n\t     *   through a provided Transitionable.\n\t     *\n\t     * @method setSize\n\t     *\n\t     * @param {Array.Number} size two element array with values between 0 and 1.\n\t     * @param {Transitionable} transition Valid transitionable object\n\t     * @param {Function} callback callback to call after transition completes\n\t     * @return {StateModifier} this\n\t     */\n\t    StateModifier.prototype.setSize = function setSize(size, transition, callback) {\n\t        if (size === null) {\n\t            if (this._hasSize) {\n\t                this._modifier.sizeFrom(null);\n\t                this._hasSize = false;\n\t            }\n\t            return this;\n\t        }\n\t        else if (!this._hasSize) {\n\t            this._hasSize = true;\n\t            this._modifier.sizeFrom(this._sizeState);\n\t        }\n\t        this._sizeState.set(size, transition, callback);\n\t        return this;\n\t    };\n\t\n\t    /**\n\t     * Stop the transition.\n\t     *\n\t     * @method halt\n\t     */\n\t    StateModifier.prototype.halt = function halt() {\n\t        this._transformState.halt();\n\t        this._opacityState.halt();\n\t        this._originState.halt();\n\t        this._sizeState.halt();\n\t    };\n\t\n\t    /**\n\t     * Get the current state of the transform matrix component.\n\t     *\n\t     * @method getTransform\n\t     * @return {Object} transform provider object\n\t     */\n\t    StateModifier.prototype.getTransform = function getTransform() {\n\t        return this._transformState.get();\n\t    };\n\t\n\t    /**\n\t     * Get the destination state of the transform component.\n\t     *\n\t     * @method getFinalTransform\n\t     * @return {Transform} transform matrix\n\t     */\n\t    StateModifier.prototype.getFinalTransform = function getFinalTransform() {\n\t        return this._transformState.getFinal();\n\t    };\n\t\n\t    /**\n\t     * Get the current state of the opacity component.\n\t     *\n\t     * @method getOpacity\n\t     * @return {Object} opacity provider object\n\t     */\n\t    StateModifier.prototype.getOpacity = function getOpacity() {\n\t        return this._opacityState.get();\n\t    };\n\t\n\t    /**\n\t     * Get the current state of the origin component.\n\t     *\n\t     * @method getOrigin\n\t     * @return {Object} origin provider object\n\t     */\n\t    StateModifier.prototype.getOrigin = function getOrigin() {\n\t        return this._hasOrigin ? this._originState.get() : null;\n\t    };\n\t\n\t    /**\n\t     * Get the current state of the size component.\n\t     *\n\t     * @method getSize\n\t     * @return {Object} size provider object\n\t     */\n\t    StateModifier.prototype.getSize = function getSize() {\n\t        return this._hasSize ? this._sizeState.get() : null;\n\t    };\n\t\n\t    /**\n\t     * Return render spec for this StateModifier, applying to the provided\n\t     *    target component.  This is similar to render() for Surfaces.\n\t     *\n\t     * @private\n\t     * @method modify\n\t     *\n\t     * @param {Object} target (already rendered) render spec to\n\t     *    which to apply the transform.\n\t     * @return {Object} render spec for this StateModifier, including the\n\t     *    provided target\n\t     */\n\t    StateModifier.prototype.modify = function modify(target) {\n\t        return this._modifier.modify(target);\n\t    };\n\t\n\t    module.exports = StateModifier;\n\t}.call(exports, __webpack_require__, exports, module)), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n\n/***/ },\n/* 14 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_RESULT__;\n\t/* This Source Code Form is subject to the terms of the Mozilla Public\n\t * License, v. 2.0. If a copy of the MPL was not distributed with this\n\t * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n\t *\n\t * Owner: mark@famo.us\n\t * @license MPL 2.0\n\t * @copyright Famous Industries, Inc. 2014\n\t */\n\t\n\t!(__WEBPACK_AMD_DEFINE_RESULT__ = (function(require, exports, module) {\n\t    var Surface = __webpack_require__(2);\n\t\n\t    /**\n\t     * A surface containing image content.\n\t     *   This extends the Surface class.\n\t     *\n\t     * @class ImageSurface\n\t     *\n\t     * @extends Surface\n\t     * @constructor\n\t     * @param {Object} [options] overrides of default options\n\t     */\n\t    function ImageSurface(options) {\n\t        this._imageUrl = undefined;\n\t        Surface.apply(this, arguments);\n\t    }\n\t\n\t    ImageSurface.prototype = Object.create(Surface.prototype);\n\t    ImageSurface.prototype.constructor = ImageSurface;\n\t    ImageSurface.prototype.elementType = 'img';\n\t    ImageSurface.prototype.elementClass = 'famous-surface';\n\t\n\t    /**\n\t     * Set content URL.  This will cause a re-rendering.\n\t     * @method setContent\n\t     * @param {string} imageUrl\n\t     */\n\t    ImageSurface.prototype.setContent = function setContent(imageUrl) {\n\t        this._imageUrl = imageUrl;\n\t        this._contentDirty = true;\n\t    };\n\t\n\t    /**\n\t     * Place the document element that this component manages into the document.\n\t     *\n\t     * @private\n\t     * @method deploy\n\t     * @param {Node} target document parent of this container\n\t     */\n\t    ImageSurface.prototype.deploy = function deploy(target) {\n\t        target.src = this._imageUrl || '';\n\t    };\n\t\n\t    /**\n\t     * Remove this component and contained content from the document\n\t     *\n\t     * @private\n\t     * @method recall\n\t     *\n\t     * @param {Node} target node to which the component was deployed\n\t     */\n\t    ImageSurface.prototype.recall = function recall(target) {\n\t        target.src = '';\n\t    };\n\t\n\t    module.exports = ImageSurface;\n\t}.call(exports, __webpack_require__, exports, module)), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n\n/***/ },\n/* 15 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_RESULT__;/* This Source Code Form is subject to the terms of the Mozilla Public\n\t * License, v. 2.0. If a copy of the MPL was not distributed with this\n\t * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n\t *\n\t * Owner: david@famo.us\n\t * @license MPL 2.0\n\t * @copyright Famous Industries, Inc. 2014\n\t */\n\t\n\t!(__WEBPACK_AMD_DEFINE_RESULT__ = (function(require, exports, module) {\n\t    var Transitionable = __webpack_require__(6);\n\t    var Transform = __webpack_require__(1);\n\t    var Utility = __webpack_require__(7);\n\t\n\t    /**\n\t     * A class for transitioning the state of a Transform by transitioning\n\t     * its translate, scale, skew and rotate components independently.\n\t     *\n\t     * @class TransitionableTransform\n\t     * @constructor\n\t     *\n\t     * @param [transform=Transform.identity] {Transform} The initial transform state\n\t     */\n\t    function TransitionableTransform(transform) {\n\t        this._final = Transform.identity.slice();\n\t        this.translate = new Transitionable([0, 0, 0]);\n\t        this.rotate = new Transitionable([0, 0, 0]);\n\t        this.skew = new Transitionable([0, 0, 0]);\n\t        this.scale = new Transitionable([1, 1, 1]);\n\t\n\t        if (transform) this.set(transform);\n\t    }\n\t\n\t    function _build() {\n\t        return Transform.build({\n\t            translate: this.translate.get(),\n\t            rotate: this.rotate.get(),\n\t            skew: this.skew.get(),\n\t            scale: this.scale.get()\n\t        });\n\t    }\n\t\n\t    /**\n\t     * An optimized way of setting only the translation component of a Transform\n\t     *\n\t     * @method setTranslate\n\t     * @chainable\n\t     *\n\t     * @param translate {Array}     New translation state\n\t     * @param [transition] {Object} Transition definition\n\t     * @param [callback] {Function} Callback\n\t     * @return {TransitionableTransform}\n\t     */\n\t    TransitionableTransform.prototype.setTranslate = function setTranslate(translate, transition, callback) {\n\t        this.translate.set(translate, transition, callback);\n\t        this._final = this._final.slice();\n\t        this._final[12] = translate[0];\n\t        this._final[13] = translate[1];\n\t        if (translate[2] !== undefined) this._final[14] = translate[2];\n\t        return this;\n\t    };\n\t\n\t    /**\n\t     * An optimized way of setting only the scale component of a Transform\n\t     *\n\t     * @method setTranslate\n\t     * @chainable\n\t     *\n\t     * @param scale {Array}         New scale state\n\t     * @param [transition] {Object} Transition definition\n\t     * @param [callback] {Function} Callback\n\t     * @return {TransitionableTransform}\n\t     */\n\t    TransitionableTransform.prototype.setScale = function setScale(scale, transition, callback) {\n\t        this.scale.set(scale, transition, callback);\n\t        this._final = this._final.slice();\n\t        this._final[0] = scale[0];\n\t        this._final[5] = scale[1];\n\t        if (scale[2] !== undefined) this._final[10] = scale[2];\n\t        return this;\n\t    };\n\t\n\t    /**\n\t     * An optimized way of setting only the rotational component of a Transform\n\t     *\n\t     * @method setTranslate\n\t     * @chainable\n\t     *\n\t     * @param eulerAngles {Array}   Euler angles for new rotation state\n\t     * @param [transition] {Object} Transition definition\n\t     * @param [callback] {Function} Callback\n\t     * @return {TransitionableTransform}\n\t     */\n\t    TransitionableTransform.prototype.setRotate = function setRotate(eulerAngles, transition, callback) {\n\t        this.rotate.set(eulerAngles, transition, callback);\n\t        this._final = _build.call(this);\n\t        this._final = Transform.build({\n\t            translate: this.translate.get(),\n\t            rotate: eulerAngles,\n\t            scale: this.scale.get(),\n\t            skew: this.skew.get()\n\t        });\n\t        return this;\n\t    };\n\t\n\t    /**\n\t     * An optimized way of setting only the skew component of a Transform\n\t     *\n\t     * @method setTranslate\n\t     * @chainable\n\t     *\n\t     * @param skewAngles {Array}    New skew state\n\t     * @param [transition] {Object} Transition definition\n\t     * @param [callback] {Function} Callback\n\t     * @return {TransitionableTransform}\n\t     */\n\t    TransitionableTransform.prototype.setSkew = function setSkew(skewAngles, transition, callback) {\n\t        this.skew.set(skewAngles, transition, callback);\n\t        this._final = Transform.build({\n\t            translate: this.translate.get(),\n\t            rotate: this.rotate.get(),\n\t            scale: this.scale.get(),\n\t            skew: skewAngles\n\t        });\n\t        return this;\n\t    };\n\t\n\t    /**\n\t     * Setter for a TransitionableTransform with optional parameters to transition\n\t     * between Transforms\n\t     *\n\t     * @method setTranslate\n\t     * @chainable\n\t     *\n\t     * @param transform {Array}     New transform state\n\t     * @param [transition] {Object} Transition definition\n\t     * @param [callback] {Function} Callback\n\t     * @return {TransitionableTransform}\n\t     */\n\t    TransitionableTransform.prototype.set = function set(transform, transition, callback) {\n\t        this._final = transform;\n\t        var components = Transform.interpret(transform);\n\t\n\t        var _callback = callback ? Utility.after(4, callback) : null;\n\t        this.translate.set(components.translate, transition, _callback);\n\t        this.rotate.set(components.rotate, transition, _callback);\n\t        this.skew.set(components.skew, transition, _callback);\n\t        this.scale.set(components.scale, transition, _callback);\n\t        return this;\n\t    };\n\t\n\t    /**\n\t     * Sets the default transition to use for transitioning betwen Transform states\n\t     *\n\t     * @method setDefaultTransition\n\t     *\n\t     * @param transition {Object} Transition definition\n\t     */\n\t    TransitionableTransform.prototype.setDefaultTransition = function setDefaultTransition(transition) {\n\t        this.translate.setDefault(transition);\n\t        this.rotate.setDefault(transition);\n\t        this.skew.setDefault(transition);\n\t        this.scale.setDefault(transition);\n\t    };\n\t\n\t    /**\n\t     * Getter. Returns the current state of the Transform\n\t     *\n\t     * @method get\n\t     *\n\t     * @return {Transform}\n\t     */\n\t    TransitionableTransform.prototype.get = function get() {\n\t        if (this.isActive()) {\n\t            return _build.call(this);\n\t        }\n\t        else return this._final;\n\t    };\n\t\n\t    /**\n\t     * Get the destination state of the Transform\n\t     *\n\t     * @method getFinal\n\t     *\n\t     * @return Transform {Transform}\n\t     */\n\t    TransitionableTransform.prototype.getFinal = function getFinal() {\n\t        return this._final;\n\t    };\n\t\n\t    /**\n\t     * Determine if the TransitionalTransform is currently transitioning\n\t     *\n\t     * @method isActive\n\t     *\n\t     * @return {Boolean}\n\t     */\n\t    TransitionableTransform.prototype.isActive = function isActive() {\n\t        return this.translate.isActive() || this.rotate.isActive() || this.scale.isActive() || this.skew.isActive();\n\t    };\n\t\n\t    /**\n\t     * Halts the transition\n\t     *\n\t     * @method halt\n\t     */\n\t    TransitionableTransform.prototype.halt = function halt() {\n\t        this._final = this.get();\n\t        this.translate.halt();\n\t        this.rotate.halt();\n\t        this.skew.halt();\n\t        this.scale.halt();\n\t    };\n\t\n\t    module.exports = TransitionableTransform;\n\t}.call(exports, __webpack_require__, exports, module)), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n\n/***/ },\n/* 16 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_RESULT__;/* This Source Code Form is subject to the terms of the Mozilla Public\n\t * License, v. 2.0. If a copy of the MPL was not distributed with this\n\t * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n\t *\n\t * Owner: mark@famo.us\n\t * @license MPL 2.0\n\t * @copyright Famous Industries, Inc. 2014\n\t */\n\t// TODO fix func-style\n\t/*eslint func-style: [0, \"declaration\"] */\n\t\n\t!(__WEBPACK_AMD_DEFINE_RESULT__ = (function(require, exports, module) {\n\t    /**\n\t     * An internal library to reproduce javascript time-based scheduling.\n\t     *   Using standard javascript setTimeout methods can have a negative performance impact\n\t     *   when combined with the Famous rendering process, so instead require Timer and call\n\t     *   Timer.setTimeout, Timer.setInterval, etc.\n\t     *\n\t     * @class Timer\n\t     * @constructor\n\t     */\n\t    var FamousEngine = __webpack_require__(9);\n\t\n\t    var _event  = 'prerender';\n\t\n\t    var getTime = (window.performance) ?\n\t        function() {\n\t            return window.performance.now();\n\t        }\n\t        : function() {\n\t            return Date.now();\n\t        };\n\t\n\t    /**\n\t     * Add a function to be run on every prerender\n\t     *\n\t     * @method addTimerFunction\n\t     *\n\t     * @param {function} fn function to be run every prerender\n\t     *\n\t     * @return {function} function passed in as parameter\n\t     */\n\t    function addTimerFunction(fn) {\n\t        FamousEngine.on(_event, fn);\n\t        return fn;\n\t    }\n\t\n\t    /**\n\t     * Wraps a function to be invoked after a certain amount of time.\n\t     *  After a set duration has passed, it executes the function and\n\t     *  removes it as a listener to 'prerender'.\n\t     *\n\t     * @method setTimeout\n\t     *\n\t     * @param {function} fn function to be run after a specified duration\n\t     * @param {number} duration milliseconds from now to execute the function\n\t     *\n\t     * @return {function} function passed in as parameter\n\t     */\n\t    function setTimeout(fn, duration) {\n\t        var t = getTime();\n\t        var callback = function() {\n\t            var t2 = getTime();\n\t            if (t2 - t >= duration) {\n\t                fn.apply(this, arguments);\n\t                FamousEngine.removeListener(_event, callback);\n\t            }\n\t        };\n\t        return addTimerFunction(callback);\n\t    }\n\t\n\t    /**\n\t     * Wraps a function to be invoked after a certain amount of time.\n\t     *  After a set duration has passed, it executes the function and\n\t     *  resets the execution time.\n\t     *\n\t     * @method setInterval\n\t     *\n\t     * @param {function} fn function to be run after a specified duration\n\t     * @param {number} duration interval to execute function in milliseconds\n\t     *\n\t     * @return {function} function passed in as parameter\n\t     */\n\t    function setInterval(fn, duration) {\n\t        var t = getTime();\n\t        var callback = function() {\n\t            var t2 = getTime();\n\t            if (t2 - t >= duration) {\n\t                fn.apply(this, arguments);\n\t                t = getTime();\n\t            }\n\t        };\n\t        return addTimerFunction(callback);\n\t    }\n\t\n\t    /**\n\t     * Wraps a function to be invoked after a certain amount of prerender ticks.\n\t     *  Similar use to setTimeout but tied to the engine's run speed.\n\t     *\n\t     * @method after\n\t     *\n\t     * @param {function} fn function to be run after a specified amount of ticks\n\t     * @param {number} numTicks number of prerender frames to wait\n\t     *\n\t     * @return {function} function passed in as parameter\n\t     */\n\t    function after(fn, numTicks) {\n\t        if (numTicks === undefined) return undefined;\n\t        var callback = function() {\n\t            numTicks--;\n\t            if (numTicks <= 0) { //in case numTicks is fraction or negative\n\t                fn.apply(this, arguments);\n\t                clear(callback);\n\t            }\n\t        };\n\t        return addTimerFunction(callback);\n\t    }\n\t\n\t    /**\n\t     * Wraps a function to be continually invoked after a certain amount of prerender ticks.\n\t     *  Similar use to setInterval but tied to the engine's run speed.\n\t     *\n\t     * @method every\n\t     *\n\t     * @param {function} fn function to be run after a specified amount of ticks\n\t     * @param {number} numTicks number of prerender frames to wait\n\t     *\n\t     * @return {function} function passed in as parameter\n\t     */\n\t    function every(fn, numTicks) {\n\t        numTicks = numTicks || 1;\n\t        var initial = numTicks;\n\t        var callback = function() {\n\t            numTicks--;\n\t            if (numTicks <= 0) { //in case numTicks is fraction or negative\n\t                fn.apply(this, arguments);\n\t                numTicks = initial;\n\t            }\n\t        };\n\t        return addTimerFunction(callback);\n\t    }\n\t\n\t    /**\n\t     * Remove a function that gets called every prerender\n\t     *\n\t     * @method clear\n\t     *\n\t     * @param {function} fn event linstener\n\t     */\n\t    function clear(fn) {\n\t        FamousEngine.removeListener(_event, fn);\n\t    }\n\t\n\t    /**\n\t     * Executes a function after a certain amount of time. Makes sure\n\t     *  the function is not run multiple times.\n\t     *\n\t     * @method debounce\n\t     *\n\t     * @param {function} func function to run after certain amount of time\n\t     * @param {number} wait amount of time\n\t     *\n\t     * @return {function} function that is not able to debounce\n\t     */\n\t    function debounce(func, wait) {\n\t        var timeout;\n\t        var ctx;\n\t        var timestamp;\n\t        var result;\n\t        var args;\n\t        return function() {\n\t            ctx = this;\n\t            args = arguments;\n\t            timestamp = getTime();\n\t\n\t            var fn = function() {\n\t                var last = getTime - timestamp;\n\t\n\t                if (last < wait) {\n\t                    timeout = setTimeout(fn, wait - last);\n\t                } else {\n\t                    timeout = null;\n\t                    result = func.apply(ctx, args);\n\t                }\n\t            };\n\t\n\t            if (!timeout) {\n\t                timeout = setTimeout(fn, wait);\n\t            }\n\t\n\t            return result;\n\t        };\n\t    }\n\t\n\t    module.exports = {\n\t        setTimeout : setTimeout,\n\t        setInterval : setInterval,\n\t        debounce : debounce,\n\t        after : after,\n\t        every : every,\n\t        clear : clear\n\t    };\n\t\n\t}.call(exports, __webpack_require__, exports, module)), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n\n/***/ },\n/* 17 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar Question,\n\t  __hasProp = {}.hasOwnProperty,\n\t  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };\n\t\n\tQuestion = (function(_super) {\n\t  __extends(Question, _super);\n\t\n\t  function Question() {\n\t    return Question.__super__.constructor.apply(this, arguments);\n\t  }\n\t\n\t  Question.prototype.defaults = {\n\t    question: '',\n\t    mood: ''\n\t  };\n\t\n\t  Question.prototype.className = \"Sets\";\n\t\n\t  return Question;\n\t\n\t})(Parse.Object);\n\t\n\tmodule.exports = Question;\n\n\n/***/ },\n/* 18 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t/*\n\t * classList.js: Cross-browser full element.classList implementation.\n\t * 2011-06-15\n\t *\n\t * By Eli Grey, http://eligrey.com\n\t * Public Domain.\n\t * NO WARRANTY EXPRESSED OR IMPLIED. USE AT YOUR OWN RISK.\n\t */\n\t\n\t/*global self, document, DOMException */\n\t\n\t/*! @source http://purl.eligrey.com/github/classList.js/blob/master/classList.js*/\n\t\n\tif (typeof document !== \"undefined\" && !(\"classList\" in document.createElement(\"a\"))) {\n\t\n\t(function (view) {\n\t\n\t\"use strict\";\n\t\n\tvar\n\t      classListProp = \"classList\"\n\t    , protoProp = \"prototype\"\n\t    , elemCtrProto = (view.HTMLElement || view.Element)[protoProp]\n\t    , objCtr = Object\n\t    , strTrim = String[protoProp].trim || function () {\n\t        return this.replace(/^\\s+|\\s+$/g, \"\");\n\t    }\n\t    , arrIndexOf = Array[protoProp].indexOf || function (item) {\n\t        var\n\t              i = 0\n\t            , len = this.length\n\t        ;\n\t        for (; i < len; i++) {\n\t            if (i in this && this[i] === item) {\n\t                return i;\n\t            }\n\t        }\n\t        return -1;\n\t    }\n\t    // Vendors: please allow content code to instantiate DOMExceptions\n\t    , DOMEx = function (type, message) {\n\t        this.name = type;\n\t        this.code = DOMException[type];\n\t        this.message = message;\n\t    }\n\t    , checkTokenAndGetIndex = function (classList, token) {\n\t        if (token === \"\") {\n\t            throw new DOMEx(\n\t                  \"SYNTAX_ERR\"\n\t                , \"An invalid or illegal string was specified\"\n\t            );\n\t        }\n\t        if (/\\s/.test(token)) {\n\t            throw new DOMEx(\n\t                  \"INVALID_CHARACTER_ERR\"\n\t                , \"String contains an invalid character\"\n\t            );\n\t        }\n\t        return arrIndexOf.call(classList, token);\n\t    }\n\t    , ClassList = function (elem) {\n\t        var\n\t              trimmedClasses = strTrim.call(elem.className)\n\t            , classes = trimmedClasses ? trimmedClasses.split(/\\s+/) : []\n\t            , i = 0\n\t            , len = classes.length\n\t        ;\n\t        for (; i < len; i++) {\n\t            this.push(classes[i]);\n\t        }\n\t        this._updateClassName = function () {\n\t            elem.className = this.toString();\n\t        };\n\t    }\n\t    , classListProto = ClassList[protoProp] = []\n\t    , classListGetter = function () {\n\t        return new ClassList(this);\n\t    }\n\t;\n\t// Most DOMException implementations don't allow calling DOMException's toString()\n\t// on non-DOMExceptions. Error's toString() is sufficient here.\n\tDOMEx[protoProp] = Error[protoProp];\n\tclassListProto.item = function (i) {\n\t    return this[i] || null;\n\t};\n\tclassListProto.contains = function (token) {\n\t    token += \"\";\n\t    return checkTokenAndGetIndex(this, token) !== -1;\n\t};\n\tclassListProto.add = function (token) {\n\t    token += \"\";\n\t    if (checkTokenAndGetIndex(this, token) === -1) {\n\t        this.push(token);\n\t        this._updateClassName();\n\t    }\n\t};\n\tclassListProto.remove = function (token) {\n\t    token += \"\";\n\t    var index = checkTokenAndGetIndex(this, token);\n\t    if (index !== -1) {\n\t        this.splice(index, 1);\n\t        this._updateClassName();\n\t    }\n\t};\n\tclassListProto.toggle = function (token) {\n\t    token += \"\";\n\t    if (checkTokenAndGetIndex(this, token) === -1) {\n\t        this.add(token);\n\t    } else {\n\t        this.remove(token);\n\t    }\n\t};\n\tclassListProto.toString = function () {\n\t    return this.join(\" \");\n\t};\n\t\n\tif (objCtr.defineProperty) {\n\t    var classListPropDesc = {\n\t          get: classListGetter\n\t        , enumerable: true\n\t        , configurable: true\n\t    };\n\t    try {\n\t        objCtr.defineProperty(elemCtrProto, classListProp, classListPropDesc);\n\t    } catch (ex) { // IE 8 doesn't support enumerable:true\n\t        if (ex.number === -0x7FF5EC54) {\n\t            classListPropDesc.enumerable = false;\n\t            objCtr.defineProperty(elemCtrProto, classListProp, classListPropDesc);\n\t        }\n\t    }\n\t} else if (objCtr[protoProp].__defineGetter__) {\n\t    elemCtrProto.__defineGetter__(classListProp, classListGetter);\n\t}\n\t\n\t}(self));\n\t\n\t}\n\n\n/***/ },\n/* 19 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tif (!Function.prototype.bind) {\n\t    Function.prototype.bind = function (oThis) {\n\t        if (typeof this !== \"function\") {\n\t            // closest thing possible to the ECMAScript 5 internal IsCallable function\n\t            throw new TypeError(\"Function.prototype.bind - what is trying to be bound is not callable\");\n\t        }\n\t\n\t        var aArgs = Array.prototype.slice.call(arguments, 1),\n\t        fToBind = this,\n\t        fNOP = function () {},\n\t        fBound = function () {\n\t            return fToBind.apply(this instanceof fNOP && oThis\n\t                ? this\n\t                : oThis,\n\t                aArgs.concat(Array.prototype.slice.call(arguments)));\n\t        };\n\t\n\t        fNOP.prototype = this.prototype;\n\t        fBound.prototype = new fNOP();\n\t\n\t        return fBound;\n\t    };\n\t}\n\n\n/***/ },\n/* 20 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// adds requestAnimationFrame functionality\n\t// Source: http://strd6.com/2011/05/better-window-requestanimationframe-shim/\n\t\n\twindow.requestAnimationFrame || (window.requestAnimationFrame =\n\t  window.webkitRequestAnimationFrame ||\n\t  window.mozRequestAnimationFrame    ||\n\t  window.oRequestAnimationFrame      ||\n\t  window.msRequestAnimationFrame     ||\n\t  function(callback, element) {\n\t    return window.setTimeout(function() {\n\t      callback(+new Date());\n\t  }, 1000 / 60);\n\t});\n\n\n/***/ },\n/* 21 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_RESULT__;/* This Source Code Form is subject to the terms of the Mozilla Public\n\t * License, v. 2.0. If a copy of the MPL was not distributed with this\n\t * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n\t *\n\t * Owner: mark@famo.us\n\t * @license MPL 2.0\n\t * @copyright Famous Industries, Inc. 2014\n\t */\n\t\n\t!(__WEBPACK_AMD_DEFINE_RESULT__ = (function(require, exports, module) {\n\t    var RenderNode = __webpack_require__(12);\n\t    var EventHandler = __webpack_require__(5);\n\t    var ElementAllocator = __webpack_require__(22);\n\t    var Transform = __webpack_require__(1);\n\t    var Transitionable = __webpack_require__(6);\n\t\n\t    var _originZeroZero = [0, 0];\n\t\n\t    function _getElementSize(element) {\n\t        return [element.clientWidth, element.clientHeight];\n\t    }\n\t\n\t    /**\n\t     * The top-level container for a Famous-renderable piece of the document.\n\t     *   It is directly updated by the process-wide Engine object, and manages one\n\t     *   render tree root, which can contain other renderables.\n\t     *\n\t     * @class Context\n\t     * @constructor\n\t     * @private\n\t     * @param {Node} container Element in which content will be inserted\n\t     */\n\t    function Context(container) {\n\t        this.container = container;\n\t        this._allocator = new ElementAllocator(container);\n\t\n\t        this._node = new RenderNode();\n\t        this._eventOutput = new EventHandler();\n\t        this._size = _getElementSize(this.container);\n\t\n\t        this._perspectiveState = new Transitionable(0);\n\t        this._perspective = undefined;\n\t\n\t        this._nodeContext = {\n\t            allocator: this._allocator,\n\t            transform: Transform.identity,\n\t            opacity: 1,\n\t            origin: _originZeroZero,\n\t            size: this._size\n\t        };\n\t\n\t        this._eventOutput.on('resize', function() {\n\t            this.setSize(_getElementSize(this.container));\n\t        }.bind(this));\n\t\n\t    }\n\t\n\t    // Note: Unused\n\t    Context.prototype.getAllocator = function getAllocator() {\n\t        return this._allocator;\n\t    };\n\t\n\t    /**\n\t     * Add renderables to this Context's render tree.\n\t     *\n\t     * @method add\n\t     *\n\t     * @param {Object} obj renderable object\n\t     * @return {RenderNode} RenderNode wrapping this object, if not already a RenderNode\n\t     */\n\t    Context.prototype.add = function add(obj) {\n\t        return this._node.add(obj);\n\t    };\n\t\n\t    /**\n\t     * Move this Context to another containing document element.\n\t     *\n\t     * @method migrate\n\t     *\n\t     * @param {Node} container Element to which content will be migrated\n\t     */\n\t    Context.prototype.migrate = function migrate(container) {\n\t        if (container === this.container) return;\n\t        this.container = container;\n\t        this._allocator.migrate(container);\n\t    };\n\t\n\t    /**\n\t     * Gets viewport size for Context.\n\t     *\n\t     * @method getSize\n\t     *\n\t     * @return {Array.Number} viewport size as [width, height]\n\t     */\n\t    Context.prototype.getSize = function getSize() {\n\t        return this._size;\n\t    };\n\t\n\t    /**\n\t     * Sets viewport size for Context.\n\t     *\n\t     * @method setSize\n\t     *\n\t     * @param {Array.Number} size [width, height].  If unspecified, use size of root document element.\n\t     */\n\t    Context.prototype.setSize = function setSize(size) {\n\t        if (!size) size = _getElementSize(this.container);\n\t        this._size[0] = size[0];\n\t        this._size[1] = size[1];\n\t    };\n\t\n\t    /**\n\t     * Commit this Context's content changes to the document.\n\t     *\n\t     * @private\n\t     * @method update\n\t     * @param {Object} contextParameters engine commit specification\n\t     */\n\t    Context.prototype.update = function update(contextParameters) {\n\t        if (contextParameters) {\n\t            if (contextParameters.transform) this._nodeContext.transform = contextParameters.transform;\n\t            if (contextParameters.opacity) this._nodeContext.opacity = contextParameters.opacity;\n\t            if (contextParameters.origin) this._nodeContext.origin = contextParameters.origin;\n\t            if (contextParameters.size) this._nodeContext.size = contextParameters.size;\n\t        }\n\t        var perspective = this._perspectiveState.get();\n\t        if (perspective !== this._perspective) {\n\t            this.container.style.perspective = perspective ? perspective.toFixed() + 'px' : '';\n\t            this.container.style.webkitPerspective = perspective ? perspective.toFixed() : '';\n\t            this._perspective = perspective;\n\t        }\n\t\n\t        this._node.commit(this._nodeContext);\n\t    };\n\t\n\t    /**\n\t     * Get current perspective of this context in pixels.\n\t     *\n\t     * @method getPerspective\n\t     * @return {Number} depth perspective in pixels\n\t     */\n\t    Context.prototype.getPerspective = function getPerspective() {\n\t        return this._perspectiveState.get();\n\t    };\n\t\n\t    /**\n\t     * Set current perspective of this context in pixels.\n\t     *\n\t     * @method setPerspective\n\t     * @param {Number} perspective in pixels\n\t     * @param {Object} [transition] Transitionable object for applying the change\n\t     * @param {function(Object)} callback function called on completion of transition\n\t     */\n\t    Context.prototype.setPerspective = function setPerspective(perspective, transition, callback) {\n\t        return this._perspectiveState.set(perspective, transition, callback);\n\t    };\n\t\n\t    /**\n\t     * Trigger an event, sending to all downstream handlers\n\t     *   listening for provided 'type' key.\n\t     *\n\t     * @method emit\n\t     *\n\t     * @param {string} type event type key (for example, 'click')\n\t     * @param {Object} event event data\n\t     * @return {EventHandler} this\n\t     */\n\t    Context.prototype.emit = function emit(type, event) {\n\t        return this._eventOutput.emit(type, event);\n\t    };\n\t\n\t    /**\n\t     * Bind a callback function to an event type handled by this object.\n\t     *\n\t     * @method \"on\"\n\t     *\n\t     * @param {string} type event type key (for example, 'click')\n\t     * @param {function(string, Object)} handler callback\n\t     * @return {EventHandler} this\n\t     */\n\t    Context.prototype.on = function on(type, handler) {\n\t        return this._eventOutput.on(type, handler);\n\t    };\n\t\n\t    /**\n\t     * Unbind an event by type and handler.\n\t     *   This undoes the work of \"on\".\n\t     *\n\t     * @method removeListener\n\t     *\n\t     * @param {string} type event type key (for example, 'click')\n\t     * @param {function} handler function object to remove\n\t     * @return {EventHandler} internal event handler object (for chaining)\n\t     */\n\t    Context.prototype.removeListener = function removeListener(type, handler) {\n\t        return this._eventOutput.removeListener(type, handler);\n\t    };\n\t\n\t    /**\n\t     * Add event handler object to set of downstream handlers.\n\t     *\n\t     * @method pipe\n\t     *\n\t     * @param {EventHandler} target event handler target object\n\t     * @return {EventHandler} passed event handler\n\t     */\n\t    Context.prototype.pipe = function pipe(target) {\n\t        return this._eventOutput.pipe(target);\n\t    };\n\t\n\t    /**\n\t     * Remove handler object from set of downstream handlers.\n\t     *   Undoes work of \"pipe\".\n\t     *\n\t     * @method unpipe\n\t     *\n\t     * @param {EventHandler} target target handler object\n\t     * @return {EventHandler} provided target\n\t     */\n\t    Context.prototype.unpipe = function unpipe(target) {\n\t        return this._eventOutput.unpipe(target);\n\t    };\n\t\n\t    module.exports = Context;\n\t}.call(exports, __webpack_require__, exports, module)), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n\n/***/ },\n/* 22 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_RESULT__;/* This Source Code Form is subject to the terms of the Mozilla Public\n\t * License, v. 2.0. If a copy of the MPL was not distributed with this\n\t * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n\t *\n\t * Owner: mark@famo.us\n\t * @license MPL 2.0\n\t * @copyright Famous Industries, Inc. 2014\n\t */\n\t\n\t!(__WEBPACK_AMD_DEFINE_RESULT__ = (function(require, exports, module) {\n\t\n\t    /**\n\t     * Internal helper object to Context that handles the process of\n\t     *   creating and allocating DOM elements within a managed div.\n\t     *   Private.\n\t     *\n\t     * @class ElementAllocator\n\t     * @constructor\n\t     * @private\n\t     * @param {Node} container document element in which Famo.us content will be inserted\n\t     */\n\t    function ElementAllocator(container) {\n\t        if (!container) container = document.createDocumentFragment();\n\t        this.container = container;\n\t        this.detachedNodes = {};\n\t        this.nodeCount = 0;\n\t    }\n\t\n\t    /**\n\t     * Move the document elements from their original container to a new one.\n\t     *\n\t     * @private\n\t     * @method migrate\n\t     *\n\t     * @param {Node} container document element to which Famo.us content will be migrated\n\t     */\n\t    ElementAllocator.prototype.migrate = function migrate(container) {\n\t        var oldContainer = this.container;\n\t        if (container === oldContainer) return;\n\t\n\t        if (oldContainer instanceof DocumentFragment) {\n\t            container.appendChild(oldContainer);\n\t        }\n\t        else {\n\t            while (oldContainer.hasChildNodes()) {\n\t                container.appendChild(oldContainer.removeChild(oldContainer.firstChild));\n\t            }\n\t        }\n\t\n\t        this.container = container;\n\t    };\n\t\n\t    /**\n\t     * Allocate an element of specified type from the pool.\n\t     *\n\t     * @private\n\t     * @method allocate\n\t     *\n\t     * @param {string} type type of element, e.g. 'div'\n\t     * @return {Node} allocated document element\n\t     */\n\t    ElementAllocator.prototype.allocate = function allocate(type) {\n\t        type = type.toLowerCase();\n\t        if (!(type in this.detachedNodes)) this.detachedNodes[type] = [];\n\t        var nodeStore = this.detachedNodes[type];\n\t        var result;\n\t        if (nodeStore.length > 0) {\n\t            result = nodeStore.pop();\n\t        }\n\t        else {\n\t            result = document.createElement(type);\n\t            this.container.appendChild(result);\n\t        }\n\t        this.nodeCount++;\n\t        return result;\n\t    };\n\t\n\t    /**\n\t     * De-allocate an element of specified type to the pool.\n\t     *\n\t     * @private\n\t     * @method deallocate\n\t     *\n\t     * @param {Node} element document element to deallocate\n\t     */\n\t    ElementAllocator.prototype.deallocate = function deallocate(element) {\n\t        var nodeType = element.nodeName.toLowerCase();\n\t        var nodeStore = this.detachedNodes[nodeType];\n\t        nodeStore.push(element);\n\t        this.nodeCount--;\n\t    };\n\t\n\t    /**\n\t     * Get count of total allocated nodes in the document.\n\t     *\n\t     * @private\n\t     * @method getNodeCount\n\t     *\n\t     * @return {Number} total node count\n\t     */\n\t    ElementAllocator.prototype.getNodeCount = function getNodeCount() {\n\t        return this.nodeCount;\n\t    };\n\t\n\t    module.exports = ElementAllocator;\n\t}.call(exports, __webpack_require__, exports, module)), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n\n/***/ },\n/* 23 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_RESULT__;/* This Source Code Form is subject to the terms of the Mozilla Public\n\t * License, v. 2.0. If a copy of the MPL was not distributed with this\n\t * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n\t *\n\t * Owner: mark@famo.us\n\t * @license MPL 2.0\n\t * @copyright Famous Industries, Inc. 2014\n\t */\n\t\n\t!(__WEBPACK_AMD_DEFINE_RESULT__ = (function(require, exports, module) {\n\t    /**\n\t     * EventEmitter represents a channel for events.\n\t     *\n\t     * @class EventEmitter\n\t     * @constructor\n\t     */\n\t    function EventEmitter() {\n\t        this.listeners = {};\n\t        this._owner = this;\n\t    }\n\t\n\t    /**\n\t     * Trigger an event, sending to all downstream handlers\n\t     *   listening for provided 'type' key.\n\t     *\n\t     * @method emit\n\t     *\n\t     * @param {string} type event type key (for example, 'click')\n\t     * @param {Object} event event data\n\t     * @return {EventHandler} this\n\t     */\n\t    EventEmitter.prototype.emit = function emit(type, event) {\n\t        var handlers = this.listeners[type];\n\t        if (handlers) {\n\t            for (var i = 0; i < handlers.length; i++) {\n\t                handlers[i].call(this._owner, event);\n\t            }\n\t        }\n\t        return this;\n\t    };\n\t\n\t    /**\n\t     * Bind a callback function to an event type handled by this object.\n\t     *\n\t     * @method \"on\"\n\t     *\n\t     * @param {string} type event type key (for example, 'click')\n\t     * @param {function(string, Object)} handler callback\n\t     * @return {EventHandler} this\n\t     */\n\t   EventEmitter.prototype.on = function on(type, handler) {\n\t        if (!(type in this.listeners)) this.listeners[type] = [];\n\t        var index = this.listeners[type].indexOf(handler);\n\t        if (index < 0) this.listeners[type].push(handler);\n\t        return this;\n\t    };\n\t\n\t    /**\n\t     * Alias for \"on\".\n\t     * @method addListener\n\t     */\n\t    EventEmitter.prototype.addListener = EventEmitter.prototype.on;\n\t\n\t   /**\n\t     * Unbind an event by type and handler.\n\t     *   This undoes the work of \"on\".\n\t     *\n\t     * @method removeListener\n\t     *\n\t     * @param {string} type event type key (for example, 'click')\n\t     * @param {function} handler function object to remove\n\t     * @return {EventEmitter} this\n\t     */\n\t    EventEmitter.prototype.removeListener = function removeListener(type, handler) {\n\t        var index = this.listeners[type].indexOf(handler);\n\t        if (index >= 0) this.listeners[type].splice(index, 1);\n\t        return this;\n\t    };\n\t\n\t    /**\n\t     * Call event handlers with this set to owner.\n\t     *\n\t     * @method bindThis\n\t     *\n\t     * @param {Object} owner object this EventEmitter belongs to\n\t     */\n\t    EventEmitter.prototype.bindThis = function bindThis(owner) {\n\t        this._owner = owner;\n\t    };\n\t\n\t    module.exports = EventEmitter;\n\t}.call(exports, __webpack_require__, exports, module)), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n\n/***/ },\n/* 24 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_RESULT__;\n\t/* This Source Code Form is subject to the terms of the Mozilla Public\n\t * License, v. 2.0. If a copy of the MPL was not distributed with this\n\t * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n\t *\n\t * Owner: mark@famo.us\n\t * @license MPL 2.0\n\t * @copyright Famous Industries, Inc. 2014\n\t */\n\t\n\t!(__WEBPACK_AMD_DEFINE_RESULT__ = (function(require, exports, module) {\n\t    var Transform = __webpack_require__(1);\n\t\n\t    /**\n\t     *\n\t     * This object translates the rendering instructions (\"render specs\")\n\t     *   that renderable components generate into document update\n\t     *   instructions (\"update specs\").  Private.\n\t     *\n\t     * @private\n\t     * @class SpecParser\n\t     * @constructor\n\t     */\n\t    function SpecParser() {\n\t        this.result = {};\n\t    }\n\t    SpecParser._instance = new SpecParser();\n\t\n\t    /**\n\t     * Convert a render spec coming from the context's render chain to an\n\t     *    update spec for the update chain. This is the only major entry point\n\t     *    for a consumer of this class.\n\t     *\n\t     * @method parse\n\t     * @static\n\t     * @private\n\t     *\n\t     * @param {renderSpec} spec input render spec\n\t     * @param {Object} context context to do the parse in\n\t     * @return {Object} the resulting update spec (if no callback\n\t     *   specified, else none)\n\t     */\n\t    SpecParser.parse = function parse(spec, context) {\n\t        return SpecParser._instance.parse(spec, context);\n\t    };\n\t\n\t    /**\n\t     * Convert a renderSpec coming from the context's render chain to an update\n\t     *    spec for the update chain. This is the only major entrypoint for a\n\t     *    consumer of this class.\n\t     *\n\t     * @method parse\n\t     *\n\t     * @private\n\t     * @param {renderSpec} spec input render spec\n\t     * @param {Context} context\n\t     * @return {updateSpec} the resulting update spec\n\t     */\n\t    SpecParser.prototype.parse = function parse(spec, context) {\n\t        this.reset();\n\t        this._parseSpec(spec, context, Transform.identity);\n\t        return this.result;\n\t    };\n\t\n\t    /**\n\t     * Prepare SpecParser for re-use (or first use) by setting internal state\n\t     *  to blank.\n\t     *\n\t     * @private\n\t     * @method reset\n\t     */\n\t    SpecParser.prototype.reset = function reset() {\n\t        this.result = {};\n\t    };\n\t\n\t    // Multiply matrix M by vector v\n\t    function _vecInContext(v, m) {\n\t        return [\n\t            v[0] * m[0] + v[1] * m[4] + v[2] * m[8],\n\t            v[0] * m[1] + v[1] * m[5] + v[2] * m[9],\n\t            v[0] * m[2] + v[1] * m[6] + v[2] * m[10]\n\t        ];\n\t    }\n\t\n\t    var _originZeroZero = [0, 0];\n\t\n\t    // From the provided renderSpec tree, recursively compose opacities,\n\t    //    origins, transforms, and sizes corresponding to each surface id from\n\t    //    the provided renderSpec tree structure. On completion, those\n\t    //    properties of 'this' object should be ready to use to build an\n\t    //    updateSpec.\n\t    SpecParser.prototype._parseSpec = function _parseSpec(spec, parentContext, sizeContext) {\n\t        var id;\n\t        var target;\n\t        var transform;\n\t        var opacity;\n\t        var origin;\n\t        var size;\n\t\n\t        if (typeof spec === 'number') {\n\t            id = spec;\n\t            transform = parentContext.transform;\n\t            if (parentContext.size && parentContext.origin && (parentContext.origin[0] || parentContext.origin[1])) {\n\t                var originAdjust = [parentContext.origin[0] * parentContext.size[0], parentContext.origin[1] * parentContext.size[1], 0];\n\t                transform = Transform.thenMove(transform, _vecInContext(originAdjust, sizeContext));\n\t            }\n\t            this.result[id] = {\n\t                transform: transform,\n\t                opacity: parentContext.opacity,\n\t                origin: parentContext.origin || _originZeroZero,\n\t                size: parentContext.size\n\t            };\n\t        }\n\t        else if (!spec) { // placed here so 0 will be cached earlier\n\t            return;\n\t        }\n\t        else if (spec instanceof Array) {\n\t            for (var i = 0; i < spec.length; i++) {\n\t                this._parseSpec(spec[i], parentContext, sizeContext);\n\t            }\n\t        }\n\t        else {\n\t            target = spec.target;\n\t            transform = parentContext.transform;\n\t            opacity = parentContext.opacity;\n\t            origin = parentContext.origin;\n\t            size = parentContext.size;\n\t            var nextSizeContext = sizeContext;\n\t\n\t            if (spec.opacity !== undefined) opacity = parentContext.opacity * spec.opacity;\n\t            if (spec.transform) transform = Transform.multiply(parentContext.transform, spec.transform);\n\t            if (spec.origin) {\n\t                origin = spec.origin;\n\t                nextSizeContext = parentContext.transform;\n\t            }\n\t            if (spec.size) {\n\t                var parentSize = parentContext.size;\n\t                size = [\n\t                    spec.size[0] !== undefined ? spec.size[0] : parentSize[0],\n\t                    spec.size[1] !== undefined ? spec.size[1] : parentSize[1]\n\t                ];\n\t                if (parentSize && origin && (origin[0] || origin[1])) {\n\t                    transform = Transform.thenMove(transform, _vecInContext([origin[0] * parentSize[0], origin[1] * parentSize[1], 0], sizeContext));\n\t                    transform = Transform.moveThen([-origin[0] * size[0], -origin[1] * size[1], 0], transform);\n\t                }\n\t                nextSizeContext = parentContext.transform;\n\t                origin = null;\n\t            }\n\t\n\t            this._parseSpec(target, {\n\t                transform: transform,\n\t                opacity: opacity,\n\t                origin: origin,\n\t                size: size\n\t            }, nextSizeContext);\n\t        }\n\t    };\n\t\n\t    module.exports = SpecParser;\n\t}.call(exports, __webpack_require__, exports, module)), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n\n/***/ },\n/* 25 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_RESULT__;/* This Source Code Form is subject to the terms of the Mozilla Public\n\t * License, v. 2.0. If a copy of the MPL was not distributed with this\n\t * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n\t *\n\t * Owner: david@famo.us\n\t * @license MPL 2.0\n\t * @copyright Famous Industries, Inc. 2014\n\t */\n\t\n\t!(__WEBPACK_AMD_DEFINE_RESULT__ = (function(require, exports, module) {\n\t\n\t    /*\n\t     * A library of curves which map an animation explicitly as a function of time.\n\t     *\n\t     * @class Easing\n\t     */\n\t    var Easing = {\n\t\n\t        /**\n\t         * @property inQuad\n\t         * @static\n\t         */\n\t        inQuad: function(t) {\n\t            return t*t;\n\t        },\n\t\n\t        /**\n\t         * @property outQuad\n\t         * @static\n\t         */\n\t        outQuad: function(t) {\n\t            return -(t-=1)*t+1;\n\t        },\n\t\n\t        /**\n\t         * @property inOutQuad\n\t         * @static\n\t         */\n\t        inOutQuad: function(t) {\n\t            if ((t/=.5) < 1) return .5*t*t;\n\t            return -.5*((--t)*(t-2) - 1);\n\t        },\n\t\n\t        /**\n\t         * @property inCubic\n\t         * @static\n\t         */\n\t        inCubic: function(t) {\n\t            return t*t*t;\n\t        },\n\t\n\t        /**\n\t         * @property outCubic\n\t         * @static\n\t         */\n\t        outCubic: function(t) {\n\t            return ((--t)*t*t + 1);\n\t        },\n\t\n\t        /**\n\t         * @property inOutCubic\n\t         * @static\n\t         */\n\t        inOutCubic: function(t) {\n\t            if ((t/=.5) < 1) return .5*t*t*t;\n\t            return .5*((t-=2)*t*t + 2);\n\t        },\n\t\n\t        /**\n\t         * @property inQuart\n\t         * @static\n\t         */\n\t        inQuart: function(t) {\n\t            return t*t*t*t;\n\t        },\n\t\n\t        /**\n\t         * @property outQuart\n\t         * @static\n\t         */\n\t        outQuart: function(t) {\n\t            return -((--t)*t*t*t - 1);\n\t        },\n\t\n\t        /**\n\t         * @property inOutQuart\n\t         * @static\n\t         */\n\t        inOutQuart: function(t) {\n\t            if ((t/=.5) < 1) return .5*t*t*t*t;\n\t            return -.5 * ((t-=2)*t*t*t - 2);\n\t        },\n\t\n\t        /**\n\t         * @property inQuint\n\t         * @static\n\t         */\n\t        inQuint: function(t) {\n\t            return t*t*t*t*t;\n\t        },\n\t\n\t        /**\n\t         * @property outQuint\n\t         * @static\n\t         */\n\t        outQuint: function(t) {\n\t            return ((--t)*t*t*t*t + 1);\n\t        },\n\t\n\t        /**\n\t         * @property inOutQuint\n\t         * @static\n\t         */\n\t        inOutQuint: function(t) {\n\t            if ((t/=.5) < 1) return .5*t*t*t*t*t;\n\t            return .5*((t-=2)*t*t*t*t + 2);\n\t        },\n\t\n\t        /**\n\t         * @property inSine\n\t         * @static\n\t         */\n\t        inSine: function(t) {\n\t            return -1.0*Math.cos(t * (Math.PI/2)) + 1.0;\n\t        },\n\t\n\t        /**\n\t         * @property outSine\n\t         * @static\n\t         */\n\t        outSine: function(t) {\n\t            return Math.sin(t * (Math.PI/2));\n\t        },\n\t\n\t        /**\n\t         * @property inOutSine\n\t         * @static\n\t         */\n\t        inOutSine: function(t) {\n\t            return -.5*(Math.cos(Math.PI*t) - 1);\n\t        },\n\t\n\t        /**\n\t         * @property inExpo\n\t         * @static\n\t         */\n\t        inExpo: function(t) {\n\t            return (t===0) ? 0.0 : Math.pow(2, 10 * (t - 1));\n\t        },\n\t\n\t        /**\n\t         * @property outExpo\n\t         * @static\n\t         */\n\t        outExpo: function(t) {\n\t            return (t===1.0) ? 1.0 : (-Math.pow(2, -10 * t) + 1);\n\t        },\n\t\n\t        /**\n\t         * @property inOutExpo\n\t         * @static\n\t         */\n\t        inOutExpo: function(t) {\n\t            if (t===0) return 0.0;\n\t            if (t===1.0) return 1.0;\n\t            if ((t/=.5) < 1) return .5 * Math.pow(2, 10 * (t - 1));\n\t            return .5 * (-Math.pow(2, -10 * --t) + 2);\n\t        },\n\t\n\t        /**\n\t         * @property inCirc\n\t         * @static\n\t         */\n\t        inCirc: function(t) {\n\t            return -(Math.sqrt(1 - t*t) - 1);\n\t        },\n\t\n\t        /**\n\t         * @property outCirc\n\t         * @static\n\t         */\n\t        outCirc: function(t) {\n\t            return Math.sqrt(1 - (--t)*t);\n\t        },\n\t\n\t        /**\n\t         * @property inOutCirc\n\t         * @static\n\t         */\n\t        inOutCirc: function(t) {\n\t            if ((t/=.5) < 1) return -.5 * (Math.sqrt(1 - t*t) - 1);\n\t            return .5 * (Math.sqrt(1 - (t-=2)*t) + 1);\n\t        },\n\t\n\t        /**\n\t         * @property inElastic\n\t         * @static\n\t         */\n\t        inElastic: function(t) {\n\t            var s=1.70158;var p=0;var a=1.0;\n\t            if (t===0) return 0.0;  if (t===1) return 1.0;  if (!p) p=.3;\n\t            s = p/(2*Math.PI) * Math.asin(1.0/a);\n\t            return -(a*Math.pow(2,10*(t-=1)) * Math.sin((t-s)*(2*Math.PI)/ p));\n\t        },\n\t\n\t        /**\n\t         * @property outElastic\n\t         * @static\n\t         */\n\t        outElastic: function(t) {\n\t            var s=1.70158;var p=0;var a=1.0;\n\t            if (t===0) return 0.0;  if (t===1) return 1.0;  if (!p) p=.3;\n\t            s = p/(2*Math.PI) * Math.asin(1.0/a);\n\t            return a*Math.pow(2,-10*t) * Math.sin((t-s)*(2*Math.PI)/p) + 1.0;\n\t        },\n\t\n\t        /**\n\t         * @property inOutElastic\n\t         * @static\n\t         */\n\t        inOutElastic: function(t) {\n\t            var s=1.70158;var p=0;var a=1.0;\n\t            if (t===0) return 0.0;  if ((t/=.5)===2) return 1.0;  if (!p) p=(.3*1.5);\n\t            s = p/(2*Math.PI) * Math.asin(1.0/a);\n\t            if (t < 1) return -.5*(a*Math.pow(2,10*(t-=1)) * Math.sin((t-s)*(2*Math.PI)/p));\n\t            return a*Math.pow(2,-10*(t-=1)) * Math.sin((t-s)*(2*Math.PI)/p)*.5 + 1.0;\n\t        },\n\t\n\t        /**\n\t         * @property inBack\n\t         * @static\n\t         */\n\t        inBack: function(t, s) {\n\t            if (s === undefined) s = 1.70158;\n\t            return t*t*((s+1)*t - s);\n\t        },\n\t\n\t        /**\n\t         * @property outBack\n\t         * @static\n\t         */\n\t        outBack: function(t, s) {\n\t            if (s === undefined) s = 1.70158;\n\t            return ((--t)*t*((s+1)*t + s) + 1);\n\t        },\n\t\n\t        /**\n\t         * @property inOutBack\n\t         * @static\n\t         */\n\t        inOutBack: function(t, s) {\n\t            if (s === undefined) s = 1.70158;\n\t            if ((t/=.5) < 1) return .5*(t*t*(((s*=(1.525))+1)*t - s));\n\t            return .5*((t-=2)*t*(((s*=(1.525))+1)*t + s) + 2);\n\t        },\n\t\n\t        /**\n\t         * @property inBounce\n\t         * @static\n\t         */\n\t        inBounce: function(t) {\n\t            return 1.0 - Easing.outBounce(1.0-t);\n\t        },\n\t\n\t        /**\n\t         * @property outBounce\n\t         * @static\n\t         */\n\t        outBounce: function(t) {\n\t            if (t < (1/2.75)) {\n\t                return (7.5625*t*t);\n\t            } else if (t < (2/2.75)) {\n\t                return (7.5625*(t-=(1.5/2.75))*t + .75);\n\t            } else if (t < (2.5/2.75)) {\n\t                return (7.5625*(t-=(2.25/2.75))*t + .9375);\n\t            } else {\n\t                return (7.5625*(t-=(2.625/2.75))*t + .984375);\n\t            }\n\t        },\n\t\n\t        /**\n\t         * @property inOutBounce\n\t         * @static\n\t         */\n\t        inOutBounce: function(t) {\n\t            if (t < .5) return Easing.inBounce(t*2) * .5;\n\t            return Easing.outBounce(t*2-1.0) * .5 + .5;\n\t        }\n\t    };\n\t\n\t    module.exports = Easing;\n\t}.call(exports, __webpack_require__, exports, module)), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n\n/***/ },\n/* 26 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_RESULT__;/* This Source Code Form is subject to the terms of the Mozilla Public\n\t * License, v. 2.0. If a copy of the MPL was not distributed with this\n\t * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n\t *\n\t * Owner: david@famo.us\n\t * @license MPL 2.0\n\t * @copyright Famous Industries, Inc. 2014\n\t */\n\t\n\t!(__WEBPACK_AMD_DEFINE_RESULT__ = (function(require, exports, module) {\n\t    var Utility = __webpack_require__(7);\n\t\n\t    /**\n\t     * Transition meta-method to support transitioning multiple\n\t     *   values with scalar-only methods.\n\t     *\n\t     *\n\t     * @class MultipleTransition\n\t     * @constructor\n\t     *\n\t     * @param {Object} method Transionable class to multiplex\n\t     */\n\t    function MultipleTransition(method) {\n\t        this.method = method;\n\t        this._instances = [];\n\t        this.state = [];\n\t    }\n\t\n\t    MultipleTransition.SUPPORTS_MULTIPLE = true;\n\t\n\t    /**\n\t     * Get the state of each transition.\n\t     *\n\t     * @method get\n\t     *\n\t     * @return state {Number|Array} state array\n\t     */\n\t    MultipleTransition.prototype.get = function get() {\n\t        for (var i = 0; i < this._instances.length; i++) {\n\t            this.state[i] = this._instances[i].get();\n\t        }\n\t        return this.state;\n\t    };\n\t\n\t    /**\n\t     * Set the end states with a shared transition, with optional callback.\n\t     *\n\t     * @method set\n\t     *\n\t     * @param {Number|Array} endState Final State.  Use a multi-element argument for multiple transitions.\n\t     * @param {Object} transition Transition definition, shared among all instances\n\t     * @param {Function} callback called when all endStates have been reached.\n\t     */\n\t    MultipleTransition.prototype.set = function set(endState, transition, callback) {\n\t        var _allCallback = Utility.after(endState.length, callback);\n\t        for (var i = 0; i < endState.length; i++) {\n\t            if (!this._instances[i]) this._instances[i] = new (this.method)();\n\t            this._instances[i].set(endState[i], transition, _allCallback);\n\t        }\n\t    };\n\t\n\t    /**\n\t     * Reset all transitions to start state.\n\t     *\n\t     * @method reset\n\t     *\n\t     * @param  {Number|Array} startState Start state\n\t     */\n\t    MultipleTransition.prototype.reset = function reset(startState) {\n\t        for (var i = 0; i < startState.length; i++) {\n\t            if (!this._instances[i]) this._instances[i] = new (this.method)();\n\t            this._instances[i].reset(startState[i]);\n\t        }\n\t    };\n\t\n\t    module.exports = MultipleTransition;\n\t}.call(exports, __webpack_require__, exports, module)), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n\n/***/ },\n/* 27 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_RESULT__;/* This Source Code Form is subject to the terms of the Mozilla Public\n\t * License, v. 2.0. If a copy of the MPL was not distributed with this\n\t * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n\t *\n\t * Owner: david@famo.us\n\t * @license MPL 2.0\n\t * @copyright Famous Industries, Inc. 2014\n\t */\n\t\n\t!(__WEBPACK_AMD_DEFINE_RESULT__ = (function(require, exports, module) {\n\t\n\t    /**\n\t     *\n\t     * A state maintainer for a smooth transition between\n\t     *    numerically-specified states.  Example numeric states include floats or\n\t     *    Transfornm objects.\n\t     *\n\t     *    An initial state is set with the constructor or set(startValue). A\n\t     *    corresponding end state and transition are set with set(endValue,\n\t     *    transition). Subsequent calls to set(endValue, transition) begin at\n\t     *    the last state. Calls to get(timestamp) provide the _interpolated state\n\t     *    along the way.\n\t     *\n\t     *   Note that there is no event loop here - calls to get() are the only way\n\t     *    to find out state projected to the current (or provided) time and are\n\t     *    the only way to trigger callbacks. Usually this kind of object would\n\t     *    be part of the render() path of a visible component.\n\t     *\n\t     * @class TweenTransition\n\t     * @constructor\n\t     *\n\t     * @param {Object} options TODO\n\t     *    beginning state\n\t     */\n\t    function TweenTransition(options) {\n\t        this.options = Object.create(TweenTransition.DEFAULT_OPTIONS);\n\t        if (options) this.setOptions(options);\n\t\n\t        this._startTime = 0;\n\t        this._startValue = 0;\n\t        this._updateTime = 0;\n\t        this._endValue = 0;\n\t        this._curve = undefined;\n\t        this._duration = 0;\n\t        this._active = false;\n\t        this._callback = undefined;\n\t        this.state = 0;\n\t        this.velocity = undefined;\n\t    }\n\t\n\t    /**\n\t     * Transition curves mapping independent variable t from domain [0,1] to a\n\t     *    range within [0,1]. Includes functions 'linear', 'easeIn', 'easeOut',\n\t     *    'easeInOut', 'easeOutBounce', 'spring'.\n\t     *\n\t     * @property {object} Curve\n\t     * @final\n\t     */\n\t    TweenTransition.Curves = {\n\t        linear: function(t) {\n\t            return t;\n\t        },\n\t        easeIn: function(t) {\n\t            return t*t;\n\t        },\n\t        easeOut: function(t) {\n\t            return t*(2-t);\n\t        },\n\t        easeInOut: function(t) {\n\t            if (t <= 0.5) return 2*t*t;\n\t            else return -2*t*t + 4*t - 1;\n\t        },\n\t        easeOutBounce: function(t) {\n\t            return t*(3 - 2*t);\n\t        },\n\t        spring: function(t) {\n\t            return (1 - t) * Math.sin(6 * Math.PI * t) + t;\n\t        }\n\t    };\n\t\n\t    TweenTransition.SUPPORTS_MULTIPLE = true;\n\t    TweenTransition.DEFAULT_OPTIONS = {\n\t        curve: TweenTransition.Curves.linear,\n\t        duration: 500,\n\t        speed: 0 /* considered only if positive */\n\t    };\n\t\n\t    var registeredCurves = {};\n\t\n\t    /**\n\t     * Add \"unit\" curve to internal dictionary of registered curves.\n\t     *\n\t     * @method registerCurve\n\t     *\n\t     * @static\n\t     *\n\t     * @param {string} curveName dictionary key\n\t     * @param {unitCurve} curve function of one numeric variable mapping [0,1]\n\t     *    to range inside [0,1]\n\t     * @return {boolean} false if key is taken, else true\n\t     */\n\t    TweenTransition.registerCurve = function registerCurve(curveName, curve) {\n\t        if (!registeredCurves[curveName]) {\n\t            registeredCurves[curveName] = curve;\n\t            return true;\n\t        }\n\t        else {\n\t            return false;\n\t        }\n\t    };\n\t\n\t    /**\n\t     * Remove object with key \"curveName\" from internal dictionary of registered\n\t     *    curves.\n\t     *\n\t     * @method unregisterCurve\n\t     *\n\t     * @static\n\t     *\n\t     * @param {string} curveName dictionary key\n\t     * @return {boolean} false if key has no dictionary value\n\t     */\n\t    TweenTransition.unregisterCurve = function unregisterCurve(curveName) {\n\t        if (registeredCurves[curveName]) {\n\t            delete registeredCurves[curveName];\n\t            return true;\n\t        }\n\t        else {\n\t            return false;\n\t        }\n\t    };\n\t\n\t    /**\n\t     * Retrieve function with key \"curveName\" from internal dictionary of\n\t     *    registered curves. Default curves are defined in the\n\t     *    TweenTransition.Curves array, where the values represent\n\t     *    unitCurve functions.\n\t     *\n\t     * @method getCurve\n\t     *\n\t     * @static\n\t     *\n\t     * @param {string} curveName dictionary key\n\t     * @return {unitCurve} curve function of one numeric variable mapping [0,1]\n\t     *    to range inside [0,1]\n\t     */\n\t    TweenTransition.getCurve = function getCurve(curveName) {\n\t        return registeredCurves[curveName];\n\t    };\n\t\n\t    /**\n\t     * Retrieve all available curves.\n\t     *\n\t     * @method getCurves\n\t     *\n\t     * @static\n\t     *\n\t     * @return {object} curve functions of one numeric variable mapping [0,1]\n\t     *    to range inside [0,1]\n\t     */\n\t    TweenTransition.getCurves = function getCurves() {\n\t        return registeredCurves;\n\t    };\n\t\n\t     // Interpolate: If a linear function f(0) = a, f(1) = b, then return f(t)\n\t    function _interpolate(a, b, t) {\n\t        return ((1 - t) * a) + (t * b);\n\t    }\n\t\n\t    function _clone(obj) {\n\t        if (obj instanceof Object) {\n\t            if (obj instanceof Array) return obj.slice(0);\n\t            else return Object.create(obj);\n\t        }\n\t        else return obj;\n\t    }\n\t\n\t    // Fill in missing properties in \"transition\" with those in defaultTransition, and\n\t    //   convert internal named curve to function object, returning as new\n\t    //   object.\n\t    function _normalize(transition, defaultTransition) {\n\t        var result = {curve: defaultTransition.curve};\n\t        if (defaultTransition.duration) result.duration = defaultTransition.duration;\n\t        if (defaultTransition.speed) result.speed = defaultTransition.speed;\n\t        if (transition instanceof Object) {\n\t            if (transition.duration !== undefined) result.duration = transition.duration;\n\t            if (transition.curve) result.curve = transition.curve;\n\t            if (transition.speed) result.speed = transition.speed;\n\t        }\n\t        if (typeof result.curve === 'string') result.curve = TweenTransition.getCurve(result.curve);\n\t        return result;\n\t    }\n\t\n\t    /**\n\t     * Set internal options, overriding any default options.\n\t     *\n\t     * @method setOptions\n\t     *\n\t     *\n\t     * @param {Object} options options object\n\t     * @param {Object} [options.curve] function mapping [0,1] to [0,1] or identifier\n\t     * @param {Number} [options.duration] duration in ms\n\t     * @param {Number} [options.speed] speed in pixels per ms\n\t     */\n\t    TweenTransition.prototype.setOptions = function setOptions(options) {\n\t        if (options.curve !== undefined) this.options.curve = options.curve;\n\t        if (options.duration !== undefined) this.options.duration = options.duration;\n\t        if (options.speed !== undefined) this.options.speed = options.speed;\n\t    };\n\t\n\t    /**\n\t     * Add transition to end state to the queue of pending transitions. Special\n\t     *    Use: calling without a transition resets the object to that state with\n\t     *    no pending actions\n\t     *\n\t     * @method set\n\t     *\n\t     *\n\t     * @param {number|FamousMatrix|Array.Number|Object.<number, number>} endValue\n\t     *    end state to which we _interpolate\n\t     * @param {transition=} transition object of type {duration: number, curve:\n\t     *    f[0,1] -> [0,1] or name}. If transition is omitted, change will be\n\t     *    instantaneous.\n\t     * @param {function()=} callback Zero-argument function to call on observed\n\t     *    completion (t=1)\n\t     */\n\t    TweenTransition.prototype.set = function set(endValue, transition, callback) {\n\t        if (!transition) {\n\t            this.reset(endValue);\n\t            if (callback) callback();\n\t            return;\n\t        }\n\t\n\t        this._startValue = _clone(this.get());\n\t        transition = _normalize(transition, this.options);\n\t        if (transition.speed) {\n\t            var startValue = this._startValue;\n\t            if (startValue instanceof Object) {\n\t                var variance = 0;\n\t                for (var i in startValue) variance += (endValue[i] - startValue[i]) * (endValue[i] - startValue[i]);\n\t                transition.duration = Math.sqrt(variance) / transition.speed;\n\t            }\n\t            else {\n\t                transition.duration = Math.abs(endValue - startValue) / transition.speed;\n\t            }\n\t        }\n\t\n\t        this._startTime = Date.now();\n\t        this._endValue = _clone(endValue);\n\t        this._startVelocity = _clone(transition.velocity);\n\t        this._duration = transition.duration;\n\t        this._curve = transition.curve;\n\t        this._active = true;\n\t        this._callback = callback;\n\t    };\n\t\n\t    /**\n\t     * Cancel all transitions and reset to a stable state\n\t     *\n\t     * @method reset\n\t     *\n\t     * @param {number|Array.Number|Object.<number, number>} startValue\n\t     *    starting state\n\t     * @param {number} startVelocity\n\t     *    starting velocity\n\t     */\n\t    TweenTransition.prototype.reset = function reset(startValue, startVelocity) {\n\t        if (this._callback) {\n\t            var callback = this._callback;\n\t            this._callback = undefined;\n\t            callback();\n\t        }\n\t        this.state = _clone(startValue);\n\t        this.velocity = _clone(startVelocity);\n\t        this._startTime = 0;\n\t        this._duration = 0;\n\t        this._updateTime = 0;\n\t        this._startValue = this.state;\n\t        this._startVelocity = this.velocity;\n\t        this._endValue = this.state;\n\t        this._active = false;\n\t    };\n\t\n\t    /**\n\t     * Get current velocity\n\t     *\n\t     * @method getVelocity\n\t     *\n\t     * @returns {Number} velocity\n\t     */\n\t    TweenTransition.prototype.getVelocity = function getVelocity() {\n\t        return this.velocity;\n\t    };\n\t\n\t    /**\n\t     * Get interpolated state of current action at provided time. If the last\n\t     *    action has completed, invoke its callback.\n\t     *\n\t     * @method get\n\t     *\n\t     *\n\t     * @param {number=} timestamp Evaluate the curve at a normalized version of this\n\t     *    time. If omitted, use current time. (Unix epoch time)\n\t     * @return {number|Object.<number|string, number>} beginning state\n\t     *    _interpolated to this point in time.\n\t     */\n\t    TweenTransition.prototype.get = function get(timestamp) {\n\t        this.update(timestamp);\n\t        return this.state;\n\t    };\n\t\n\t    function _calculateVelocity(current, start, curve, duration, t) {\n\t        var velocity;\n\t        var eps = 1e-7;\n\t        var speed = (curve(t) - curve(t - eps)) / eps;\n\t        if (current instanceof Array) {\n\t            velocity = [];\n\t            for (var i = 0; i < current.length; i++)\n\t                velocity[i] = speed * (current[i] - start[i]) / duration;\n\t        }\n\t        else velocity = speed * (current - start) / duration;\n\t        return velocity;\n\t    }\n\t\n\t    function _calculateState(start, end, t) {\n\t        var state;\n\t        if (start instanceof Array) {\n\t            state = [];\n\t            for (var i = 0; i < start.length; i++)\n\t                state[i] = _interpolate(start[i], end[i], t);\n\t        }\n\t        else state = _interpolate(start, end, t);\n\t        return state;\n\t    }\n\t\n\t    /**\n\t     * Update internal state to the provided timestamp. This may invoke the last\n\t     *    callback and begin a new action.\n\t     *\n\t     * @method update\n\t     *\n\t     *\n\t     * @param {number=} timestamp Evaluate the curve at a normalized version of this\n\t     *    time. If omitted, use current time. (Unix epoch time)\n\t     */\n\t    TweenTransition.prototype.update = function update(timestamp) {\n\t        if (!this._active) {\n\t            if (this._callback) {\n\t                var callback = this._callback;\n\t                this._callback = undefined;\n\t                callback();\n\t            }\n\t            return;\n\t        }\n\t\n\t        if (!timestamp) timestamp = Date.now();\n\t        if (this._updateTime >= timestamp) return;\n\t        this._updateTime = timestamp;\n\t\n\t        var timeSinceStart = timestamp - this._startTime;\n\t        if (timeSinceStart >= this._duration) {\n\t            this.state = this._endValue;\n\t            this.velocity = _calculateVelocity(this.state, this._startValue, this._curve, this._duration, 1);\n\t            this._active = false;\n\t        }\n\t        else if (timeSinceStart < 0) {\n\t            this.state = this._startValue;\n\t            this.velocity = this._startVelocity;\n\t        }\n\t        else {\n\t            var t = timeSinceStart / this._duration;\n\t            this.state = _calculateState(this._startValue, this._endValue, this._curve(t));\n\t            this.velocity = _calculateVelocity(this.state, this._startValue, this._curve, this._duration, t);\n\t        }\n\t    };\n\t\n\t    /**\n\t     * Is there at least one action pending completion?\n\t     *\n\t     * @method isActive\n\t     *\n\t     *\n\t     * @return {boolean}\n\t     */\n\t    TweenTransition.prototype.isActive = function isActive() {\n\t        return this._active;\n\t    };\n\t\n\t    /**\n\t     * Halt transition at current state and erase all pending actions.\n\t     *\n\t     * @method halt\n\t     *\n\t     */\n\t    TweenTransition.prototype.halt = function halt() {\n\t        this.reset(this.get());\n\t    };\n\t\n\t    // Register all the default curves\n\t    TweenTransition.registerCurve('linear', TweenTransition.Curves.linear);\n\t    TweenTransition.registerCurve('easeIn', TweenTransition.Curves.easeIn);\n\t    TweenTransition.registerCurve('easeOut', TweenTransition.Curves.easeOut);\n\t    TweenTransition.registerCurve('easeInOut', TweenTransition.Curves.easeInOut);\n\t    TweenTransition.registerCurve('easeOutBounce', TweenTransition.Curves.easeOutBounce);\n\t    TweenTransition.registerCurve('spring', TweenTransition.Curves.spring);\n\t\n\t    TweenTransition.customCurve = function customCurve(v1, v2) {\n\t        v1 = v1 || 0; v2 = v2 || 0;\n\t        return function(t) {\n\t            return v1*t + (-2*v1 - v2 + 3)*t*t + (v1 + v2 - 2)*t*t*t;\n\t        };\n\t    };\n\t\n\t    module.exports = TweenTransition;\n\t}.call(exports, __webpack_require__, exports, module)), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n\n/***/ },\n/* 28 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_RESULT__;/* This Source Code Form is subject to the terms of the Mozilla Public\n\t * License, v. 2.0. If a copy of the MPL was not distributed with this\n\t * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n\t *\n\t * Owner: felix@famo.us\n\t * @license MPL 2.0\n\t * @copyright Famous Industries, Inc. 2014\n\t */\n\t\n\t!(__WEBPACK_AMD_DEFINE_RESULT__ = (function(require, exports, module) {\n\t    var Entity = __webpack_require__(10);\n\t    var RenderNode = __webpack_require__(12);\n\t    var Transform = __webpack_require__(1);\n\t    var OptionsManager = __webpack_require__(11);\n\t\n\t    /**\n\t     * A layout which will arrange three renderables into a header and footer area of defined size,\n\t      and a content area of flexible size.\n\t     * @class HeaderFooterLayout\n\t     * @constructor\n\t     * @param {Options} [options] An object of configurable options.\n\t     * @param {Number} [options.direction=HeaderFooterLayout.DIRECTION_Y] A direction of HeaderFooterLayout.DIRECTION_X\n\t     * lays your HeaderFooterLayout instance horizontally, and a direction of HeaderFooterLayout.DIRECTION_Y\n\t     * lays it out vertically.\n\t     * @param {Number} [options.headerSize=undefined]  The amount of pixels allocated to the header node\n\t     * in the HeaderFooterLayout instance's direction.\n\t     * @param {Number} [options.footerSize=undefined] The amount of pixels allocated to the footer node\n\t     * in the HeaderFooterLayout instance's direction.\n\t     */\n\t    function HeaderFooterLayout(options) {\n\t        this.options = Object.create(HeaderFooterLayout.DEFAULT_OPTIONS);\n\t        this._optionsManager = new OptionsManager(this.options);\n\t        if (options) this.setOptions(options);\n\t\n\t        this._entityId = Entity.register(this);\n\t\n\t        this.header = new RenderNode();\n\t        this.footer = new RenderNode();\n\t        this.content = new RenderNode();\n\t    }\n\t\n\t    /**\n\t     *  When used as a value for your HeaderFooterLayout's direction option, causes it to lay out horizontally.\n\t     *\n\t     *  @attribute DIRECTION_X\n\t     *  @type Number\n\t     *  @static\n\t     *  @default 0\n\t     *  @protected\n\t     */\n\t    HeaderFooterLayout.DIRECTION_X = 0;\n\t\n\t    /**\n\t     *  When used as a value for your HeaderFooterLayout's direction option, causes it to lay out vertically.\n\t     *\n\t     *  @attribute DIRECTION_Y\n\t     *  @type Number\n\t     *  @static\n\t     *  @default 1\n\t     *  @protected\n\t     */\n\t    HeaderFooterLayout.DIRECTION_Y = 1;\n\t\n\t    HeaderFooterLayout.DEFAULT_OPTIONS = {\n\t        direction: HeaderFooterLayout.DIRECTION_Y,\n\t        headerSize: undefined,\n\t        footerSize: undefined,\n\t        defaultHeaderSize: 0,\n\t        defaultFooterSize: 0\n\t    };\n\t\n\t    /**\n\t     * Generate a render spec from the contents of this component.\n\t     *\n\t     * @private\n\t     * @method render\n\t     * @return {Object} Render spec for this component\n\t     */\n\t    HeaderFooterLayout.prototype.render = function render() {\n\t        return this._entityId;\n\t    };\n\t\n\t    /**\n\t     * Patches the HeaderFooterLayout instance's options with the passed-in ones.\n\t     *\n\t     * @method setOptions\n\t     * @param {Options} options An object of configurable options for the HeaderFooterLayout instance.\n\t     */\n\t    HeaderFooterLayout.prototype.setOptions = function setOptions(options) {\n\t        return this._optionsManager.setOptions(options);\n\t    };\n\t\n\t    function _resolveNodeSize(node, defaultSize) {\n\t        var nodeSize = node.getSize();\n\t        return nodeSize ? nodeSize[this.options.direction] : defaultSize;\n\t    }\n\t\n\t    function _outputTransform(offset) {\n\t        if (this.options.direction === HeaderFooterLayout.DIRECTION_X) return Transform.translate(offset, 0, 0);\n\t        else return Transform.translate(0, offset, 0);\n\t    }\n\t\n\t    function _finalSize(directionSize, size) {\n\t        if (this.options.direction === HeaderFooterLayout.DIRECTION_X) return [directionSize, size[1]];\n\t        else return [size[0], directionSize];\n\t    }\n\t\n\t    /**\n\t     * Apply changes from this component to the corresponding document element.\n\t     * This includes changes to classes, styles, size, content, opacity, origin,\n\t     * and matrix transforms.\n\t     *\n\t     * @private\n\t     * @method commit\n\t     * @param {Context} context commit context\n\t     */\n\t    HeaderFooterLayout.prototype.commit = function commit(context) {\n\t        var transform = context.transform;\n\t        var origin = context.origin;\n\t        var size = context.size;\n\t        var opacity = context.opacity;\n\t\n\t        var headerSize = (this.options.headerSize !== undefined) ? this.options.headerSize : _resolveNodeSize.call(this, this.header, this.options.defaultHeaderSize);\n\t        var footerSize = (this.options.footerSize !== undefined) ? this.options.footerSize : _resolveNodeSize.call(this, this.footer, this.options.defaultFooterSize);\n\t        var contentSize = size[this.options.direction] - headerSize - footerSize;\n\t\n\t        if (size) transform = Transform.moveThen([-size[0]*origin[0], -size[1]*origin[1], 0], transform);\n\t\n\t        var result = [\n\t            {\n\t                size: _finalSize.call(this, headerSize, size),\n\t                target: this.header.render()\n\t            },\n\t            {\n\t                transform: _outputTransform.call(this, headerSize),\n\t                size: _finalSize.call(this, contentSize, size),\n\t                target: this.content.render()\n\t            },\n\t            {\n\t                transform: _outputTransform.call(this, headerSize + contentSize),\n\t                size: _finalSize.call(this, footerSize, size),\n\t                target: this.footer.render()\n\t            }\n\t        ];\n\t\n\t        return {\n\t            transform: transform,\n\t            opacity: opacity,\n\t            size: size,\n\t            target: result\n\t        };\n\t    };\n\t\n\t    module.exports = HeaderFooterLayout;\n\t}.call(exports, __webpack_require__, exports, module)), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n\n/***/ },\n/* 29 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar Parse, Question, Questions,\n\t  __hasProp = {}.hasOwnProperty,\n\t  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };\n\t\n\tParse = __webpack_require__(38);\n\t\n\tQuestion = __webpack_require__(17);\n\t\n\tQuestions = (function(_super) {\n\t  __extends(Questions, _super);\n\t\n\t  function Questions() {\n\t    return Questions.__super__.constructor.apply(this, arguments);\n\t  }\n\t\n\t  Questions.prototype.model = Question;\n\t\n\t  return Questions;\n\t\n\t})(Parse.Collection);\n\t\n\tmodule.exports = Questions;\n\n\n/***/ },\n/* 30 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar AppView, CardView, HeaderFooterLayout, HeaderView, MenuView, Modifier, Question, Questions, Surface, Transform, Transitionable, Utility, View,\n\t  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },\n\t  __hasProp = {}.hasOwnProperty,\n\t  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };\n\t\n\tView = __webpack_require__(4);\n\t\n\tUtility = __webpack_require__(7);\n\t\n\tHeaderFooterLayout = __webpack_require__(28);\n\t\n\tSurface = __webpack_require__(2);\n\t\n\tTransform = __webpack_require__(1);\n\t\n\tTransitionable = __webpack_require__(6);\n\t\n\tModifier = __webpack_require__(3);\n\t\n\tQuestions = __webpack_require__(29);\n\t\n\tQuestion = __webpack_require__(17);\n\t\n\tHeaderView = __webpack_require__(32);\n\t\n\tMenuView = __webpack_require__(33);\n\t\n\tCardView = __webpack_require__(31);\n\t\n\tAppView = (function(_super) {\n\t  __extends(AppView, _super);\n\t\n\t  AppView.DEFAULT_OPTIONS = {\n\t    menu: {\n\t      width: 280,\n\t      transition: {\n\t        duration: 300,\n\t        curve: 'easeOut'\n\t      }\n\t    }\n\t  };\n\t\n\t  AppView.prototype.menuOpen = false;\n\t\n\t  function AppView() {\n\t    this.toggleMenu = __bind(this.toggleMenu, this);\n\t    AppView.__super__.constructor.apply(this, arguments);\n\t    this.page = new HeaderFooterLayout({\n\t      headerSize: 60,\n\t      footerSize: 50\n\t    });\n\t    this.initHeader();\n\t    this.initMenu();\n\t    this.initContent();\n\t  }\n\t\n\t  AppView.prototype.initHeader = function() {\n\t    this.header = new HeaderView;\n\t    this.header.on('toggleMenu', this.toggleMenu);\n\t    return this.page.header.add(this.header);\n\t  };\n\t\n\t  AppView.prototype.initMenu = function() {\n\t    this.menuPosition = new Transitionable(0);\n\t    this.menu = new MenuView;\n\t    return this.menu.on('toggleMenu', this.toggleMenu);\n\t  };\n\t\n\t  AppView.prototype.initContent = function() {\n\t    var modifier;\n\t    this.content = new CardView;\n\t    modifier = new Modifier({\n\t      origin: [0.5, 0.5]\n\t    });\n\t    return this.page.content.add(modifier).add(this.content);\n\t  };\n\t\n\t  AppView.prototype.toggleMenu = function() {\n\t    if (this.menuOpen) {\n\t      return this.closeMenu();\n\t    } else {\n\t      return this.openMenu();\n\t    }\n\t  };\n\t\n\t  AppView.prototype.closeMenu = function() {\n\t    return this.menuPosition.set(0, this.options.menu.transition, (function(_this) {\n\t      return function() {\n\t        return _this.menuOpen = false;\n\t      };\n\t    })(this));\n\t  };\n\t\n\t  AppView.prototype.openMenu = function() {\n\t    return this.menuPosition.set(this.options.menu.width, this.options.menu.transition, (function(_this) {\n\t      return function() {\n\t        return _this.menuOpen = true;\n\t      };\n\t    })(this));\n\t  };\n\t\n\t  AppView.prototype.render = function() {\n\t    return [\n\t      {\n\t        transform: Transform.translate(0, 0, -1),\n\t        target: this.menu.render()\n\t      }, {\n\t        transform: Transform.translate(this.menuPosition.get(), 0, 0),\n\t        target: this.page.render()\n\t      }\n\t    ];\n\t  };\n\t\n\t  return AppView;\n\t\n\t})(View);\n\t\n\tmodule.exports = AppView;\n\n\n/***/ },\n/* 31 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar CardView, Modifier, StateModifer, Surface, Transform, Utility, View,\n\t  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },\n\t  __hasProp = {}.hasOwnProperty,\n\t  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };\n\t\n\t__webpack_require__(49);\n\t\n\tView = __webpack_require__(4);\n\t\n\tSurface = __webpack_require__(2);\n\t\n\tModifier = __webpack_require__(3);\n\t\n\tStateModifer = __webpack_require__(13);\n\t\n\tTransform = __webpack_require__(1);\n\t\n\tUtility = __webpack_require__(7);\n\t\n\tCardView = (function(_super) {\n\t  __extends(CardView, _super);\n\t\n\t  CardView.DEFAULT_OPTIONS = {\n\t    width: 400,\n\t    height: 600,\n\t    depth: 10,\n\t    borderRadius: 30\n\t  };\n\t\n\t  function CardView() {\n\t    this.flip = __bind(this.flip, this);\n\t    CardView.__super__.constructor.apply(this, arguments);\n\t    this.init();\n\t  }\n\t\n\t  CardView.prototype.init = function() {\n\t    var depth, height, width;\n\t    width = this.options.width;\n\t    height = this.options.height;\n\t    depth = this.options.depth;\n\t    this.state = new StateModifer;\n\t    this.mainNode = this.add(this.state);\n\t    this.addSurface({\n\t      size: [width, height],\n\t      content: \"<h2>Front of card.</h2>\",\n\t      classes: ['card__front'],\n\t      properties: {\n\t        borderRadius: \"\" + this.options.borderRadius + \"px\"\n\t      },\n\t      transform: Transform.translate(0, 0, depth / 2)\n\t    });\n\t    this.addSurface({\n\t      size: [width, height],\n\t      classes: ['card__backing'],\n\t      properties: {\n\t        borderRadius: \"\" + this.options.borderRadius + \"px\"\n\t      },\n\t      transform: Transform.multiply(Transform.translate(0, 0, depth / 2 - 1), Transform.multiply(Transform.rotateZ(Math.PI), Transform.rotateX(Math.PI)))\n\t    });\n\t    this.addSurface({\n\t      size: [depth - 2, height],\n\t      classes: ['card__shim'],\n\t      transform: Transform.multiply(Transform.translate(-width / 2 + this.options.borderRadius, 0, 1), Transform.rotateY(-Math.PI / 2))\n\t    });\n\t    this.addSurface({\n\t      size: [width, height],\n\t      content: \"<h3>Back of card</h3>\",\n\t      classes: ['card__back'],\n\t      properties: {\n\t        borderRadius: \"\" + this.options.borderRadius + \"px\"\n\t      },\n\t      transform: Transform.multiply(Transform.translate(0, 0, -depth / 2), Transform.multiply(Transform.rotateZ(Math.PI), Transform.rotateX(Math.PI)))\n\t    });\n\t    return this.addSurface({\n\t      size: [width, height],\n\t      classes: ['card__backing'],\n\t      properties: {\n\t        borderRadius: \"\" + this.options.borderRadius + \"px\"\n\t      },\n\t      transform: Transform.translate(0, 0, -depth / 2 + 1)\n\t    });\n\t  };\n\t\n\t  CardView.prototype.addSurface = function(params) {\n\t    var modifier, surface;\n\t    surface = new Surface({\n\t      size: params.size,\n\t      content: params.content,\n\t      classes: params.classes,\n\t      properties: params.properties\n\t    });\n\t    modifier = new Modifier({\n\t      transform: params.transform\n\t    });\n\t    surface.on('click', this.flip);\n\t    return this.mainNode.add(modifier).add(surface);\n\t  };\n\t\n\t  CardView.prototype.flip = function(side) {\n\t    if (this.currentSide == null) {\n\t      this.currentSide = 0;\n\t    }\n\t    if (side === 0 || side === 1) {\n\t      this.currentSide = side;\n\t    } else {\n\t      this.currentSide = this.currentSide === 1 ? 0 : 1;\n\t    }\n\t    return this.state.setTransform(Transform.rotateY(Math.PI * this.currentSide), {\n\t      duration: 500,\n\t      curve: 'easeInOut'\n\t    });\n\t  };\n\t\n\t  return CardView;\n\t\n\t})(View);\n\t\n\tmodule.exports = CardView;\n\n\n/***/ },\n/* 32 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar HeaderView, ImageSurface, Modifier, Surface, Transform, Utility, View,\n\t  __hasProp = {}.hasOwnProperty,\n\t  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };\n\t\n\t__webpack_require__(50);\n\t\n\tView = __webpack_require__(4);\n\t\n\tUtility = __webpack_require__(7);\n\t\n\tSurface = __webpack_require__(2);\n\t\n\tImageSurface = __webpack_require__(14);\n\t\n\tModifier = __webpack_require__(3);\n\t\n\tTransform = __webpack_require__(1);\n\t\n\tHeaderView = (function(_super) {\n\t  __extends(HeaderView, _super);\n\t\n\t  HeaderView.prototype.title = 'Pegg';\n\t\n\t  HeaderView.prototype.cssPrefix = 'header';\n\t\n\t  function HeaderView() {\n\t    HeaderView.__super__.constructor.apply(this, arguments);\n\t    this.build();\n\t    this.initEvents();\n\t  }\n\t\n\t  HeaderView.prototype.build = function() {\n\t    this.background = new Surface({\n\t      classes: [\"\" + this.cssPrefix + \"__background\"]\n\t    });\n\t    this.logo = new ImageSurface({\n\t      size: [55, 40],\n\t      classes: [\"\" + this.cssPrefix + \"__logo\"],\n\t      content: 'images/mark_tiny.png'\n\t    });\n\t    this.title = new Surface({\n\t      content: this.title,\n\t      classes: [\"\" + this.cssPrefix + \"__title\"]\n\t    });\n\t    this.add(this.background);\n\t    this.add(new Modifier({\n\t      origin: [0, 0],\n\t      transform: Transform.multiply(Transform.inFront, Transform.translate(10, 10))\n\t    })).add(this.logo);\n\t    return this.add(new Modifier({\n\t      transform: Transform.translate(0, 10)\n\t    })).add(this.title);\n\t  };\n\t\n\t  HeaderView.prototype.initEvents = function() {\n\t    return this.logo.on('click', (function(_this) {\n\t      return function() {\n\t        return _this._eventOutput.emit('toggleMenu');\n\t      };\n\t    })(this));\n\t  };\n\t\n\t  return HeaderView;\n\t\n\t})(View);\n\t\n\tmodule.exports = HeaderView;\n\n\n/***/ },\n/* 33 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar MenuView, Surface, View,\n\t  __hasProp = {}.hasOwnProperty,\n\t  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };\n\t\n\tView = __webpack_require__(4);\n\t\n\tSurface = __webpack_require__(2);\n\t\n\tMenuView = (function(_super) {\n\t  __extends(MenuView, _super);\n\t\n\t  function MenuView() {\n\t    MenuView.__super__.constructor.apply(this, arguments);\n\t    this.background = new Surface({\n\t      size: [280, void 0],\n\t      content: 'MENU!!!'\n\t    });\n\t    this.add(this.background);\n\t    this.background.on('click', (function(_this) {\n\t      return function() {\n\t        return _this._eventOutput.emit('toggleMenu');\n\t      };\n\t    })(this));\n\t  }\n\t\n\t  return MenuView;\n\t\n\t})(View);\n\t\n\tmodule.exports = MenuView;\n\n\n/***/ },\n/* 34 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar Engine, FpsMeter, Modifier, Surface, Timer, Transform, View,\n\t  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },\n\t  __hasProp = {}.hasOwnProperty,\n\t  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };\n\t\n\t__webpack_require__(51);\n\t\n\tView = __webpack_require__(4);\n\t\n\tSurface = __webpack_require__(2);\n\t\n\tModifier = __webpack_require__(3);\n\t\n\tEngine = __webpack_require__(9);\n\t\n\tTimer = __webpack_require__(16);\n\t\n\tTransform = __webpack_require__(1);\n\t\n\tFpsMeter = (function(_super) {\n\t  __extends(FpsMeter, _super);\n\t\n\t  FpsMeter.prototype.currTime = 0;\n\t\n\t  FpsMeter.prototype.lastTime = 0;\n\t\n\t  FpsMeter.prototype.frameTime = 0;\n\t\n\t  FpsMeter.prototype.state = true;\n\t\n\t  FpsMeter.prototype.filterStrength = 10;\n\t\n\t  FpsMeter.prototype.updateFrequency = 100;\n\t\n\t  function FpsMeter() {\n\t    this.update = __bind(this.update, this);\n\t    this.toggleState = __bind(this.toggleState, this);\n\t    this.tick = __bind(this.tick, this);\n\t    FpsMeter.__super__.constructor.apply(this, arguments);\n\t    this.initTime();\n\t    this.surface = new Surface({\n\t      size: [100, 20],\n\t      classes: ['fpsmeter'],\n\t      content: ''\n\t    });\n\t    this.add(new Modifier({\n\t      origin: [1, 1],\n\t      transform: Transform.inFront\n\t    })).add(this.surface);\n\t    this.surface.on('click', this.toggleState);\n\t    this.start();\n\t  }\n\t\n\t  FpsMeter.prototype.initTime = function() {\n\t    var perf, perfNow;\n\t    perf = window.performance;\n\t    if (perf && (perf.now || perf.webkitNow)) {\n\t      perfNow = perf.now ? 'now' : 'webkitNow';\n\t      this.getTime = perf[perfNow].bind(perf);\n\t    }\n\t    return this.lastTime = this.getTime();\n\t  };\n\t\n\t  FpsMeter.prototype.tick = function() {\n\t    var thisFrameTime;\n\t    this.currTime = this.getTime();\n\t    thisFrameTime = this.currTime - this.lastTime;\n\t    this.frameTime += (thisFrameTime - this.frameTime) / this.filterStrength;\n\t    return this.lastTime = this.currTime;\n\t  };\n\t\n\t  FpsMeter.prototype.toggleState = function() {\n\t    if (this.state) {\n\t      this.stop();\n\t    } else {\n\t      this.start();\n\t    }\n\t    return this.state = !this.state;\n\t  };\n\t\n\t  FpsMeter.prototype.start = function() {\n\t    Engine.on('prerender', this.tick);\n\t    return this.interval = Timer.setInterval(this.update, this.updateFrequency);\n\t  };\n\t\n\t  FpsMeter.prototype.stop = function() {\n\t    Engine.removeListener('prerender', this.tick);\n\t    return Timer.clear(this.interval);\n\t  };\n\t\n\t  FpsMeter.prototype.update = function() {\n\t    return this.surface.setContent(\"\" + ((1000 / this.frameTime).toFixed(1)) + \" fps\");\n\t  };\n\t\n\t  FpsMeter.prototype.getTime = function() {\n\t    return +new Date();\n\t  };\n\t\n\t  return FpsMeter;\n\t\n\t})(View);\n\t\n\tmodule.exports = FpsMeter;\n\n\n/***/ },\n/* 35 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar Easing, ImageSurface, Mascot, Modifier, StateModifier, Surface, Timer, Transform, View,\n\t  __hasProp = {}.hasOwnProperty,\n\t  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };\n\t\n\tView = __webpack_require__(4);\n\t\n\tSurface = __webpack_require__(2);\n\t\n\tImageSurface = __webpack_require__(14);\n\t\n\tModifier = __webpack_require__(3);\n\t\n\tStateModifier = __webpack_require__(13);\n\t\n\tTransform = __webpack_require__(1);\n\t\n\tEasing = __webpack_require__(25);\n\t\n\tTimer = __webpack_require__(16);\n\t\n\tMascot = (function(_super) {\n\t  __extends(Mascot, _super);\n\t\n\t  function Mascot() {\n\t    Mascot.__super__.constructor.apply(this, arguments);\n\t    this.stateModifier = new StateModifier;\n\t    this.modifier = this.add(this.stateModifier);\n\t    this.modifier.add(new ImageSurface({\n\t      size: [417, 800],\n\t      content: '/images/mascot_medium.png'\n\t    }));\n\t    this.stateModifier.setTransform(Transform.translate(0, 300), {\n\t      duration: 1000,\n\t      curve: Easing.inExpo\n\t    });\n\t    this.stateModifier.setTransform(Transform.translate(100, 300), {\n\t      duration: 800,\n\t      curve: Easing.outElastic\n\t    }, (function(_this) {\n\t      return function() {\n\t        _this.modifier.add(new Modifier({\n\t          transform: Transform.translate(400, 0)\n\t        })).add(new ImageSurface({\n\t          size: [192, 200],\n\t          content: 'images/talk_medium.png'\n\t        }));\n\t        _this.modifier.add(new Modifier({\n\t          transform: Transform.translate(480, 60)\n\t        })).add(new Surface({\n\t          content: 'Sup?'\n\t        }));\n\t        return Timer.setTimeout(function() {\n\t          return _this.fadeOut();\n\t        }, 1000);\n\t      };\n\t    })(this));\n\t  }\n\t\n\t  Mascot.prototype.fadeOut = function() {\n\t    return this.stateModifier.setOpacity(0, {\n\t      duration: 500,\n\t      curve: Easing.outCubic\n\t    });\n\t  };\n\t\n\t  return Mascot;\n\t\n\t})(View);\n\t\n\tmodule.exports = Mascot;\n\n\n/***/ },\n/* 36 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = {\n\t  \"public\": __webpack_require__(37)\n\t};\n\n\n/***/ },\n/* 37 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = {\n\t  parse: {\n\t    appId: 'sMSeqS1EP23z0vo3TgZKd38MBiP9qzrvnv0OHMk8',\n\t    jsKey: 'XrA5EweJyzPmhxQZY6DqE8qotDmAk13s5JKhkyql'\n\t  },\n\t  facebook: {\n\t    appId: '1410524409215955'\n\t  },\n\t  gatekeeper: {\n\t    server: 'http://localhost:9999'\n\t  },\n\t  upload: {\n\t    server: 'http://localhost:9998',\n\t    s3bucket: 'http://pegg.s3.amazonaws.com'\n\t  },\n\t  aviary: {\n\t    apiKey: 'cdef40f2d4f076a2'\n\t  }\n\t};\n\n\n/***/ },\n/* 38 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar Config;\n\t\n\t__webpack_require__(45);\n\t\n\tConfig = __webpack_require__(36)[\"public\"].parse;\n\t\n\tParse.initialize(Config.appId, Config.jsKey);\n\t\n\tmodule.exports = window.Parse;\n\n\n/***/ },\n/* 39 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports =\n\t\t\"html{transform-style:preserve-3d}html,body{width:100%;height:100%;margin:0;padding:0;-webkit-transform-style:preserve-3d;overflow:hidden}body{-webkit-font-smoothing:antialiased;-webkit-tap-highlight-color:transparent;-webkit-perspective:0;perspective:none}body,.famous-container{position:absolute;transform-style:preserve-3d}.famous-container,.famous-group{top:0;left:0;bottom:0;right:0;overflow:visible;-webkit-backface-visibility:visible;backface-visibility:visible;pointer-events:none;-webkit-transform-style:preserve-3d}.famous-group{width:0;height:0;margin:0;padding:0}.famous-group,.famous-surface{position:absolute;transform-style:preserve-3d}.famous-surface{-webkit-transform-origin:center center;transform-origin:center center;-webkit-backface-visibility:hidden;backface-visibility:hidden;-webkit-transform-style:flat;-webkit-box-sizing:border-box;-moz-box-sizing:border-box;-webkit-tap-highlight-color:transparent;pointer-events:auto}.famous-container-group{position:relative;width:100%;height:100%}\";\n\n/***/ },\n/* 40 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = \"body {\\n  font-family: \\\"Helvetica Neue\\\", \\\"Helvetica\\\", Helvetica, Arial, sans-serif; }\\n\\nbutton {\\n  width: 100%;\\n  height: 100%; }\\n\\n.answer {\\n  background-color: #00a5ff;\\n  padding: 10px;\\n  border: 10px solid white;\\n  text-align: center; }\\n\"\n\n/***/ },\n/* 41 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = \".backface-visible, .card__shim {\\n  backface-visibility: visible;\\n  -webkit-backface-visibility: visible;\\n  -moz-backface-visibility: visible;\\n  -ms-backface-visibility: visible; }\\n\\n.card__front, .card__middle, .card__back {\\n  text-align: center;\\n  cursor: pointer; }\\n\\n.card__front {\\n  background-color: #9fcacf; }\\n\\n.card__backing {\\n  background-color: #000; }\\n\\n.card__shim {\\n  background-color: #000; }\\n\\n.card__back {\\n  background-color: #ffd500; }\\n\"\n\n/***/ },\n/* 42 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = \".header__background, .footer {\\n  background-color: #0c0d2a;\\n  color: #fff;\\n  line-height: 100px;\\n  text-align: center; }\\n\\n.header__title {\\n  font-weight: bold;\\n  font-size: 30px;\\n  text-align: center;\\n  color: #fff; }\\n\\n.header__logo {\\n  cursor: pointer; }\\n\"\n\n/***/ },\n/* 43 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = \".fpsmeter {\\n  color: #000;\\n  cursor: pointer; }\\n\"\n\n/***/ },\n/* 44 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/*\r\n\t\tMIT License http://www.opensource.org/licenses/mit-license.php\r\n\t\tAuthor Tobias Koppers @sokra\r\n\t*/\r\n\tmodule.exports = function(src) {\r\n\t\tif (window.execScript)\r\n\t\t\twindow.execScript(src);\r\n\t\telse\r\n\t\t\teval.call(null, src);\r\n\t}\n\n/***/ },\n/* 45 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t__webpack_require__(44)(__webpack_require__(46))\n\n/***/ },\n/* 46 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = \"/*!\\n * Parse JavaScript SDK\\n * Version: 1.2.18\\n * Built: Wed Mar 12 2014 15:36:03\\n * http://parse.com\\n *\\n * Copyright 2014 Parse, Inc.\\n * The Parse JavaScript SDK is freely distributable under the MIT license.\\n *\\n * Includes: Underscore.js\\n * Copyright 2009-2012 Jeremy Ashkenas, DocumentCloud Inc.\\n * Released under the MIT license.\\n */\\n(function(root) {\\n  root.Parse = root.Parse || {};\\n  root.Parse.VERSION = \\\"js1.2.18\\\";\\n}(this));\\n//     Underscore.js 1.4.4\\n//     http://underscorejs.org\\n//     (c) 2009-2013 Jeremy Ashkenas, DocumentCloud Inc.\\n//     Underscore may be freely distributed under the MIT license.\\n\\n(function() {\\n\\n  // Baseline setup\\n  // --------------\\n\\n  // Establish the root object, `window` in the browser, or `global` on the server.\\n  var root = this;\\n\\n  // Save the previous value of the `_` variable.\\n  var previousUnderscore = root._;\\n\\n  // Establish the object that gets returned to break out of a loop iteration.\\n  var breaker = {};\\n\\n  // Save bytes in the minified (but not gzipped) version:\\n  var ArrayProto = Array.prototype, ObjProto = Object.prototype, FuncProto = Function.prototype;\\n\\n  // Create quick reference variables for speed access to core prototypes.\\n  var push             = ArrayProto.push,\\n      slice            = ArrayProto.slice,\\n      concat           = ArrayProto.concat,\\n      toString         = ObjProto.toString,\\n      hasOwnProperty   = ObjProto.hasOwnProperty;\\n\\n  // All **ECMAScript 5** native function implementations that we hope to use\\n  // are declared here.\\n  var\\n    nativeForEach      = ArrayProto.forEach,\\n    nativeMap          = ArrayProto.map,\\n    nativeReduce       = ArrayProto.reduce,\\n    nativeReduceRight  = ArrayProto.reduceRight,\\n    nativeFilter       = ArrayProto.filter,\\n    nativeEvery        = ArrayProto.every,\\n    nativeSome         = ArrayProto.some,\\n    nativeIndexOf      = ArrayProto.indexOf,\\n    nativeLastIndexOf  = ArrayProto.lastIndexOf,\\n    nativeIsArray      = Array.isArray,\\n    nativeKeys         = Object.keys,\\n    nativeBind         = FuncProto.bind;\\n\\n  // Create a safe reference to the Underscore object for use below.\\n  var _ = function(obj) {\\n    if (obj instanceof _) return obj;\\n    if (!(this instanceof _)) return new _(obj);\\n    this._wrapped = obj;\\n  };\\n\\n  // Export the Underscore object for **Node.js**, with\\n  // backwards-compatibility for the old `require()` API. If we're in\\n  // the browser, add `_` as a global object via a string identifier,\\n  // for Closure Compiler \\\"advanced\\\" mode.\\n  if (typeof exports !== 'undefined') {\\n    if (typeof module !== 'undefined' && module.exports) {\\n      exports = module.exports = _;\\n    }\\n    exports._ = _;\\n  } else {\\n    root._ = _;\\n  }\\n\\n  // Current version.\\n  _.VERSION = '1.4.4';\\n\\n  // Collection Functions\\n  // --------------------\\n\\n  // The cornerstone, an `each` implementation, aka `forEach`.\\n  // Handles objects with the built-in `forEach`, arrays, and raw objects.\\n  // Delegates to **ECMAScript 5**'s native `forEach` if available.\\n  var each = _.each = _.forEach = function(obj, iterator, context) {\\n    if (obj == null) return;\\n    if (nativeForEach && obj.forEach === nativeForEach) {\\n      obj.forEach(iterator, context);\\n    } else if (obj.length === +obj.length) {\\n      for (var i = 0, l = obj.length; i < l; i++) {\\n        if (iterator.call(context, obj[i], i, obj) === breaker) return;\\n      }\\n    } else {\\n      for (var key in obj) {\\n        if (_.has(obj, key)) {\\n          if (iterator.call(context, obj[key], key, obj) === breaker) return;\\n        }\\n      }\\n    }\\n  };\\n\\n  // Return the results of applying the iterator to each element.\\n  // Delegates to **ECMAScript 5**'s native `map` if available.\\n  _.map = _.collect = function(obj, iterator, context) {\\n    var results = [];\\n    if (obj == null) return results;\\n    if (nativeMap && obj.map === nativeMap) return obj.map(iterator, context);\\n    each(obj, function(value, index, list) {\\n      results[results.length] = iterator.call(context, value, index, list);\\n    });\\n    return results;\\n  };\\n\\n  var reduceError = 'Reduce of empty array with no initial value';\\n\\n  // **Reduce** builds up a single result from a list of values, aka `inject`,\\n  // or `foldl`. Delegates to **ECMAScript 5**'s native `reduce` if available.\\n  _.reduce = _.foldl = _.inject = function(obj, iterator, memo, context) {\\n    var initial = arguments.length > 2;\\n    if (obj == null) obj = [];\\n    if (nativeReduce && obj.reduce === nativeReduce) {\\n      if (context) iterator = _.bind(iterator, context);\\n      return initial ? obj.reduce(iterator, memo) : obj.reduce(iterator);\\n    }\\n    each(obj, function(value, index, list) {\\n      if (!initial) {\\n        memo = value;\\n        initial = true;\\n      } else {\\n        memo = iterator.call(context, memo, value, index, list);\\n      }\\n    });\\n    if (!initial) throw new TypeError(reduceError);\\n    return memo;\\n  };\\n\\n  // The right-associative version of reduce, also known as `foldr`.\\n  // Delegates to **ECMAScript 5**'s native `reduceRight` if available.\\n  _.reduceRight = _.foldr = function(obj, iterator, memo, context) {\\n    var initial = arguments.length > 2;\\n    if (obj == null) obj = [];\\n    if (nativeReduceRight && obj.reduceRight === nativeReduceRight) {\\n      if (context) iterator = _.bind(iterator, context);\\n      return initial ? obj.reduceRight(iterator, memo) : obj.reduceRight(iterator);\\n    }\\n    var length = obj.length;\\n    if (length !== +length) {\\n      var keys = _.keys(obj);\\n      length = keys.length;\\n    }\\n    each(obj, function(value, index, list) {\\n      index = keys ? keys[--length] : --length;\\n      if (!initial) {\\n        memo = obj[index];\\n        initial = true;\\n      } else {\\n        memo = iterator.call(context, memo, obj[index], index, list);\\n      }\\n    });\\n    if (!initial) throw new TypeError(reduceError);\\n    return memo;\\n  };\\n\\n  // Return the first value which passes a truth test. Aliased as `detect`.\\n  _.find = _.detect = function(obj, iterator, context) {\\n    var result;\\n    any(obj, function(value, index, list) {\\n      if (iterator.call(context, value, index, list)) {\\n        result = value;\\n        return true;\\n      }\\n    });\\n    return result;\\n  };\\n\\n  // Return all the elements that pass a truth test.\\n  // Delegates to **ECMAScript 5**'s native `filter` if available.\\n  // Aliased as `select`.\\n  _.filter = _.select = function(obj, iterator, context) {\\n    var results = [];\\n    if (obj == null) return results;\\n    if (nativeFilter && obj.filter === nativeFilter) return obj.filter(iterator, context);\\n    each(obj, function(value, index, list) {\\n      if (iterator.call(context, value, index, list)) results[results.length] = value;\\n    });\\n    return results;\\n  };\\n\\n  // Return all the elements for which a truth test fails.\\n  _.reject = function(obj, iterator, context) {\\n    return _.filter(obj, function(value, index, list) {\\n      return !iterator.call(context, value, index, list);\\n    }, context);\\n  };\\n\\n  // Determine whether all of the elements match a truth test.\\n  // Delegates to **ECMAScript 5**'s native `every` if available.\\n  // Aliased as `all`.\\n  _.every = _.all = function(obj, iterator, context) {\\n    iterator || (iterator = _.identity);\\n    var result = true;\\n    if (obj == null) return result;\\n    if (nativeEvery && obj.every === nativeEvery) return obj.every(iterator, context);\\n    each(obj, function(value, index, list) {\\n      if (!(result = result && iterator.call(context, value, index, list))) return breaker;\\n    });\\n    return !!result;\\n  };\\n\\n  // Determine if at least one element in the object matches a truth test.\\n  // Delegates to **ECMAScript 5**'s native `some` if available.\\n  // Aliased as `any`.\\n  var any = _.some = _.any = function(obj, iterator, context) {\\n    iterator || (iterator = _.identity);\\n    var result = false;\\n    if (obj == null) return result;\\n    if (nativeSome && obj.some === nativeSome) return obj.some(iterator, context);\\n    each(obj, function(value, index, list) {\\n      if (result || (result = iterator.call(context, value, index, list))) return breaker;\\n    });\\n    return !!result;\\n  };\\n\\n  // Determine if the array or object contains a given value (using `===`).\\n  // Aliased as `include`.\\n  _.contains = _.include = function(obj, target) {\\n    if (obj == null) return false;\\n    if (nativeIndexOf && obj.indexOf === nativeIndexOf) return obj.indexOf(target) != -1;\\n    return any(obj, function(value) {\\n      return value === target;\\n    });\\n  };\\n\\n  // Invoke a method (with arguments) on every item in a collection.\\n  _.invoke = function(obj, method) {\\n    var args = slice.call(arguments, 2);\\n    var isFunc = _.isFunction(method);\\n    return _.map(obj, function(value) {\\n      return (isFunc ? method : value[method]).apply(value, args);\\n    });\\n  };\\n\\n  // Convenience version of a common use case of `map`: fetching a property.\\n  _.pluck = function(obj, key) {\\n    return _.map(obj, function(value){ return value[key]; });\\n  };\\n\\n  // Convenience version of a common use case of `filter`: selecting only objects\\n  // containing specific `key:value` pairs.\\n  _.where = function(obj, attrs, first) {\\n    if (_.isEmpty(attrs)) return first ? null : [];\\n    return _[first ? 'find' : 'filter'](obj, function(value) {\\n      for (var key in attrs) {\\n        if (attrs[key] !== value[key]) return false;\\n      }\\n      return true;\\n    });\\n  };\\n\\n  // Convenience version of a common use case of `find`: getting the first object\\n  // containing specific `key:value` pairs.\\n  _.findWhere = function(obj, attrs) {\\n    return _.where(obj, attrs, true);\\n  };\\n\\n  // Return the maximum element or (element-based computation).\\n  // Can't optimize arrays of integers longer than 65,535 elements.\\n  // See: https://bugs.webkit.org/show_bug.cgi?id=80797\\n  _.max = function(obj, iterator, context) {\\n    if (!iterator && _.isArray(obj) && obj[0] === +obj[0] && obj.length < 65535) {\\n      return Math.max.apply(Math, obj);\\n    }\\n    if (!iterator && _.isEmpty(obj)) return -Infinity;\\n    var result = {computed : -Infinity, value: -Infinity};\\n    each(obj, function(value, index, list) {\\n      var computed = iterator ? iterator.call(context, value, index, list) : value;\\n      computed >= result.computed && (result = {value : value, computed : computed});\\n    });\\n    return result.value;\\n  };\\n\\n  // Return the minimum element (or element-based computation).\\n  _.min = function(obj, iterator, context) {\\n    if (!iterator && _.isArray(obj) && obj[0] === +obj[0] && obj.length < 65535) {\\n      return Math.min.apply(Math, obj);\\n    }\\n    if (!iterator && _.isEmpty(obj)) return Infinity;\\n    var result = {computed : Infinity, value: Infinity};\\n    each(obj, function(value, index, list) {\\n      var computed = iterator ? iterator.call(context, value, index, list) : value;\\n      computed < result.computed && (result = {value : value, computed : computed});\\n    });\\n    return result.value;\\n  };\\n\\n  // Shuffle an array.\\n  _.shuffle = function(obj) {\\n    var rand;\\n    var index = 0;\\n    var shuffled = [];\\n    each(obj, function(value) {\\n      rand = _.random(index++);\\n      shuffled[index - 1] = shuffled[rand];\\n      shuffled[rand] = value;\\n    });\\n    return shuffled;\\n  };\\n\\n  // An internal function to generate lookup iterators.\\n  var lookupIterator = function(value) {\\n    return _.isFunction(value) ? value : function(obj){ return obj[value]; };\\n  };\\n\\n  // Sort the object's values by a criterion produced by an iterator.\\n  _.sortBy = function(obj, value, context) {\\n    var iterator = lookupIterator(value);\\n    return _.pluck(_.map(obj, function(value, index, list) {\\n      return {\\n        value : value,\\n        index : index,\\n        criteria : iterator.call(context, value, index, list)\\n      };\\n    }).sort(function(left, right) {\\n      var a = left.criteria;\\n      var b = right.criteria;\\n      if (a !== b) {\\n        if (a > b || a === void 0) return 1;\\n        if (a < b || b === void 0) return -1;\\n      }\\n      return left.index < right.index ? -1 : 1;\\n    }), 'value');\\n  };\\n\\n  // An internal function used for aggregate \\\"group by\\\" operations.\\n  var group = function(obj, value, context, behavior) {\\n    var result = {};\\n    var iterator = lookupIterator(value || _.identity);\\n    each(obj, function(value, index) {\\n      var key = iterator.call(context, value, index, obj);\\n      behavior(result, key, value);\\n    });\\n    return result;\\n  };\\n\\n  // Groups the object's values by a criterion. Pass either a string attribute\\n  // to group by, or a function that returns the criterion.\\n  _.groupBy = function(obj, value, context) {\\n    return group(obj, value, context, function(result, key, value) {\\n      (_.has(result, key) ? result[key] : (result[key] = [])).push(value);\\n    });\\n  };\\n\\n  // Counts instances of an object that group by a certain criterion. Pass\\n  // either a string attribute to count by, or a function that returns the\\n  // criterion.\\n  _.countBy = function(obj, value, context) {\\n    return group(obj, value, context, function(result, key) {\\n      if (!_.has(result, key)) result[key] = 0;\\n      result[key]++;\\n    });\\n  };\\n\\n  // Use a comparator function to figure out the smallest index at which\\n  // an object should be inserted so as to maintain order. Uses binary search.\\n  _.sortedIndex = function(array, obj, iterator, context) {\\n    iterator = iterator == null ? _.identity : lookupIterator(iterator);\\n    var value = iterator.call(context, obj);\\n    var low = 0, high = array.length;\\n    while (low < high) {\\n      var mid = (low + high) >>> 1;\\n      iterator.call(context, array[mid]) < value ? low = mid + 1 : high = mid;\\n    }\\n    return low;\\n  };\\n\\n  // Safely convert anything iterable into a real, live array.\\n  _.toArray = function(obj) {\\n    if (!obj) return [];\\n    if (_.isArray(obj)) return slice.call(obj);\\n    if (obj.length === +obj.length) return _.map(obj, _.identity);\\n    return _.values(obj);\\n  };\\n\\n  // Return the number of elements in an object.\\n  _.size = function(obj) {\\n    if (obj == null) return 0;\\n    return (obj.length === +obj.length) ? obj.length : _.keys(obj).length;\\n  };\\n\\n  // Array Functions\\n  // ---------------\\n\\n  // Get the first element of an array. Passing **n** will return the first N\\n  // values in the array. Aliased as `head` and `take`. The **guard** check\\n  // allows it to work with `_.map`.\\n  _.first = _.head = _.take = function(array, n, guard) {\\n    if (array == null) return void 0;\\n    return (n != null) && !guard ? slice.call(array, 0, n) : array[0];\\n  };\\n\\n  // Returns everything but the last entry of the array. Especially useful on\\n  // the arguments object. Passing **n** will return all the values in\\n  // the array, excluding the last N. The **guard** check allows it to work with\\n  // `_.map`.\\n  _.initial = function(array, n, guard) {\\n    return slice.call(array, 0, array.length - ((n == null) || guard ? 1 : n));\\n  };\\n\\n  // Get the last element of an array. Passing **n** will return the last N\\n  // values in the array. The **guard** check allows it to work with `_.map`.\\n  _.last = function(array, n, guard) {\\n    if (array == null) return void 0;\\n    if ((n != null) && !guard) {\\n      return slice.call(array, Math.max(array.length - n, 0));\\n    } else {\\n      return array[array.length - 1];\\n    }\\n  };\\n\\n  // Returns everything but the first entry of the array. Aliased as `tail` and `drop`.\\n  // Especially useful on the arguments object. Passing an **n** will return\\n  // the rest N values in the array. The **guard**\\n  // check allows it to work with `_.map`.\\n  _.rest = _.tail = _.drop = function(array, n, guard) {\\n    return slice.call(array, (n == null) || guard ? 1 : n);\\n  };\\n\\n  // Trim out all falsy values from an array.\\n  _.compact = function(array) {\\n    return _.filter(array, _.identity);\\n  };\\n\\n  // Internal implementation of a recursive `flatten` function.\\n  var flatten = function(input, shallow, output) {\\n    each(input, function(value) {\\n      if (_.isArray(value)) {\\n        shallow ? push.apply(output, value) : flatten(value, shallow, output);\\n      } else {\\n        output.push(value);\\n      }\\n    });\\n    return output;\\n  };\\n\\n  // Return a completely flattened version of an array.\\n  _.flatten = function(array, shallow) {\\n    return flatten(array, shallow, []);\\n  };\\n\\n  // Return a version of the array that does not contain the specified value(s).\\n  _.without = function(array) {\\n    return _.difference(array, slice.call(arguments, 1));\\n  };\\n\\n  // Produce a duplicate-free version of the array. If the array has already\\n  // been sorted, you have the option of using a faster algorithm.\\n  // Aliased as `unique`.\\n  _.uniq = _.unique = function(array, isSorted, iterator, context) {\\n    if (_.isFunction(isSorted)) {\\n      context = iterator;\\n      iterator = isSorted;\\n      isSorted = false;\\n    }\\n    var initial = iterator ? _.map(array, iterator, context) : array;\\n    var results = [];\\n    var seen = [];\\n    each(initial, function(value, index) {\\n      if (isSorted ? (!index || seen[seen.length - 1] !== value) : !_.contains(seen, value)) {\\n        seen.push(value);\\n        results.push(array[index]);\\n      }\\n    });\\n    return results;\\n  };\\n\\n  // Produce an array that contains the union: each distinct element from all of\\n  // the passed-in arrays.\\n  _.union = function() {\\n    return _.uniq(concat.apply(ArrayProto, arguments));\\n  };\\n\\n  // Produce an array that contains every item shared between all the\\n  // passed-in arrays.\\n  _.intersection = function(array) {\\n    var rest = slice.call(arguments, 1);\\n    return _.filter(_.uniq(array), function(item) {\\n      return _.every(rest, function(other) {\\n        return _.indexOf(other, item) >= 0;\\n      });\\n    });\\n  };\\n\\n  // Take the difference between one array and a number of other arrays.\\n  // Only the elements present in just the first array will remain.\\n  _.difference = function(array) {\\n    var rest = concat.apply(ArrayProto, slice.call(arguments, 1));\\n    return _.filter(array, function(value){ return !_.contains(rest, value); });\\n  };\\n\\n  // Zip together multiple lists into a single array -- elements that share\\n  // an index go together.\\n  _.zip = function() {\\n    var args = slice.call(arguments);\\n    var length = _.max(_.pluck(args, 'length'));\\n    var results = new Array(length);\\n    for (var i = 0; i < length; i++) {\\n      results[i] = _.pluck(args, \\\"\\\" + i);\\n    }\\n    return results;\\n  };\\n\\n  // Converts lists into objects. Pass either a single array of `[key, value]`\\n  // pairs, or two parallel arrays of the same length -- one of keys, and one of\\n  // the corresponding values.\\n  _.object = function(list, values) {\\n    if (list == null) return {};\\n    var result = {};\\n    for (var i = 0, l = list.length; i < l; i++) {\\n      if (values) {\\n        result[list[i]] = values[i];\\n      } else {\\n        result[list[i][0]] = list[i][1];\\n      }\\n    }\\n    return result;\\n  };\\n\\n  // If the browser doesn't supply us with indexOf (I'm looking at you, **MSIE**),\\n  // we need this function. Return the position of the first occurrence of an\\n  // item in an array, or -1 if the item is not included in the array.\\n  // Delegates to **ECMAScript 5**'s native `indexOf` if available.\\n  // If the array is large and already in sort order, pass `true`\\n  // for **isSorted** to use binary search.\\n  _.indexOf = function(array, item, isSorted) {\\n    if (array == null) return -1;\\n    var i = 0, l = array.length;\\n    if (isSorted) {\\n      if (typeof isSorted == 'number') {\\n        i = (isSorted < 0 ? Math.max(0, l + isSorted) : isSorted);\\n      } else {\\n        i = _.sortedIndex(array, item);\\n        return array[i] === item ? i : -1;\\n      }\\n    }\\n    if (nativeIndexOf && array.indexOf === nativeIndexOf) return array.indexOf(item, isSorted);\\n    for (; i < l; i++) if (array[i] === item) return i;\\n    return -1;\\n  };\\n\\n  // Delegates to **ECMAScript 5**'s native `lastIndexOf` if available.\\n  _.lastIndexOf = function(array, item, from) {\\n    if (array == null) return -1;\\n    var hasIndex = from != null;\\n    if (nativeLastIndexOf && array.lastIndexOf === nativeLastIndexOf) {\\n      return hasIndex ? array.lastIndexOf(item, from) : array.lastIndexOf(item);\\n    }\\n    var i = (hasIndex ? from : array.length);\\n    while (i--) if (array[i] === item) return i;\\n    return -1;\\n  };\\n\\n  // Generate an integer Array containing an arithmetic progression. A port of\\n  // the native Python `range()` function. See\\n  // [the Python documentation](http://docs.python.org/library/functions.html#range).\\n  _.range = function(start, stop, step) {\\n    if (arguments.length <= 1) {\\n      stop = start || 0;\\n      start = 0;\\n    }\\n    step = arguments[2] || 1;\\n\\n    var len = Math.max(Math.ceil((stop - start) / step), 0);\\n    var idx = 0;\\n    var range = new Array(len);\\n\\n    while(idx < len) {\\n      range[idx++] = start;\\n      start += step;\\n    }\\n\\n    return range;\\n  };\\n\\n  // Function (ahem) Functions\\n  // ------------------\\n\\n  // Create a function bound to a given object (assigning `this`, and arguments,\\n  // optionally). Delegates to **ECMAScript 5**'s native `Function.bind` if\\n  // available.\\n  _.bind = function(func, context) {\\n    if (func.bind === nativeBind && nativeBind) return nativeBind.apply(func, slice.call(arguments, 1));\\n    var args = slice.call(arguments, 2);\\n    return function() {\\n      return func.apply(context, args.concat(slice.call(arguments)));\\n    };\\n  };\\n\\n  // Partially apply a function by creating a version that has had some of its\\n  // arguments pre-filled, without changing its dynamic `this` context.\\n  _.partial = function(func) {\\n    var args = slice.call(arguments, 1);\\n    return function() {\\n      return func.apply(this, args.concat(slice.call(arguments)));\\n    };\\n  };\\n\\n  // Bind all of an object's methods to that object. Useful for ensuring that\\n  // all callbacks defined on an object belong to it.\\n  _.bindAll = function(obj) {\\n    var funcs = slice.call(arguments, 1);\\n    if (funcs.length === 0) funcs = _.functions(obj);\\n    each(funcs, function(f) { obj[f] = _.bind(obj[f], obj); });\\n    return obj;\\n  };\\n\\n  // Memoize an expensive function by storing its results.\\n  _.memoize = function(func, hasher) {\\n    var memo = {};\\n    hasher || (hasher = _.identity);\\n    return function() {\\n      var key = hasher.apply(this, arguments);\\n      return _.has(memo, key) ? memo[key] : (memo[key] = func.apply(this, arguments));\\n    };\\n  };\\n\\n  // Delays a function for the given number of milliseconds, and then calls\\n  // it with the arguments supplied.\\n  _.delay = function(func, wait) {\\n    var args = slice.call(arguments, 2);\\n    return setTimeout(function(){ return func.apply(null, args); }, wait);\\n  };\\n\\n  // Defers a function, scheduling it to run after the current call stack has\\n  // cleared.\\n  _.defer = function(func) {\\n    return _.delay.apply(_, [func, 1].concat(slice.call(arguments, 1)));\\n  };\\n\\n  // Returns a function, that, when invoked, will only be triggered at most once\\n  // during a given window of time.\\n  _.throttle = function(func, wait) {\\n    var context, args, timeout, result;\\n    var previous = 0;\\n    var later = function() {\\n      previous = new Date;\\n      timeout = null;\\n      result = func.apply(context, args);\\n    };\\n    return function() {\\n      var now = new Date;\\n      var remaining = wait - (now - previous);\\n      context = this;\\n      args = arguments;\\n      if (remaining <= 0) {\\n        clearTimeout(timeout);\\n        timeout = null;\\n        previous = now;\\n        result = func.apply(context, args);\\n      } else if (!timeout) {\\n        timeout = setTimeout(later, remaining);\\n      }\\n      return result;\\n    };\\n  };\\n\\n  // Returns a function, that, as long as it continues to be invoked, will not\\n  // be triggered. The function will be called after it stops being called for\\n  // N milliseconds. If `immediate` is passed, trigger the function on the\\n  // leading edge, instead of the trailing.\\n  _.debounce = function(func, wait, immediate) {\\n    var timeout, result;\\n    return function() {\\n      var context = this, args = arguments;\\n      var later = function() {\\n        timeout = null;\\n        if (!immediate) result = func.apply(context, args);\\n      };\\n      var callNow = immediate && !timeout;\\n      clearTimeout(timeout);\\n      timeout = setTimeout(later, wait);\\n      if (callNow) result = func.apply(context, args);\\n      return result;\\n    };\\n  };\\n\\n  // Returns a function that will be executed at most one time, no matter how\\n  // often you call it. Useful for lazy initialization.\\n  _.once = function(func) {\\n    var ran = false, memo;\\n    return function() {\\n      if (ran) return memo;\\n      ran = true;\\n      memo = func.apply(this, arguments);\\n      func = null;\\n      return memo;\\n    };\\n  };\\n\\n  // Returns the first function passed as an argument to the second,\\n  // allowing you to adjust arguments, run code before and after, and\\n  // conditionally execute the original function.\\n  _.wrap = function(func, wrapper) {\\n    return function() {\\n      var args = [func];\\n      push.apply(args, arguments);\\n      return wrapper.apply(this, args);\\n    };\\n  };\\n\\n  // Returns a function that is the composition of a list of functions, each\\n  // consuming the return value of the function that follows.\\n  _.compose = function() {\\n    var funcs = arguments;\\n    return function() {\\n      var args = arguments;\\n      for (var i = funcs.length - 1; i >= 0; i--) {\\n        args = [funcs[i].apply(this, args)];\\n      }\\n      return args[0];\\n    };\\n  };\\n\\n  // Returns a function that will only be executed after being called N times.\\n  _.after = function(times, func) {\\n    if (times <= 0) return func();\\n    return function() {\\n      if (--times < 1) {\\n        return func.apply(this, arguments);\\n      }\\n    };\\n  };\\n\\n  // Object Functions\\n  // ----------------\\n\\n  // Retrieve the names of an object's properties.\\n  // Delegates to **ECMAScript 5**'s native `Object.keys`\\n  _.keys = nativeKeys || function(obj) {\\n    if (obj !== Object(obj)) throw new TypeError('Invalid object');\\n    var keys = [];\\n    for (var key in obj) if (_.has(obj, key)) keys[keys.length] = key;\\n    return keys;\\n  };\\n\\n  // Retrieve the values of an object's properties.\\n  _.values = function(obj) {\\n    var values = [];\\n    for (var key in obj) if (_.has(obj, key)) values.push(obj[key]);\\n    return values;\\n  };\\n\\n  // Convert an object into a list of `[key, value]` pairs.\\n  _.pairs = function(obj) {\\n    var pairs = [];\\n    for (var key in obj) if (_.has(obj, key)) pairs.push([key, obj[key]]);\\n    return pairs;\\n  };\\n\\n  // Invert the keys and values of an object. The values must be serializable.\\n  _.invert = function(obj) {\\n    var result = {};\\n    for (var key in obj) if (_.has(obj, key)) result[obj[key]] = key;\\n    return result;\\n  };\\n\\n  // Return a sorted list of the function names available on the object.\\n  // Aliased as `methods`\\n  _.functions = _.methods = function(obj) {\\n    var names = [];\\n    for (var key in obj) {\\n      if (_.isFunction(obj[key])) names.push(key);\\n    }\\n    return names.sort();\\n  };\\n\\n  // Extend a given object with all the properties in passed-in object(s).\\n  _.extend = function(obj) {\\n    each(slice.call(arguments, 1), function(source) {\\n      if (source) {\\n        for (var prop in source) {\\n          obj[prop] = source[prop];\\n        }\\n      }\\n    });\\n    return obj;\\n  };\\n\\n  // Return a copy of the object only containing the whitelisted properties.\\n  _.pick = function(obj) {\\n    var copy = {};\\n    var keys = concat.apply(ArrayProto, slice.call(arguments, 1));\\n    each(keys, function(key) {\\n      if (key in obj) copy[key] = obj[key];\\n    });\\n    return copy;\\n  };\\n\\n   // Return a copy of the object without the blacklisted properties.\\n  _.omit = function(obj) {\\n    var copy = {};\\n    var keys = concat.apply(ArrayProto, slice.call(arguments, 1));\\n    for (var key in obj) {\\n      if (!_.contains(keys, key)) copy[key] = obj[key];\\n    }\\n    return copy;\\n  };\\n\\n  // Fill in a given object with default properties.\\n  _.defaults = function(obj) {\\n    each(slice.call(arguments, 1), function(source) {\\n      if (source) {\\n        for (var prop in source) {\\n          if (obj[prop] == null) obj[prop] = source[prop];\\n        }\\n      }\\n    });\\n    return obj;\\n  };\\n\\n  // Create a (shallow-cloned) duplicate of an object.\\n  _.clone = function(obj) {\\n    if (!_.isObject(obj)) return obj;\\n    return _.isArray(obj) ? obj.slice() : _.extend({}, obj);\\n  };\\n\\n  // Invokes interceptor with the obj, and then returns obj.\\n  // The primary purpose of this method is to \\\"tap into\\\" a method chain, in\\n  // order to perform operations on intermediate results within the chain.\\n  _.tap = function(obj, interceptor) {\\n    interceptor(obj);\\n    return obj;\\n  };\\n\\n  // Internal recursive comparison function for `isEqual`.\\n  var eq = function(a, b, aStack, bStack) {\\n    // Identical objects are equal. `0 === -0`, but they aren't identical.\\n    // See the Harmony `egal` proposal: http://wiki.ecmascript.org/doku.php?id=harmony:egal.\\n    if (a === b) return a !== 0 || 1 / a == 1 / b;\\n    // A strict comparison is necessary because `null == undefined`.\\n    if (a == null || b == null) return a === b;\\n    // Unwrap any wrapped objects.\\n    if (a instanceof _) a = a._wrapped;\\n    if (b instanceof _) b = b._wrapped;\\n    // Compare `[[Class]]` names.\\n    var className = toString.call(a);\\n    if (className != toString.call(b)) return false;\\n    switch (className) {\\n      // Strings, numbers, dates, and booleans are compared by value.\\n      case '[object String]':\\n        // Primitives and their corresponding object wrappers are equivalent; thus, `\\\"5\\\"` is\\n        // equivalent to `new String(\\\"5\\\")`.\\n        return a == String(b);\\n      case '[object Number]':\\n        // `NaN`s are equivalent, but non-reflexive. An `egal` comparison is performed for\\n        // other numeric values.\\n        return a != +a ? b != +b : (a == 0 ? 1 / a == 1 / b : a == +b);\\n      case '[object Date]':\\n      case '[object Boolean]':\\n        // Coerce dates and booleans to numeric primitive values. Dates are compared by their\\n        // millisecond representations. Note that invalid dates with millisecond representations\\n        // of `NaN` are not equivalent.\\n        return +a == +b;\\n      // RegExps are compared by their source patterns and flags.\\n      case '[object RegExp]':\\n        return a.source == b.source &&\\n               a.global == b.global &&\\n               a.multiline == b.multiline &&\\n               a.ignoreCase == b.ignoreCase;\\n    }\\n    if (typeof a != 'object' || typeof b != 'object') return false;\\n    // Assume equality for cyclic structures. The algorithm for detecting cyclic\\n    // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.\\n    var length = aStack.length;\\n    while (length--) {\\n      // Linear search. Performance is inversely proportional to the number of\\n      // unique nested structures.\\n      if (aStack[length] == a) return bStack[length] == b;\\n    }\\n    // Add the first object to the stack of traversed objects.\\n    aStack.push(a);\\n    bStack.push(b);\\n    var size = 0, result = true;\\n    // Recursively compare objects and arrays.\\n    if (className == '[object Array]') {\\n      // Compare array lengths to determine if a deep comparison is necessary.\\n      size = a.length;\\n      result = size == b.length;\\n      if (result) {\\n        // Deep compare the contents, ignoring non-numeric properties.\\n        while (size--) {\\n          if (!(result = eq(a[size], b[size], aStack, bStack))) break;\\n        }\\n      }\\n    } else {\\n      // Objects with different constructors are not equivalent, but `Object`s\\n      // from different frames are.\\n      var aCtor = a.constructor, bCtor = b.constructor;\\n      if (aCtor !== bCtor && !(_.isFunction(aCtor) && (aCtor instanceof aCtor) &&\\n                               _.isFunction(bCtor) && (bCtor instanceof bCtor))) {\\n        return false;\\n      }\\n      // Deep compare objects.\\n      for (var key in a) {\\n        if (_.has(a, key)) {\\n          // Count the expected number of properties.\\n          size++;\\n          // Deep compare each member.\\n          if (!(result = _.has(b, key) && eq(a[key], b[key], aStack, bStack))) break;\\n        }\\n      }\\n      // Ensure that both objects contain the same number of properties.\\n      if (result) {\\n        for (key in b) {\\n          if (_.has(b, key) && !(size--)) break;\\n        }\\n        result = !size;\\n      }\\n    }\\n    // Remove the first object from the stack of traversed objects.\\n    aStack.pop();\\n    bStack.pop();\\n    return result;\\n  };\\n\\n  // Perform a deep comparison to check if two objects are equal.\\n  _.isEqual = function(a, b) {\\n    return eq(a, b, [], []);\\n  };\\n\\n  // Is a given array, string, or object empty?\\n  // An \\\"empty\\\" object has no enumerable own-properties.\\n  _.isEmpty = function(obj) {\\n    if (obj == null) return true;\\n    if (_.isArray(obj) || _.isString(obj)) return obj.length === 0;\\n    for (var key in obj) if (_.has(obj, key)) return false;\\n    return true;\\n  };\\n\\n  // Is a given value a DOM element?\\n  _.isElement = function(obj) {\\n    return !!(obj && obj.nodeType === 1);\\n  };\\n\\n  // Is a given value an array?\\n  // Delegates to ECMA5's native Array.isArray\\n  _.isArray = nativeIsArray || function(obj) {\\n    return toString.call(obj) == '[object Array]';\\n  };\\n\\n  // Is a given variable an object?\\n  _.isObject = function(obj) {\\n    return obj === Object(obj);\\n  };\\n\\n  // Add some isType methods: isArguments, isFunction, isString, isNumber, isDate, isRegExp.\\n  each(['Arguments', 'Function', 'String', 'Number', 'Date', 'RegExp'], function(name) {\\n    _['is' + name] = function(obj) {\\n      return toString.call(obj) == '[object ' + name + ']';\\n    };\\n  });\\n\\n  // Define a fallback version of the method in browsers (ahem, IE), where\\n  // there isn't any inspectable \\\"Arguments\\\" type.\\n  if (!_.isArguments(arguments)) {\\n    _.isArguments = function(obj) {\\n      return !!(obj && _.has(obj, 'callee'));\\n    };\\n  }\\n\\n  // Optimize `isFunction` if appropriate.\\n  if (typeof (/./) !== 'function') {\\n    _.isFunction = function(obj) {\\n      return typeof obj === 'function';\\n    };\\n  }\\n\\n  // Is a given object a finite number?\\n  _.isFinite = function(obj) {\\n    return isFinite(obj) && !isNaN(parseFloat(obj));\\n  };\\n\\n  // Is the given value `NaN`? (NaN is the only number which does not equal itself).\\n  _.isNaN = function(obj) {\\n    return _.isNumber(obj) && obj != +obj;\\n  };\\n\\n  // Is a given value a boolean?\\n  _.isBoolean = function(obj) {\\n    return obj === true || obj === false || toString.call(obj) == '[object Boolean]';\\n  };\\n\\n  // Is a given value equal to null?\\n  _.isNull = function(obj) {\\n    return obj === null;\\n  };\\n\\n  // Is a given variable undefined?\\n  _.isUndefined = function(obj) {\\n    return obj === void 0;\\n  };\\n\\n  // Shortcut function for checking if an object has a given property directly\\n  // on itself (in other words, not on a prototype).\\n  _.has = function(obj, key) {\\n    return hasOwnProperty.call(obj, key);\\n  };\\n\\n  // Utility Functions\\n  // -----------------\\n\\n  // Run Underscore.js in *noConflict* mode, returning the `_` variable to its\\n  // previous owner. Returns a reference to the Underscore object.\\n  _.noConflict = function() {\\n    root._ = previousUnderscore;\\n    return this;\\n  };\\n\\n  // Keep the identity function around for default iterators.\\n  _.identity = function(value) {\\n    return value;\\n  };\\n\\n  // Run a function **n** times.\\n  _.times = function(n, iterator, context) {\\n    var accum = Array(n);\\n    for (var i = 0; i < n; i++) accum[i] = iterator.call(context, i);\\n    return accum;\\n  };\\n\\n  // Return a random integer between min and max (inclusive).\\n  _.random = function(min, max) {\\n    if (max == null) {\\n      max = min;\\n      min = 0;\\n    }\\n    return min + Math.floor(Math.random() * (max - min + 1));\\n  };\\n\\n  // List of HTML entities for escaping.\\n  var entityMap = {\\n    escape: {\\n      '&': '&amp;',\\n      '<': '&lt;',\\n      '>': '&gt;',\\n      '\\\"': '&quot;',\\n      \\\"'\\\": '&#x27;',\\n      '/': '&#x2F;'\\n    }\\n  };\\n  entityMap.unescape = _.invert(entityMap.escape);\\n\\n  // Regexes containing the keys and values listed immediately above.\\n  var entityRegexes = {\\n    escape:   new RegExp('[' + _.keys(entityMap.escape).join('') + ']', 'g'),\\n    unescape: new RegExp('(' + _.keys(entityMap.unescape).join('|') + ')', 'g')\\n  };\\n\\n  // Functions for escaping and unescaping strings to/from HTML interpolation.\\n  _.each(['escape', 'unescape'], function(method) {\\n    _[method] = function(string) {\\n      if (string == null) return '';\\n      return ('' + string).replace(entityRegexes[method], function(match) {\\n        return entityMap[method][match];\\n      });\\n    };\\n  });\\n\\n  // If the value of the named property is a function then invoke it;\\n  // otherwise, return it.\\n  _.result = function(object, property) {\\n    if (object == null) return null;\\n    var value = object[property];\\n    return _.isFunction(value) ? value.call(object) : value;\\n  };\\n\\n  // Add your own custom functions to the Underscore object.\\n  _.mixin = function(obj) {\\n    each(_.functions(obj), function(name){\\n      var func = _[name] = obj[name];\\n      _.prototype[name] = function() {\\n        var args = [this._wrapped];\\n        push.apply(args, arguments);\\n        return result.call(this, func.apply(_, args));\\n      };\\n    });\\n  };\\n\\n  // Generate a unique integer id (unique within the entire client session).\\n  // Useful for temporary DOM ids.\\n  var idCounter = 0;\\n  _.uniqueId = function(prefix) {\\n    var id = ++idCounter + '';\\n    return prefix ? prefix + id : id;\\n  };\\n\\n  // By default, Underscore uses ERB-style template delimiters, change the\\n  // following template settings to use alternative delimiters.\\n  _.templateSettings = {\\n    evaluate    : /<%([\\\\s\\\\S]+?)%>/g,\\n    interpolate : /<%=([\\\\s\\\\S]+?)%>/g,\\n    escape      : /<%-([\\\\s\\\\S]+?)%>/g\\n  };\\n\\n  // When customizing `templateSettings`, if you don't want to define an\\n  // interpolation, evaluation or escaping regex, we need one that is\\n  // guaranteed not to match.\\n  var noMatch = /(.)^/;\\n\\n  // Certain characters need to be escaped so that they can be put into a\\n  // string literal.\\n  var escapes = {\\n    \\\"'\\\":      \\\"'\\\",\\n    '\\\\\\\\':     '\\\\\\\\',\\n    '\\\\r':     'r',\\n    '\\\\n':     'n',\\n    '\\\\t':     't',\\n    '\\\\u2028': 'u2028',\\n    '\\\\u2029': 'u2029'\\n  };\\n\\n  var escaper = /\\\\\\\\|'|\\\\r|\\\\n|\\\\t|\\\\u2028|\\\\u2029/g;\\n\\n  // JavaScript micro-templating, similar to John Resig's implementation.\\n  // Underscore templating handles arbitrary delimiters, preserves whitespace,\\n  // and correctly escapes quotes within interpolated code.\\n  _.template = function(text, data, settings) {\\n    var render;\\n    settings = _.defaults({}, settings, _.templateSettings);\\n\\n    // Combine delimiters into one regular expression via alternation.\\n    var matcher = new RegExp([\\n      (settings.escape || noMatch).source,\\n      (settings.interpolate || noMatch).source,\\n      (settings.evaluate || noMatch).source\\n    ].join('|') + '|$', 'g');\\n\\n    // Compile the template source, escaping string literals appropriately.\\n    var index = 0;\\n    var source = \\\"__p+='\\\";\\n    text.replace(matcher, function(match, escape, interpolate, evaluate, offset) {\\n      source += text.slice(index, offset)\\n        .replace(escaper, function(match) { return '\\\\\\\\' + escapes[match]; });\\n\\n      if (escape) {\\n        source += \\\"'+\\\\n((__t=(\\\" + escape + \\\"))==null?'':_.escape(__t))+\\\\n'\\\";\\n      }\\n      if (interpolate) {\\n        source += \\\"'+\\\\n((__t=(\\\" + interpolate + \\\"))==null?'':__t)+\\\\n'\\\";\\n      }\\n      if (evaluate) {\\n        source += \\\"';\\\\n\\\" + evaluate + \\\"\\\\n__p+='\\\";\\n      }\\n      index = offset + match.length;\\n      return match;\\n    });\\n    source += \\\"';\\\\n\\\";\\n\\n    // If a variable is not specified, place data values in local scope.\\n    if (!settings.variable) source = 'with(obj||{}){\\\\n' + source + '}\\\\n';\\n\\n    source = \\\"var __t,__p='',__j=Array.prototype.join,\\\" +\\n      \\\"print=function(){__p+=__j.call(arguments,'');};\\\\n\\\" +\\n      source + \\\"return __p;\\\\n\\\";\\n\\n    try {\\n      render = new Function(settings.variable || 'obj', '_', source);\\n    } catch (e) {\\n      e.source = source;\\n      throw e;\\n    }\\n\\n    if (data) return render(data, _);\\n    var template = function(data) {\\n      return render.call(this, data, _);\\n    };\\n\\n    // Provide the compiled function source as a convenience for precompilation.\\n    template.source = 'function(' + (settings.variable || 'obj') + '){\\\\n' + source + '}';\\n\\n    return template;\\n  };\\n\\n  // Add a \\\"chain\\\" function, which will delegate to the wrapper.\\n  _.chain = function(obj) {\\n    return _(obj).chain();\\n  };\\n\\n  // OOP\\n  // ---------------\\n  // If Underscore is called as a function, it returns a wrapped object that\\n  // can be used OO-style. This wrapper holds altered versions of all the\\n  // underscore functions. Wrapped objects may be chained.\\n\\n  // Helper function to continue chaining intermediate results.\\n  var result = function(obj) {\\n    return this._chain ? _(obj).chain() : obj;\\n  };\\n\\n  // Add all of the Underscore functions to the wrapper object.\\n  _.mixin(_);\\n\\n  // Add all mutator Array functions to the wrapper.\\n  each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function(name) {\\n    var method = ArrayProto[name];\\n    _.prototype[name] = function() {\\n      var obj = this._wrapped;\\n      method.apply(obj, arguments);\\n      if ((name == 'shift' || name == 'splice') && obj.length === 0) delete obj[0];\\n      return result.call(this, obj);\\n    };\\n  });\\n\\n  // Add all accessor Array functions to the wrapper.\\n  each(['concat', 'join', 'slice'], function(name) {\\n    var method = ArrayProto[name];\\n    _.prototype[name] = function() {\\n      return result.call(this, method.apply(this._wrapped, arguments));\\n    };\\n  });\\n\\n  _.extend(_.prototype, {\\n\\n    // Start chaining a wrapped Underscore object.\\n    chain: function() {\\n      this._chain = true;\\n      return this;\\n    },\\n\\n    // Extracts the result from a wrapped and chained object.\\n    value: function() {\\n      return this._wrapped;\\n    }\\n\\n  });\\n\\n}).call(this);\\n\\n/*global _: false, $: false, localStorage: false, process: true,\\n  XMLHttpRequest: false, XDomainRequest: false, exports: false,\\n  require: false */\\n(function(root) {\\n  root.Parse = root.Parse || {};\\n  /**\\n   * Contains all Parse API classes and functions.\\n   * @name Parse\\n   * @namespace\\n   *\\n   * Contains all Parse API classes and functions.\\n   */\\n  var Parse = root.Parse;\\n\\n  // Import Parse's local copy of underscore.\\n  if (typeof(exports) !== \\\"undefined\\\" && exports._) {\\n    // We're running in Node.js.  Pull in the dependencies.\\n    Parse._ = exports._.noConflict();\\n    Parse.localStorage = require('localStorage');\\n    Parse.XMLHttpRequest = require('xmlhttprequest').XMLHttpRequest;\\n    exports.Parse = Parse;\\n  } else {\\n    Parse._ = _.noConflict();\\n    if (typeof(localStorage) !== \\\"undefined\\\") {\\n      Parse.localStorage = localStorage;\\n    }\\n    if (typeof(XMLHttpRequest) !== \\\"undefined\\\") {\\n      Parse.XMLHttpRequest = XMLHttpRequest;\\n    }\\n  }\\n\\n  // If jQuery or Zepto has been included, grab a reference to it.\\n  if (typeof($) !== \\\"undefined\\\") {\\n    Parse.$ = $;\\n  }\\n\\n  // Helpers\\n  // -------\\n\\n  // Shared empty constructor function to aid in prototype-chain creation.\\n  var EmptyConstructor = function() {};\\n\\n\\n  // Helper function to correctly set up the prototype chain, for subclasses.\\n  // Similar to `goog.inherits`, but uses a hash of prototype properties and\\n  // class properties to be extended.\\n  var inherits = function(parent, protoProps, staticProps) {\\n    var child;\\n\\n    // The constructor function for the new subclass is either defined by you\\n    // (the \\\"constructor\\\" property in your `extend` definition), or defaulted\\n    // by us to simply call the parent's constructor.\\n    if (protoProps && protoProps.hasOwnProperty('constructor')) {\\n      child = protoProps.constructor;\\n    } else {\\n      /** @ignore */\\n      child = function(){ parent.apply(this, arguments); };\\n    }\\n\\n    // Inherit class (static) properties from parent.\\n    Parse._.extend(child, parent);\\n\\n    // Set the prototype chain to inherit from `parent`, without calling\\n    // `parent`'s constructor function.\\n    EmptyConstructor.prototype = parent.prototype;\\n    child.prototype = new EmptyConstructor();\\n\\n    // Add prototype properties (instance properties) to the subclass,\\n    // if supplied.\\n    if (protoProps) {\\n      Parse._.extend(child.prototype, protoProps);\\n    }\\n\\n    // Add static properties to the constructor function, if supplied.\\n    if (staticProps) {\\n      Parse._.extend(child, staticProps);\\n    }\\n\\n    // Correctly set child's `prototype.constructor`.\\n    child.prototype.constructor = child;\\n\\n    // Set a convenience property in case the parent's prototype is\\n    // needed later.\\n    child.__super__ = parent.prototype;\\n\\n    return child;\\n  };\\n\\n  // Set the server for Parse to talk to.\\n  Parse.serverURL = \\\"https://api.parse.com\\\";\\n\\n  // Check whether we are running in Node.js.\\n  if (typeof(process) !== \\\"undefined\\\" &&\\n      process.versions &&\\n      process.versions.node) {\\n    Parse._isNode = true;\\n  }\\n\\n  /**\\n   * Call this method first to set up your authentication tokens for Parse.\\n   * You can get your keys from the Data Browser on parse.com.\\n   * @param {String} applicationId Your Parse Application ID.\\n   * @param {String} javaScriptKey Your Parse JavaScript Key.\\n   * @param {String} masterKey (optional) Your Parse Master Key. (Node.js only!)\\n   */\\n  Parse.initialize = function(applicationId, javaScriptKey, masterKey) {\\n    if (masterKey) {\\n      throw \\\"Parse.initialize() was passed a Master Key, which is only \\\" +\\n        \\\"allowed from within Node.js.\\\";\\n    }\\n    Parse._initialize(applicationId, javaScriptKey);\\n  };\\n\\n  /**\\n   * Call this method first to set up master authentication tokens for Parse.\\n   * This method is for Parse's own private use.\\n   * @param {String} applicationId Your Parse Application ID.\\n   * @param {String} javaScriptKey Your Parse JavaScript Key.\\n   * @param {String} masterKey Your Parse Master Key.\\n   */\\n  Parse._initialize = function(applicationId, javaScriptKey, masterKey) {\\n    Parse.applicationId = applicationId;\\n    Parse.javaScriptKey = javaScriptKey;\\n    Parse.masterKey = masterKey;\\n    Parse._useMasterKey = false;\\n  };\\n\\n  // If we're running in node.js, allow using the master key.\\n  if (Parse._isNode) {\\n    Parse.initialize = Parse._initialize;\\n\\n    Parse.Cloud = Parse.Cloud || {};\\n    /**\\n     * Switches the Parse SDK to using the Master key.  The Master key grants\\n     * priveleged access to the data in Parse and can be used to bypass ACLs and\\n     * other restrictions that are applied to the client SDKs.\\n     * <p><strong><em>Available in Cloud Code and Node.js only.</em></strong>\\n     * </p>\\n     */\\n    Parse.Cloud.useMasterKey = function() {\\n      Parse._useMasterKey = true;\\n    };\\n  }\\n\\n  /**\\n   * Returns prefix for localStorage keys used by this instance of Parse.\\n   * @param {String} path The relative suffix to append to it.\\n   *     null or undefined is treated as the empty string.\\n   * @return {String} The full key name.\\n   */\\n  Parse._getParsePath = function(path) {\\n    if (!Parse.applicationId) {\\n      throw \\\"You need to call Parse.initialize before using Parse.\\\";\\n    }\\n    if (!path) {\\n      path = \\\"\\\";\\n    }\\n    if (!Parse._.isString(path)) {\\n      throw \\\"Tried to get a localStorage path that wasn't a String.\\\";\\n    }\\n    if (path[0] === \\\"/\\\") {\\n      path = path.substring(1);\\n    }\\n    return \\\"Parse/\\\" + Parse.applicationId + \\\"/\\\" + path;\\n  };\\n\\n  /**\\n   * Returns the unique string for this app on this machine.\\n   * Gets reset when localStorage is cleared.\\n   */\\n  Parse._installationId = null;\\n  Parse._getInstallationId = function() {\\n    // See if it's cached in RAM.\\n    if (Parse._installationId) {\\n      return Parse._installationId;\\n    }\\n\\n    // Try to get it from localStorage.\\n    var path = Parse._getParsePath(\\\"installationId\\\");\\n    Parse._installationId = Parse.localStorage.getItem(path);\\n\\n    if (!Parse._installationId || Parse._installationId === \\\"\\\") {\\n      // It wasn't in localStorage, so create a new one.\\n      var hexOctet = function() {\\n        return Math.floor((1+Math.random())*0x10000).toString(16).substring(1);\\n      };\\n      Parse._installationId = (\\n        hexOctet() + hexOctet() + \\\"-\\\" +\\n        hexOctet() + \\\"-\\\" +\\n        hexOctet() + \\\"-\\\" +\\n        hexOctet() + \\\"-\\\" +\\n        hexOctet() + hexOctet() + hexOctet());\\n      Parse.localStorage.setItem(path, Parse._installationId);\\n    }\\n\\n    return Parse._installationId;\\n  };\\n\\n  Parse._parseDate = function(iso8601) {\\n    var regexp = new RegExp(\\n      \\\"^([0-9]{1,4})-([0-9]{1,2})-([0-9]{1,2})\\\" + \\\"T\\\" +\\n      \\\"([0-9]{1,2}):([0-9]{1,2}):([0-9]{1,2})\\\" +\\n      \\\"(.([0-9]+))?\\\" + \\\"Z$\\\");\\n    var match = regexp.exec(iso8601);\\n    if (!match) {\\n      var date = new Date(iso8601);\\n      return date.getTime() === NaN ? null : date;\\n    }\\n\\n    var year = match[1] || 0;\\n    var month = (match[2] || 1) - 1;\\n    var day = match[3] || 0;\\n    var hour = match[4] || 0;\\n    var minute = match[5] || 0;\\n    var second = match[6] || 0;\\n    var milli = match[8] || 0;\\n\\n    return new Date(Date.UTC(year, month, day, hour, minute, second, milli));\\n  };\\n\\n  Parse._ajaxIE8 = function(method, url, data) {\\n    var promise = new Parse.Promise();\\n    var xdr = new XDomainRequest();\\n    xdr.onload = function() {\\n      var response;\\n      try {\\n        response = JSON.parse(xdr.responseText);\\n      } catch (e) {\\n        promise.reject(e);\\n      }\\n      if (response) {\\n        promise.resolve(response);\\n      }\\n    };\\n    xdr.onerror = xdr.ontimeout = function() {\\n      // Let's fake a real error message.\\n      var fakeResponse = {\\n        responseText: JSON.stringify({\\n          code: Parse.Error.X_DOMAIN_REQUEST,\\n          error: \\\"IE's XDomainRequest does not supply error info.\\\"\\n        })\\n      };\\n      promise.reject(fakeResponse);\\n    };\\n    xdr.onprogress = function() {};\\n    xdr.open(method, url);\\n    xdr.send(data);\\n    return promise;\\n  };\\n\\n  Parse._useXDomainRequest = function() {\\n    if (typeof(XDomainRequest) !== \\\"undefined\\\") {\\n      // We're in IE 8+.\\n      if ('withCredentials' in new XMLHttpRequest()) {\\n        // We're in IE 10+.\\n        return false;\\n      }\\n      return true;\\n    }\\n    return false;\\n  };\\n\\n\\n  Parse._ajax = function(method, url, data, success, error) {\\n    var options = {\\n      success: success,\\n      error: error\\n    };\\n\\n    if (Parse._useXDomainRequest()) {\\n      return Parse._ajaxIE8(method, url, data)._thenRunCallbacks(options);\\n    }\\n\\n    var promise = new Parse.Promise();\\n    var handled = false;\\n\\n    var xhr = new Parse.XMLHttpRequest();\\n    xhr.onreadystatechange = function() {\\n      if (xhr.readyState === 4) {\\n        if (handled) {\\n          return;\\n        }\\n        handled = true;\\n\\n        if (xhr.status >= 200 && xhr.status < 300) {\\n          var response;\\n          try {\\n            response = JSON.parse(xhr.responseText);\\n          } catch (e) {\\n            promise.reject(e);\\n          }\\n          if (response) {\\n            promise.resolve(response, xhr.status, xhr);\\n          }\\n        } else {\\n          promise.reject(xhr);\\n        }\\n      }\\n    };\\n    xhr.open(method, url, true);\\n    xhr.setRequestHeader(\\\"Content-Type\\\", \\\"text/plain\\\");  // avoid pre-flight.\\n    if (Parse._isNode) {\\n      // Add a special user agent just for request from node.js.\\n      xhr.setRequestHeader(\\\"User-Agent\\\",\\n                           \\\"Parse/\\\" + Parse.VERSION +\\n                           \\\" (NodeJS \\\" + process.versions.node + \\\")\\\");\\n    }\\n    xhr.send(data);\\n    return promise._thenRunCallbacks(options);\\n  };\\n\\n  // A self-propagating extend function.\\n  Parse._extend = function(protoProps, classProps) {\\n    var child = inherits(this, protoProps, classProps);\\n    child.extend = this.extend;\\n    return child;\\n  };\\n\\n  /**\\n   * Options:\\n   *   route: is classes, users, login, etc.\\n   *   objectId: null if there is no associated objectId.\\n   *   method: the http method for the REST API.\\n   *   dataObject: the payload as an object, or null if there is none.\\n   *   useMasterKey: overrides whether to use the master key if set.\\n   * @ignore\\n   */\\n  Parse._request = function(options) {\\n    var route = options.route;\\n    var className = options.className;\\n    var objectId = options.objectId;\\n    var method = options.method;\\n    var useMasterKey = options.useMasterKey;\\n    var sessionToken = options.sessionToken;\\n    var dataObject = options.data;\\n\\n    if (!Parse.applicationId) {\\n      throw \\\"You must specify your applicationId using Parse.initialize.\\\";\\n    }\\n\\n    if (!Parse.javaScriptKey && !Parse.masterKey) {\\n      throw \\\"You must specify a key using Parse.initialize.\\\";\\n    }\\n\\n\\n    if (!sessionToken) {\\n      // Use the current user session token if none was provided.\\n      var currentUser = Parse.User.current();\\n      if (currentUser && currentUser._sessionToken) {\\n        sessionToken = currentUser._sessionToken;\\n      }\\n    }\\n\\n\\n    if (route !== \\\"batch\\\" &&\\n        route !== \\\"classes\\\" &&\\n        route !== \\\"events\\\" &&\\n        route !== \\\"files\\\" &&\\n        route !== \\\"functions\\\" &&\\n        route !== \\\"login\\\" &&\\n        route !== \\\"push\\\" &&\\n        route !== \\\"requestPasswordReset\\\" &&\\n        route !== \\\"rest_verify_analytics\\\" &&\\n        route !== \\\"users\\\" &&\\n        route !== \\\"jobs\\\") {\\n      throw \\\"Bad route: '\\\" + route + \\\"'.\\\";\\n    }\\n\\n    var url = Parse.serverURL;\\n    if (url.charAt(url.length - 1) !== \\\"/\\\") {\\n      url += \\\"/\\\";\\n    }\\n    url += \\\"1/\\\" + route;\\n    if (className) {\\n      url += \\\"/\\\" + className;\\n    }\\n    if (objectId) {\\n      url += \\\"/\\\" + objectId;\\n    }\\n\\n    dataObject = Parse._.clone(dataObject || {});\\n    if (method !== \\\"POST\\\") {\\n      dataObject._method = method;\\n      method = \\\"POST\\\";\\n    }\\n\\n    if (Parse._.isUndefined(useMasterKey)) {\\n      useMasterKey = Parse._useMasterKey;\\n    }\\n\\n    dataObject._ApplicationId = Parse.applicationId;\\n    if (!useMasterKey) {\\n      dataObject._JavaScriptKey = Parse.javaScriptKey;\\n    } else {\\n      dataObject._MasterKey = Parse.masterKey;\\n    }\\n\\n    dataObject._ClientVersion = Parse.VERSION;\\n    dataObject._InstallationId = Parse._getInstallationId();\\n    if (sessionToken) {\\n      dataObject._SessionToken = sessionToken;\\n    }\\n    var data = JSON.stringify(dataObject);\\n\\n    return Parse._ajax(method, url, data).then(null, function(response) {\\n      // Transform the error into an instance of Parse.Error by trying to parse\\n      // the error string as JSON.\\n      var error;\\n      if (response && response.responseText) {\\n        try {\\n          var errorJSON = JSON.parse(response.responseText);\\n          error = new Parse.Error(errorJSON.code, errorJSON.error);\\n        } catch (e) {\\n          // If we fail to parse the error text, that's okay.\\n          error = new Parse.Error(\\n              Parse.Error.INVALID_JSON,\\n              \\\"Received an error with invalid JSON from Parse: \\\" +\\n                  response.responseText);\\n        }\\n      } else {\\n        error = new Parse.Error(\\n            Parse.Error.CONNECTION_FAILED,\\n            \\\"XMLHttpRequest failed: \\\" + JSON.stringify(response));\\n      }\\n      // By explicitly returning a rejected Promise, this will work with\\n      // either jQuery or Promises/A semantics.\\n      return Parse.Promise.error(error);\\n    });\\n  };\\n\\n  // Helper function to get a value from a Backbone object as a property\\n  // or as a function.\\n  Parse._getValue = function(object, prop) {\\n    if (!(object && object[prop])) {\\n      return null;\\n    }\\n    return Parse._.isFunction(object[prop]) ? object[prop]() : object[prop];\\n  };\\n\\n  /**\\n   * Converts a value in a Parse Object into the appropriate representation.\\n   * This is the JS equivalent of Java's Parse.maybeReferenceAndEncode(Object)\\n   * if seenObjects is falsey. Otherwise any Parse.Objects not in\\n   * seenObjects will be fully embedded rather than encoded\\n   * as a pointer.  This array will be used to prevent going into an infinite\\n   * loop because we have circular references.  If seenObjects\\n   * is set, then none of the Parse Objects that are serialized can be dirty.\\n   */\\n  Parse._encode = function(value, seenObjects, disallowObjects) {\\n    var _ = Parse._;\\n    if (value instanceof Parse.Object) {\\n      if (disallowObjects) {\\n        throw \\\"Parse.Objects not allowed here\\\";\\n      }\\n      if (!seenObjects || _.include(seenObjects, value) || !value._hasData) {\\n        return value._toPointer();\\n      }\\n      if (!value.dirty()) {\\n        seenObjects = seenObjects.concat(value);\\n        return Parse._encode(value._toFullJSON(seenObjects),\\n                             seenObjects,\\n                             disallowObjects);\\n      }\\n      throw \\\"Tried to save an object with a pointer to a new, unsaved object.\\\";\\n    }\\n    if (value instanceof Parse.ACL) {\\n      return value.toJSON();\\n    }\\n    if (_.isDate(value)) {\\n      return { \\\"__type\\\": \\\"Date\\\", \\\"iso\\\": value.toJSON() };\\n    }\\n    if (value instanceof Parse.GeoPoint) {\\n      return value.toJSON();\\n    }\\n    if (_.isArray(value)) {\\n      return _.map(value, function(x) {\\n        return Parse._encode(x, seenObjects, disallowObjects);\\n      });\\n    }\\n    if (_.isRegExp(value)) {\\n      return value.source;\\n    }\\n    if (value instanceof Parse.Relation) {\\n      return value.toJSON();\\n    }\\n    if (value instanceof Parse.Op) {\\n      return value.toJSON();\\n    }\\n    if (value instanceof Parse.File) {\\n      if (!value.url()) {\\n        throw \\\"Tried to save an object containing an unsaved file.\\\";\\n      }\\n      return {\\n        __type: \\\"File\\\",\\n        name: value.name(),\\n        url: value.url()\\n      };\\n    }\\n    if (_.isObject(value)) {\\n      var output = {};\\n      Parse._objectEach(value, function(v, k) {\\n        output[k] = Parse._encode(v, seenObjects, disallowObjects);\\n      });\\n      return output;\\n    }\\n    return value;\\n  };\\n\\n  /**\\n   * The inverse function of Parse._encode.\\n   * TODO: make decode not mutate value.\\n   */\\n  Parse._decode = function(key, value) {\\n    var _ = Parse._;\\n    if (!_.isObject(value)) {\\n      return value;\\n    }\\n    if (_.isArray(value)) {\\n      Parse._arrayEach(value, function(v, k) {\\n        value[k] = Parse._decode(k, v);\\n      });\\n      return value;\\n    }\\n    if (value instanceof Parse.Object) {\\n      return value;\\n    }\\n    if (value instanceof Parse.File) {\\n      return value;\\n    }\\n    if (value instanceof Parse.Op) {\\n      return value;\\n    }\\n    if (value.__op) {\\n      return Parse.Op._decode(value);\\n    }\\n    if (value.__type === \\\"Pointer\\\") {\\n      var pointer = Parse.Object._create(value.className);\\n      pointer._finishFetch({ objectId: value.objectId }, false);\\n      return pointer;\\n    }\\n    if (value.__type === \\\"Object\\\") {\\n      // It's an Object included in a query result.\\n      var className = value.className;\\n      delete value.__type;\\n      delete value.className;\\n      var object = Parse.Object._create(className);\\n      object._finishFetch(value, true);\\n      return object;\\n    }\\n    if (value.__type === \\\"Date\\\") {\\n      return Parse._parseDate(value.iso);\\n    }\\n    if (value.__type === \\\"GeoPoint\\\") {\\n      return new Parse.GeoPoint({\\n        latitude: value.latitude,\\n        longitude: value.longitude\\n      });\\n    }\\n    if (key === \\\"ACL\\\") {\\n      if (value instanceof Parse.ACL) {\\n        return value;\\n      }\\n      return new Parse.ACL(value);\\n    }\\n    if (value.__type === \\\"Relation\\\") {\\n      var relation = new Parse.Relation(null, key);\\n      relation.targetClassName = value.className;\\n      return relation;\\n    }\\n    if (value.__type === \\\"File\\\") {\\n      var file = new Parse.File(value.name);\\n      file._url = value.url;\\n      return file;\\n    }\\n    Parse._objectEach(value, function(v, k) {\\n      value[k] = Parse._decode(k, v);\\n    });\\n    return value;\\n  };\\n\\n  Parse._arrayEach = Parse._.each;\\n\\n  /**\\n   * Does a deep traversal of every item in object, calling func on every one.\\n   * @param {Object} object The object or array to traverse deeply.\\n   * @param {Function} func The function to call for every item. It will\\n   *     be passed the item as an argument. If it returns a truthy value, that\\n   *     value will replace the item in its parent container.\\n   * @returns {} the result of calling func on the top-level object itself.\\n   */\\n  Parse._traverse = function(object, func, seen) {\\n    if (object instanceof Parse.Object) {\\n      seen = seen || [];\\n      if (Parse._.indexOf(seen, object) >= 0) {\\n        // We've already visited this object in this call.\\n        return;\\n      }\\n      seen.push(object);\\n      Parse._traverse(object.attributes, func, seen);\\n      return func(object);\\n    }\\n    if (object instanceof Parse.Relation || object instanceof Parse.File) {\\n      // Nothing needs to be done, but we don't want to recurse into the\\n      // object's parent infinitely, so we catch this case.\\n      return func(object);\\n    }\\n    if (Parse._.isArray(object)) {\\n      Parse._.each(object, function(child, index) {\\n        var newChild = Parse._traverse(child, func, seen);\\n        if (newChild) {\\n          object[index] = newChild;\\n        }\\n      });\\n      return func(object);\\n    }\\n    if (Parse._.isObject(object)) {\\n      Parse._each(object, function(child, key) {\\n        var newChild = Parse._traverse(child, func, seen);\\n        if (newChild) {\\n          object[key] = newChild;\\n        }\\n      });\\n      return func(object);\\n    }\\n    return func(object);\\n  };\\n\\n  /**\\n   * This is like _.each, except:\\n   * * it doesn't work for so-called array-like objects,\\n   * * it does work for dictionaries with a \\\"length\\\" attribute.\\n   */\\n  Parse._objectEach = Parse._each = function(obj, callback) {\\n    var _ = Parse._;\\n    if (_.isObject(obj)) {\\n      _.each(_.keys(obj), function(key) {\\n        callback(obj[key], key);\\n      });\\n    } else {\\n      _.each(obj, callback);\\n    }\\n  };\\n\\n  // Helper function to check null or undefined.\\n  Parse._isNullOrUndefined = function(x) {\\n    return Parse._.isNull(x) || Parse._.isUndefined(x);\\n  };\\n}(this));\\n\\n(function(root) {\\n  root.Parse = root.Parse || {};\\n  var Parse = root.Parse;\\n  var _ = Parse._;\\n\\n  /**\\n   * @namespace Provides an interface to Parse's logging and analytics backend.\\n   */\\n  Parse.Analytics = Parse.Analytics || {};\\n\\n  _.extend(Parse.Analytics, /** @lends Parse.Analytics */ {\\n    /**\\n     * Tracks the occurrence of a custom event with additional dimensions.\\n     * Parse will store a data point at the time of invocation with the given\\n     * event name.\\n     *\\n     * Dimensions will allow segmentation of the occurrences of this custom\\n     * event. Keys and values should be {@code String}s, and will throw\\n     * otherwise.\\n     *\\n     * To track a user signup along with additional metadata, consider the\\n     * following:\\n     * <pre>\\n     * var dimensions = {\\n     *  gender: 'm',\\n     *  source: 'web',\\n     *  dayType: 'weekend'\\n     * };\\n     * Parse.Analytics.track('signup', dimensions);\\n     * </pre>\\n     *\\n     * There is a default limit of 4 dimensions per event tracked.\\n     *\\n     * @param {String} name The name of the custom event to report to Parse as\\n     * having happened.\\n     * @param {Object} dimensions The dictionary of information by which to\\n     * segment this event.\\n     * @return {Parse.Promise} A promise that is resolved when the round-trip\\n     * to the server completes.\\n     */\\n    track: function(name, dimensions) {\\n      name = name || '';\\n      name = name.replace(/^\\\\s*/, '');\\n      name = name.replace(/\\\\s*$/, '');\\n      if (name.length === 0) {\\n        throw 'A name for the custom event must be provided';\\n      }\\n\\n      _.each(dimensions, function(val, key) {\\n        if (!_.isString(key) || !_.isString(val)) {\\n          throw 'track() dimensions expects keys and values of type \\\"string\\\".';\\n        }\\n      });\\n\\n      return Parse._request({\\n        route: 'events',\\n        className: name,\\n        method: 'POST',\\n        data: { dimensions: dimensions }\\n      });\\n    }\\n  });\\n}(this));\\n\\n(function(root) {\\n  root.Parse = root.Parse || {};\\n  var Parse = root.Parse;\\n  var _ = Parse._;\\n\\n  /**\\n   * Constructs a new Parse.Error object with the given code and message.\\n   * @param {Number} code An error code constant from <code>Parse.Error</code>.\\n   * @param {String} message A detailed description of the error.\\n   * @class\\n   *\\n   * <p>Class used for all objects passed to error callbacks.</p>\\n   */\\n  Parse.Error = function(code, message) {\\n    this.code = code;\\n    this.message = message;\\n  };\\n\\n  _.extend(Parse.Error, /** @lends Parse.Error */ {\\n    /**\\n     * Error code indicating some error other than those enumerated here.\\n     * @constant\\n     */\\n    OTHER_CAUSE: -1,\\n\\n    /**\\n     * Error code indicating that something has gone wrong with the server.\\n     * If you get this error code, it is Parse's fault. Contact us at\\n     * https://parse.com/help\\n     * @constant\\n     */\\n    INTERNAL_SERVER_ERROR: 1,\\n\\n    /**\\n     * Error code indicating the connection to the Parse servers failed.\\n     * @constant\\n     */\\n    CONNECTION_FAILED: 100,\\n\\n    /**\\n     * Error code indicating the specified object doesn't exist.\\n     * @constant\\n     */\\n    OBJECT_NOT_FOUND: 101,\\n\\n    /**\\n     * Error code indicating you tried to query with a datatype that doesn't\\n     * support it, like exact matching an array or object.\\n     * @constant\\n     */\\n    INVALID_QUERY: 102,\\n\\n    /**\\n     * Error code indicating a missing or invalid classname. Classnames are\\n     * case-sensitive. They must start with a letter, and a-zA-Z0-9_ are the\\n     * only valid characters.\\n     * @constant\\n     */\\n    INVALID_CLASS_NAME: 103,\\n\\n    /**\\n     * Error code indicating an unspecified object id.\\n     * @constant\\n     */\\n    MISSING_OBJECT_ID: 104,\\n\\n    /**\\n     * Error code indicating an invalid key name. Keys are case-sensitive. They\\n     * must start with a letter, and a-zA-Z0-9_ are the only valid characters.\\n     * @constant\\n     */\\n    INVALID_KEY_NAME: 105,\\n\\n    /**\\n     * Error code indicating a malformed pointer. You should not see this unless\\n     * you have been mucking about changing internal Parse code.\\n     * @constant\\n     */\\n    INVALID_POINTER: 106,\\n\\n    /**\\n     * Error code indicating that badly formed JSON was received upstream. This\\n     * either indicates you have done something unusual with modifying how\\n     * things encode to JSON, or the network is failing badly.\\n     * @constant\\n     */\\n    INVALID_JSON: 107,\\n\\n    /**\\n     * Error code indicating that the feature you tried to access is only\\n     * available internally for testing purposes.\\n     * @constant\\n     */\\n    COMMAND_UNAVAILABLE: 108,\\n\\n    /**\\n     * You must call Parse.initialize before using the Parse library.\\n     * @constant\\n     */\\n    NOT_INITIALIZED: 109,\\n\\n    /**\\n     * Error code indicating that a field was set to an inconsistent type.\\n     * @constant\\n     */\\n    INCORRECT_TYPE: 111,\\n\\n    /**\\n     * Error code indicating an invalid channel name. A channel name is either\\n     * an empty string (the broadcast channel) or contains only a-zA-Z0-9_\\n     * characters and starts with a letter.\\n     * @constant\\n     */\\n    INVALID_CHANNEL_NAME: 112,\\n\\n    /**\\n     * Error code indicating that push is misconfigured.\\n     * @constant\\n     */\\n    PUSH_MISCONFIGURED: 115,\\n\\n    /**\\n     * Error code indicating that the object is too large.\\n     * @constant\\n     */\\n    OBJECT_TOO_LARGE: 116,\\n\\n    /**\\n     * Error code indicating that the operation isn't allowed for clients.\\n     * @constant\\n     */\\n    OPERATION_FORBIDDEN: 119,\\n\\n    /**\\n     * Error code indicating the result was not found in the cache.\\n     * @constant\\n     */\\n    CACHE_MISS: 120,\\n\\n    /**\\n     * Error code indicating that an invalid key was used in a nested\\n     * JSONObject.\\n     * @constant\\n     */\\n    INVALID_NESTED_KEY: 121,\\n\\n    /**\\n     * Error code indicating that an invalid filename was used for ParseFile.\\n     * A valid file name contains only a-zA-Z0-9_. characters and is between 1\\n     * and 128 characters.\\n     * @constant\\n     */\\n    INVALID_FILE_NAME: 122,\\n\\n    /**\\n     * Error code indicating an invalid ACL was provided.\\n     * @constant\\n     */\\n    INVALID_ACL: 123,\\n\\n    /**\\n     * Error code indicating that the request timed out on the server. Typically\\n     * this indicates that the request is too expensive to run.\\n     * @constant\\n     */\\n    TIMEOUT: 124,\\n\\n    /**\\n     * Error code indicating that the email address was invalid.\\n     * @constant\\n     */\\n    INVALID_EMAIL_ADDRESS: 125,\\n\\n    /**\\n     * Error code indicating a missing content type.\\n     * @constant\\n     */\\n    MISSING_CONTENT_TYPE: 126,\\n\\n    /**\\n     * Error code indicating a missing content length.\\n     * @constant\\n     */\\n    MISSING_CONTENT_LENGTH: 127,\\n\\n    /**\\n     * Error code indicating an invalid content length.\\n     * @constant\\n     */\\n    INVALID_CONTENT_LENGTH: 128,\\n\\n    /**\\n     * Error code indicating a file that was too large.\\n     * @constant\\n     */\\n    FILE_TOO_LARGE: 129,\\n\\n    /**\\n     * Error code indicating an error saving a file.\\n     * @constant\\n     */\\n    FILE_SAVE_ERROR: 130,\\n\\n    /**\\n     * Error code indicating an error deleting a file.\\n     * @constant\\n     */\\n    FILE_DELETE_ERROR: 153,\\n\\n    /**\\n     * Error code indicating that a unique field was given a value that is\\n     * already taken.\\n     * @constant\\n     */\\n    DUPLICATE_VALUE: 137,\\n\\n    /**\\n     * Error code indicating that a role's name is invalid.\\n     * @constant\\n     */\\n    INVALID_ROLE_NAME: 139,\\n\\n    /**\\n     * Error code indicating that an application quota was exceeded.  Upgrade to\\n     * resolve.\\n     * @constant\\n     */\\n    EXCEEDED_QUOTA: 140,\\n\\n    /**\\n     * Error code indicating that a Cloud Code script failed.\\n     * @constant\\n     */\\n    SCRIPT_FAILED: 141,\\n\\n    /**\\n     * Error code indicating that a Cloud Code validation failed.\\n     * @constant\\n     */\\n    VALIDATION_ERROR: 142,\\n\\n    /**\\n     * Error code indicating that invalid image data was provided.\\n     * @constant\\n     */\\n    INVALID_IMAGE_DATA: 150,\\n\\n    /**\\n     * Error code indicating an unsaved file.\\n     * @constant\\n     */\\n    UNSAVED_FILE_ERROR: 151,\\n\\n    /**\\n     * Error code indicating an invalid push time.\\n     */\\n    INVALID_PUSH_TIME_ERROR: 152,\\n\\n    /**\\n     * Error code indicating that the username is missing or empty.\\n     * @constant\\n     */\\n    USERNAME_MISSING: 200,\\n\\n    /**\\n     * Error code indicating that the password is missing or empty.\\n     * @constant\\n     */\\n    PASSWORD_MISSING: 201,\\n\\n    /**\\n     * Error code indicating that the username has already been taken.\\n     * @constant\\n     */\\n    USERNAME_TAKEN: 202,\\n\\n    /**\\n     * Error code indicating that the email has already been taken.\\n     * @constant\\n     */\\n    EMAIL_TAKEN: 203,\\n\\n    /**\\n     * Error code indicating that the email is missing, but must be specified.\\n     * @constant\\n     */\\n    EMAIL_MISSING: 204,\\n\\n    /**\\n     * Error code indicating that a user with the specified email was not found.\\n     * @constant\\n     */\\n    EMAIL_NOT_FOUND: 205,\\n\\n    /**\\n     * Error code indicating that a user object without a valid session could\\n     * not be altered.\\n     * @constant\\n     */\\n    SESSION_MISSING: 206,\\n\\n    /**\\n     * Error code indicating that a user can only be created through signup.\\n     * @constant\\n     */\\n    MUST_CREATE_USER_THROUGH_SIGNUP: 207,\\n\\n    /**\\n     * Error code indicating that an an account being linked is already linked\\n     * to another user.\\n     * @constant\\n     */\\n    ACCOUNT_ALREADY_LINKED: 208,\\n\\n    /**\\n     * Error code indicating that a user cannot be linked to an account because\\n     * that account's id could not be found.\\n     * @constant\\n     */\\n    LINKED_ID_MISSING: 250,\\n\\n    /**\\n     * Error code indicating that a user with a linked (e.g. Facebook) account\\n     * has an invalid session.\\n     * @constant\\n     */\\n    INVALID_LINKED_SESSION: 251,\\n\\n    /**\\n     * Error code indicating that a service being linked (e.g. Facebook or\\n     * Twitter) is unsupported.\\n     * @constant\\n     */\\n    UNSUPPORTED_SERVICE: 252,\\n\\n    /**\\n     * Error code indicating that there were multiple errors. Aggregate errors\\n     * have an \\\"errors\\\" property, which is an array of error objects with more\\n     * detail about each error that occurred.\\n     * @constant\\n     */\\n    AGGREGATE_ERROR: 600,\\n\\n    /**\\n     * Error code indicating the client was unable to read an input file.\\n     * @constant\\n     */\\n    FILE_READ_ERROR: 601,\\n\\n    /**\\n     * Error code indicating a real error code is unavailable because\\n     * we had to use an XDomainRequest object to allow CORS requests in\\n     * Internet Explorer, which strips the body from HTTP responses that have\\n     * a non-2XX status code.\\n     * @constant\\n     */\\n    X_DOMAIN_REQUEST: 602\\n  });\\n\\n}(this));\\n\\n/*global _: false */\\n(function() {\\n  var root = this;\\n  var Parse = (root.Parse || (root.Parse = {}));\\n  var eventSplitter = /\\\\s+/;\\n  var slice = Array.prototype.slice;\\n\\n  /**\\n   * @class\\n   *\\n   * <p>Parse.Events is a fork of Backbone's Events module, provided for your\\n   * convenience.</p>\\n   *\\n   * <p>A module that can be mixed in to any object in order to provide\\n   * it with custom events. You may bind callback functions to an event\\n   * with `on`, or remove these functions with `off`.\\n   * Triggering an event fires all callbacks in the order that `on` was\\n   * called.\\n   *\\n   * <pre>\\n   *     var object = {};\\n   *     _.extend(object, Parse.Events);\\n   *     object.on('expand', function(){ alert('expanded'); });\\n   *     object.trigger('expand');</pre></p>\\n   *\\n   * <p>For more information, see the\\n   * <a href=\\\"http://documentcloud.github.com/backbone/#Events\\\">Backbone\\n   * documentation</a>.</p>\\n   */\\n  Parse.Events = {\\n    /**\\n     * Bind one or more space separated events, `events`, to a `callback`\\n     * function. Passing `\\\"all\\\"` will bind the callback to all events fired.\\n     */\\n    on: function(events, callback, context) {\\n\\n      var calls, event, node, tail, list;\\n      if (!callback) {\\n        return this;\\n      }\\n      events = events.split(eventSplitter);\\n      calls = this._callbacks || (this._callbacks = {});\\n\\n      // Create an immutable callback list, allowing traversal during\\n      // modification.  The tail is an empty object that will always be used\\n      // as the next node.\\n      event = events.shift();\\n      while (event) {\\n        list = calls[event];\\n        node = list ? list.tail : {};\\n        node.next = tail = {};\\n        node.context = context;\\n        node.callback = callback;\\n        calls[event] = {tail: tail, next: list ? list.next : node};\\n        event = events.shift();\\n      }\\n\\n      return this;\\n    },\\n\\n    /**\\n     * Remove one or many callbacks. If `context` is null, removes all callbacks\\n     * with that function. If `callback` is null, removes all callbacks for the\\n     * event. If `events` is null, removes all bound callbacks for all events.\\n     */\\n    off: function(events, callback, context) {\\n      var event, calls, node, tail, cb, ctx;\\n\\n      // No events, or removing *all* events.\\n      if (!(calls = this._callbacks)) {\\n        return;\\n      }\\n      if (!(events || callback || context)) {\\n        delete this._callbacks;\\n        return this;\\n      }\\n\\n      // Loop through the listed events and contexts, splicing them out of the\\n      // linked list of callbacks if appropriate.\\n      events = events ? events.split(eventSplitter) : _.keys(calls);\\n      event = events.shift();\\n      while (event) {\\n        node = calls[event];\\n        delete calls[event];\\n        if (!node || !(callback || context)) {\\n          continue;\\n        }\\n        // Create a new list, omitting the indicated callbacks.\\n        tail = node.tail;\\n        node = node.next;\\n        while (node !== tail) {\\n          cb = node.callback;\\n          ctx = node.context;\\n          if ((callback && cb !== callback) || (context && ctx !== context)) {\\n            this.on(event, cb, ctx);\\n          }\\n          node = node.next;\\n        }\\n        event = events.shift();\\n      }\\n\\n      return this;\\n    },\\n\\n    /**\\n     * Trigger one or many events, firing all bound callbacks. Callbacks are\\n     * passed the same arguments as `trigger` is, apart from the event name\\n     * (unless you're listening on `\\\"all\\\"`, which will cause your callback to\\n     * receive the true name of the event as the first argument).\\n     */\\n    trigger: function(events) {\\n      var event, node, calls, tail, args, all, rest;\\n      if (!(calls = this._callbacks)) {\\n        return this;\\n      }\\n      all = calls.all;\\n      events = events.split(eventSplitter);\\n      rest = slice.call(arguments, 1);\\n\\n      // For each event, walk through the linked list of callbacks twice,\\n      // first to trigger the event, then to trigger any `\\\"all\\\"` callbacks.\\n      event = events.shift();\\n      while (event) {\\n        node = calls[event];\\n        if (node) {\\n          tail = node.tail;\\n          while ((node = node.next) !== tail) {\\n            node.callback.apply(node.context || this, rest);\\n          }\\n        }\\n        node = all;\\n        if (node) {\\n          tail = node.tail;\\n          args = [event].concat(rest);\\n          while ((node = node.next) !== tail) {\\n            node.callback.apply(node.context || this, args);\\n          }\\n        }\\n        event = events.shift();\\n      }\\n\\n      return this;\\n    }\\n  };\\n\\n  /**\\n   * @function\\n   */\\n  Parse.Events.bind = Parse.Events.on;\\n\\n  /**\\n   * @function\\n   */\\n  Parse.Events.unbind = Parse.Events.off;\\n}.call(this));\\n\\n\\n/*global navigator: false */\\n(function(root) {\\n  root.Parse = root.Parse || {};\\n  var Parse = root.Parse;\\n  var _ = Parse._;\\n\\n  /**\\n   * Creates a new GeoPoint with any of the following forms:<br>\\n   *   <pre>\\n   *   new GeoPoint(otherGeoPoint)\\n   *   new GeoPoint(30, 30)\\n   *   new GeoPoint([30, 30])\\n   *   new GeoPoint({latitude: 30, longitude: 30})\\n   *   new GeoPoint()  // defaults to (0, 0)\\n   *   </pre>\\n   * @class\\n   *\\n   * <p>Represents a latitude / longitude point that may be associated\\n   * with a key in a ParseObject or used as a reference point for geo queries.\\n   * This allows proximity-based queries on the key.</p>\\n   *\\n   * <p>Only one key in a class may contain a GeoPoint.</p>\\n   *\\n   * <p>Example:<pre>\\n   *   var point = new Parse.GeoPoint(30.0, -20.0);\\n   *   var object = new Parse.Object(\\\"PlaceObject\\\");\\n   *   object.set(\\\"location\\\", point);\\n   *   object.save();</pre></p>\\n   */\\n  Parse.GeoPoint = function(arg1, arg2) {\\n    if (_.isArray(arg1)) {\\n      Parse.GeoPoint._validate(arg1[0], arg1[1]);\\n      this.latitude = arg1[0];\\n      this.longitude = arg1[1];\\n    } else if (_.isObject(arg1)) {\\n      Parse.GeoPoint._validate(arg1.latitude, arg1.longitude);\\n      this.latitude = arg1.latitude;\\n      this.longitude = arg1.longitude;\\n    } else if (_.isNumber(arg1) && _.isNumber(arg2)) {\\n      Parse.GeoPoint._validate(arg1, arg2);\\n      this.latitude = arg1;\\n      this.longitude = arg2;\\n    } else {\\n      this.latitude = 0;\\n      this.longitude = 0;\\n    }\\n\\n    // Add properties so that anyone using Webkit or Mozilla will get an error\\n    // if they try to set values that are out of bounds.\\n    var self = this;\\n    if (this.__defineGetter__ && this.__defineSetter__) {\\n      // Use _latitude and _longitude to actually store the values, and add\\n      // getters and setters for latitude and longitude.\\n      this._latitude = this.latitude;\\n      this._longitude = this.longitude;\\n      this.__defineGetter__(\\\"latitude\\\", function() {\\n        return self._latitude;\\n      });\\n      this.__defineGetter__(\\\"longitude\\\", function() {\\n        return self._longitude;\\n      });\\n      this.__defineSetter__(\\\"latitude\\\", function(val) {\\n        Parse.GeoPoint._validate(val, self.longitude);\\n        self._latitude = val;\\n      });\\n      this.__defineSetter__(\\\"longitude\\\", function(val) {\\n        Parse.GeoPoint._validate(self.latitude, val);\\n        self._longitude = val;\\n      });\\n    }\\n  };\\n\\n  /**\\n   * @lends Parse.GeoPoint.prototype\\n   * @property {float} latitude North-south portion of the coordinate, in range\\n   *   [-90, 90].  Throws an exception if set out of range in a modern browser.\\n   * @property {float} longitude East-west portion of the coordinate, in range\\n   *   [-180, 180].  Throws if set out of range in a modern browser.\\n   */\\n\\n  /**\\n   * Throws an exception if the given lat-long is out of bounds.\\n   */\\n  Parse.GeoPoint._validate = function(latitude, longitude) {\\n    if (latitude < -90.0) {\\n      throw \\\"Parse.GeoPoint latitude \\\" + latitude + \\\" < -90.0.\\\";\\n    }\\n    if (latitude > 90.0) {\\n      throw \\\"Parse.GeoPoint latitude \\\" + latitude + \\\" > 90.0.\\\";\\n    }\\n    if (longitude < -180.0) {\\n      throw \\\"Parse.GeoPoint longitude \\\" + longitude + \\\" < -180.0.\\\";\\n    }\\n    if (longitude > 180.0) {\\n      throw \\\"Parse.GeoPoint longitude \\\" + longitude + \\\" > 180.0.\\\";\\n    }\\n  };\\n\\n  /**\\n   * Creates a GeoPoint with the user's current location, if available.\\n   * Calls options.success with a new GeoPoint instance or calls options.error.\\n   * @param {Object} options An object with success and error callbacks.\\n   */\\n  Parse.GeoPoint.current = function(options) {\\n    var promise = new Parse.Promise();\\n    navigator.geolocation.getCurrentPosition(function(location) {\\n      promise.resolve(new Parse.GeoPoint({\\n        latitude: location.coords.latitude,\\n        longitude: location.coords.longitude\\n      }));\\n\\n    }, function(error) {\\n      promise.reject(error);\\n    });\\n\\n    return promise._thenRunCallbacks(options);\\n  };\\n\\n  Parse.GeoPoint.prototype = {\\n    /**\\n     * Returns a JSON representation of the GeoPoint, suitable for Parse.\\n     * @return {Object}\\n     */\\n    toJSON: function() {\\n      Parse.GeoPoint._validate(this.latitude, this.longitude);\\n      return {\\n        \\\"__type\\\": \\\"GeoPoint\\\",\\n        latitude: this.latitude,\\n        longitude: this.longitude\\n      };\\n    },\\n\\n    /**\\n     * Returns the distance from this GeoPoint to another in radians.\\n     * @param {Parse.GeoPoint} point the other Parse.GeoPoint.\\n     * @return {Number}\\n     */\\n    radiansTo: function(point) {\\n      var d2r = Math.PI / 180.0;\\n      var lat1rad = this.latitude * d2r;\\n      var long1rad = this.longitude * d2r;\\n      var lat2rad = point.latitude * d2r;\\n      var long2rad = point.longitude * d2r;\\n      var deltaLat = lat1rad - lat2rad;\\n      var deltaLong = long1rad - long2rad;\\n      var sinDeltaLatDiv2 = Math.sin(deltaLat / 2);\\n      var sinDeltaLongDiv2 = Math.sin(deltaLong / 2);\\n      // Square of half the straight line chord distance between both points.\\n      var a = ((sinDeltaLatDiv2 * sinDeltaLatDiv2) +\\n               (Math.cos(lat1rad) * Math.cos(lat2rad) *\\n                sinDeltaLongDiv2 * sinDeltaLongDiv2));\\n      a = Math.min(1.0, a);\\n      return 2 * Math.asin(Math.sqrt(a));\\n    },\\n\\n    /**\\n     * Returns the distance from this GeoPoint to another in kilometers.\\n     * @param {Parse.GeoPoint} point the other Parse.GeoPoint.\\n     * @return {Number}\\n     */\\n    kilometersTo: function(point) {\\n      return this.radiansTo(point) * 6371.0;\\n    },\\n\\n    /**\\n     * Returns the distance from this GeoPoint to another in miles.\\n     * @param {Parse.GeoPoint} point the other Parse.GeoPoint.\\n     * @return {Number}\\n     */\\n    milesTo: function(point) {\\n      return this.radiansTo(point) * 3958.8;\\n    }\\n  };\\n}(this));\\n\\n/*global navigator: false */\\n(function(root) {\\n  root.Parse = root.Parse || {};\\n  var Parse = root.Parse;\\n  var _ = Parse._;\\n\\n  var PUBLIC_KEY = \\\"*\\\";\\n\\n  /**\\n   * Creates a new ACL.\\n   * If no argument is given, the ACL has no permissions for anyone.\\n   * If the argument is a Parse.User, the ACL will have read and write\\n   *   permission for only that user.\\n   * If the argument is any other JSON object, that object will be interpretted\\n   *   as a serialized ACL created with toJSON().\\n   * @see Parse.Object#setACL\\n   * @class\\n   *\\n   * <p>An ACL, or Access Control List can be added to any\\n   * <code>Parse.Object</code> to restrict access to only a subset of users\\n   * of your application.</p>\\n   */\\n  Parse.ACL = function(arg1) {\\n    var self = this;\\n    self.permissionsById = {};\\n    if (_.isObject(arg1)) {\\n      if (arg1 instanceof Parse.User) {\\n        self.setReadAccess(arg1, true);\\n        self.setWriteAccess(arg1, true);\\n      } else {\\n        if (_.isFunction(arg1)) {\\n          throw \\\"Parse.ACL() called with a function.  Did you forget ()?\\\";\\n        }\\n        Parse._objectEach(arg1, function(accessList, userId) {\\n          if (!_.isString(userId)) {\\n            throw \\\"Tried to create an ACL with an invalid userId.\\\";\\n          }\\n          self.permissionsById[userId] = {};\\n          Parse._objectEach(accessList, function(allowed, permission) {\\n            if (permission !== \\\"read\\\" && permission !== \\\"write\\\") {\\n              throw \\\"Tried to create an ACL with an invalid permission type.\\\";\\n            }\\n            if (!_.isBoolean(allowed)) {\\n              throw \\\"Tried to create an ACL with an invalid permission value.\\\";\\n            }\\n            self.permissionsById[userId][permission] = allowed;\\n          });\\n        });\\n      }\\n    }\\n  };\\n\\n  /**\\n   * Returns a JSON-encoded version of the ACL.\\n   * @return {Object}\\n   */\\n  Parse.ACL.prototype.toJSON = function() {\\n    return _.clone(this.permissionsById);\\n  };\\n\\n  Parse.ACL.prototype._setAccess = function(accessType, userId, allowed) {\\n    if (userId instanceof Parse.User) {\\n      userId = userId.id;\\n    } else if (userId instanceof Parse.Role) {\\n      userId = \\\"role:\\\" + userId.getName();\\n    }\\n    if (!_.isString(userId)) {\\n      throw \\\"userId must be a string.\\\";\\n    }\\n    if (!_.isBoolean(allowed)) {\\n      throw \\\"allowed must be either true or false.\\\";\\n    }\\n    var permissions = this.permissionsById[userId];\\n    if (!permissions) {\\n      if (!allowed) {\\n        // The user already doesn't have this permission, so no action needed.\\n        return;\\n      } else {\\n        permissions = {};\\n        this.permissionsById[userId] = permissions;\\n      }\\n    }\\n\\n    if (allowed) {\\n      this.permissionsById[userId][accessType] = true;\\n    } else {\\n      delete permissions[accessType];\\n      if (_.isEmpty(permissions)) {\\n        delete permissions[userId];\\n      }\\n    }\\n  };\\n\\n  Parse.ACL.prototype._getAccess = function(accessType, userId) {\\n    if (userId instanceof Parse.User) {\\n      userId = userId.id;\\n    } else if (userId instanceof Parse.Role) {\\n      userId = \\\"role:\\\" + userId.getName();\\n    }\\n    var permissions = this.permissionsById[userId];\\n    if (!permissions) {\\n      return false;\\n    }\\n    return permissions[accessType] ? true : false;\\n  };\\n\\n  /**\\n   * Set whether the given user is allowed to read this object.\\n   * @param userId An instance of Parse.User or its objectId.\\n   * @param {Boolean} allowed Whether that user should have read access.\\n   */\\n  Parse.ACL.prototype.setReadAccess = function(userId, allowed) {\\n    this._setAccess(\\\"read\\\", userId, allowed);\\n  };\\n\\n  /**\\n   * Get whether the given user id is *explicitly* allowed to read this object.\\n   * Even if this returns false, the user may still be able to access it if\\n   * getPublicReadAccess returns true or a role that the user belongs to has\\n   * write access.\\n   * @param userId An instance of Parse.User or its objectId, or a Parse.Role.\\n   * @return {Boolean}\\n   */\\n  Parse.ACL.prototype.getReadAccess = function(userId) {\\n    return this._getAccess(\\\"read\\\", userId);\\n  };\\n\\n  /**\\n   * Set whether the given user id is allowed to write this object.\\n   * @param userId An instance of Parse.User or its objectId, or a Parse.Role..\\n   * @param {Boolean} allowed Whether that user should have write access.\\n   */\\n  Parse.ACL.prototype.setWriteAccess = function(userId, allowed) {\\n    this._setAccess(\\\"write\\\", userId, allowed);\\n  };\\n\\n  /**\\n   * Get whether the given user id is *explicitly* allowed to write this object.\\n   * Even if this returns false, the user may still be able to write it if\\n   * getPublicWriteAccess returns true or a role that the user belongs to has\\n   * write access.\\n   * @param userId An instance of Parse.User or its objectId, or a Parse.Role.\\n   * @return {Boolean}\\n   */\\n  Parse.ACL.prototype.getWriteAccess = function(userId) {\\n    return this._getAccess(\\\"write\\\", userId);\\n  };\\n\\n  /**\\n   * Set whether the public is allowed to read this object.\\n   * @param {Boolean} allowed\\n   */\\n  Parse.ACL.prototype.setPublicReadAccess = function(allowed) {\\n    this.setReadAccess(PUBLIC_KEY, allowed);\\n  };\\n\\n  /**\\n   * Get whether the public is allowed to read this object.\\n   * @return {Boolean}\\n   */\\n  Parse.ACL.prototype.getPublicReadAccess = function() {\\n    return this.getReadAccess(PUBLIC_KEY);\\n  };\\n\\n  /**\\n   * Set whether the public is allowed to write this object.\\n   * @param {Boolean} allowed\\n   */\\n  Parse.ACL.prototype.setPublicWriteAccess = function(allowed) {\\n    this.setWriteAccess(PUBLIC_KEY, allowed);\\n  };\\n\\n  /**\\n   * Get whether the public is allowed to write this object.\\n   * @return {Boolean}\\n   */\\n  Parse.ACL.prototype.getPublicWriteAccess = function() {\\n    return this.getWriteAccess(PUBLIC_KEY);\\n  };\\n\\n  /**\\n   * Get whether users belonging to the given role are allowed\\n   * to read this object. Even if this returns false, the role may\\n   * still be able to write it if a parent role has read access.\\n   *\\n   * @param role The name of the role, or a Parse.Role object.\\n   * @return {Boolean} true if the role has read access. false otherwise.\\n   * @throws {String} If role is neither a Parse.Role nor a String.\\n   */\\n  Parse.ACL.prototype.getRoleReadAccess = function(role) {\\n    if (role instanceof Parse.Role) {\\n      // Normalize to the String name\\n      role = role.getName();\\n    }\\n    if (_.isString(role)) {\\n      return this.getReadAccess(\\\"role:\\\" + role);\\n    }\\n    throw \\\"role must be a Parse.Role or a String\\\";\\n  };\\n\\n  /**\\n   * Get whether users belonging to the given role are allowed\\n   * to write this object. Even if this returns false, the role may\\n   * still be able to write it if a parent role has write access.\\n   *\\n   * @param role The name of the role, or a Parse.Role object.\\n   * @return {Boolean} true if the role has write access. false otherwise.\\n   * @throws {String} If role is neither a Parse.Role nor a String.\\n   */\\n  Parse.ACL.prototype.getRoleWriteAccess = function(role) {\\n    if (role instanceof Parse.Role) {\\n      // Normalize to the String name\\n      role = role.getName();\\n    }\\n    if (_.isString(role)) {\\n      return this.getWriteAccess(\\\"role:\\\" + role);\\n    }\\n    throw \\\"role must be a Parse.Role or a String\\\";\\n  };\\n\\n  /**\\n   * Set whether users belonging to the given role are allowed\\n   * to read this object.\\n   *\\n   * @param role The name of the role, or a Parse.Role object.\\n   * @param {Boolean} allowed Whether the given role can read this object.\\n   * @throws {String} If role is neither a Parse.Role nor a String.\\n   */\\n  Parse.ACL.prototype.setRoleReadAccess = function(role, allowed) {\\n    if (role instanceof Parse.Role) {\\n      // Normalize to the String name\\n      role = role.getName();\\n    }\\n    if (_.isString(role)) {\\n      this.setReadAccess(\\\"role:\\\" + role, allowed);\\n      return;\\n    }\\n    throw \\\"role must be a Parse.Role or a String\\\";\\n  };\\n\\n  /**\\n   * Set whether users belonging to the given role are allowed\\n   * to write this object.\\n   *\\n   * @param role The name of the role, or a Parse.Role object.\\n   * @param {Boolean} allowed Whether the given role can write this object.\\n   * @throws {String} If role is neither a Parse.Role nor a String.\\n   */\\n  Parse.ACL.prototype.setRoleWriteAccess = function(role, allowed) {\\n    if (role instanceof Parse.Role) {\\n      // Normalize to the String name\\n      role = role.getName();\\n    }\\n    if (_.isString(role)) {\\n      this.setWriteAccess(\\\"role:\\\" + role, allowed);\\n      return;\\n    }\\n    throw \\\"role must be a Parse.Role or a String\\\";\\n  };\\n\\n}(this));\\n\\n(function(root) {\\n  root.Parse = root.Parse || {};\\n  var Parse = root.Parse;\\n  var _ = Parse._;\\n\\n  /**\\n   * @class\\n   * A Parse.Op is an atomic operation that can be applied to a field in a\\n   * Parse.Object. For example, calling <code>object.set(\\\"foo\\\", \\\"bar\\\")</code>\\n   * is an example of a Parse.Op.Set. Calling <code>object.unset(\\\"foo\\\")</code>\\n   * is a Parse.Op.Unset. These operations are stored in a Parse.Object and\\n   * sent to the server as part of <code>object.save()</code> operations.\\n   * Instances of Parse.Op should be immutable.\\n   *\\n   * You should not create subclasses of Parse.Op or instantiate Parse.Op\\n   * directly.\\n   */\\n  Parse.Op = function() {\\n    this._initialize.apply(this, arguments);\\n  };\\n\\n  Parse.Op.prototype = {\\n    _initialize: function() {}\\n  };\\n\\n  _.extend(Parse.Op, {\\n    /**\\n     * To create a new Op, call Parse.Op._extend();\\n     */\\n    _extend: Parse._extend,\\n\\n    // A map of __op string to decoder function.\\n    _opDecoderMap: {},\\n\\n    /**\\n     * Registers a function to convert a json object with an __op field into an\\n     * instance of a subclass of Parse.Op.\\n     */\\n    _registerDecoder: function(opName, decoder) {\\n      Parse.Op._opDecoderMap[opName] = decoder;\\n    },\\n\\n    /**\\n     * Converts a json object into an instance of a subclass of Parse.Op.\\n     */\\n    _decode: function(json) {\\n      var decoder = Parse.Op._opDecoderMap[json.__op];\\n      if (decoder) {\\n        return decoder(json);\\n      } else {\\n        return undefined;\\n      }\\n    }\\n  });\\n\\n  /*\\n   * Add a handler for Batch ops.\\n   */\\n  Parse.Op._registerDecoder(\\\"Batch\\\", function(json) {\\n    var op = null;\\n    Parse._arrayEach(json.ops, function(nextOp) {\\n      nextOp = Parse.Op._decode(nextOp);\\n      op = nextOp._mergeWithPrevious(op);\\n    });\\n    return op;\\n  });\\n\\n  /**\\n   * @class\\n   * A Set operation indicates that either the field was changed using\\n   * Parse.Object.set, or it is a mutable container that was detected as being\\n   * changed.\\n   */\\n  Parse.Op.Set = Parse.Op._extend(/** @lends Parse.Op.Set.prototype */ {\\n    _initialize: function(value) {\\n      this._value = value;\\n    },\\n\\n    /**\\n     * Returns the new value of this field after the set.\\n     */\\n    value: function() {\\n      return this._value;\\n    },\\n\\n    /**\\n     * Returns a JSON version of the operation suitable for sending to Parse.\\n     * @return {Object}\\n     */\\n    toJSON: function() {\\n      return Parse._encode(this.value());\\n    },\\n\\n    _mergeWithPrevious: function(previous) {\\n      return this;\\n    },\\n\\n    _estimate: function(oldValue) {\\n      return this.value();\\n    }\\n  });\\n\\n  /**\\n   * A sentinel value that is returned by Parse.Op.Unset._estimate to\\n   * indicate the field should be deleted. Basically, if you find _UNSET as a\\n   * value in your object, you should remove that key.\\n   */\\n  Parse.Op._UNSET = {};\\n\\n  /**\\n   * @class\\n   * An Unset operation indicates that this field has been deleted from the\\n   * object.\\n   */\\n  Parse.Op.Unset = Parse.Op._extend(/** @lends Parse.Op.Unset.prototype */ {\\n    /**\\n     * Returns a JSON version of the operation suitable for sending to Parse.\\n     * @return {Object}\\n     */\\n    toJSON: function() {\\n      return { __op: \\\"Delete\\\" };\\n    },\\n\\n    _mergeWithPrevious: function(previous) {\\n      return this;\\n    },\\n\\n    _estimate: function(oldValue) {\\n      return Parse.Op._UNSET;\\n    }\\n  });\\n\\n  Parse.Op._registerDecoder(\\\"Delete\\\", function(json) {\\n    return new Parse.Op.Unset();\\n  });\\n\\n  /**\\n   * @class\\n   * An Increment is an atomic operation where the numeric value for the field\\n   * will be increased by a given amount.\\n   */\\n  Parse.Op.Increment = Parse.Op._extend(\\n      /** @lends Parse.Op.Increment.prototype */ {\\n\\n    _initialize: function(amount) {\\n      this._amount = amount;\\n    },\\n\\n    /**\\n     * Returns the amount to increment by.\\n     * @return {Number} the amount to increment by.\\n     */\\n    amount: function() {\\n      return this._amount;\\n    },\\n\\n    /**\\n     * Returns a JSON version of the operation suitable for sending to Parse.\\n     * @return {Object}\\n     */\\n    toJSON: function() {\\n      return { __op: \\\"Increment\\\", amount: this._amount };\\n    },\\n\\n    _mergeWithPrevious: function(previous) {\\n      if (!previous) {\\n        return this;\\n      } else if (previous instanceof Parse.Op.Unset) {\\n        return new Parse.Op.Set(this.amount());\\n      } else if (previous instanceof Parse.Op.Set) {\\n        return new Parse.Op.Set(previous.value() + this.amount());\\n      } else if (previous instanceof Parse.Op.Increment) {\\n        return new Parse.Op.Increment(this.amount() + previous.amount());\\n      } else {\\n        throw \\\"Op is invalid after previous op.\\\";\\n      }\\n    },\\n\\n    _estimate: function(oldValue) {\\n      if (!oldValue) {\\n        return this.amount();\\n      }\\n      return oldValue + this.amount();\\n    }\\n  });\\n\\n  Parse.Op._registerDecoder(\\\"Increment\\\", function(json) {\\n    return new Parse.Op.Increment(json.amount);\\n  });\\n\\n  /**\\n   * @class\\n   * Add is an atomic operation where the given objects will be appended to the\\n   * array that is stored in this field.\\n   */\\n  Parse.Op.Add = Parse.Op._extend(/** @lends Parse.Op.Add.prototype */ {\\n    _initialize: function(objects) {\\n      this._objects = objects;\\n    },\\n\\n    /**\\n     * Returns the objects to be added to the array.\\n     * @return {Array} The objects to be added to the array.\\n     */\\n    objects: function() {\\n      return this._objects;\\n    },\\n\\n    /**\\n     * Returns a JSON version of the operation suitable for sending to Parse.\\n     * @return {Object}\\n     */\\n    toJSON: function() {\\n      return { __op: \\\"Add\\\", objects: Parse._encode(this.objects()) };\\n    },\\n\\n    _mergeWithPrevious: function(previous) {\\n      if (!previous) {\\n        return this;\\n      } else if (previous instanceof Parse.Op.Unset) {\\n        return new Parse.Op.Set(this.objects());\\n      } else if (previous instanceof Parse.Op.Set) {\\n        return new Parse.Op.Set(this._estimate(previous.value()));\\n      } else if (previous instanceof Parse.Op.Add) {\\n        return new Parse.Op.Add(previous.objects().concat(this.objects()));\\n      } else {\\n        throw \\\"Op is invalid after previous op.\\\";\\n      }\\n    },\\n\\n    _estimate: function(oldValue) {\\n      if (!oldValue) {\\n        return _.clone(this.objects());\\n      } else {\\n        return oldValue.concat(this.objects());\\n      }\\n    }\\n  });\\n\\n  Parse.Op._registerDecoder(\\\"Add\\\", function(json) {\\n    return new Parse.Op.Add(Parse._decode(undefined, json.objects));\\n  });\\n\\n  /**\\n   * @class\\n   * AddUnique is an atomic operation where the given items will be appended to\\n   * the array that is stored in this field only if they were not already\\n   * present in the array.\\n   */\\n  Parse.Op.AddUnique = Parse.Op._extend(\\n      /** @lends Parse.Op.AddUnique.prototype */ {\\n\\n    _initialize: function(objects) {\\n      this._objects = _.uniq(objects);\\n    },\\n\\n    /**\\n     * Returns the objects to be added to the array.\\n     * @return {Array} The objects to be added to the array.\\n     */\\n    objects: function() {\\n      return this._objects;\\n    },\\n\\n    /**\\n     * Returns a JSON version of the operation suitable for sending to Parse.\\n     * @return {Object}\\n     */\\n    toJSON: function() {\\n      return { __op: \\\"AddUnique\\\", objects: Parse._encode(this.objects()) };\\n    },\\n\\n    _mergeWithPrevious: function(previous) {\\n      if (!previous) {\\n        return this;\\n      } else if (previous instanceof Parse.Op.Unset) {\\n        return new Parse.Op.Set(this.objects());\\n      } else if (previous instanceof Parse.Op.Set) {\\n        return new Parse.Op.Set(this._estimate(previous.value()));\\n      } else if (previous instanceof Parse.Op.AddUnique) {\\n        return new Parse.Op.AddUnique(this._estimate(previous.objects()));\\n      } else {\\n        throw \\\"Op is invalid after previous op.\\\";\\n      }\\n    },\\n\\n    _estimate: function(oldValue) {\\n      if (!oldValue) {\\n        return _.clone(this.objects());\\n      } else {\\n        // We can't just take the _.uniq(_.union(...)) of oldValue and\\n        // this.objects, because the uniqueness may not apply to oldValue\\n        // (especially if the oldValue was set via .set())\\n        var newValue = _.clone(oldValue);\\n        Parse._arrayEach(this.objects(), function(obj) {\\n          if (obj instanceof Parse.Object && obj.id) {\\n            var matchingObj = _.find(newValue, function(anObj) {\\n              return (anObj instanceof Parse.Object) && (anObj.id === obj.id);\\n            });\\n            if (!matchingObj) {\\n              newValue.push(obj);\\n            } else {\\n              var index = _.indexOf(newValue, matchingObj);\\n              newValue[index] = obj;\\n            }\\n          } else if (!_.contains(newValue, obj)) {\\n            newValue.push(obj);\\n          }\\n        });\\n        return newValue;\\n      }\\n    }\\n  });\\n\\n  Parse.Op._registerDecoder(\\\"AddUnique\\\", function(json) {\\n    return new Parse.Op.AddUnique(Parse._decode(undefined, json.objects));\\n  });\\n\\n  /**\\n   * @class\\n   * Remove is an atomic operation where the given objects will be removed from\\n   * the array that is stored in this field.\\n   */\\n  Parse.Op.Remove = Parse.Op._extend(/** @lends Parse.Op.Remove.prototype */ {\\n    _initialize: function(objects) {\\n      this._objects = _.uniq(objects);\\n    },\\n\\n    /**\\n     * Returns the objects to be removed from the array.\\n     * @return {Array} The objects to be removed from the array.\\n     */\\n    objects: function() {\\n      return this._objects;\\n    },\\n\\n    /**\\n     * Returns a JSON version of the operation suitable for sending to Parse.\\n     * @return {Object}\\n     */\\n    toJSON: function() {\\n      return { __op: \\\"Remove\\\", objects: Parse._encode(this.objects()) };\\n    },\\n\\n    _mergeWithPrevious: function(previous) {\\n      if (!previous) {\\n        return this;\\n      } else if (previous instanceof Parse.Op.Unset) {\\n        return previous;\\n      } else if (previous instanceof Parse.Op.Set) {\\n        return new Parse.Op.Set(this._estimate(previous.value()));\\n      } else if (previous instanceof Parse.Op.Remove) {\\n        return new Parse.Op.Remove(_.union(previous.objects(), this.objects()));\\n      } else {\\n        throw \\\"Op is invalid after previous op.\\\";\\n      }\\n    },\\n\\n    _estimate: function(oldValue) {\\n      if (!oldValue) {\\n        return [];\\n      } else {\\n        var newValue = _.difference(oldValue, this.objects());\\n        // If there are saved Parse Objects being removed, also remove them.\\n        Parse._arrayEach(this.objects(), function(obj) {\\n          if (obj instanceof Parse.Object && obj.id) {\\n            newValue = _.reject(newValue, function(other) {\\n              return (other instanceof Parse.Object) && (other.id === obj.id);\\n            });\\n          }\\n        });\\n        return newValue;\\n      }\\n    }\\n  });\\n\\n  Parse.Op._registerDecoder(\\\"Remove\\\", function(json) {\\n    return new Parse.Op.Remove(Parse._decode(undefined, json.objects));\\n  });\\n\\n  /**\\n   * @class\\n   * A Relation operation indicates that the field is an instance of\\n   * Parse.Relation, and objects are being added to, or removed from, that\\n   * relation.\\n   */\\n  Parse.Op.Relation = Parse.Op._extend(\\n      /** @lends Parse.Op.Relation.prototype */ {\\n\\n    _initialize: function(adds, removes) {\\n      this._targetClassName = null;\\n\\n      var self = this;\\n\\n      var pointerToId = function(object) {\\n        if (object instanceof Parse.Object) {\\n          if (!object.id) {\\n            throw \\\"You can't add an unsaved Parse.Object to a relation.\\\";\\n          }\\n          if (!self._targetClassName) {\\n            self._targetClassName = object.className;\\n          }\\n          if (self._targetClassName !== object.className) {\\n            throw \\\"Tried to create a Parse.Relation with 2 different types: \\\" +\\n                  self._targetClassName + \\\" and \\\" + object.className + \\\".\\\";\\n          }\\n          return object.id;\\n        }\\n        return object;\\n      };\\n\\n      this.relationsToAdd = _.uniq(_.map(adds, pointerToId));\\n      this.relationsToRemove = _.uniq(_.map(removes, pointerToId));\\n    },\\n\\n    /**\\n     * Returns an array of unfetched Parse.Object that are being added to the\\n     * relation.\\n     * @return {Array}\\n     */\\n    added: function() {\\n      var self = this;\\n      return _.map(this.relationsToAdd, function(objectId) {\\n        var object = Parse.Object._create(self._targetClassName);\\n        object.id = objectId;\\n        return object;\\n      });\\n    },\\n\\n    /**\\n     * Returns an array of unfetched Parse.Object that are being removed from\\n     * the relation.\\n     * @return {Array}\\n     */\\n    removed: function() {\\n      var self = this;\\n      return _.map(this.relationsToRemove, function(objectId) {\\n        var object = Parse.Object._create(self._targetClassName);\\n        object.id = objectId;\\n        return object;\\n      });\\n    },\\n\\n    /**\\n     * Returns a JSON version of the operation suitable for sending to Parse.\\n     * @return {Object}\\n     */\\n    toJSON: function() {\\n      var adds = null;\\n      var removes = null;\\n      var self = this;\\n      var idToPointer = function(id) {\\n        return { __type: 'Pointer',\\n                 className: self._targetClassName,\\n                 objectId: id };\\n      };\\n      var pointers = null;\\n      if (this.relationsToAdd.length > 0) {\\n        pointers = _.map(this.relationsToAdd, idToPointer);\\n        adds = { \\\"__op\\\": \\\"AddRelation\\\", \\\"objects\\\": pointers };\\n      }\\n\\n      if (this.relationsToRemove.length > 0) {\\n        pointers = _.map(this.relationsToRemove, idToPointer);\\n        removes = { \\\"__op\\\": \\\"RemoveRelation\\\", \\\"objects\\\": pointers };\\n      }\\n\\n      if (adds && removes) {\\n        return { \\\"__op\\\": \\\"Batch\\\", \\\"ops\\\": [adds, removes]};\\n      }\\n\\n      return adds || removes || {};\\n    },\\n\\n    _mergeWithPrevious: function(previous) {\\n      if (!previous) {\\n        return this;\\n      } else if (previous instanceof Parse.Op.Unset) {\\n        throw \\\"You can't modify a relation after deleting it.\\\";\\n      } else if (previous instanceof Parse.Op.Relation) {\\n        if (previous._targetClassName &&\\n            previous._targetClassName !== this._targetClassName) {\\n          throw \\\"Related object must be of class \\\" + previous._targetClassName +\\n              \\\", but \\\" + this._targetClassName + \\\" was passed in.\\\";\\n        }\\n        var newAdd = _.union(_.difference(previous.relationsToAdd,\\n                                          this.relationsToRemove),\\n                             this.relationsToAdd);\\n        var newRemove = _.union(_.difference(previous.relationsToRemove,\\n                                             this.relationsToAdd),\\n                                this.relationsToRemove);\\n\\n        var newRelation = new Parse.Op.Relation(newAdd, newRemove);\\n        newRelation._targetClassName = this._targetClassName;\\n        return newRelation;\\n      } else {\\n        throw \\\"Op is invalid after previous op.\\\";\\n      }\\n    },\\n\\n    _estimate: function(oldValue, object, key) {\\n      if (!oldValue) {\\n        var relation = new Parse.Relation(object, key);\\n        relation.targetClassName = this._targetClassName;\\n      } else if (oldValue instanceof Parse.Relation) {\\n        if (this._targetClassName) {\\n          if (oldValue.targetClassName) {\\n            if (oldValue.targetClassName !== this._targetClassName) {\\n              throw \\\"Related object must be a \\\" + oldValue.targetClassName +\\n                  \\\", but a \\\" + this._targetClassName + \\\" was passed in.\\\";\\n            }\\n          } else {\\n            oldValue.targetClassName = this._targetClassName;\\n          }\\n        }\\n        return oldValue;\\n      } else {\\n        throw \\\"Op is invalid after previous op.\\\";\\n      }\\n    }\\n  });\\n\\n  Parse.Op._registerDecoder(\\\"AddRelation\\\", function(json) {\\n    return new Parse.Op.Relation(Parse._decode(undefined, json.objects), []);\\n  });\\n  Parse.Op._registerDecoder(\\\"RemoveRelation\\\", function(json) {\\n    return new Parse.Op.Relation([], Parse._decode(undefined, json.objects));\\n  });\\n\\n}(this));\\n\\n(function(root) {\\n  root.Parse = root.Parse || {};\\n  var Parse = root.Parse;\\n  var _ = Parse._;\\n\\n  /**\\n   * Creates a new Relation for the given parent object and key. This\\n   * constructor should rarely be used directly, but rather created by\\n   * Parse.Object.relation.\\n   * @param {Parse.Object} parent The parent of this relation.\\n   * @param {String} key The key for this relation on the parent.\\n   * @see Parse.Object#relation\\n   * @class\\n   *\\n   * <p>\\n   * A class that is used to access all of the children of a many-to-many\\n   * relationship.  Each instance of Parse.Relation is associated with a\\n   * particular parent object and key.\\n   * </p>\\n   */\\n  Parse.Relation = function(parent, key) {\\n    this.parent = parent;\\n    this.key = key;\\n    this.targetClassName = null;\\n  };\\n\\n  Parse.Relation.prototype = {\\n    /**\\n     * Makes sure that this relation has the right parent and key.\\n     */\\n    _ensureParentAndKey: function(parent, key) {\\n      this.parent = this.parent || parent;\\n      this.key = this.key || key;\\n      if (this.parent !== parent) {\\n        throw \\\"Internal Error. Relation retrieved from two different Objects.\\\";\\n      }\\n      if (this.key !== key) {\\n        throw \\\"Internal Error. Relation retrieved from two different keys.\\\";\\n      }\\n    },\\n\\n    /**\\n     * Adds a Parse.Object or an array of Parse.Objects to the relation.\\n     * @param {} objects The item or items to add.\\n     */\\n    add: function(objects) {\\n      if (!_.isArray(objects)) {\\n        objects = [objects];\\n      }\\n\\n      var change = new Parse.Op.Relation(objects, []);\\n      this.parent.set(this.key, change);\\n      this.targetClassName = change._targetClassName;\\n    },\\n\\n    /**\\n     * Removes a Parse.Object or an array of Parse.Objects from this relation.\\n     * @param {} objects The item or items to remove.\\n     */\\n    remove: function(objects) {\\n      if (!_.isArray(objects)) {\\n        objects = [objects];\\n      }\\n\\n      var change = new Parse.Op.Relation([], objects);\\n      this.parent.set(this.key, change);\\n      this.targetClassName = change._targetClassName;\\n    },\\n\\n    /**\\n     * Returns a JSON version of the object suitable for saving to disk.\\n     * @return {Object}\\n     */\\n    toJSON: function() {\\n      return { \\\"__type\\\": \\\"Relation\\\", \\\"className\\\": this.targetClassName };\\n    },\\n\\n    /**\\n     * Returns a Parse.Query that is limited to objects in this\\n     * relation.\\n     * @return {Parse.Query}\\n     */\\n    query: function() {\\n      var targetClass;\\n      var query;\\n      if (!this.targetClassName) {\\n        targetClass = Parse.Object._getSubclass(this.parent.className);\\n        query = new Parse.Query(targetClass);\\n        query._extraOptions.redirectClassNameForKey = this.key;\\n      } else {\\n        targetClass = Parse.Object._getSubclass(this.targetClassName);\\n        query = new Parse.Query(targetClass);\\n      }\\n      query._addCondition(\\\"$relatedTo\\\", \\\"object\\\", this.parent._toPointer());\\n      query._addCondition(\\\"$relatedTo\\\", \\\"key\\\", this.key);\\n\\n      return query;\\n    }\\n  };\\n}(this));\\n\\n(function(root) {\\n  root.Parse = root.Parse || {};\\n  var Parse = root.Parse;\\n  var _ = Parse._;\\n\\n  /**\\n   * A Promise is returned by async methods as a hook to provide callbacks to be\\n   * called when the async task is fulfilled.\\n   *\\n   * <p>Typical usage would be like:<pre>\\n   *    query.find().then(function(results) {\\n   *      results[0].set(\\\"foo\\\", \\\"bar\\\");\\n   *      return results[0].saveAsync();\\n   *    }).then(function(result) {\\n   *      console.log(\\\"Updated \\\" + result.id);\\n   *    });\\n   * </pre></p>\\n   *\\n   * @see Parse.Promise.prototype.then\\n   * @class\\n   */\\n  Parse.Promise = function() {\\n    this._resolved = false;\\n    this._rejected = false;\\n    this._resolvedCallbacks = [];\\n    this._rejectedCallbacks = [];\\n  };\\n\\n  _.extend(Parse.Promise, /** @lends Parse.Promise */ {\\n\\n    /**\\n     * Returns true iff the given object fulfils the Promise interface.\\n     * @return {Boolean}\\n     */\\n    is: function(promise) {\\n      return promise && promise.then && _.isFunction(promise.then);\\n    },\\n\\n    /**\\n     * Returns a new promise that is resolved with a given value.\\n     * @return {Parse.Promise} the new promise.\\n     */\\n    as: function() {\\n      var promise = new Parse.Promise();\\n      promise.resolve.apply(promise, arguments);\\n      return promise;\\n    },\\n\\n    /**\\n     * Returns a new promise that is rejected with a given error.\\n     * @return {Parse.Promise} the new promise.\\n     */\\n    error: function() {\\n      var promise = new Parse.Promise();\\n      promise.reject.apply(promise, arguments);\\n      return promise;\\n    },\\n\\n    /**\\n     * Returns a new promise that is fulfilled when all of the input promises\\n     * are resolved. If any promise in the list fails, then the returned promise\\n     * will fail with the last error. If they all succeed, then the returned\\n     * promise will succeed, with the results being the results of all the input\\n     * promises. For example: <pre>\\n     *   var p1 = Parse.Promise.as(1);\\n     *   var p2 = Parse.Promise.as(2);\\n     *   var p3 = Parse.Promise.as(3);\\n     *\\n     *   Parse.Promise.when(p1, p2, p3).then(function(r1, r2, r3) {\\n     *     console.log(r1);  // prints 1\\n     *     console.log(r2);  // prints 2\\n     *     console.log(r3);  // prints 3\\n     *   });</pre>\\n     *\\n     * The input promises can also be specified as an array: <pre>\\n     *   var promises = [p1, p2, p3];\\n     *   Parse.Promise.when(promises).then(function(r1, r2, r3) {\\n     *     console.log(r1);  // prints 1\\n     *     console.log(r2);  // prints 2\\n     *     console.log(r3);  // prints 3\\n     *   });\\n     * </pre>\\n     * @param {Array} promises a list of promises to wait for.\\n     * @return {Parse.Promise} the new promise.\\n     */\\n    when: function(promises) {\\n      // Allow passing in Promises as separate arguments instead of an Array.\\n      var objects;\\n      if (promises && Parse._isNullOrUndefined(promises.length)) {\\n        objects = arguments;\\n      } else {\\n        objects = promises;\\n      }\\n\\n      var total = objects.length;\\n      var hadError = false;\\n      var results = [];\\n      var errors = [];\\n      results.length = objects.length;\\n      errors.length = objects.length;\\n\\n      if (total === 0) {\\n        return Parse.Promise.as.apply(this, results);\\n      }\\n\\n      var promise = new Parse.Promise();\\n\\n      var resolveOne = function() {\\n        total = total - 1;\\n        if (total === 0) {\\n          if (hadError) {\\n            promise.reject(errors);\\n          } else {\\n            promise.resolve.apply(promise, results);\\n          }\\n        }\\n      };\\n\\n      Parse._arrayEach(objects, function(object, i) {\\n        if (Parse.Promise.is(object)) {\\n          object.then(function(result) {\\n            results[i] = result;\\n            resolveOne();\\n          }, function(error) {\\n            errors[i] = error;\\n            hadError = true;\\n            resolveOne();\\n          });\\n        } else {\\n          results[i] = object;\\n          resolveOne();\\n        }\\n      });\\n\\n      return promise;\\n    },\\n\\n    /**\\n     * Runs the given asyncFunction repeatedly, as long as the predicate\\n     * function returns a truthy value. Stops repeating if asyncFunction returns\\n     * a rejected promise.\\n     * @param {Function} predicate should return false when ready to stop.\\n     * @param {Function} asyncFunction should return a Promise.\\n     */\\n    _continueWhile: function(predicate, asyncFunction) {\\n      if (predicate()) {\\n        return asyncFunction().then(function() {\\n          return Parse.Promise._continueWhile(predicate, asyncFunction);\\n        });\\n      }\\n      return Parse.Promise.as();\\n    }\\n  });\\n\\n  _.extend(Parse.Promise.prototype, /** @lends Parse.Promise.prototype */ {\\n\\n    /**\\n     * Marks this promise as fulfilled, firing any callbacks waiting on it.\\n     * @param {Object} result the result to pass to the callbacks.\\n     */\\n    resolve: function(result) {\\n      if (this._resolved || this._rejected) {\\n        throw \\\"A promise was resolved even though it had already been \\\" +\\n          (this._resolved ? \\\"resolved\\\" : \\\"rejected\\\") + \\\".\\\";\\n      }\\n      this._resolved = true;\\n      this._result = arguments;\\n      var results = arguments;\\n      Parse._arrayEach(this._resolvedCallbacks, function(resolvedCallback) {\\n        resolvedCallback.apply(this, results);\\n      });\\n      this._resolvedCallbacks = [];\\n      this._rejectedCallbacks = [];\\n    },\\n\\n    /**\\n     * Marks this promise as fulfilled, firing any callbacks waiting on it.\\n     * @param {Object} error the error to pass to the callbacks.\\n     */\\n    reject: function(error) {\\n      if (this._resolved || this._rejected) {\\n        throw \\\"A promise was rejected even though it had already been \\\" +\\n          (this._resolved ? \\\"resolved\\\" : \\\"rejected\\\") + \\\".\\\";\\n      }\\n      this._rejected = true;\\n      this._error = error;\\n      Parse._arrayEach(this._rejectedCallbacks, function(rejectedCallback) {\\n        rejectedCallback(error);\\n      });\\n      this._resolvedCallbacks = [];\\n      this._rejectedCallbacks = [];\\n    },\\n\\n    /**\\n     * Adds callbacks to be called when this promise is fulfilled. Returns a new\\n     * Promise that will be fulfilled when the callback is complete. It allows\\n     * chaining. If the callback itself returns a Promise, then the one returned\\n     * by \\\"then\\\" will not be fulfilled until that one returned by the callback\\n     * is fulfilled.\\n     * @param {Function} resolvedCallback Function that is called when this\\n     * Promise is resolved. Once the callback is complete, then the Promise\\n     * returned by \\\"then\\\" will also be fulfilled.\\n     * @param {Function} rejectedCallback Function that is called when this\\n     * Promise is rejected with an error. Once the callback is complete, then\\n     * the promise returned by \\\"then\\\" with be resolved successfully. If\\n     * rejectedCallback is null, or it returns a rejected Promise, then the\\n     * Promise returned by \\\"then\\\" will be rejected with that error.\\n     * @return {Parse.Promise} A new Promise that will be fulfilled after this\\n     * Promise is fulfilled and either callback has completed. If the callback\\n     * returned a Promise, then this Promise will not be fulfilled until that\\n     * one is.\\n     */\\n    then: function(resolvedCallback, rejectedCallback) {\\n      var promise = new Parse.Promise();\\n\\n      var wrappedResolvedCallback = function() {\\n        var result = arguments;\\n        if (resolvedCallback) {\\n          result = [resolvedCallback.apply(this, result)];\\n        }\\n        if (result.length === 1 && Parse.Promise.is(result[0])) {\\n          result[0].then(function() {\\n            promise.resolve.apply(promise, arguments);\\n          }, function(error) {\\n            promise.reject(error);\\n          });\\n        } else {\\n          promise.resolve.apply(promise, result);\\n        }\\n      };\\n\\n      var wrappedRejectedCallback = function(error) {\\n        var result = [];\\n        if (rejectedCallback) {\\n          result = [rejectedCallback(error)];\\n          if (result.length === 1 && Parse.Promise.is(result[0])) {\\n            result[0].then(function() {\\n              promise.resolve.apply(promise, arguments);\\n            }, function(error) {\\n              promise.reject(error);\\n            });\\n          } else {\\n            // A Promises/A+ compliant implementation would call:\\n            // promise.resolve.apply(promise, result);\\n            promise.reject(result[0]);\\n          }\\n        } else {\\n          promise.reject(error);\\n        }\\n      };\\n\\n      if (this._resolved) {\\n        wrappedResolvedCallback.apply(this, this._result);\\n      } else if (this._rejected) {\\n        wrappedRejectedCallback(this._error);\\n      } else {\\n        this._resolvedCallbacks.push(wrappedResolvedCallback);\\n        this._rejectedCallbacks.push(wrappedRejectedCallback);\\n      }\\n\\n      return promise;\\n    },\\n\\n    /**\\n     * Add handlers to be called when the promise\\n     * is either resolved or rejected\\n     */\\n    always: function(callback) {\\n      return this.then(callback, callback);\\n    },\\n\\n    /**\\n     * Add handlers to be called when the Promise object is resolved\\n     */\\n    done: function(callback) {\\n      return this.then(callback);\\n    },\\n\\n    /**\\n     * Add handlers to be called when the Promise object is rejected\\n     */\\n    fail: function(callback) {\\n      return this.then(null, callback);\\n    },\\n\\n    /**\\n     * Run the given callbacks after this promise is fulfilled.\\n     * @param optionsOrCallback {} A Backbone-style options callback, or a\\n     * callback function. If this is an options object and contains a \\\"model\\\"\\n     * attributes, that will be passed to error callbacks as the first argument.\\n     * @param model {} If truthy, this will be passed as the first result of\\n     * error callbacks. This is for Backbone-compatability.\\n     * @return {Parse.Promise} A promise that will be resolved after the\\n     * callbacks are run, with the same result as this.\\n     */\\n    _thenRunCallbacks: function(optionsOrCallback, model) {\\n      var options;\\n      if (_.isFunction(optionsOrCallback)) {\\n        var callback = optionsOrCallback;\\n        options = {\\n          success: function(result) {\\n            callback(result, null);\\n          },\\n          error: function(error) {\\n            callback(null, error);\\n          }\\n        };\\n      } else {\\n        options = _.clone(optionsOrCallback);\\n      }\\n      options = options || {};\\n\\n      return this.then(function(result) {\\n        if (options.success) {\\n          options.success.apply(this, arguments);\\n        } else if (model) {\\n          // When there's no callback, a sync event should be triggered.\\n          model.trigger('sync', model, result, options);\\n        }\\n        return Parse.Promise.as.apply(Parse.Promise, arguments);\\n      }, function(error) {\\n        if (options.error) {\\n          if (!_.isUndefined(model)) {\\n            options.error(model, error);\\n          } else {\\n            options.error(error);\\n          }\\n        } else if (model) {\\n          // When there's no error callback, an error event should be triggered.\\n          model.trigger('error', model, error, options);\\n        }\\n        // By explicitly returning a rejected Promise, this will work with\\n        // either jQuery or Promises/A semantics.\\n        return Parse.Promise.error(error);\\n      });\\n    },\\n\\n    /**\\n     * Adds a callback function that should be called regardless of whether\\n     * this promise failed or succeeded. The callback will be given either the\\n     * array of results for its first argument, or the error as its second,\\n     * depending on whether this Promise was rejected or resolved. Returns a\\n     * new Promise, like \\\"then\\\" would.\\n     * @param {Function} continuation the callback.\\n     */\\n    _continueWith: function(continuation) {\\n      return this.then(function() {\\n        return continuation(arguments, null);\\n      }, function(error) {\\n        return continuation(null, error);\\n      });\\n    }\\n\\n  });\\n\\n}(this));\\n\\n/*jshint bitwise:false *//*global FileReader: true, File: true */\\n(function(root) {\\n  root.Parse = root.Parse || {};\\n  var Parse = root.Parse;\\n  var _ = Parse._;\\n\\n  var b64Digit = function(number) {\\n    if (number < 26) {\\n      return String.fromCharCode(65 + number);\\n    }\\n    if (number < 52) {\\n      return String.fromCharCode(97 + (number - 26));\\n    }\\n    if (number < 62) {\\n      return String.fromCharCode(48 + (number - 52));\\n    }\\n    if (number === 62) {\\n      return \\\"+\\\";\\n    }\\n    if (number === 63) {\\n      return \\\"/\\\";\\n    }\\n    throw \\\"Tried to encode large digit \\\" + number + \\\" in base64.\\\";\\n  };\\n\\n  var encodeBase64 = function(array) {\\n    var chunks = [];\\n    chunks.length = Math.ceil(array.length / 3);\\n    _.times(chunks.length, function(i) {\\n      var b1 = array[i * 3];\\n      var b2 = array[i * 3 + 1] || 0;\\n      var b3 = array[i * 3 + 2] || 0;\\n\\n      var has2 = (i * 3 + 1) < array.length;\\n      var has3 = (i * 3 + 2) < array.length;\\n\\n      chunks[i] = [\\n        b64Digit((b1 >> 2) & 0x3F),\\n        b64Digit(((b1 << 4) & 0x30) | ((b2 >> 4) & 0x0F)),\\n        has2 ? b64Digit(((b2 << 2) & 0x3C) | ((b3 >> 6) & 0x03)) : \\\"=\\\",\\n        has3 ? b64Digit(b3 & 0x3F) : \\\"=\\\"\\n      ].join(\\\"\\\");\\n    });\\n    return chunks.join(\\\"\\\");\\n  };\\n\\n\\n  // A list of file extensions to mime types as found here:\\n  // http://stackoverflow.com/questions/58510/using-net-how-can-you-find-the-\\n  //     mime-type-of-a-file-based-on-the-file-signature\\n  var mimeTypes = {\\n    ai: \\\"application/postscript\\\",\\n    aif: \\\"audio/x-aiff\\\",\\n    aifc: \\\"audio/x-aiff\\\",\\n    aiff: \\\"audio/x-aiff\\\",\\n    asc: \\\"text/plain\\\",\\n    atom: \\\"application/atom+xml\\\",\\n    au: \\\"audio/basic\\\",\\n    avi: \\\"video/x-msvideo\\\",\\n    bcpio: \\\"application/x-bcpio\\\",\\n    bin: \\\"application/octet-stream\\\",\\n    bmp: \\\"image/bmp\\\",\\n    cdf: \\\"application/x-netcdf\\\",\\n    cgm: \\\"image/cgm\\\",\\n    \\\"class\\\": \\\"application/octet-stream\\\",\\n    cpio: \\\"application/x-cpio\\\",\\n    cpt: \\\"application/mac-compactpro\\\",\\n    csh: \\\"application/x-csh\\\",\\n    css: \\\"text/css\\\",\\n    dcr: \\\"application/x-director\\\",\\n    dif: \\\"video/x-dv\\\",\\n    dir: \\\"application/x-director\\\",\\n    djv: \\\"image/vnd.djvu\\\",\\n    djvu: \\\"image/vnd.djvu\\\",\\n    dll: \\\"application/octet-stream\\\",\\n    dmg: \\\"application/octet-stream\\\",\\n    dms: \\\"application/octet-stream\\\",\\n    doc: \\\"application/msword\\\",\\n    docx: \\\"application/vnd.openxmlformats-officedocument.wordprocessingml.\\\" +\\n          \\\"document\\\",\\n    dotx: \\\"application/vnd.openxmlformats-officedocument.wordprocessingml.\\\" +\\n          \\\"template\\\",\\n    docm: \\\"application/vnd.ms-word.document.macroEnabled.12\\\",\\n    dotm: \\\"application/vnd.ms-word.template.macroEnabled.12\\\",\\n    dtd: \\\"application/xml-dtd\\\",\\n    dv: \\\"video/x-dv\\\",\\n    dvi: \\\"application/x-dvi\\\",\\n    dxr: \\\"application/x-director\\\",\\n    eps: \\\"application/postscript\\\",\\n    etx: \\\"text/x-setext\\\",\\n    exe: \\\"application/octet-stream\\\",\\n    ez: \\\"application/andrew-inset\\\",\\n    gif: \\\"image/gif\\\",\\n    gram: \\\"application/srgs\\\",\\n    grxml: \\\"application/srgs+xml\\\",\\n    gtar: \\\"application/x-gtar\\\",\\n    hdf: \\\"application/x-hdf\\\",\\n    hqx: \\\"application/mac-binhex40\\\",\\n    htm: \\\"text/html\\\",\\n    html: \\\"text/html\\\",\\n    ice: \\\"x-conference/x-cooltalk\\\",\\n    ico: \\\"image/x-icon\\\",\\n    ics: \\\"text/calendar\\\",\\n    ief: \\\"image/ief\\\",\\n    ifb: \\\"text/calendar\\\",\\n    iges: \\\"model/iges\\\",\\n    igs: \\\"model/iges\\\",\\n    jnlp: \\\"application/x-java-jnlp-file\\\",\\n    jp2: \\\"image/jp2\\\",\\n    jpe: \\\"image/jpeg\\\",\\n    jpeg: \\\"image/jpeg\\\",\\n    jpg: \\\"image/jpeg\\\",\\n    js: \\\"application/x-javascript\\\",\\n    kar: \\\"audio/midi\\\",\\n    latex: \\\"application/x-latex\\\",\\n    lha: \\\"application/octet-stream\\\",\\n    lzh: \\\"application/octet-stream\\\",\\n    m3u: \\\"audio/x-mpegurl\\\",\\n    m4a: \\\"audio/mp4a-latm\\\",\\n    m4b: \\\"audio/mp4a-latm\\\",\\n    m4p: \\\"audio/mp4a-latm\\\",\\n    m4u: \\\"video/vnd.mpegurl\\\",\\n    m4v: \\\"video/x-m4v\\\",\\n    mac: \\\"image/x-macpaint\\\",\\n    man: \\\"application/x-troff-man\\\",\\n    mathml: \\\"application/mathml+xml\\\",\\n    me: \\\"application/x-troff-me\\\",\\n    mesh: \\\"model/mesh\\\",\\n    mid: \\\"audio/midi\\\",\\n    midi: \\\"audio/midi\\\",\\n    mif: \\\"application/vnd.mif\\\",\\n    mov: \\\"video/quicktime\\\",\\n    movie: \\\"video/x-sgi-movie\\\",\\n    mp2: \\\"audio/mpeg\\\",\\n    mp3: \\\"audio/mpeg\\\",\\n    mp4: \\\"video/mp4\\\",\\n    mpe: \\\"video/mpeg\\\",\\n    mpeg: \\\"video/mpeg\\\",\\n    mpg: \\\"video/mpeg\\\",\\n    mpga: \\\"audio/mpeg\\\",\\n    ms: \\\"application/x-troff-ms\\\",\\n    msh: \\\"model/mesh\\\",\\n    mxu: \\\"video/vnd.mpegurl\\\",\\n    nc: \\\"application/x-netcdf\\\",\\n    oda: \\\"application/oda\\\",\\n    ogg: \\\"application/ogg\\\",\\n    pbm: \\\"image/x-portable-bitmap\\\",\\n    pct: \\\"image/pict\\\",\\n    pdb: \\\"chemical/x-pdb\\\",\\n    pdf: \\\"application/pdf\\\",\\n    pgm: \\\"image/x-portable-graymap\\\",\\n    pgn: \\\"application/x-chess-pgn\\\",\\n    pic: \\\"image/pict\\\",\\n    pict: \\\"image/pict\\\",\\n    png: \\\"image/png\\\",\\n    pnm: \\\"image/x-portable-anymap\\\",\\n    pnt: \\\"image/x-macpaint\\\",\\n    pntg: \\\"image/x-macpaint\\\",\\n    ppm: \\\"image/x-portable-pixmap\\\",\\n    ppt: \\\"application/vnd.ms-powerpoint\\\",\\n    pptx: \\\"application/vnd.openxmlformats-officedocument.presentationml.\\\" +\\n          \\\"presentation\\\",\\n    potx: \\\"application/vnd.openxmlformats-officedocument.presentationml.\\\" +\\n          \\\"template\\\",\\n    ppsx: \\\"application/vnd.openxmlformats-officedocument.presentationml.\\\" +\\n          \\\"slideshow\\\",\\n    ppam: \\\"application/vnd.ms-powerpoint.addin.macroEnabled.12\\\",\\n    pptm: \\\"application/vnd.ms-powerpoint.presentation.macroEnabled.12\\\",\\n    potm: \\\"application/vnd.ms-powerpoint.template.macroEnabled.12\\\",\\n    ppsm: \\\"application/vnd.ms-powerpoint.slideshow.macroEnabled.12\\\",\\n    ps: \\\"application/postscript\\\",\\n    qt: \\\"video/quicktime\\\",\\n    qti: \\\"image/x-quicktime\\\",\\n    qtif: \\\"image/x-quicktime\\\",\\n    ra: \\\"audio/x-pn-realaudio\\\",\\n    ram: \\\"audio/x-pn-realaudio\\\",\\n    ras: \\\"image/x-cmu-raster\\\",\\n    rdf: \\\"application/rdf+xml\\\",\\n    rgb: \\\"image/x-rgb\\\",\\n    rm: \\\"application/vnd.rn-realmedia\\\",\\n    roff: \\\"application/x-troff\\\",\\n    rtf: \\\"text/rtf\\\",\\n    rtx: \\\"text/richtext\\\",\\n    sgm: \\\"text/sgml\\\",\\n    sgml: \\\"text/sgml\\\",\\n    sh: \\\"application/x-sh\\\",\\n    shar: \\\"application/x-shar\\\",\\n    silo: \\\"model/mesh\\\",\\n    sit: \\\"application/x-stuffit\\\",\\n    skd: \\\"application/x-koan\\\",\\n    skm: \\\"application/x-koan\\\",\\n    skp: \\\"application/x-koan\\\",\\n    skt: \\\"application/x-koan\\\",\\n    smi: \\\"application/smil\\\",\\n    smil: \\\"application/smil\\\",\\n    snd: \\\"audio/basic\\\",\\n    so: \\\"application/octet-stream\\\",\\n    spl: \\\"application/x-futuresplash\\\",\\n    src: \\\"application/x-wais-source\\\",\\n    sv4cpio: \\\"application/x-sv4cpio\\\",\\n    sv4crc: \\\"application/x-sv4crc\\\",\\n    svg: \\\"image/svg+xml\\\",\\n    swf: \\\"application/x-shockwave-flash\\\",\\n    t: \\\"application/x-troff\\\",\\n    tar: \\\"application/x-tar\\\",\\n    tcl: \\\"application/x-tcl\\\",\\n    tex: \\\"application/x-tex\\\",\\n    texi: \\\"application/x-texinfo\\\",\\n    texinfo: \\\"application/x-texinfo\\\",\\n    tif: \\\"image/tiff\\\",\\n    tiff: \\\"image/tiff\\\",\\n    tr: \\\"application/x-troff\\\",\\n    tsv: \\\"text/tab-separated-values\\\",\\n    txt: \\\"text/plain\\\",\\n    ustar: \\\"application/x-ustar\\\",\\n    vcd: \\\"application/x-cdlink\\\",\\n    vrml: \\\"model/vrml\\\",\\n    vxml: \\\"application/voicexml+xml\\\",\\n    wav: \\\"audio/x-wav\\\",\\n    wbmp: \\\"image/vnd.wap.wbmp\\\",\\n    wbmxl: \\\"application/vnd.wap.wbxml\\\",\\n    wml: \\\"text/vnd.wap.wml\\\",\\n    wmlc: \\\"application/vnd.wap.wmlc\\\",\\n    wmls: \\\"text/vnd.wap.wmlscript\\\",\\n    wmlsc: \\\"application/vnd.wap.wmlscriptc\\\",\\n    wrl: \\\"model/vrml\\\",\\n    xbm: \\\"image/x-xbitmap\\\",\\n    xht: \\\"application/xhtml+xml\\\",\\n    xhtml: \\\"application/xhtml+xml\\\",\\n    xls: \\\"application/vnd.ms-excel\\\",\\n    xml: \\\"application/xml\\\",\\n    xpm: \\\"image/x-xpixmap\\\",\\n    xsl: \\\"application/xml\\\",\\n    xlsx: \\\"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet\\\",\\n    xltx: \\\"application/vnd.openxmlformats-officedocument.spreadsheetml.\\\" +\\n          \\\"template\\\",\\n    xlsm: \\\"application/vnd.ms-excel.sheet.macroEnabled.12\\\",\\n    xltm: \\\"application/vnd.ms-excel.template.macroEnabled.12\\\",\\n    xlam: \\\"application/vnd.ms-excel.addin.macroEnabled.12\\\",\\n    xlsb: \\\"application/vnd.ms-excel.sheet.binary.macroEnabled.12\\\",\\n    xslt: \\\"application/xslt+xml\\\",\\n    xul: \\\"application/vnd.mozilla.xul+xml\\\",\\n    xwd: \\\"image/x-xwindowdump\\\",\\n    xyz: \\\"chemical/x-xyz\\\",\\n    zip: \\\"application/zip\\\"\\n  };\\n\\n  /**\\n   * Reads a File using a FileReader.\\n   * @param file {File} the File to read.\\n   * @param type {String} (optional) the mimetype to override with.\\n   * @return {Parse.Promise} A Promise that will be fulfilled with a\\n   *     base64-encoded string of the data and its mime type.\\n   */\\n  var readAsync = function(file, type) {\\n    var promise = new Parse.Promise();\\n\\n    if (typeof(FileReader) === \\\"undefined\\\") {\\n      return Parse.Promise.error(new Parse.Error(\\n          Parse.Error.FILE_READ_ERROR,\\n          \\\"Attempted to use a FileReader on an unsupported browser.\\\"));\\n    }\\n\\n    var reader = new FileReader();\\n    reader.onloadend = function() {\\n      if (reader.readyState !== 2) {\\n        promise.reject(new Parse.Error(\\n            Parse.Error.FILE_READ_ERROR,\\n            \\\"Error reading file.\\\"));\\n        return;\\n      }\\n\\n      var dataURL = reader.result;\\n      var matches = /^data:([^;]*);base64,(.*)$/.exec(dataURL);\\n      if (!matches) {\\n        promise.reject(new Parse.Error(\\n            Parse.ERROR.FILE_READ_ERROR,\\n            \\\"Unable to interpret data URL: \\\" + dataURL));\\n        return;\\n      }\\n\\n      promise.resolve(matches[2], type || matches[1]);\\n    };\\n    reader.readAsDataURL(file);\\n    return promise;\\n  };\\n\\n  /**\\n   * A Parse.File is a local representation of a file that is saved to the Parse\\n   * cloud.\\n   * @class\\n   * @param name {String} The file's name. This will be prefixed by a unique\\n   *     value once the file has finished saving. The file name must begin with\\n   *     an alphanumeric character, and consist of alphanumeric characters,\\n   *     periods, spaces, underscores, or dashes.\\n   * @param data {Array} The data for the file, as either:\\n   *     1. an Array of byte value Numbers, or\\n   *     2. an Object like { base64: \\\"...\\\" } with a base64-encoded String.\\n   *     3. a File object selected with a file upload control. (3) only works\\n   *        in Firefox 3.6+, Safari 6.0.2+, Chrome 7+, and IE 10+.\\n   *        For example:<pre>\\n   * var fileUploadControl = $(\\\"#profilePhotoFileUpload\\\")[0];\\n   * if (fileUploadControl.files.length > 0) {\\n   *   var file = fileUploadControl.files[0];\\n   *   var name = \\\"photo.jpg\\\";\\n   *   var parseFile = new Parse.File(name, file);\\n   *   parseFile.save().then(function() {\\n   *     // The file has been saved to Parse.\\n   *   }, function(error) {\\n   *     // The file either could not be read, or could not be saved to Parse.\\n   *   });\\n   * }</pre>\\n   * @param type {String} Optional Content-Type header to use for the file. If\\n   *     this is omitted, the content type will be inferred from the name's\\n   *     extension.\\n   */\\n  Parse.File = function(name, data, type) {\\n    this._name = name;\\n\\n    // Guess the content type from the extension if we need to.\\n    var extension = /\\\\.([^.]*)$/.exec(name);\\n    if (extension) {\\n      extension = extension[1].toLowerCase();\\n    }\\n    var guessedType = type || mimeTypes[extension] || \\\"text/plain\\\";\\n\\n    if (_.isArray(data)) {\\n      this._source = Parse.Promise.as(encodeBase64(data), guessedType);\\n    } else if (data && data.base64) {\\n      // if it contains data uri, extract based64 and the type out of it.\\n      /*jslint maxlen: 1000*/\\n      var dataUriRegexp = /^data:([a-zA-Z]*\\\\/[a-zA-Z+.-]*);(charset=[a-zA-Z0-9\\\\-\\\\/\\\\s]*,)?base64,(\\\\S+)/;\\n      /*jslint maxlen: 80*/\\n\\n      var matches = dataUriRegexp.exec(data.base64);\\n      if (matches && matches.length > 0) {\\n        // if data URI with charset, there will have 4 matches.\\n        this._source = Parse.Promise.as(\\n          (matches.length === 4 ? matches[3] : matches[2]), matches[1]\\n        );\\n      } else {\\n        this._source = Parse.Promise.as(data.base64, guessedType);\\n      }\\n    } else if (typeof(File) !== \\\"undefined\\\" && data instanceof File) {\\n      this._source = readAsync(data, type);\\n    } else if (_.isString(data)) {\\n      throw \\\"Creating a Parse.File from a String is not yet supported.\\\";\\n    }\\n  };\\n\\n  Parse.File.prototype = {\\n\\n    /**\\n     * Gets the name of the file. Before save is called, this is the filename\\n     * given by the user. After save is called, that name gets prefixed with a\\n     * unique identifier.\\n     */\\n    name: function() {\\n      return this._name;\\n    },\\n\\n    /**\\n     * Gets the url of the file. It is only available after you save the file or\\n     * after you get the file from a Parse.Object.\\n     * @return {String}\\n     */\\n    url: function() {\\n      return this._url;\\n    },\\n\\n    /**\\n     * Saves the file to the Parse cloud.\\n     * @param {Object} options A Backbone-style options object.\\n     * @return {Parse.Promise} Promise that is resolved when the save finishes.\\n     */\\n    save: function(options) {\\n      options= options || {};\\n\\n      var self = this;\\n      if (!self._previousSave) {\\n        self._previousSave = self._source.then(function(base64, type) {\\n          var data = {\\n            base64: base64,\\n            _ContentType: type\\n          };\\n          return Parse._request({\\n            route: \\\"files\\\",\\n            className: self._name,\\n            method: 'POST',\\n            data: data,\\n            useMasterKey: options.useMasterKey\\n          });\\n\\n        }).then(function(response) {\\n          self._name = response.name;\\n          self._url = response.url;\\n          return self;\\n        });\\n      }\\n      return self._previousSave._thenRunCallbacks(options);\\n    }\\n  };\\n\\n}(this));\\n\\n// Parse.Object is analogous to the Java ParseObject.\\n// It also implements the same interface as a Backbone model.\\n\\n(function(root) {\\n  root.Parse = root.Parse || {};\\n  var Parse = root.Parse;\\n  var _ = Parse._;\\n\\n  /**\\n   * Creates a new model with defined attributes. A client id (cid) is\\n   * automatically generated and assigned for you.\\n   *\\n   * <p>You won't normally call this method directly.  It is recommended that\\n   * you use a subclass of <code>Parse.Object</code> instead, created by calling\\n   * <code>extend</code>.</p>\\n   *\\n   * <p>However, if you don't want to use a subclass, or aren't sure which\\n   * subclass is appropriate, you can use this form:<pre>\\n   *     var object = new Parse.Object(\\\"ClassName\\\");\\n   * </pre>\\n   * That is basically equivalent to:<pre>\\n   *     var MyClass = Parse.Object.extend(\\\"ClassName\\\");\\n   *     var object = new MyClass();\\n   * </pre></p>\\n   *\\n   * @param {Object} attributes The initial set of data to store in the object.\\n   * @param {Object} options A set of Backbone-like options for creating the\\n   *     object.  The only option currently supported is \\\"collection\\\".\\n   * @see Parse.Object.extend\\n   *\\n   * @class\\n   *\\n   * <p>The fundamental unit of Parse data, which implements the Backbone Model\\n   * interface.</p>\\n   */\\n  Parse.Object = function(attributes, options) {\\n    // Allow new Parse.Object(\\\"ClassName\\\") as a shortcut to _create.\\n    if (_.isString(attributes)) {\\n      return Parse.Object._create.apply(this, arguments);\\n    }\\n\\n    attributes = attributes || {};\\n    if (options && options.parse) {\\n      attributes = this.parse(attributes);\\n    }\\n    var defaults = Parse._getValue(this, 'defaults');\\n    if (defaults) {\\n      attributes = _.extend({}, defaults, attributes);\\n    }\\n    if (options && options.collection) {\\n      this.collection = options.collection;\\n    }\\n\\n    this._serverData = {};  // The last known data for this object from cloud.\\n    this._opSetQueue = [{}];  // List of sets of changes to the data.\\n    this.attributes = {};  // The best estimate of this's current data.\\n\\n    this._hashedJSON = {};  // Hash of values of containers at last save.\\n    this._escapedAttributes = {};\\n    this.cid = _.uniqueId('c');\\n    this.changed = {};\\n    this._silent = {};\\n    this._pending = {};\\n    if (!this.set(attributes, {silent: true})) {\\n      throw new Error(\\\"Can't create an invalid Parse.Object\\\");\\n    }\\n    this.changed = {};\\n    this._silent = {};\\n    this._pending = {};\\n    this._hasData = true;\\n    this._previousAttributes = _.clone(this.attributes);\\n    this.initialize.apply(this, arguments);\\n  };\\n\\n  /**\\n   * @lends Parse.Object.prototype\\n   * @property {String} id The objectId of the Parse Object.\\n   */\\n\\n  /**\\n   * Saves the given list of Parse.Object.\\n   * If any error is encountered, stops and calls the error handler.\\n   *\\n   * <pre>\\n   *   Parse.Object.saveAll([object1, object2, ...], {\\n   *     success: function(list) {\\n   *       // All the objects were saved.\\n   *     },\\n   *     error: function(error) {\\n   *       // An error occurred while saving one of the objects.\\n   *     },\\n   *   });\\n   * </pre>\\n   *\\n   * @param {Array} list A list of <code>Parse.Object</code>.\\n   * @param {Object} options A Backbone-style callback object.\\n   * Valid options are:<ul>\\n   *   <li>useMasterKey: In Cloud Code and Node only, causes the Master Key to\\n   *     be used for this request.\\n   * </ul>\\n   */\\n  Parse.Object.saveAll = function(list, options) {\\n    options = options || {};\\n    return Parse.Object._deepSaveAsync(list, {\\n      useMasterKey: options.useMasterKey\\n    })._thenRunCallbacks(options);\\n  };\\n\\n  /**\\n   * Destroy the given list of models on the server if it was already persisted.\\n   * Optimistically removes each model from its collection, if it has one.\\n   * If `wait: true` is passed, waits for the server to respond before removal.\\n   *\\n   * <p>Unlike saveAll, if an error occurs while deleting an individual model,\\n   * this method will continue trying to delete the rest of the models if\\n   * possible, except in the case of a fatal error like a connection error.\\n   *\\n   * <p>In particular, the Parse.Error object returned in the case of error may\\n   * be one of two types:\\n   *\\n   * <ul>\\n   *   <li>A Parse.Error.AGGREGATE_ERROR. This object's \\\"errors\\\" property is an\\n   *       array of other Parse.Error objects. Each error object in this array\\n   *       has an \\\"object\\\" property that references the object that could not be\\n   *       deleted (for instance, because that object could not be found).</li>\\n   *   <li>A non-aggregate Parse.Error. This indicates a serious error that\\n   *       caused the delete operation to be aborted partway through (for\\n   *       instance, a connection failure in the middle of the delete).</li>\\n   * </ul>\\n   *\\n   * <pre>\\n   *   Parse.Object.destroyAll([object1, object2, ...], {\\n   *     success: function() {\\n   *       // All the objects were deleted.\\n   *     },\\n   *     error: function(error) {\\n   *       // An error occurred while deleting one or more of the objects.\\n   *       // If this is an aggregate error, then we can inspect each error\\n   *       // object individually to determine the reason why a particular\\n   *       // object was not deleted.\\n   *       if (error.code == Parse.Error.AGGREGATE_ERROR) {\\n   *         for (var i = 0; i < error.errors.length; i++) {\\n   *           console.log(\\\"Couldn't delete \\\" + error.errors[i].object.id +\\n   *             \\\"due to \\\" + error.errors[i].message);\\n   *         }\\n   *       } else {\\n   *         console.log(\\\"Delete aborted because of \\\" + error.message);\\n   *       }\\n   *     },\\n   *   });\\n   * </pre>\\n   *\\n   * @param {Array} list A list of <code>Parse.Object</code>.\\n   * @param {Object} options A Backbone-style callback object.\\n   * Valid options are:<ul>\\n   *   <li>useMasterKey: In Cloud Code and Node only, causes the Master Key to\\n   *     be used for this request.\\n   * </ul>\\n   */\\n  Parse.Object.destroyAll = function(list, options) {\\n    options = options || {};\\n\\n    var triggerDestroy = function(object) {\\n      object.trigger('destroy', object, object.collection, options);\\n    };\\n\\n    var errors = [];\\n    var destroyBatch = function(batch) {\\n      var promise = Parse.Promise.as();\\n\\n      if (batch.length > 0) {\\n        promise = promise.then(function() {\\n          return Parse._request({\\n            route: \\\"batch\\\",\\n            method: \\\"POST\\\",\\n            useMasterKey: options.useMasterKey,\\n            data: {\\n              requests: _.map(batch, function(object) {\\n                return {\\n                  method: \\\"DELETE\\\",\\n                  path: \\\"/1/classes/\\\" + object.className + \\\"/\\\" + object.id\\n                };\\n              })\\n            }\\n          });\\n        }).then(function(responses, status, xhr) {\\n          Parse._arrayEach(batch, function(object, i) {\\n            if (responses[i].success && options.wait) {\\n              triggerDestroy(object);\\n            } else if (responses[i].error) {\\n              var error = new Parse.Error(responses[i].error.code,\\n                                          responses[i].error.error);\\n              error.object = object;\\n\\n              errors.push(error);\\n            }\\n          });\\n        });\\n      }\\n\\n      return promise;\\n    };\\n\\n    var promise = Parse.Promise.as();\\n    var batch = [];\\n    Parse._arrayEach(list, function(object, i) {\\n      if (!object.id || !options.wait) {\\n        triggerDestroy(object);\\n      }\\n\\n      if (object.id) {\\n        batch.push(object);\\n      }\\n\\n      if (batch.length === 20 || i+1 === list.length) {\\n        var thisBatch = batch;\\n        batch = [];\\n\\n        promise = promise.then(function() {\\n          return destroyBatch(thisBatch);\\n        });\\n      }\\n    });\\n\\n    return promise.then(function() {\\n      if (errors.length === 0) {\\n        return true;\\n      } else {\\n        var error = new Parse.Error(Parse.Error.AGGREGATE_ERROR,\\n                                    \\\"Error deleting an object in destroyAll\\\");\\n        error.errors = errors;\\n\\n        return Parse.Promise.error(error);\\n      }\\n    })._thenRunCallbacks(options);\\n  };\\n\\n  /**\\n   * Fetches the given list of Parse.Object.\\n   * If any error is encountered, stops and calls the error handler.\\n   *\\n   * <pre>\\n   *   Parse.Object.fetchAll([object1, object2, ...], {\\n   *     success: function(list) {\\n   *       // All the objects were fetched.\\n   *     },\\n   *     error: function(error) {\\n   *       // An error occurred while fetching one of the objects.\\n   *     },\\n   *   });\\n   * </pre>\\n   *\\n   * @param {Array} list A list of <code>Parse.Object</code>.\\n   * @param {Object} options A Backbone-style callback object.\\n   * Valid options are:<ul>\\n   *   <li>success: A Backbone-style success callback.\\n   *   <li>error: An Backbone-style error callback.\\n   * </ul>\\n   */\\n  Parse.Object.fetchAll = function(list, options) {\\n    return Parse.Object._fetchAll(\\n      list,\\n      true\\n    )._thenRunCallbacks(options);\\n  };\\n\\n  /**\\n   * Fetches the given list of Parse.Object if needed.\\n   * If any error is encountered, stops and calls the error handler.\\n   *\\n   * <pre>\\n   *   Parse.Object.fetchAllIfNeeded([object1, ...], {\\n   *     success: function(list) {\\n   *       // Objects were fetched and updated.\\n   *     },\\n   *     error: function(error) {\\n   *       // An error occurred while fetching one of the objects.\\n   *     },\\n   *   });\\n   * </pre>\\n   *\\n   * @param {Array} list A list of <code>Parse.Object</code>.\\n   * @param {Object} options A Backbone-style callback object.\\n   * Valid options are:<ul>\\n   *   <li>success: A Backbone-style success callback.\\n   *   <li>error: An Backbone-style error callback.\\n   * </ul>\\n   */\\n  Parse.Object.fetchAllIfNeeded = function(list, options) {\\n    return Parse.Object._fetchAll(\\n      list,\\n      false\\n    )._thenRunCallbacks(options);\\n  };\\n\\n  // Attach all inheritable methods to the Parse.Object prototype.\\n  _.extend(Parse.Object.prototype, Parse.Events,\\n           /** @lends Parse.Object.prototype */ {\\n    _existed: false,\\n\\n    /**\\n     * Initialize is an empty function by default. Override it with your own\\n     * initialization logic.\\n     */\\n    initialize: function(){},\\n\\n    /**\\n     * Returns a JSON version of the object suitable for saving to Parse.\\n     * @return {Object}\\n     */\\n    toJSON: function() {\\n      var json = this._toFullJSON();\\n      Parse._arrayEach([\\\"__type\\\", \\\"className\\\"],\\n                       function(key) { delete json[key]; });\\n      return json;\\n    },\\n\\n    _toFullJSON: function(seenObjects) {\\n      var json = _.clone(this.attributes);\\n      Parse._objectEach(json, function(val, key) {\\n        json[key] = Parse._encode(val, seenObjects);\\n      });\\n      Parse._objectEach(this._operations, function(val, key) {\\n        json[key] = val;\\n      });\\n\\n      if (_.has(this, \\\"id\\\")) {\\n        json.objectId = this.id;\\n      }\\n      if (_.has(this, \\\"createdAt\\\")) {\\n        if (_.isDate(this.createdAt)) {\\n          json.createdAt = this.createdAt.toJSON();\\n        } else {\\n          json.createdAt = this.createdAt;\\n        }\\n      }\\n\\n      if (_.has(this, \\\"updatedAt\\\")) {\\n        if (_.isDate(this.updatedAt)) {\\n          json.updatedAt = this.updatedAt.toJSON();\\n        } else {\\n          json.updatedAt = this.updatedAt;\\n        }\\n      }\\n      json.__type = \\\"Object\\\";\\n      json.className = this.className;\\n      return json;\\n    },\\n\\n    /**\\n     * Updates _hashedJSON to reflect the current state of this object.\\n     * Adds any changed hash values to the set of pending changes.\\n     */\\n    _refreshCache: function() {\\n      var self = this;\\n      if (self._refreshingCache) {\\n        return;\\n      }\\n      self._refreshingCache = true;\\n      Parse._objectEach(this.attributes, function(value, key) {\\n        if (value instanceof Parse.Object) {\\n          value._refreshCache();\\n        } else if (_.isObject(value)) {\\n          if (self._resetCacheForKey(key)) {\\n            self.set(key, new Parse.Op.Set(value), { silent: true });\\n          }\\n        }\\n      });\\n      delete self._refreshingCache;\\n    },\\n\\n    /**\\n     * Returns true if this object has been modified since its last\\n     * save/refresh.  If an attribute is specified, it returns true only if that\\n     * particular attribute has been modified since the last save/refresh.\\n     * @param {String} attr An attribute name (optional).\\n     * @return {Boolean}\\n     */\\n    dirty: function(attr) {\\n      this._refreshCache();\\n\\n      var currentChanges = _.last(this._opSetQueue);\\n\\n      if (attr) {\\n        return (currentChanges[attr] ? true : false);\\n      }\\n      if (!this.id) {\\n        return true;\\n      }\\n      if (_.keys(currentChanges).length > 0) {\\n        return true;\\n      }\\n      return false;\\n    },\\n\\n    /**\\n     * Returns an array of keys that have been modified since last save/refresh\\n     * @return {Array of string}\\n     */\\n    dirtyKeys: function() {\\n      return _.keys(_.last(this._opSetQueue));\\n    },\\n\\n    /**\\n     * Gets a Pointer referencing this Object.\\n     */\\n    _toPointer: function() {\\n      if (!this.id) {\\n        throw new Error(\\\"Can't serialize an unsaved Parse.Object\\\");\\n      }\\n      return { __type: \\\"Pointer\\\",\\n               className: this.className,\\n               objectId: this.id };\\n    },\\n\\n    /**\\n     * Gets the value of an attribute.\\n     * @param {String} attr The string name of an attribute.\\n     */\\n    get: function(attr) {\\n      return this.attributes[attr];\\n    },\\n\\n    /**\\n     * Gets a relation on the given class for the attribute.\\n     * @param String attr The attribute to get the relation for.\\n     */\\n    relation: function(attr) {\\n      var value = this.get(attr);\\n      if (value) {\\n        if (!(value instanceof Parse.Relation)) {\\n          throw \\\"Called relation() on non-relation field \\\" + attr;\\n        }\\n        value._ensureParentAndKey(this, attr);\\n        return value;\\n      } else {\\n        return new Parse.Relation(this, attr);\\n      }\\n    },\\n\\n    /**\\n     * Gets the HTML-escaped value of an attribute.\\n     */\\n    escape: function(attr) {\\n      var html = this._escapedAttributes[attr];\\n      if (html) {\\n        return html;\\n      }\\n      var val = this.attributes[attr];\\n      var escaped;\\n      if (Parse._isNullOrUndefined(val)) {\\n        escaped = '';\\n      } else {\\n        escaped = _.escape(val.toString());\\n      }\\n      this._escapedAttributes[attr] = escaped;\\n      return escaped;\\n    },\\n\\n    /**\\n     * Returns <code>true</code> if the attribute contains a value that is not\\n     * null or undefined.\\n     * @param {String} attr The string name of the attribute.\\n     * @return {Boolean}\\n     */\\n    has: function(attr) {\\n      return !Parse._isNullOrUndefined(this.attributes[attr]);\\n    },\\n\\n    /**\\n     * Pulls \\\"special\\\" fields like objectId, createdAt, etc. out of attrs\\n     * and puts them on \\\"this\\\" directly.  Removes them from attrs.\\n     * @param attrs - A dictionary with the data for this Parse.Object.\\n     */\\n    _mergeMagicFields: function(attrs) {\\n      // Check for changes of magic fields.\\n      var model = this;\\n      var specialFields = [\\\"id\\\", \\\"objectId\\\", \\\"createdAt\\\", \\\"updatedAt\\\"];\\n      Parse._arrayEach(specialFields, function(attr) {\\n        if (attrs[attr]) {\\n          if (attr === \\\"objectId\\\") {\\n            model.id = attrs[attr];\\n          } else if ((attr === \\\"createdAt\\\" || attr === \\\"updatedAt\\\") &&\\n                     !_.isDate(attrs[attr])) {\\n            model[attr] = Parse._parseDate(attrs[attr]);\\n          } else {\\n            model[attr] = attrs[attr];\\n          }\\n          delete attrs[attr];\\n        }\\n      });\\n    },\\n\\n    /**\\n     * Copies the given serverData to \\\"this\\\", refreshes attributes, and\\n     * clears pending changes;\\n     */\\n    _copyServerData: function(serverData) {\\n      // Copy server data\\n      var tempServerData = {};\\n      Parse._objectEach(serverData, function(value, key) {\\n        tempServerData[key] = Parse._decode(key, value);\\n      });\\n      this._serverData = tempServerData;\\n\\n      // Refresh the attributes.\\n      this._rebuildAllEstimatedData();\\n\\n\\n      // Clear out any changes the user might have made previously.\\n      this._refreshCache();\\n      this._opSetQueue = [{}];\\n\\n      // Refresh the attributes again.\\n      this._rebuildAllEstimatedData();\\n    },\\n\\n    /**\\n     * Merges another object's attributes into this object.\\n     */\\n    _mergeFromObject: function(other) {\\n      if (!other) {\\n        return;\\n      }\\n\\n      // This does the inverse of _mergeMagicFields.\\n      this.id = other.id;\\n      this.createdAt = other.createdAt;\\n      this.updatedAt = other.updatedAt;\\n\\n      this._copyServerData(other._serverData);\\n\\n      this._hasData = true;\\n    },\\n\\n    /**\\n     * Returns the json to be sent to the server.\\n     */\\n    _startSave: function() {\\n      this._opSetQueue.push({});\\n    },\\n\\n    /**\\n     * Called when a save fails because of an error. Any changes that were part\\n     * of the save need to be merged with changes made after the save. This\\n     * might throw an exception is you do conflicting operations. For example,\\n     * if you do:\\n     *   object.set(\\\"foo\\\", \\\"bar\\\");\\n     *   object.set(\\\"invalid field name\\\", \\\"baz\\\");\\n     *   object.save();\\n     *   object.increment(\\\"foo\\\");\\n     * then this will throw when the save fails and the client tries to merge\\n     * \\\"bar\\\" with the +1.\\n     */\\n    _cancelSave: function() {\\n      var self = this;\\n      var failedChanges = _.first(this._opSetQueue);\\n      this._opSetQueue = _.rest(this._opSetQueue);\\n      var nextChanges = _.first(this._opSetQueue);\\n      Parse._objectEach(failedChanges, function(op, key) {\\n        var op1 = failedChanges[key];\\n        var op2 = nextChanges[key];\\n        if (op1 && op2) {\\n          nextChanges[key] = op2._mergeWithPrevious(op1);\\n        } else if (op1) {\\n          nextChanges[key] = op1;\\n        }\\n      });\\n      this._saving = this._saving - 1;\\n    },\\n\\n    /**\\n     * Called when a save completes successfully. This merges the changes that\\n     * were saved into the known server data, and overrides it with any data\\n     * sent directly from the server.\\n     */\\n    _finishSave: function(serverData) {\\n      // Grab a copy of any object referenced by this object. These instances\\n      // may have already been fetched, and we don't want to lose their data.\\n      // Note that doing it like this means we will unify separate copies of the\\n      // same object, but that's a risk we have to take.\\n      var fetchedObjects = {};\\n      Parse._traverse(this.attributes, function(object) {\\n        if (object instanceof Parse.Object && object.id && object._hasData) {\\n          fetchedObjects[object.id] = object;\\n        }\\n      });\\n\\n      var savedChanges = _.first(this._opSetQueue);\\n      this._opSetQueue = _.rest(this._opSetQueue);\\n      this._applyOpSet(savedChanges, this._serverData);\\n      this._mergeMagicFields(serverData);\\n      var self = this;\\n      Parse._objectEach(serverData, function(value, key) {\\n        self._serverData[key] = Parse._decode(key, value);\\n\\n        // Look for any objects that might have become unfetched and fix them\\n        // by replacing their values with the previously observed values.\\n        var fetched = Parse._traverse(self._serverData[key], function(object) {\\n          if (object instanceof Parse.Object && fetchedObjects[object.id]) {\\n            return fetchedObjects[object.id];\\n          }\\n        });\\n        if (fetched) {\\n          self._serverData[key] = fetched;\\n        }\\n      });\\n      this._rebuildAllEstimatedData();\\n      this._saving = this._saving - 1;\\n    },\\n\\n    /**\\n     * Called when a fetch or login is complete to set the known server data to\\n     * the given object.\\n     */\\n    _finishFetch: function(serverData, hasData) {\\n\\n      this._opSetQueue = [{}];\\n\\n      // Bring in all the new server data.\\n      this._mergeMagicFields(serverData);\\n      this._copyServerData(serverData);\\n\\n      this._hasData = hasData;\\n    },\\n\\n    /**\\n     * Applies the set of Parse.Op in opSet to the object target.\\n     */\\n    _applyOpSet: function(opSet, target) {\\n      var self = this;\\n      Parse._objectEach(opSet, function(change, key) {\\n        target[key] = change._estimate(target[key], self, key);\\n        if (target[key] === Parse.Op._UNSET) {\\n          delete target[key];\\n        }\\n      });\\n    },\\n\\n    /**\\n     * Replaces the cached value for key with the current value.\\n     * Returns true if the new value is different than the old value.\\n     */\\n    _resetCacheForKey: function(key) {\\n      var value = this.attributes[key];\\n      if (_.isObject(value) &&\\n          !(value instanceof Parse.Object) &&\\n          !(value instanceof Parse.File)) {\\n        value = value.toJSON ? value.toJSON() : value;\\n        var json = JSON.stringify(value);\\n        if (this._hashedJSON[key] !== json) {\\n          this._hashedJSON[key] = json;\\n          return true;\\n        }\\n      }\\n      return false;\\n    },\\n\\n    /**\\n     * Populates attributes[key] by starting with the last known data from the\\n     * server, and applying all of the local changes that have been made to that\\n     * key since then.\\n     */\\n    _rebuildEstimatedDataForKey: function(key) {\\n      var self = this;\\n      delete this.attributes[key];\\n      if (this._serverData[key]) {\\n        this.attributes[key] = this._serverData[key];\\n      }\\n      Parse._arrayEach(this._opSetQueue, function(opSet) {\\n        var op = opSet[key];\\n        if (op) {\\n          self.attributes[key] = op._estimate(self.attributes[key], self, key);\\n          if (self.attributes[key] === Parse.Op._UNSET) {\\n            delete self.attributes[key];\\n          } else {\\n            self._resetCacheForKey(key);\\n          }\\n        }\\n      });\\n    },\\n\\n    /**\\n     * Populates attributes by starting with the last known data from the\\n     * server, and applying all of the local changes that have been made since\\n     * then.\\n     */\\n    _rebuildAllEstimatedData: function() {\\n      var self = this;\\n\\n      var previousAttributes = _.clone(this.attributes);\\n\\n      this.attributes = _.clone(this._serverData);\\n      Parse._arrayEach(this._opSetQueue, function(opSet) {\\n        self._applyOpSet(opSet, self.attributes);\\n        Parse._objectEach(opSet, function(op, key) {\\n          self._resetCacheForKey(key);\\n        });\\n      });\\n\\n      // Trigger change events for anything that changed because of the fetch.\\n      Parse._objectEach(previousAttributes, function(oldValue, key) {\\n        if (self.attributes[key] !== oldValue) {\\n          self.trigger('change:' + key, self, self.attributes[key], {});\\n        }\\n      });\\n      Parse._objectEach(this.attributes, function(newValue, key) {\\n        if (!_.has(previousAttributes, key)) {\\n          self.trigger('change:' + key, self, newValue, {});\\n        }\\n      });\\n    },\\n\\n    /**\\n     * Sets a hash of model attributes on the object, firing\\n     * <code>\\\"change\\\"</code> unless you choose to silence it.\\n     *\\n     * <p>You can call it with an object containing keys and values, or with one\\n     * key and value.  For example:<pre>\\n     *   gameTurn.set({\\n     *     player: player1,\\n     *     diceRoll: 2\\n     *   }, {\\n     *     error: function(gameTurnAgain, error) {\\n     *       // The set failed validation.\\n     *     }\\n     *   });\\n     *\\n     *   game.set(\\\"currentPlayer\\\", player2, {\\n     *     error: function(gameTurnAgain, error) {\\n     *       // The set failed validation.\\n     *     }\\n     *   });\\n     *\\n     *   game.set(\\\"finished\\\", true);</pre></p>\\n     *\\n     * @param {String} key The key to set.\\n     * @param {} value The value to give it.\\n     * @param {Object} options A set of Backbone-like options for the set.\\n     *     The only supported options are <code>silent</code>,\\n     *     <code>error</code>, and <code>promise</code>.\\n     * @return {Boolean} true if the set succeeded.\\n     * @see Parse.Object#validate\\n     * @see Parse.Error\\n     */\\n    set: function(key, value, options) {\\n      var attrs, attr;\\n      if (_.isObject(key) || Parse._isNullOrUndefined(key)) {\\n        attrs = key;\\n        Parse._objectEach(attrs, function(v, k) {\\n          attrs[k] = Parse._decode(k, v);\\n        });\\n        options = value;\\n      } else {\\n        attrs = {};\\n        attrs[key] = Parse._decode(key, value);\\n      }\\n\\n      // Extract attributes and options.\\n      options = options || {};\\n      if (!attrs) {\\n        return this;\\n      }\\n      if (attrs instanceof Parse.Object) {\\n        attrs = attrs.attributes;\\n      }\\n\\n      // If the unset option is used, every attribute should be a Unset.\\n      if (options.unset) {\\n        Parse._objectEach(attrs, function(unused_value, key) {\\n          attrs[key] = new Parse.Op.Unset();\\n        });\\n      }\\n\\n      // Apply all the attributes to get the estimated values.\\n      var dataToValidate = _.clone(attrs);\\n      var self = this;\\n      Parse._objectEach(dataToValidate, function(value, key) {\\n        if (value instanceof Parse.Op) {\\n          dataToValidate[key] = value._estimate(self.attributes[key],\\n                                                self, key);\\n          if (dataToValidate[key] === Parse.Op._UNSET) {\\n            delete dataToValidate[key];\\n          }\\n        }\\n      });\\n\\n      // Run validation.\\n      if (!this._validate(attrs, options)) {\\n        return false;\\n      }\\n\\n      this._mergeMagicFields(attrs);\\n\\n      options.changes = {};\\n      var escaped = this._escapedAttributes;\\n      var prev = this._previousAttributes || {};\\n\\n      // Update attributes.\\n      Parse._arrayEach(_.keys(attrs), function(attr) {\\n        var val = attrs[attr];\\n\\n        // If this is a relation object we need to set the parent correctly,\\n        // since the location where it was parsed does not have access to\\n        // this object.\\n        if (val instanceof Parse.Relation) {\\n          val.parent = self;\\n        }\\n\\n        if (!(val instanceof Parse.Op)) {\\n          val = new Parse.Op.Set(val);\\n        }\\n\\n        // See if this change will actually have any effect.\\n        var isRealChange = true;\\n        if (val instanceof Parse.Op.Set &&\\n            _.isEqual(self.attributes[attr], val.value)) {\\n          isRealChange = false;\\n        }\\n\\n        if (isRealChange) {\\n          delete escaped[attr];\\n          if (options.silent) {\\n            self._silent[attr] = true;\\n          } else {\\n            options.changes[attr] = true;\\n          }\\n        }\\n\\n        var currentChanges = _.last(self._opSetQueue);\\n        currentChanges[attr] = val._mergeWithPrevious(currentChanges[attr]);\\n        self._rebuildEstimatedDataForKey(attr);\\n\\n        if (isRealChange) {\\n          self.changed[attr] = self.attributes[attr];\\n          if (!options.silent) {\\n            self._pending[attr] = true;\\n          }\\n        } else {\\n          delete self.changed[attr];\\n          delete self._pending[attr];\\n        }\\n      });\\n\\n      if (!options.silent) {\\n        this.change(options);\\n      }\\n      return this;\\n    },\\n\\n    /**\\n     * Remove an attribute from the model, firing <code>\\\"change\\\"</code> unless\\n     * you choose to silence it. This is a noop if the attribute doesn't\\n     * exist.\\n     */\\n    unset: function(attr, options) {\\n      options = options || {};\\n      options.unset = true;\\n      return this.set(attr, null, options);\\n    },\\n\\n    /**\\n     * Atomically increments the value of the given attribute the next time the\\n     * object is saved. If no amount is specified, 1 is used by default.\\n     *\\n     * @param attr {String} The key.\\n     * @param amount {Number} The amount to increment by.\\n     */\\n    increment: function(attr, amount) {\\n      if (_.isUndefined(amount) || _.isNull(amount)) {\\n        amount = 1;\\n      }\\n      return this.set(attr, new Parse.Op.Increment(amount));\\n    },\\n\\n    /**\\n     * Atomically add an object to the end of the array associated with a given\\n     * key.\\n     * @param attr {String} The key.\\n     * @param item {} The item to add.\\n     */\\n    add: function(attr, item) {\\n      return this.set(attr, new Parse.Op.Add([item]));\\n    },\\n\\n    /**\\n     * Atomically add an object to the array associated with a given key, only\\n     * if it is not already present in the array. The position of the insert is\\n     * not guaranteed.\\n     *\\n     * @param attr {String} The key.\\n     * @param item {} The object to add.\\n     */\\n    addUnique: function(attr, item) {\\n      return this.set(attr, new Parse.Op.AddUnique([item]));\\n    },\\n\\n    /**\\n     * Atomically remove all instances of an object from the array associated\\n     * with a given key.\\n     *\\n     * @param attr {String} The key.\\n     * @param item {} The object to remove.\\n     */\\n    remove: function(attr, item) {\\n      return this.set(attr, new Parse.Op.Remove([item]));\\n    },\\n\\n    /**\\n     * Returns an instance of a subclass of Parse.Op describing what kind of\\n     * modification has been performed on this field since the last time it was\\n     * saved. For example, after calling object.increment(\\\"x\\\"), calling\\n     * object.op(\\\"x\\\") would return an instance of Parse.Op.Increment.\\n     *\\n     * @param attr {String} The key.\\n     * @returns {Parse.Op} The operation, or undefined if none.\\n     */\\n    op: function(attr) {\\n      return _.last(this._opSetQueue)[attr];\\n    },\\n\\n    /**\\n     * Clear all attributes on the model, firing <code>\\\"change\\\"</code> unless\\n     * you choose to silence it.\\n     */\\n    clear: function(options) {\\n      options = options || {};\\n      options.unset = true;\\n      var keysToClear = _.extend(this.attributes, this._operations);\\n      return this.set(keysToClear, options);\\n    },\\n\\n    /**\\n     * Returns a JSON-encoded set of operations to be sent with the next save\\n     * request.\\n     */\\n    _getSaveJSON: function() {\\n      var json = _.clone(_.first(this._opSetQueue));\\n      Parse._objectEach(json, function(op, key) {\\n        json[key] = op.toJSON();\\n      });\\n      return json;\\n    },\\n\\n    /**\\n     * Returns true if this object can be serialized for saving.\\n     */\\n    _canBeSerialized: function() {\\n      return Parse.Object._canBeSerializedAsValue(this.attributes);\\n    },\\n\\n    /**\\n     * Fetch the model from the server. If the server's representation of the\\n     * model differs from its current attributes, they will be overriden,\\n     * triggering a <code>\\\"change\\\"</code> event.\\n     *\\n     * @param {Object} options A Backbone-style callback object.\\n     * Valid options are:<ul>\\n     *   <li>success: A Backbone-style success callback.\\n     *   <li>error: An Backbone-style error callback.\\n     *   <li>useMasterKey: In Cloud Code and Node only, causes the Master Key to\\n     *     be used for this request.\\n     * </ul>\\n     * @return {Parse.Promise} A promise that is fulfilled when the fetch\\n     *     completes.\\n     */\\n    fetch: function(options) {\\n      var self = this;\\n      options = options || {};\\n      var request = Parse._request({\\n        method: 'GET',\\n        route: \\\"classes\\\",\\n        className: this.className,\\n        objectId: this.id,\\n        useMasterKey: options.useMasterKey\\n      });\\n      return request.then(function(response, status, xhr) {\\n        self._finishFetch(self.parse(response, status, xhr), true);\\n        return self;\\n      })._thenRunCallbacks(options, this);\\n    },\\n\\n    /**\\n     * Set a hash of model attributes, and save the model to the server.\\n     * updatedAt will be updated when the request returns.\\n     * You can either call it as:<pre>\\n     *   object.save();</pre>\\n     * or<pre>\\n     *   object.save(null, options);</pre>\\n     * or<pre>\\n     *   object.save(attrs, options);</pre>\\n     * or<pre>\\n     *   object.save(key, value, options);</pre>\\n     *\\n     * For example, <pre>\\n     *   gameTurn.save({\\n     *     player: \\\"Jake Cutter\\\",\\n     *     diceRoll: 2\\n     *   }, {\\n     *     success: function(gameTurnAgain) {\\n     *       // The save was successful.\\n     *     },\\n     *     error: function(gameTurnAgain, error) {\\n     *       // The save failed.  Error is an instance of Parse.Error.\\n     *     }\\n     *   });</pre>\\n     * or with promises:<pre>\\n     *   gameTurn.save({\\n     *     player: \\\"Jake Cutter\\\",\\n     *     diceRoll: 2\\n     *   }).then(function(gameTurnAgain) {\\n     *     // The save was successful.\\n     *   }, function(error) {\\n     *     // The save failed.  Error is an instance of Parse.Error.\\n     *   });</pre>\\n     *\\n     * @param {Object} options A Backbone-style callback object.\\n     * Valid options are:<ul>\\n     *   <li>wait: Set to true to wait for the server to confirm a successful\\n     *   save before modifying the attributes on the object.\\n     *   <li>silent: Set to true to avoid firing the `set` event.\\n     *   <li>success: A Backbone-style success callback.\\n     *   <li>error: An Backbone-style error callback.\\n     *   <li>useMasterKey: In Cloud Code and Node only, causes the Master Key to\\n     *     be used for this request.\\n     * </ul>\\n     * @return {Parse.Promise} A promise that is fulfilled when the save\\n     *     completes.\\n     * @see Parse.Error\\n     */\\n    save: function(arg1, arg2, arg3) {\\n      var i, attrs, current, options, saved;\\n      if (_.isObject(arg1) || Parse._isNullOrUndefined(arg1)) {\\n        attrs = arg1;\\n        options = arg2;\\n      } else {\\n        attrs = {};\\n        attrs[arg1] = arg2;\\n        options = arg3;\\n      }\\n\\n      // Make save({ success: function() {} }) work.\\n      if (!options && attrs) {\\n        var extra_keys = _.reject(attrs, function(value, key) {\\n          return _.include([\\\"success\\\", \\\"error\\\", \\\"wait\\\"], key);\\n        });\\n        if (extra_keys.length === 0) {\\n          var all_functions = true;\\n          if (_.has(attrs, \\\"success\\\") && !_.isFunction(attrs.success)) {\\n            all_functions = false;\\n          }\\n          if (_.has(attrs, \\\"error\\\") && !_.isFunction(attrs.error)) {\\n            all_functions = false;\\n          }\\n          if (all_functions) {\\n            // This attrs object looks like it's really an options object,\\n            // and there's no other options object, so let's just use it.\\n            return this.save(null, attrs);\\n          }\\n        }\\n      }\\n\\n      options = _.clone(options) || {};\\n      if (options.wait) {\\n        current = _.clone(this.attributes);\\n      }\\n\\n      var setOptions = _.clone(options) || {};\\n      if (setOptions.wait) {\\n        setOptions.silent = true;\\n      }\\n      var setError;\\n      setOptions.error = function(model, error) {\\n        setError = error;\\n      };\\n      if (attrs && !this.set(attrs, setOptions)) {\\n        return Parse.Promise.error(setError)._thenRunCallbacks(options, this);\\n      }\\n\\n      var model = this;\\n\\n      // If there is any unsaved child, save it first.\\n      model._refreshCache();\\n\\n\\n\\n      var unsavedChildren = [];\\n      var unsavedFiles = [];\\n      Parse.Object._findUnsavedChildren(model.attributes,\\n                                        unsavedChildren,\\n                                        unsavedFiles);\\n      if (unsavedChildren.length + unsavedFiles.length > 0) {\\n        return Parse.Object._deepSaveAsync(this.attributes, {\\n          useMasterKey: options.useMasterKey\\n        }).then(function() {\\n          return model.save(null, options);\\n        }, function(error) {\\n          return Parse.Promise.error(error)._thenRunCallbacks(options, model);\\n        });\\n      }\\n\\n      this._startSave();\\n      this._saving = (this._saving || 0) + 1;\\n\\n      this._allPreviousSaves = this._allPreviousSaves || Parse.Promise.as();\\n      this._allPreviousSaves = this._allPreviousSaves._continueWith(function() {\\n        var method = model.id ? 'PUT' : 'POST';\\n\\n        var json = model._getSaveJSON();\\n\\n        var route = \\\"classes\\\";\\n        var className = model.className;\\n        if (model.className === \\\"_User\\\" && !model.id) {\\n          // Special-case user sign-up.\\n          route = \\\"users\\\";\\n          className = null;\\n        }\\n        var request = Parse._request({\\n          route: route,\\n          className: className,\\n          objectId: model.id,\\n          method: method,\\n          useMasterKey: options.useMasterKey,\\n          data: json\\n        });\\n\\n        request = request.then(function(resp, status, xhr) {\\n          var serverAttrs = model.parse(resp, status, xhr);\\n          if (options.wait) {\\n            serverAttrs = _.extend(attrs || {}, serverAttrs);\\n          }\\n          model._finishSave(serverAttrs);\\n          if (options.wait) {\\n            model.set(current, setOptions);\\n          }\\n          return model;\\n\\n        }, function(error) {\\n          model._cancelSave();\\n          return Parse.Promise.error(error);\\n\\n        })._thenRunCallbacks(options, model);\\n\\n        return request;\\n      });\\n      return this._allPreviousSaves;\\n    },\\n\\n    /**\\n     * Destroy this model on the server if it was already persisted.\\n     * Optimistically removes the model from its collection, if it has one.\\n     * If `wait: true` is passed, waits for the server to respond\\n     * before removal.\\n     *\\n     * @param {Object} options A Backbone-style callback object.\\n     * Valid options are:<ul>\\n     *   <li>wait: Set to true to wait for the server to confirm successful\\n     *   deletion of the object before triggering the `destroy` event.\\n     *   <li>success: A Backbone-style success callback\\n     *   <li>error: An Backbone-style error callback.\\n     *   <li>useMasterKey: In Cloud Code and Node only, causes the Master Key to\\n     *     be used for this request.\\n     * </ul>\\n     * @return {Parse.Promise} A promise that is fulfilled when the destroy\\n     *     completes.\\n     */\\n    destroy: function(options) {\\n      options = options || {};\\n      var model = this;\\n\\n      var triggerDestroy = function() {\\n        model.trigger('destroy', model, model.collection, options);\\n      };\\n\\n      if (!this.id) {\\n        return triggerDestroy();\\n      }\\n\\n      if (!options.wait) {\\n        triggerDestroy();\\n      }\\n\\n      var request = Parse._request({\\n        route: \\\"classes\\\",\\n        className: this.className,\\n        objectId: this.id,\\n        method: 'DELETE',\\n        useMasterKey: options.useMasterKey\\n      });\\n      return request.then(function() {\\n        if (options.wait) {\\n          triggerDestroy();\\n        }\\n        return model;\\n      })._thenRunCallbacks(options, this);\\n    },\\n\\n    /**\\n     * Converts a response into the hash of attributes to be set on the model.\\n     * @ignore\\n     */\\n    parse: function(resp, status, xhr) {\\n      var output = _.clone(resp);\\n      _([\\\"createdAt\\\", \\\"updatedAt\\\"]).each(function(key) {\\n        if (output[key]) {\\n          output[key] = Parse._parseDate(output[key]);\\n        }\\n      });\\n      if (!output.updatedAt) {\\n        output.updatedAt = output.createdAt;\\n      }\\n      if (status) {\\n        this._existed = (status !== 201);\\n      }\\n      return output;\\n    },\\n\\n    /**\\n     * Creates a new model with identical attributes to this one.\\n     * @return {Parse.Object}\\n     */\\n    clone: function() {\\n      return new this.constructor(this.attributes);\\n    },\\n\\n    /**\\n     * Returns true if this object has never been saved to Parse.\\n     * @return {Boolean}\\n     */\\n    isNew: function() {\\n      return !this.id;\\n    },\\n\\n    /**\\n     * Call this method to manually fire a `\\\"change\\\"` event for this model and\\n     * a `\\\"change:attribute\\\"` event for each changed attribute.\\n     * Calling this will cause all objects observing the model to update.\\n     */\\n    change: function(options) {\\n      options = options || {};\\n      var changing = this._changing;\\n      this._changing = true;\\n\\n      // Silent changes become pending changes.\\n      var self = this;\\n      Parse._objectEach(this._silent, function(attr) {\\n        self._pending[attr] = true;\\n      });\\n\\n      // Silent changes are triggered.\\n      var changes = _.extend({}, options.changes, this._silent);\\n      this._silent = {};\\n      Parse._objectEach(changes, function(unused_value, attr) {\\n        self.trigger('change:' + attr, self, self.get(attr), options);\\n      });\\n      if (changing) {\\n        return this;\\n      }\\n\\n      // This is to get around lint not letting us make a function in a loop.\\n      var deleteChanged = function(value, attr) {\\n        if (!self._pending[attr] && !self._silent[attr]) {\\n          delete self.changed[attr];\\n        }\\n      };\\n\\n      // Continue firing `\\\"change\\\"` events while there are pending changes.\\n      while (!_.isEmpty(this._pending)) {\\n        this._pending = {};\\n        this.trigger('change', this, options);\\n        // Pending and silent changes still remain.\\n        Parse._objectEach(this.changed, deleteChanged);\\n        self._previousAttributes = _.clone(this.attributes);\\n      }\\n\\n      this._changing = false;\\n      return this;\\n    },\\n\\n    /**\\n     * Returns true if this object was created by the Parse server when the\\n     * object might have already been there (e.g. in the case of a Facebook\\n     * login)\\n     */\\n    existed: function() {\\n      return this._existed;\\n    },\\n\\n    /**\\n     * Determine if the model has changed since the last <code>\\\"change\\\"</code>\\n     * event.  If you specify an attribute name, determine if that attribute\\n     * has changed.\\n     * @param {String} attr Optional attribute name\\n     * @return {Boolean}\\n     */\\n    hasChanged: function(attr) {\\n      if (!arguments.length) {\\n        return !_.isEmpty(this.changed);\\n      }\\n      return this.changed && _.has(this.changed, attr);\\n    },\\n\\n    /**\\n     * Returns an object containing all the attributes that have changed, or\\n     * false if there are no changed attributes. Useful for determining what\\n     * parts of a view need to be updated and/or what attributes need to be\\n     * persisted to the server. Unset attributes will be set to undefined.\\n     * You can also pass an attributes object to diff against the model,\\n     * determining if there *would be* a change.\\n     */\\n    changedAttributes: function(diff) {\\n      if (!diff) {\\n        return this.hasChanged() ? _.clone(this.changed) : false;\\n      }\\n      var changed = {};\\n      var old = this._previousAttributes;\\n      Parse._objectEach(diff, function(diffVal, attr) {\\n        if (!_.isEqual(old[attr], diffVal)) {\\n          changed[attr] = diffVal;\\n        }\\n      });\\n      return changed;\\n    },\\n\\n    /**\\n     * Gets the previous value of an attribute, recorded at the time the last\\n     * <code>\\\"change\\\"</code> event was fired.\\n     * @param {String} attr Name of the attribute to get.\\n     */\\n    previous: function(attr) {\\n      if (!arguments.length || !this._previousAttributes) {\\n        return null;\\n      }\\n      return this._previousAttributes[attr];\\n    },\\n\\n    /**\\n     * Gets all of the attributes of the model at the time of the previous\\n     * <code>\\\"change\\\"</code> event.\\n     * @return {Object}\\n     */\\n    previousAttributes: function() {\\n      return _.clone(this._previousAttributes);\\n    },\\n\\n    /**\\n     * Checks if the model is currently in a valid state. It's only possible to\\n     * get into an *invalid* state if you're using silent changes.\\n     * @return {Boolean}\\n     */\\n    isValid: function() {\\n      return !this.validate(this.attributes);\\n    },\\n\\n    /**\\n     * You should not call this function directly unless you subclass\\n     * <code>Parse.Object</code>, in which case you can override this method\\n     * to provide additional validation on <code>set</code> and\\n     * <code>save</code>.  Your implementation should return\\n     *\\n     * @param {Object} attrs The current data to validate.\\n     * @param {Object} options A Backbone-like options object.\\n     * @return {} False if the data is valid.  An error object otherwise.\\n     * @see Parse.Object#set\\n     */\\n    validate: function(attrs, options) {\\n      if (_.has(attrs, \\\"ACL\\\") && !(attrs.ACL instanceof Parse.ACL)) {\\n        return new Parse.Error(Parse.Error.OTHER_CAUSE,\\n                               \\\"ACL must be a Parse.ACL.\\\");\\n      }\\n      var correct = true;\\n      Parse._objectEach(attrs, function(unused_value, key) {\\n        if (!(/^[A-Za-z][0-9A-Za-z_]*$/).test(key)) {\\n          correct = false;\\n        }\\n      });\\n      if (!correct) {\\n        return new Parse.Error(Parse.Error.INVALID_KEY_NAME);\\n      }\\n      return false;\\n    },\\n\\n    /**\\n     * Run validation against a set of incoming attributes, returning `true`\\n     * if all is well. If a specific `error` callback has been passed,\\n     * call that instead of firing the general `\\\"error\\\"` event.\\n     */\\n    _validate: function(attrs, options) {\\n      if (options.silent || !this.validate) {\\n        return true;\\n      }\\n      attrs = _.extend({}, this.attributes, attrs);\\n      var error = this.validate(attrs, options);\\n      if (!error) {\\n        return true;\\n      }\\n      if (options && options.error) {\\n        options.error(this, error, options);\\n      } else {\\n        this.trigger('error', this, error, options);\\n      }\\n      return false;\\n    },\\n\\n    /**\\n     * Returns the ACL for this object.\\n     * @returns {Parse.ACL} An instance of Parse.ACL.\\n     * @see Parse.Object#get\\n     */\\n    getACL: function() {\\n      return this.get(\\\"ACL\\\");\\n    },\\n\\n    /**\\n     * Sets the ACL to be used for this object.\\n     * @param {Parse.ACL} acl An instance of Parse.ACL.\\n     * @param {Object} options Optional Backbone-like options object to be\\n     *     passed in to set.\\n     * @return {Boolean} Whether the set passed validation.\\n     * @see Parse.Object#set\\n     */\\n    setACL: function(acl, options) {\\n      return this.set(\\\"ACL\\\", acl, options);\\n    }\\n\\n  });\\n\\n  /**\\n   * Returns the appropriate subclass for making new instances of the given\\n   * className string.\\n   */\\n  Parse.Object._getSubclass = function(className) {\\n    if (!_.isString(className)) {\\n      throw \\\"Parse.Object._getSubclass requires a string argument.\\\";\\n    }\\n    var ObjectClass = Parse.Object._classMap[className];\\n    if (!ObjectClass) {\\n      ObjectClass = Parse.Object.extend(className);\\n      Parse.Object._classMap[className] = ObjectClass;\\n    }\\n    return ObjectClass;\\n  };\\n\\n  /**\\n   * Creates an instance of a subclass of Parse.Object for the given classname.\\n   */\\n  Parse.Object._create = function(className, attributes, options) {\\n    var ObjectClass = Parse.Object._getSubclass(className);\\n    return new ObjectClass(attributes, options);\\n  };\\n\\n  /**\\n   * Returns a list of object ids given a list of objects.\\n   */\\n  Parse.Object._toObjectIdArray = function(list, omitObjectsWithData) {\\n    if (list.length === 0) {\\n      return Parse.Promise.as(list);\\n    }\\n\\n    var error;\\n    var className = list[0].className;\\n    var objectIds = [];\\n    for (var i = 0; i < list.length; i++) {\\n      var object = list[i];\\n      if (className !== object.className) {\\n        error = new Parse.Error(Parse.Error.INVALID_CLASS_NAME,\\n                                \\\"All objects should be of the same class\\\");\\n        return Parse.Promise.error(error);\\n      } else if (!object.id) {\\n        error = new Parse.Error(Parse.Error.MISSING_OBJECT_ID,\\n                                \\\"All objects must have an ID\\\");\\n        return Parse.Promise.error(error);\\n      } else if (omitObjectsWithData && object._hasData) {\\n        continue;\\n      }\\n      objectIds.push(object.id);\\n    }\\n\\n    return Parse.Promise.as(objectIds);\\n  };\\n\\n  /**\\n   * Updates a list of objects with fetched results.\\n   */\\n  Parse.Object._updateWithFetchedResults = function(list, fetched, forceFetch) {\\n    var fetchedObjectsById = {};\\n    Parse._arrayEach(fetched, function(object, i) {\\n      fetchedObjectsById[object.id] = object;\\n    });\\n\\n    for (var i = 0; i < list.length; i++) {\\n      var object = list[i];\\n      var fetchedObject = fetchedObjectsById[object.id];\\n      if (!fetchedObject && forceFetch) {\\n        var error = new Parse.Error(Parse.Error.OBJECT_NOT_FOUND,\\n                                \\\"All objects must exist on the server\\\");\\n        return Parse.Promise.error(error);\\n      }\\n\\n      object._mergeFromObject(fetchedObject);\\n    }\\n\\n    return Parse.Promise.as(list);\\n  };\\n\\n  /**\\n   * Fetches the objects given in list.  The forceFetch option will fetch all\\n   * objects if true and ignore objects with data if false.\\n   */\\n  Parse.Object._fetchAll = function(list, forceFetch) {\\n    if (list.length === 0) {\\n      return Parse.Promise.as(list);\\n    }\\n\\n    var omitObjectsWithData = !forceFetch;\\n    return Parse.Object._toObjectIdArray(\\n      list,\\n      omitObjectsWithData\\n    ).then(function(objectIds) {\\n      var className = list[0].className;\\n      var query = new Parse.Query(className);\\n      query.containedIn(\\\"objectId\\\", objectIds);\\n      query.limit = objectIds.length;\\n      return query.find();\\n    }).then(function(results) {\\n      return Parse.Object._updateWithFetchedResults(\\n        list,\\n        results,\\n        forceFetch\\n      );\\n    });\\n  };\\n\\n  // Set up a map of className to class so that we can create new instances of\\n  // Parse Objects from JSON automatically.\\n  Parse.Object._classMap = {};\\n\\n  Parse.Object._extend = Parse._extend;\\n\\n  /**\\n   * Creates a new subclass of Parse.Object for the given Parse class name.\\n   *\\n   * <p>Every extension of a Parse class will inherit from the most recent\\n   * previous extension of that class. When a Parse.Object is automatically\\n   * created by parsing JSON, it will use the most recent extension of that\\n   * class.</p>\\n   *\\n   * <p>You should call either:<pre>\\n   *     var MyClass = Parse.Object.extend(\\\"MyClass\\\", {\\n   *         <i>Instance methods</i>,\\n   *         initialize: function(attrs, options) {\\n   *             this.someInstanceProperty = [],\\n   *             <i>Other instance properties</i>\\n   *         }\\n   *     }, {\\n   *         <i>Class properties</i>\\n   *     });</pre>\\n   * or, for Backbone compatibility:<pre>\\n   *     var MyClass = Parse.Object.extend({\\n   *         className: \\\"MyClass\\\",\\n   *         <i>Instance methods</i>,\\n   *         initialize: function(attrs, options) {\\n   *             this.someInstanceProperty = [],\\n   *             <i>Other instance properties</i>\\n   *         }\\n   *     }, {\\n   *         <i>Class properties</i>\\n   *     });</pre></p>\\n   *\\n   * @param {String} className The name of the Parse class backing this model.\\n   * @param {Object} protoProps Instance properties to add to instances of the\\n   *     class returned from this method.\\n   * @param {Object} classProps Class properties to add the class returned from\\n   *     this method.\\n   * @return {Class} A new subclass of Parse.Object.\\n   */\\n  Parse.Object.extend = function(className, protoProps, classProps) {\\n    // Handle the case with only two args.\\n    if (!_.isString(className)) {\\n      if (className && _.has(className, \\\"className\\\")) {\\n        return Parse.Object.extend(className.className, className, protoProps);\\n      } else {\\n        throw new Error(\\n            \\\"Parse.Object.extend's first argument should be the className.\\\");\\n      }\\n    }\\n\\n    // If someone tries to subclass \\\"User\\\", coerce it to the right type.\\n    if (className === \\\"User\\\" && Parse.User._performUserRewrite) {\\n      className = \\\"_User\\\";\\n    }\\n    protoProps = protoProps || {};\\n    protoProps.className = className;\\n\\n    var NewClassObject = null;\\n    if (_.has(Parse.Object._classMap, className)) {\\n      var OldClassObject = Parse.Object._classMap[className];\\n      // This new subclass has been told to extend both from \\\"this\\\" and from\\n      // OldClassObject. This is multiple inheritance, which isn't supported.\\n      // For now, let's just pick one.\\n      NewClassObject = OldClassObject._extend(protoProps, classProps);\\n    } else {\\n      NewClassObject = this._extend(protoProps, classProps);\\n    }\\n    // Extending a subclass should reuse the classname automatically.\\n    NewClassObject.extend = function(arg0) {\\n      if (_.isString(arg0) || (arg0 && _.has(arg0, \\\"className\\\"))) {\\n        return Parse.Object.extend.apply(NewClassObject, arguments);\\n      }\\n      var newArguments = [className].concat(Parse._.toArray(arguments));\\n      return Parse.Object.extend.apply(NewClassObject, newArguments);\\n    };\\n    Parse.Object._classMap[className] = NewClassObject;\\n    return NewClassObject;\\n  };\\n\\n  Parse.Object._findUnsavedChildren = function(object, children, files) {\\n    Parse._traverse(object, function(object) {\\n      if (object instanceof Parse.Object) {\\n        object._refreshCache();\\n        if (object.dirty()) {\\n          children.push(object);\\n        }\\n        return;\\n      }\\n\\n      if (object instanceof Parse.File) {\\n        if (!object.url()) {\\n          files.push(object);\\n        }\\n        return;\\n      }\\n    });\\n  };\\n\\n  Parse.Object._canBeSerializedAsValue = function(object) {\\n\\n    if (object instanceof Parse.Object) {\\n      return !!object.id;\\n    }\\n    if (object instanceof Parse.File) {\\n      // Don't recurse indefinitely into files.\\n      return true;\\n    }\\n\\n    var canBeSerializedAsValue = true;\\n\\n    if (_.isArray(object)) {\\n      Parse._arrayEach(object, function(child) {\\n        if (!Parse.Object._canBeSerializedAsValue(child)) {\\n          canBeSerializedAsValue = false;\\n        }\\n      });\\n    } else if (_.isObject(object)) {\\n      Parse._objectEach(object, function(child) {\\n        if (!Parse.Object._canBeSerializedAsValue(child)) {\\n          canBeSerializedAsValue = false;\\n        }\\n      });\\n    }\\n    return canBeSerializedAsValue;\\n  };\\n\\n  /**\\n   * @param {Object} object The root object.\\n   * @param {Object} options: The only valid option is useMasterKey.\\n   */\\n  Parse.Object._deepSaveAsync = function(object, options) {\\n    var unsavedChildren = [];\\n    var unsavedFiles = [];\\n    Parse.Object._findUnsavedChildren(object, unsavedChildren, unsavedFiles);\\n\\n    var promise = Parse.Promise.as();\\n    _.each(unsavedFiles, function(file) {\\n      promise = promise.then(function() {\\n        return file.save(options);\\n      });\\n    });\\n\\n    var objects = _.uniq(unsavedChildren);\\n    var remaining = _.uniq(objects);\\n\\n    return promise.then(function() {\\n      return Parse.Promise._continueWhile(function() {\\n        return remaining.length > 0;\\n      }, function() {\\n\\n        // Gather up all the objects that can be saved in this batch.\\n        var batch = [];\\n        var newRemaining = [];\\n        Parse._arrayEach(remaining, function(object) {\\n          // Limit batches to 20 objects.\\n          if (batch.length > 20) {\\n            newRemaining.push(object);\\n            return;\\n          }\\n\\n          if (object._canBeSerialized()) {\\n            batch.push(object);\\n          } else {\\n            newRemaining.push(object);\\n          }\\n        });\\n        remaining = newRemaining;\\n\\n        // If we can't save any objects, there must be a circular reference.\\n        if (batch.length === 0) {\\n          return Parse.Promise.error(\\n            new Parse.Error(Parse.Error.OTHER_CAUSE,\\n                            \\\"Tried to save a batch with a cycle.\\\"));\\n        }\\n\\n        // Reserve a spot in every object's save queue.\\n        var readyToStart = Parse.Promise.when(_.map(batch, function(object) {\\n          return object._allPreviousSaves || Parse.Promise.as();\\n        }));\\n        var batchFinished = new Parse.Promise();\\n        Parse._arrayEach(batch, function(object) {\\n          object._allPreviousSaves = batchFinished;\\n        });\\n\\n        // Save a single batch, whether previous saves succeeded or failed.\\n        return readyToStart._continueWith(function() {\\n          return Parse._request({\\n            route: \\\"batch\\\",\\n            method: \\\"POST\\\",\\n            useMasterKey: options.useMasterKey,\\n            data: {\\n              requests: _.map(batch, function(object) {\\n                var json = object._getSaveJSON();\\n                var method = \\\"POST\\\";\\n\\n                var path = \\\"/1/classes/\\\" + object.className;\\n                if (object.id) {\\n                  path = path + \\\"/\\\" + object.id;\\n                  method = \\\"PUT\\\";\\n                }\\n\\n                object._startSave();\\n\\n                return {\\n                  method: method,\\n                  path: path,\\n                  body: json\\n                };\\n              })\\n            }\\n          }).then(function(response, status, xhr) {\\n            var error;\\n            Parse._arrayEach(batch, function(object, i) {\\n              if (response[i].success) {\\n                object._finishSave(\\n                  object.parse(response[i].success, status, xhr));\\n              } else {\\n                error = error || response[i].error;\\n                object._cancelSave();\\n              }\\n            });\\n            if (error) {\\n              return Parse.Promise.error(\\n                new Parse.Error(error.code, error.error));\\n            }\\n\\n          }).then(function(results) {\\n            batchFinished.resolve(results);\\n            return results;\\n          }, function(error) {\\n            batchFinished.reject(error);\\n            return Parse.Promise.error(error);\\n          });\\n        });\\n      });\\n    }).then(function() {\\n      return object;\\n    });\\n  };\\n\\n}(this));\\n\\n(function(root) {\\n  root.Parse = root.Parse || {};\\n  var Parse = root.Parse;\\n  var _ = Parse._;\\n\\n  /**\\n   * Represents a Role on the Parse server. Roles represent groupings of\\n   * Users for the purposes of granting permissions (e.g. specifying an ACL\\n   * for an Object). Roles are specified by their sets of child users and\\n   * child roles, all of which are granted any permissions that the parent\\n   * role has.\\n   *\\n   * <p>Roles must have a name (which cannot be changed after creation of the\\n   * role), and must specify an ACL.</p>\\n   * @class\\n   * A Parse.Role is a local representation of a role persisted to the Parse\\n   * cloud.\\n   */\\n  Parse.Role = Parse.Object.extend(\\\"_Role\\\", /** @lends Parse.Role.prototype */ {\\n    // Instance Methods\\n\\n    /**\\n     * Constructs a new ParseRole with the given name and ACL.\\n     *\\n     * @param {String} name The name of the Role to create.\\n     * @param {Parse.ACL} acl The ACL for this role. Roles must have an ACL.\\n     */\\n    constructor: function(name, acl) {\\n      if (_.isString(name) && (acl instanceof Parse.ACL)) {\\n        Parse.Object.prototype.constructor.call(this, null, null);\\n        this.setName(name);\\n        this.setACL(acl);\\n      } else {\\n        Parse.Object.prototype.constructor.call(this, name, acl);\\n      }\\n    },\\n\\n    /**\\n     * Gets the name of the role.  You can alternatively call role.get(\\\"name\\\")\\n     *\\n     * @return {String} the name of the role.\\n     */\\n    getName: function() {\\n      return this.get(\\\"name\\\");\\n    },\\n\\n    /**\\n     * Sets the name for a role. This value must be set before the role has\\n     * been saved to the server, and cannot be set once the role has been\\n     * saved.\\n     *\\n     * <p>\\n     *   A role's name can only contain alphanumeric characters, _, -, and\\n     *   spaces.\\n     * </p>\\n     *\\n     * <p>This is equivalent to calling role.set(\\\"name\\\", name)</p>\\n     *\\n     * @param {String} name The name of the role.\\n     * @param {Object} options Standard options object with success and error\\n     *     callbacks.\\n     */\\n    setName: function(name, options) {\\n      return this.set(\\\"name\\\", name, options);\\n    },\\n\\n    /**\\n     * Gets the Parse.Relation for the Parse.Users that are direct\\n     * children of this role. These users are granted any privileges that this\\n     * role has been granted (e.g. read or write access through ACLs). You can\\n     * add or remove users from the role through this relation.\\n     *\\n     * <p>This is equivalent to calling role.relation(\\\"users\\\")</p>\\n     *\\n     * @return {Parse.Relation} the relation for the users belonging to this\\n     *     role.\\n     */\\n    getUsers: function() {\\n      return this.relation(\\\"users\\\");\\n    },\\n\\n    /**\\n     * Gets the Parse.Relation for the Parse.Roles that are direct\\n     * children of this role. These roles' users are granted any privileges that\\n     * this role has been granted (e.g. read or write access through ACLs). You\\n     * can add or remove child roles from this role through this relation.\\n     *\\n     * <p>This is equivalent to calling role.relation(\\\"roles\\\")</p>\\n     *\\n     * @return {Parse.Relation} the relation for the roles belonging to this\\n     *     role.\\n     */\\n    getRoles: function() {\\n      return this.relation(\\\"roles\\\");\\n    },\\n\\n    /**\\n     * @ignore\\n     */\\n    validate: function(attrs, options) {\\n      if (\\\"name\\\" in attrs && attrs.name !== this.getName()) {\\n        var newName = attrs.name;\\n        if (this.id && this.id !== attrs.objectId) {\\n          // Check to see if the objectId being set matches this.id.\\n          // This happens during a fetch -- the id is set before calling fetch.\\n          // Let the name be set in this case.\\n          return new Parse.Error(Parse.Error.OTHER_CAUSE,\\n              \\\"A role's name can only be set before it has been saved.\\\");\\n        }\\n        if (!_.isString(newName)) {\\n          return new Parse.Error(Parse.Error.OTHER_CAUSE,\\n              \\\"A role's name must be a String.\\\");\\n        }\\n        if (!(/^[0-9a-zA-Z\\\\-_ ]+$/).test(newName)) {\\n          return new Parse.Error(Parse.Error.OTHER_CAUSE,\\n              \\\"A role's name can only contain alphanumeric characters, _,\\\" +\\n              \\\" -, and spaces.\\\");\\n        }\\n      }\\n      if (Parse.Object.prototype.validate) {\\n        return Parse.Object.prototype.validate.call(this, attrs, options);\\n      }\\n      return false;\\n    }\\n  });\\n}(this));\\n\\n\\n/*global _: false */\\n(function(root) {\\n  root.Parse = root.Parse || {};\\n  var Parse = root.Parse;\\n  var _ = Parse._;\\n\\n  /**\\n   * Creates a new instance with the given models and options.  Typically, you\\n   * will not call this method directly, but will instead make a subclass using\\n   * <code>Parse.Collection.extend</code>.\\n   *\\n   * @param {Array} models An array of instances of <code>Parse.Object</code>.\\n   *\\n   * @param {Object} options An optional object with Backbone-style options.\\n   * Valid options are:<ul>\\n   *   <li>model: The Parse.Object subclass that this collection contains.\\n   *   <li>query: An instance of Parse.Query to use when fetching items.\\n   *   <li>comparator: A string property name or function to sort by.\\n   * </ul>\\n   *\\n   * @see Parse.Collection.extend\\n   *\\n   * @class\\n   *\\n   * <p>Provides a standard collection class for our sets of models, ordered\\n   * or unordered.  For more information, see the\\n   * <a href=\\\"http://documentcloud.github.com/backbone/#Collection\\\">Backbone\\n   * documentation</a>.</p>\\n   */\\n  Parse.Collection = function(models, options) {\\n    options = options || {};\\n    if (options.comparator) {\\n      this.comparator = options.comparator;\\n    }\\n    if (options.model) {\\n      this.model = options.model;\\n    }\\n    if (options.query) {\\n      this.query = options.query;\\n    }\\n    this._reset();\\n    this.initialize.apply(this, arguments);\\n    if (models) {\\n      this.reset(models, {silent: true, parse: options.parse});\\n    }\\n  };\\n\\n  // Define the Collection's inheritable methods.\\n  _.extend(Parse.Collection.prototype, Parse.Events,\\n      /** @lends Parse.Collection.prototype */ {\\n\\n    // The default model for a collection is just a Parse.Object.\\n    // This should be overridden in most cases.\\n\\n    model: Parse.Object,\\n\\n    /**\\n     * Initialize is an empty function by default. Override it with your own\\n     * initialization logic.\\n     */\\n    initialize: function(){},\\n\\n    /**\\n     * The JSON representation of a Collection is an array of the\\n     * models' attributes.\\n     */\\n    toJSON: function() {\\n      return this.map(function(model){ return model.toJSON(); });\\n    },\\n\\n    /**\\n     * Add a model, or list of models to the set. Pass **silent** to avoid\\n     * firing the `add` event for every new model.\\n     *\\n     * @param {Array} models An array of instances of <code>Parse.Object</code>.\\n     *\\n     * @param {Object} options An optional object with Backbone-style options.\\n     * Valid options are:<ul>\\n     *   <li>at: The index at which to add the models.\\n     *   <li>silent: Set to true to avoid firing the `add` event for every new\\n     *   model.\\n     * </ul>\\n     */\\n    add: function(models, options) {\\n      var i, index, length, model, cid, id, cids = {}, ids = {};\\n      options = options || {};\\n      models = _.isArray(models) ? models.slice() : [models];\\n\\n      // Begin by turning bare objects into model references, and preventing\\n      // invalid models or duplicate models from being added.\\n      for (i = 0, length = models.length; i < length; i++) {\\n        models[i] = this._prepareModel(models[i], options);\\n        model = models[i];\\n        if (!model) {\\n          throw new Error(\\\"Can't add an invalid model to a collection\\\");\\n        }\\n        cid = model.cid;\\n        if (cids[cid] || this._byCid[cid]) {\\n          throw new Error(\\\"Duplicate cid: can't add the same model \\\" +\\n                          \\\"to a collection twice\\\");\\n        }\\n        id = model.id;\\n        if (!Parse._isNullOrUndefined(id) && (ids[id] || this._byId[id])) {\\n          throw new Error(\\\"Duplicate id: can't add the same model \\\" +\\n                          \\\"to a collection twice\\\");\\n        }\\n        ids[id] = model;\\n        cids[cid] = model;\\n      }\\n\\n      // Listen to added models' events, and index models for lookup by\\n      // `id` and by `cid`.\\n      for (i = 0; i < length; i++) {\\n        (model = models[i]).on('all', this._onModelEvent, this);\\n        this._byCid[model.cid] = model;\\n        if (model.id) {\\n          this._byId[model.id] = model;\\n        }\\n      }\\n\\n      // Insert models into the collection, re-sorting if needed, and triggering\\n      // `add` events unless silenced.\\n      this.length += length;\\n      index = Parse._isNullOrUndefined(options.at) ?\\n          this.models.length : options.at;\\n      this.models.splice.apply(this.models, [index, 0].concat(models));\\n      if (this.comparator) {\\n        this.sort({silent: true});\\n      }\\n      if (options.silent) {\\n        return this;\\n      }\\n      for (i = 0, length = this.models.length; i < length; i++) {\\n        model = this.models[i];\\n        if (cids[model.cid]) {\\n          options.index = i;\\n          model.trigger('add', model, this, options);\\n        }\\n      }\\n      return this;\\n    },\\n\\n    /**\\n     * Remove a model, or a list of models from the set. Pass silent to avoid\\n     * firing the <code>remove</code> event for every model removed.\\n     *\\n     * @param {Array} models The model or list of models to remove from the\\n     *   collection.\\n     * @param {Object} options An optional object with Backbone-style options.\\n     * Valid options are: <ul>\\n     *   <li>silent: Set to true to avoid firing the `remove` event.\\n     * </ul>\\n     */\\n    remove: function(models, options) {\\n      var i, l, index, model;\\n      options = options || {};\\n      models = _.isArray(models) ? models.slice() : [models];\\n      for (i = 0, l = models.length; i < l; i++) {\\n        model = this.getByCid(models[i]) || this.get(models[i]);\\n        if (!model) {\\n          continue;\\n        }\\n        delete this._byId[model.id];\\n        delete this._byCid[model.cid];\\n        index = this.indexOf(model);\\n        this.models.splice(index, 1);\\n        this.length--;\\n        if (!options.silent) {\\n          options.index = index;\\n          model.trigger('remove', model, this, options);\\n        }\\n        this._removeReference(model);\\n      }\\n      return this;\\n    },\\n\\n    /**\\n     * Gets a model from the set by id.\\n     * @param {String} id The Parse objectId identifying the Parse.Object to\\n     * fetch from this collection.\\n     */\\n    get: function(id) {\\n      return id && this._byId[id.id || id];\\n    },\\n\\n    /**\\n     * Gets a model from the set by client id.\\n     * @param {} cid The Backbone collection id identifying the Parse.Object to\\n     * fetch from this collection.\\n     */\\n    getByCid: function(cid) {\\n      return cid && this._byCid[cid.cid || cid];\\n    },\\n\\n    /**\\n     * Gets the model at the given index.\\n     *\\n     * @param {Number} index The index of the model to return.\\n     */\\n    at: function(index) {\\n      return this.models[index];\\n    },\\n\\n    /**\\n     * Forces the collection to re-sort itself. You don't need to call this\\n     * under normal circumstances, as the set will maintain sort order as each\\n     * item is added.\\n     * @param {Object} options An optional object with Backbone-style options.\\n     * Valid options are: <ul>\\n     *   <li>silent: Set to true to avoid firing the `reset` event.\\n     * </ul>\\n     */\\n    sort: function(options) {\\n      options = options || {};\\n      if (!this.comparator) {\\n        throw new Error('Cannot sort a set without a comparator');\\n      }\\n      var boundComparator = _.bind(this.comparator, this);\\n      if (this.comparator.length === 1) {\\n        this.models = this.sortBy(boundComparator);\\n      } else {\\n        this.models.sort(boundComparator);\\n      }\\n      if (!options.silent) {\\n        this.trigger('reset', this, options);\\n      }\\n      return this;\\n    },\\n\\n    /**\\n     * Plucks an attribute from each model in the collection.\\n     * @param {String} attr The attribute to return from each model in the\\n     * collection.\\n     */\\n    pluck: function(attr) {\\n      return _.map(this.models, function(model){ return model.get(attr); });\\n    },\\n\\n    /**\\n     * When you have more items than you want to add or remove individually,\\n     * you can reset the entire set with a new list of models, without firing\\n     * any `add` or `remove` events. Fires `reset` when finished.\\n     *\\n     * @param {Array} models The model or list of models to remove from the\\n     *   collection.\\n     * @param {Object} options An optional object with Backbone-style options.\\n     * Valid options are: <ul>\\n     *   <li>silent: Set to true to avoid firing the `reset` event.\\n     * </ul>\\n     */\\n    reset: function(models, options) {\\n      var self = this;\\n      models = models || [];\\n      options = options || {};\\n      Parse._arrayEach(this.models, function(model) {\\n        self._removeReference(model);\\n      });\\n      this._reset();\\n      this.add(models, {silent: true, parse: options.parse});\\n      if (!options.silent) {\\n        this.trigger('reset', this, options);\\n      }\\n      return this;\\n    },\\n\\n    /**\\n     * Fetches the default set of models for this collection, resetting the\\n     * collection when they arrive. If `add: true` is passed, appends the\\n     * models to the collection instead of resetting.\\n     *\\n     * @param {Object} options An optional object with Backbone-style options.\\n     * Valid options are:<ul>\\n     *   <li>silent: Set to true to avoid firing `add` or `reset` events for\\n     *   models fetched by this fetch.\\n     *   <li>success: A Backbone-style success callback.\\n     *   <li>error: An Backbone-style error callback.\\n     *   <li>useMasterKey: In Cloud Code and Node only, uses the Master Key for\\n     *       this request.\\n     * </ul>\\n     */\\n    fetch: function(options) {\\n      options = _.clone(options) || {};\\n      if (options.parse === undefined) {\\n        options.parse = true;\\n      }\\n      var collection = this;\\n      var query = this.query || new Parse.Query(this.model);\\n      return query.find({\\n        useMasterKey: options.useMasterKey\\n      }).then(function(results) {\\n        if (options.add) {\\n          collection.add(results, options);\\n        } else {\\n          collection.reset(results, options);\\n        }\\n        return collection;\\n      })._thenRunCallbacks(options, this);\\n    },\\n\\n    /**\\n     * Creates a new instance of a model in this collection. Add the model to\\n     * the collection immediately, unless `wait: true` is passed, in which case\\n     * we wait for the server to agree.\\n     *\\n     * @param {Parse.Object} model The new model to create and add to the\\n     *   collection.\\n     * @param {Object} options An optional object with Backbone-style options.\\n     * Valid options are:<ul>\\n     *   <li>wait: Set to true to wait for the server to confirm creation of the\\n     *       model before adding it to the collection.\\n     *   <li>silent: Set to true to avoid firing an `add` event.\\n     *   <li>success: A Backbone-style success callback.\\n     *   <li>error: An Backbone-style error callback.\\n     *   <li>useMasterKey: In Cloud Code and Node only, uses the Master Key for\\n     *       this request.\\n     * </ul>\\n     */\\n    create: function(model, options) {\\n      var coll = this;\\n      options = options ? _.clone(options) : {};\\n      model = this._prepareModel(model, options);\\n      if (!model) {\\n        return false;\\n      }\\n      if (!options.wait) {\\n        coll.add(model, options);\\n      }\\n      var success = options.success;\\n      options.success = function(nextModel, resp, xhr) {\\n        if (options.wait) {\\n          coll.add(nextModel, options);\\n        }\\n        if (success) {\\n          success(nextModel, resp);\\n        } else {\\n          nextModel.trigger('sync', model, resp, options);\\n        }\\n      };\\n      model.save(null, options);\\n      return model;\\n    },\\n\\n    /**\\n     * Converts a response into a list of models to be added to the collection.\\n     * The default implementation is just to pass it through.\\n     * @ignore\\n     */\\n    parse: function(resp, xhr) {\\n      return resp;\\n    },\\n\\n    /**\\n     * Proxy to _'s chain. Can't be proxied the same way the rest of the\\n     * underscore methods are proxied because it relies on the underscore\\n     * constructor.\\n     */\\n    chain: function() {\\n      return _(this.models).chain();\\n    },\\n\\n    /**\\n     * Reset all internal state. Called when the collection is reset.\\n     */\\n    _reset: function(options) {\\n      this.length = 0;\\n      this.models = [];\\n      this._byId  = {};\\n      this._byCid = {};\\n    },\\n\\n    /**\\n     * Prepare a model or hash of attributes to be added to this collection.\\n     */\\n    _prepareModel: function(model, options) {\\n      if (!(model instanceof Parse.Object)) {\\n        var attrs = model;\\n        options.collection = this;\\n        model = new this.model(attrs, options);\\n        if (!model._validate(model.attributes, options)) {\\n          model = false;\\n        }\\n      } else if (!model.collection) {\\n        model.collection = this;\\n      }\\n      return model;\\n    },\\n\\n    /**\\n     * Internal method to remove a model's ties to a collection.\\n     */\\n    _removeReference: function(model) {\\n      if (this === model.collection) {\\n        delete model.collection;\\n      }\\n      model.off('all', this._onModelEvent, this);\\n    },\\n\\n    /**\\n     * Internal method called every time a model in the set fires an event.\\n     * Sets need to update their indexes when models change ids. All other\\n     * events simply proxy through. \\\"add\\\" and \\\"remove\\\" events that originate\\n     * in other collections are ignored.\\n     */\\n    _onModelEvent: function(ev, model, collection, options) {\\n      if ((ev === 'add' || ev === 'remove') && collection !== this) {\\n        return;\\n      }\\n      if (ev === 'destroy') {\\n        this.remove(model, options);\\n      }\\n      if (model && ev === 'change:objectId') {\\n        delete this._byId[model.previous(\\\"objectId\\\")];\\n        this._byId[model.id] = model;\\n      }\\n      this.trigger.apply(this, arguments);\\n    }\\n\\n  });\\n\\n  // Underscore methods that we want to implement on the Collection.\\n  var methods = ['forEach', 'each', 'map', 'reduce', 'reduceRight', 'find',\\n    'detect', 'filter', 'select', 'reject', 'every', 'all', 'some', 'any',\\n    'include', 'contains', 'invoke', 'max', 'min', 'sortBy', 'sortedIndex',\\n    'toArray', 'size', 'first', 'initial', 'rest', 'last', 'without', 'indexOf',\\n    'shuffle', 'lastIndexOf', 'isEmpty', 'groupBy'];\\n\\n  // Mix in each Underscore method as a proxy to `Collection#models`.\\n  Parse._arrayEach(methods, function(method) {\\n    Parse.Collection.prototype[method] = function() {\\n      return _[method].apply(_, [this.models].concat(_.toArray(arguments)));\\n    };\\n  });\\n\\n  /**\\n   * Creates a new subclass of <code>Parse.Collection</code>.  For example,<pre>\\n   *   var MyCollection = Parse.Collection.extend({\\n   *     // Instance properties\\n   *\\n   *     model: MyClass,\\n   *     query: MyQuery,\\n   *\\n   *     getFirst: function() {\\n   *       return this.at(0);\\n   *     }\\n   *   }, {\\n   *     // Class properties\\n   *\\n   *     makeOne: function() {\\n   *       return new MyCollection();\\n   *     }\\n   *   });\\n   *\\n   *   var collection = new MyCollection();\\n   * </pre>\\n   *\\n   * @function\\n   * @param {Object} instanceProps Instance properties for the collection.\\n   * @param {Object} classProps Class properies for the collection.\\n   * @return {Class} A new subclass of <code>Parse.Collection</code>.\\n   */\\n  Parse.Collection.extend = Parse._extend;\\n\\n}(this));\\n\\n/*global _: false, document: false */\\n(function(root) {\\n  root.Parse = root.Parse || {};\\n  var Parse = root.Parse;\\n  var _ = Parse._;\\n\\n  /**\\n   * Creating a Parse.View creates its initial element outside of the DOM,\\n   * if an existing element is not provided...\\n   * @class\\n   *\\n   * <p>A fork of Backbone.View, provided for your convenience.  If you use this\\n   * class, you must also include jQuery, or another library that provides a\\n   * jQuery-compatible $ function.  For more information, see the\\n   * <a href=\\\"http://documentcloud.github.com/backbone/#View\\\">Backbone\\n   * documentation</a>.</p>\\n   * <p><strong><em>Available in the client SDK only.</em></strong></p>\\n   */\\n  Parse.View = function(options) {\\n    this.cid = _.uniqueId('view');\\n    this._configure(options || {});\\n    this._ensureElement();\\n    this.initialize.apply(this, arguments);\\n    this.delegateEvents();\\n  };\\n\\n  // Cached regex to split keys for `delegate`.\\n  var eventSplitter = /^(\\\\S+)\\\\s*(.*)$/;\\n\\n  // List of view options to be merged as properties.\\n\\n  var viewOptions = ['model', 'collection', 'el', 'id', 'attributes',\\n                     'className', 'tagName'];\\n\\n  // Set up all inheritable **Parse.View** properties and methods.\\n  _.extend(Parse.View.prototype, Parse.Events,\\n           /** @lends Parse.View.prototype */ {\\n\\n    // The default `tagName` of a View's element is `\\\"div\\\"`.\\n    tagName: 'div',\\n\\n    /**\\n     * jQuery delegate for element lookup, scoped to DOM elements within the\\n     * current view. This should be prefered to global lookups where possible.\\n     */\\n    $: function(selector) {\\n      return this.$el.find(selector);\\n    },\\n\\n    /**\\n     * Initialize is an empty function by default. Override it with your own\\n     * initialization logic.\\n     */\\n    initialize: function(){},\\n\\n    /**\\n     * The core function that your view should override, in order\\n     * to populate its element (`this.el`), with the appropriate HTML. The\\n     * convention is for **render** to always return `this`.\\n     */\\n    render: function() {\\n      return this;\\n    },\\n\\n    /**\\n     * Remove this view from the DOM. Note that the view isn't present in the\\n     * DOM by default, so calling this method may be a no-op.\\n     */\\n    remove: function() {\\n      this.$el.remove();\\n      return this;\\n    },\\n\\n    /**\\n     * For small amounts of DOM Elements, where a full-blown template isn't\\n     * needed, use **make** to manufacture elements, one at a time.\\n     * <pre>\\n     *     var el = this.make('li', {'class': 'row'},\\n     *                        this.model.escape('title'));</pre>\\n     */\\n    make: function(tagName, attributes, content) {\\n      var el = document.createElement(tagName);\\n      if (attributes) {\\n        Parse.$(el).attr(attributes);\\n      }\\n      if (content) {\\n        Parse.$(el).html(content);\\n      }\\n      return el;\\n    },\\n\\n    /**\\n     * Changes the view's element (`this.el` property), including event\\n     * re-delegation.\\n     */\\n    setElement: function(element, delegate) {\\n      this.$el = Parse.$(element);\\n      this.el = this.$el[0];\\n      if (delegate !== false) {\\n        this.delegateEvents();\\n      }\\n      return this;\\n    },\\n\\n    /**\\n     * Set callbacks.  <code>this.events</code> is a hash of\\n     * <pre>\\n     * *{\\\"event selector\\\": \\\"callback\\\"}*\\n     *\\n     *     {\\n     *       'mousedown .title':  'edit',\\n     *       'click .button':     'save'\\n     *       'click .open':       function(e) { ... }\\n     *     }\\n     * </pre>\\n     * pairs. Callbacks will be bound to the view, with `this` set properly.\\n     * Uses event delegation for efficiency.\\n     * Omitting the selector binds the event to `this.el`.\\n     * This only works for delegate-able events: not `focus`, `blur`, and\\n     * not `change`, `submit`, and `reset` in Internet Explorer.\\n     */\\n    delegateEvents: function(events) {\\n      events = events || Parse._getValue(this, 'events');\\n      if (!events) {\\n        return;\\n      }\\n      this.undelegateEvents();\\n      var self = this;\\n      Parse._objectEach(events, function(method, key) {\\n        if (!_.isFunction(method)) {\\n          method = self[events[key]];\\n        }\\n        if (!method) {\\n          throw new Error('Event \\\"' + events[key] + '\\\" does not exist');\\n        }\\n        var match = key.match(eventSplitter);\\n        var eventName = match[1], selector = match[2];\\n        method = _.bind(method, self);\\n        eventName += '.delegateEvents' + self.cid;\\n        if (selector === '') {\\n          self.$el.bind(eventName, method);\\n        } else {\\n          self.$el.delegate(selector, eventName, method);\\n        }\\n      });\\n    },\\n\\n    /**\\n     * Clears all callbacks previously bound to the view with `delegateEvents`.\\n     * You usually don't need to use this, but may wish to if you have multiple\\n     * Backbone views attached to the same DOM element.\\n     */\\n    undelegateEvents: function() {\\n      this.$el.unbind('.delegateEvents' + this.cid);\\n    },\\n\\n    /**\\n     * Performs the initial configuration of a View with a set of options.\\n     * Keys with special meaning *(model, collection, id, className)*, are\\n     * attached directly to the view.\\n     */\\n    _configure: function(options) {\\n      if (this.options) {\\n        options = _.extend({}, this.options, options);\\n      }\\n      var self = this;\\n      _.each(viewOptions, function(attr) {\\n        if (options[attr]) {\\n          self[attr] = options[attr];\\n        }\\n      });\\n      this.options = options;\\n    },\\n\\n    /**\\n     * Ensure that the View has a DOM element to render into.\\n     * If `this.el` is a string, pass it through `$()`, take the first\\n     * matching element, and re-assign it to `el`. Otherwise, create\\n     * an element from the `id`, `className` and `tagName` properties.\\n     */\\n    _ensureElement: function() {\\n      if (!this.el) {\\n        var attrs = Parse._getValue(this, 'attributes') || {};\\n        if (this.id) {\\n          attrs.id = this.id;\\n        }\\n        if (this.className) {\\n          attrs['class'] = this.className;\\n        }\\n        this.setElement(this.make(this.tagName, attrs), false);\\n      } else {\\n        this.setElement(this.el, false);\\n      }\\n    }\\n\\n  });\\n\\n  /**\\n   * @function\\n   * @param {Object} instanceProps Instance properties for the view.\\n   * @param {Object} classProps Class properies for the view.\\n   * @return {Class} A new subclass of <code>Parse.View</code>.\\n   */\\n  Parse.View.extend = Parse._extend;\\n\\n}(this));\\n\\n(function(root) {\\n  root.Parse = root.Parse || {};\\n  var Parse = root.Parse;\\n  var _ = Parse._;\\n\\n  /**\\n   * @class\\n   *\\n   * <p>A Parse.User object is a local representation of a user persisted to the\\n   * Parse cloud. This class is a subclass of a Parse.Object, and retains the\\n   * same functionality of a Parse.Object, but also extends it with various\\n   * user specific methods, like authentication, signing up, and validation of\\n   * uniqueness.</p>\\n   */\\n  Parse.User = Parse.Object.extend(\\\"_User\\\", /** @lends Parse.User.prototype */ {\\n    // Instance Variables\\n    _isCurrentUser: false,\\n\\n\\n    // Instance Methods\\n\\n    /**\\n     * Merges another object's attributes into this object.\\n     */\\n    _mergeFromObject: function(other) {\\n      if (other.getSessionToken()) {\\n        this._sessionToken = other.getSessionToken();\\n      }\\n      Parse.User.__super__._mergeFromObject.call(this, other);\\n    },\\n\\n    /**\\n     * Internal method to handle special fields in a _User response.\\n     */\\n    _mergeMagicFields: function(attrs) {\\n      if (attrs.sessionToken) {\\n        this._sessionToken = attrs.sessionToken;\\n        delete attrs.sessionToken;\\n      }\\n      Parse.User.__super__._mergeMagicFields.call(this, attrs);\\n    },\\n\\n    /**\\n     * Removes null values from authData (which exist temporarily for\\n     * unlinking)\\n     */\\n    _cleanupAuthData: function() {\\n      if (!this.isCurrent()) {\\n        return;\\n      }\\n      var authData = this.get('authData');\\n      if (!authData) {\\n        return;\\n      }\\n      Parse._objectEach(this.get('authData'), function(value, key) {\\n        if (!authData[key]) {\\n          delete authData[key];\\n        }\\n      });\\n    },\\n\\n    /**\\n     * Synchronizes authData for all providers.\\n     */\\n    _synchronizeAllAuthData: function() {\\n      var authData = this.get('authData');\\n      if (!authData) {\\n        return;\\n      }\\n\\n      var self = this;\\n      Parse._objectEach(this.get('authData'), function(value, key) {\\n        self._synchronizeAuthData(key);\\n      });\\n    },\\n\\n    /**\\n     * Synchronizes auth data for a provider (e.g. puts the access token in the\\n     * right place to be used by the Facebook SDK).\\n     */\\n    _synchronizeAuthData: function(provider) {\\n      if (!this.isCurrent()) {\\n        return;\\n      }\\n      var authType;\\n      if (_.isString(provider)) {\\n        authType = provider;\\n        provider = Parse.User._authProviders[authType];\\n      } else {\\n        authType = provider.getAuthType();\\n      }\\n      var authData = this.get('authData');\\n      if (!authData || !provider) {\\n        return;\\n      }\\n      var success = provider.restoreAuthentication(authData[authType]);\\n      if (!success) {\\n        this._unlinkFrom(provider);\\n      }\\n    },\\n\\n    _handleSaveResult: function(makeCurrent) {\\n      // Clean up and synchronize the authData object, removing any unset values\\n      if (makeCurrent) {\\n        this._isCurrentUser = true;\\n      }\\n      this._cleanupAuthData();\\n      this._synchronizeAllAuthData();\\n      // Don't keep the password around.\\n      delete this._serverData.password;\\n      this._rebuildEstimatedDataForKey(\\\"password\\\");\\n      this._refreshCache();\\n      if (makeCurrent || this.isCurrent()) {\\n        Parse.User._saveCurrentUser(this);\\n      }\\n    },\\n\\n    /**\\n     * Unlike in the Android/iOS SDKs, logInWith is unnecessary, since you can\\n     * call linkWith on the user (even if it doesn't exist yet on the server).\\n     */\\n    _linkWith: function(provider, options) {\\n      var authType;\\n      if (_.isString(provider)) {\\n        authType = provider;\\n        provider = Parse.User._authProviders[provider];\\n      } else {\\n        authType = provider.getAuthType();\\n      }\\n      if (_.has(options, 'authData')) {\\n        var authData = this.get('authData') || {};\\n        authData[authType] = options.authData;\\n        this.set('authData', authData);\\n\\n        // Overridden so that the user can be made the current user.\\n        var newOptions = _.clone(options) || {};\\n        newOptions.success = function(model) {\\n          model._handleSaveResult(true);\\n          if (options.success) {\\n            options.success.apply(this, arguments);\\n          }\\n        };\\n        return this.save({'authData': authData}, newOptions);\\n      } else {\\n        var self = this;\\n        var promise = new Parse.Promise();\\n        provider.authenticate({\\n          success: function(provider, result) {\\n            self._linkWith(provider, {\\n              authData: result,\\n              success: options.success,\\n              error: options.error\\n            }).then(function() {\\n              promise.resolve(self);\\n            });\\n          },\\n          error: function(provider, error) {\\n            if (options.error) {\\n              options.error(self, error);\\n            }\\n            promise.reject(error);\\n          }\\n        });\\n        return promise;\\n      }\\n    },\\n\\n    /**\\n     * Unlinks a user from a service.\\n     */\\n    _unlinkFrom: function(provider, options) {\\n      var authType;\\n      if (_.isString(provider)) {\\n        authType = provider;\\n        provider = Parse.User._authProviders[provider];\\n      } else {\\n        authType = provider.getAuthType();\\n      }\\n      var newOptions = _.clone(options);\\n      var self = this;\\n      newOptions.authData = null;\\n      newOptions.success = function(model) {\\n        self._synchronizeAuthData(provider);\\n        if (options.success) {\\n          options.success.apply(this, arguments);\\n        }\\n      };\\n      return this._linkWith(provider, newOptions);\\n    },\\n\\n    /**\\n     * Checks whether a user is linked to a service.\\n     */\\n    _isLinked: function(provider) {\\n      var authType;\\n      if (_.isString(provider)) {\\n        authType = provider;\\n      } else {\\n        authType = provider.getAuthType();\\n      }\\n      var authData = this.get('authData') || {};\\n      return !!authData[authType];\\n    },\\n\\n    /**\\n     * Deauthenticates all providers.\\n     */\\n    _logOutWithAll: function() {\\n      var authData = this.get('authData');\\n      if (!authData) {\\n        return;\\n      }\\n      var self = this;\\n      Parse._objectEach(this.get('authData'), function(value, key) {\\n        self._logOutWith(key);\\n      });\\n    },\\n\\n    /**\\n     * Deauthenticates a single provider (e.g. removing access tokens from the\\n     * Facebook SDK).\\n     */\\n    _logOutWith: function(provider) {\\n      if (!this.isCurrent()) {\\n        return;\\n      }\\n      if (_.isString(provider)) {\\n        provider = Parse.User._authProviders[provider];\\n      }\\n      if (provider && provider.deauthenticate) {\\n        provider.deauthenticate();\\n      }\\n    },\\n\\n    /**\\n     * Signs up a new user. You should call this instead of save for\\n     * new Parse.Users. This will create a new Parse.User on the server, and\\n     * also persist the session on disk so that you can access the user using\\n     * <code>current</code>.\\n     *\\n     * <p>A username and password must be set before calling signUp.</p>\\n     *\\n     * <p>Calls options.success or options.error on completion.</p>\\n     *\\n     * @param {Object} attrs Extra fields to set on the new user, or null.\\n     * @param {Object} options A Backbone-style options object.\\n     * @return {Parse.Promise} A promise that is fulfilled when the signup\\n     *     finishes.\\n     * @see Parse.User.signUp\\n     */\\n    signUp: function(attrs, options) {\\n      var error;\\n      options = options || {};\\n\\n      var username = (attrs && attrs.username) || this.get(\\\"username\\\");\\n      if (!username || (username === \\\"\\\")) {\\n        error = new Parse.Error(\\n            Parse.Error.OTHER_CAUSE,\\n            \\\"Cannot sign up user with an empty name.\\\");\\n        if (options && options.error) {\\n          options.error(this, error);\\n        }\\n        return Parse.Promise.error(error);\\n      }\\n\\n      var password = (attrs && attrs.password) || this.get(\\\"password\\\");\\n      if (!password || (password === \\\"\\\")) {\\n        error = new Parse.Error(\\n            Parse.Error.OTHER_CAUSE,\\n            \\\"Cannot sign up user with an empty password.\\\");\\n        if (options && options.error) {\\n          options.error(this, error);\\n        }\\n        return Parse.Promise.error(error);\\n      }\\n\\n      // Overridden so that the user can be made the current user.\\n      var newOptions = _.clone(options);\\n      newOptions.success = function(model) {\\n        model._handleSaveResult(true);\\n        if (options.success) {\\n          options.success.apply(this, arguments);\\n        }\\n      };\\n      return this.save(attrs, newOptions);\\n    },\\n\\n    /**\\n     * Logs in a Parse.User. On success, this saves the session to localStorage,\\n     * so you can retrieve the currently logged in user using\\n     * <code>current</code>.\\n     *\\n     * <p>A username and password must be set before calling logIn.</p>\\n     *\\n     * <p>Calls options.success or options.error on completion.</p>\\n     *\\n     * @param {Object} options A Backbone-style options object.\\n     * @see Parse.User.logIn\\n     * @return {Parse.Promise} A promise that is fulfilled with the user when\\n     *     the login is complete.\\n     */\\n    logIn: function(options) {\\n      var model = this;\\n      options = options || {};\\n      var request = Parse._request({\\n        route: \\\"login\\\",\\n        method: \\\"GET\\\",\\n        useMasterKey: options.useMasterKey,\\n        data: this.toJSON()\\n      });\\n      return request.then(function(resp, status, xhr) {\\n        var serverAttrs = model.parse(resp, status, xhr);\\n        model._finishFetch(serverAttrs);\\n        model._handleSaveResult(true);\\n        return model;\\n      })._thenRunCallbacks(options, this);\\n    },\\n\\n    /**\\n     * @see Parse.Object#save\\n     */\\n    save: function(arg1, arg2, arg3) {\\n      var i, attrs, current, options, saved;\\n      if (_.isObject(arg1) || _.isNull(arg1) || _.isUndefined(arg1)) {\\n        attrs = arg1;\\n        options = arg2;\\n      } else {\\n        attrs = {};\\n        attrs[arg1] = arg2;\\n        options = arg3;\\n      }\\n      options = options || {};\\n\\n      var newOptions = _.clone(options);\\n      newOptions.success = function(model) {\\n        model._handleSaveResult(false);\\n        if (options.success) {\\n          options.success.apply(this, arguments);\\n        }\\n      };\\n      return Parse.Object.prototype.save.call(this, attrs, newOptions);\\n    },\\n\\n    /**\\n     * @see Parse.Object#fetch\\n     */\\n    fetch: function(options) {\\n      var newOptions = options ? _.clone(options) : {};\\n      newOptions.success = function(model) {\\n        model._handleSaveResult(false);\\n        if (options && options.success) {\\n          options.success.apply(this, arguments);\\n        }\\n      };\\n      return Parse.Object.prototype.fetch.call(this, newOptions);\\n    },\\n\\n    /**\\n     * Returns true if <code>current</code> would return this user.\\n     * @see Parse.User#current\\n     */\\n    isCurrent: function() {\\n      return this._isCurrentUser;\\n    },\\n\\n    /**\\n     * Returns get(\\\"username\\\").\\n     * @return {String}\\n     * @see Parse.Object#get\\n     */\\n    getUsername: function() {\\n      return this.get(\\\"username\\\");\\n    },\\n\\n    /**\\n     * Calls set(\\\"username\\\", username, options) and returns the result.\\n     * @param {String} username\\n     * @param {Object} options A Backbone-style options object.\\n     * @return {Boolean}\\n     * @see Parse.Object.set\\n     */\\n    setUsername: function(username, options) {\\n      return this.set(\\\"username\\\", username, options);\\n    },\\n\\n    /**\\n     * Calls set(\\\"password\\\", password, options) and returns the result.\\n     * @param {String} password\\n     * @param {Object} options A Backbone-style options object.\\n     * @return {Boolean}\\n     * @see Parse.Object.set\\n     */\\n    setPassword: function(password, options) {\\n      return this.set(\\\"password\\\", password, options);\\n    },\\n\\n    /**\\n     * Returns get(\\\"email\\\").\\n     * @return {String}\\n     * @see Parse.Object#get\\n     */\\n    getEmail: function() {\\n      return this.get(\\\"email\\\");\\n    },\\n\\n    /**\\n     * Calls set(\\\"email\\\", email, options) and returns the result.\\n     * @param {String} email\\n     * @param {Object} options A Backbone-style options object.\\n     * @return {Boolean}\\n     * @see Parse.Object.set\\n     */\\n    setEmail: function(email, options) {\\n      return this.set(\\\"email\\\", email, options);\\n    },\\n\\n    /**\\n     * Checks whether this user is the current user and has been authenticated.\\n     * @return (Boolean) whether this user is the current user and is logged in.\\n     */\\n    authenticated: function() {\\n      return !!this._sessionToken &&\\n          (Parse.User.current() && Parse.User.current().id === this.id);\\n    },\\n\\n    /**\\n     * Returns the session token for this user, if the user has been logged in,\\n     * or if it is the result of a query with the master key. Otherwise, returns\\n     * undefined.\\n     * @return {String} the session token, or undefined\\n     */\\n    getSessionToken: function() {\\n      return this._sessionToken;\\n    }\\n\\n  }, /** @lends Parse.User */ {\\n    // Class Variables\\n\\n    // The currently logged-in user.\\n    _currentUser: null,\\n\\n    // Whether currentUser is known to match the serialized version on disk.\\n    // This is useful for saving a localstorage check if you try to load\\n    // _currentUser frequently while there is none stored.\\n    _currentUserMatchesDisk: false,\\n\\n    // The localStorage key suffix that the current user is stored under.\\n    _CURRENT_USER_KEY: \\\"currentUser\\\",\\n\\n    // The mapping of auth provider names to actual providers\\n    _authProviders: {},\\n\\n    // Whether to rewrite className User to _User\\n    _performUserRewrite: true,\\n\\n\\n    // Class Methods\\n\\n    /**\\n     * Signs up a new user with a username (or email) and password.\\n     * This will create a new Parse.User on the server, and also persist the\\n     * session in localStorage so that you can access the user using\\n     * {@link #current}.\\n     *\\n     * <p>Calls options.success or options.error on completion.</p>\\n     *\\n     * @param {String} username The username (or email) to sign up with.\\n     * @param {String} password The password to sign up with.\\n     * @param {Object} attrs Extra fields to set on the new user.\\n     * @param {Object} options A Backbone-style options object.\\n     * @return {Parse.Promise} A promise that is fulfilled with the user when\\n     *     the signup completes.\\n     * @see Parse.User#signUp\\n     */\\n    signUp: function(username, password, attrs, options) {\\n      attrs = attrs || {};\\n      attrs.username = username;\\n      attrs.password = password;\\n      var user = Parse.Object._create(\\\"_User\\\");\\n      return user.signUp(attrs, options);\\n    },\\n\\n    /**\\n     * Logs in a user with a username (or email) and password. On success, this\\n     * saves the session to disk, so you can retrieve the currently logged in\\n     * user using <code>current</code>.\\n     *\\n     * <p>Calls options.success or options.error on completion.</p>\\n     *\\n     * @param {String} username The username (or email) to log in with.\\n     * @param {String} password The password to log in with.\\n     * @param {Object} options A Backbone-style options object.\\n     * @return {Parse.Promise} A promise that is fulfilled with the user when\\n     *     the login completes.\\n     * @see Parse.User#logIn\\n     */\\n    logIn: function(username, password, options) {\\n      var user = Parse.Object._create(\\\"_User\\\");\\n      user._finishFetch({ username: username, password: password });\\n      return user.logIn(options);\\n    },\\n\\n    /**\\n     * Logs in a user with a session token. On success, this saves the session\\n     * to disk, so you can retrieve the currently logged in user using\\n     * <code>current</code>.\\n     *\\n     * <p>Calls options.success or options.error on completion.</p>\\n     *\\n     * @param {String} sessionToken The sessionToken to log in with.\\n     * @param {Object} options A Backbone-style options object.\\n     * @return {Parse.Promise} A promise that is fulfilled with the user when\\n     *     the login completes.\\n     */\\n    become: function(sessionToken, options) {\\n      options = options || {};\\n\\n      var user = Parse.Object._create(\\\"_User\\\");\\n      return Parse._request({\\n        route: \\\"users\\\",\\n        className: \\\"me\\\",\\n        method: \\\"GET\\\",\\n        useMasterKey: options.useMasterKey,\\n        sessionToken: sessionToken\\n      }).then(function(resp, status, xhr) {\\n        var serverAttrs = user.parse(resp, status, xhr);\\n        user._finishFetch(serverAttrs);\\n        user._handleSaveResult(true);\\n        return user;\\n\\n      })._thenRunCallbacks(options, user);\\n    },\\n\\n    /**\\n     * Logs out the currently logged in user session. This will remove the\\n     * session from disk, log out of linked services, and future calls to\\n     * <code>current</code> will return <code>null</code>.\\n     */\\n    logOut: function() {\\n      if (Parse.User._currentUser !== null) {\\n        Parse.User._currentUser._logOutWithAll();\\n        Parse.User._currentUser._isCurrentUser = false;\\n      }\\n      Parse.User._currentUserMatchesDisk = true;\\n      Parse.User._currentUser = null;\\n      Parse.localStorage.removeItem(\\n          Parse._getParsePath(Parse.User._CURRENT_USER_KEY));\\n    },\\n\\n    /**\\n     * Requests a password reset email to be sent to the specified email address\\n     * associated with the user account. This email allows the user to securely\\n     * reset their password on the Parse site.\\n     *\\n     * <p>Calls options.success or options.error on completion.</p>\\n     *\\n     * @param {String} email The email address associated with the user that\\n     *     forgot their password.\\n     * @param {Object} options A Backbone-style options object.\\n     */\\n    requestPasswordReset: function(email, options) {\\n      options = options || {};\\n      var request = Parse._request({\\n        route: \\\"requestPasswordReset\\\",\\n        method: \\\"POST\\\",\\n        useMasterKey: options.useMasterKey,\\n        data: { email: email }\\n      });\\n      return request._thenRunCallbacks(options);\\n    },\\n\\n    /**\\n     * Retrieves the currently logged in ParseUser with a valid session,\\n     * either from memory or localStorage, if necessary.\\n     * @return {Parse.Object} The currently logged in Parse.User.\\n     */\\n    current: function() {\\n      if (Parse.User._currentUser) {\\n        return Parse.User._currentUser;\\n      }\\n\\n      if (Parse.User._currentUserMatchesDisk) {\\n\\n        return Parse.User._currentUser;\\n      }\\n\\n      // Load the user from local storage.\\n      Parse.User._currentUserMatchesDisk = true;\\n\\n      var userData = Parse.localStorage.getItem(Parse._getParsePath(\\n          Parse.User._CURRENT_USER_KEY));\\n      if (!userData) {\\n\\n        return null;\\n      }\\n      Parse.User._currentUser = Parse.Object._create(\\\"_User\\\");\\n      Parse.User._currentUser._isCurrentUser = true;\\n\\n      var json = JSON.parse(userData);\\n      Parse.User._currentUser.id = json._id;\\n      delete json._id;\\n      Parse.User._currentUser._sessionToken = json._sessionToken;\\n      delete json._sessionToken;\\n      Parse.User._currentUser._finishFetch(json);\\n\\n      Parse.User._currentUser._synchronizeAllAuthData();\\n      Parse.User._currentUser._refreshCache();\\n      Parse.User._currentUser._opSetQueue = [{}];\\n      return Parse.User._currentUser;\\n    },\\n\\n    /**\\n     * Allow someone to define a custom User class without className\\n     * being rewritten to _User. The default behavior is to rewrite\\n     * User to _User for legacy reasons. This allows developers to\\n     * override that behavior.\\n     *\\n     * @param {Boolean} isAllowed Whether or not to allow custom User class\\n     */\\n    allowCustomUserClass: function(isAllowed) {\\n      this._performUserRewrite = !isAllowed;\\n    },\\n\\n    /**\\n     * Persists a user as currentUser to localStorage, and into the singleton.\\n     */\\n    _saveCurrentUser: function(user) {\\n      if (Parse.User._currentUser !== user) {\\n        Parse.User.logOut();\\n      }\\n      user._isCurrentUser = true;\\n      Parse.User._currentUser = user;\\n      Parse.User._currentUserMatchesDisk = true;\\n\\n      var json = user.toJSON();\\n      json._id = user.id;\\n      json._sessionToken = user._sessionToken;\\n      Parse.localStorage.setItem(\\n          Parse._getParsePath(Parse.User._CURRENT_USER_KEY),\\n          JSON.stringify(json));\\n    },\\n\\n    _registerAuthenticationProvider: function(provider) {\\n      Parse.User._authProviders[provider.getAuthType()] = provider;\\n      // Synchronize the current user with the auth provider.\\n      if (Parse.User.current()) {\\n        Parse.User.current()._synchronizeAuthData(provider.getAuthType());\\n      }\\n    },\\n\\n    _logInWith: function(provider, options) {\\n      var user = Parse.Object._create(\\\"_User\\\");\\n      return user._linkWith(provider, options);\\n    }\\n\\n  });\\n}(this));\\n\\n\\n// Parse.Query is a way to create a list of Parse.Objects.\\n(function(root) {\\n  root.Parse = root.Parse || {};\\n  var Parse = root.Parse;\\n  var _ = Parse._;\\n\\n  /**\\n   * Creates a new parse Parse.Query for the given Parse.Object subclass.\\n   * @param objectClass -\\n   *   An instance of a subclass of Parse.Object, or a Parse className string.\\n   * @class\\n   *\\n   * <p>Parse.Query defines a query that is used to fetch Parse.Objects. The\\n   * most common use case is finding all objects that match a query through the\\n   * <code>find</code> method. For example, this sample code fetches all objects\\n   * of class <code>MyClass</code>. It calls a different function depending on\\n   * whether the fetch succeeded or not.\\n   *\\n   * <pre>\\n   * var query = new Parse.Query(MyClass);\\n   * query.find({\\n   *   success: function(results) {\\n   *     // results is an array of Parse.Object.\\n   *   },\\n   *\\n   *   error: function(error) {\\n   *     // error is an instance of Parse.Error.\\n   *   }\\n   * });</pre></p>\\n   *\\n   * <p>A Parse.Query can also be used to retrieve a single object whose id is\\n   * known, through the get method. For example, this sample code fetches an\\n   * object of class <code>MyClass</code> and id <code>myId</code>. It calls a\\n   * different function depending on whether the fetch succeeded or not.\\n   *\\n   * <pre>\\n   * var query = new Parse.Query(MyClass);\\n   * query.get(myId, {\\n   *   success: function(object) {\\n   *     // object is an instance of Parse.Object.\\n   *   },\\n   *\\n   *   error: function(object, error) {\\n   *     // error is an instance of Parse.Error.\\n   *   }\\n   * });</pre></p>\\n   *\\n   * <p>A Parse.Query can also be used to count the number of objects that match\\n   * the query without retrieving all of those objects. For example, this\\n   * sample code counts the number of objects of the class <code>MyClass</code>\\n   * <pre>\\n   * var query = new Parse.Query(MyClass);\\n   * query.count({\\n   *   success: function(number) {\\n   *     // There are number instances of MyClass.\\n   *   },\\n   *\\n   *   error: function(error) {\\n   *     // error is an instance of Parse.Error.\\n   *   }\\n   * });</pre></p>\\n   */\\n  Parse.Query = function(objectClass) {\\n    if (_.isString(objectClass)) {\\n      objectClass = Parse.Object._getSubclass(objectClass);\\n    }\\n\\n    this.objectClass = objectClass;\\n\\n    this.className = objectClass.prototype.className;\\n\\n    this._where = {};\\n    this._include = [];\\n    this._limit = -1; // negative limit means, do not send a limit\\n    this._skip = 0;\\n    this._extraOptions = {};\\n  };\\n\\n  /**\\n   * Constructs a Parse.Query that is the OR of the passed in queries.  For\\n   * example:\\n   * <pre>var compoundQuery = Parse.Query.or(query1, query2, query3);</pre>\\n   *\\n   * will create a compoundQuery that is an or of the query1, query2, and\\n   * query3.\\n   * @param {...Parse.Query} var_args The list of queries to OR.\\n   * @return {Parse.Query} The query that is the OR of the passed in queries.\\n   */\\n  Parse.Query.or = function() {\\n    var queries = _.toArray(arguments);\\n    var className = null;\\n    Parse._arrayEach(queries, function(q) {\\n      if (_.isNull(className)) {\\n        className = q.className;\\n      }\\n\\n      if (className !== q.className) {\\n        throw \\\"All queries must be for the same class\\\";\\n      }\\n    });\\n    var query = new Parse.Query(className);\\n    query._orQuery(queries);\\n    return query;\\n  };\\n\\n  Parse.Query.prototype = {\\n    /**\\n     * Constructs a Parse.Object whose id is already known by fetching data from\\n     * the server.  Either options.success or options.error is called when the\\n     * find completes.\\n     *\\n     * @param {String} objectId The id of the object to be fetched.\\n     * @param {Object} options A Backbone-style options object.\\n     * Valid options are:<ul>\\n     *   <li>success: A Backbone-style success callback\\n     *   <li>error: An Backbone-style error callback.\\n     *   <li>useMasterKey: In Cloud Code and Node only, causes the Master Key to\\n     *     be used for this request.\\n     * </ul>\\n     */\\n    get: function(objectId, options) {\\n      var self = this;\\n      self.equalTo('objectId', objectId);\\n\\n      var firstOptions = {};\\n      if (options && _.has(options, 'useMasterKey')) {\\n        firstOptions = { useMasterKey: options.useMasterKey };\\n      }\\n\\n      return self.first(firstOptions).then(function(response) {\\n        if (response) {\\n          return response;\\n        }\\n\\n        var errorObject = new Parse.Error(Parse.Error.OBJECT_NOT_FOUND,\\n                                          \\\"Object not found.\\\");\\n        return Parse.Promise.error(errorObject);\\n\\n      })._thenRunCallbacks(options, null);\\n    },\\n\\n    /**\\n     * Returns a JSON representation of this query.\\n     * @return {Object} The JSON representation of the query.\\n     */\\n    toJSON: function() {\\n      var params = {\\n        where: this._where\\n      };\\n\\n      if (this._include.length > 0) {\\n        params.include = this._include.join(\\\",\\\");\\n      }\\n      if (this._select) {\\n        params.keys = this._select.join(\\\",\\\");\\n      }\\n      if (this._limit >= 0) {\\n        params.limit = this._limit;\\n      }\\n      if (this._skip > 0) {\\n        params.skip = this._skip;\\n      }\\n      if (this._order !== undefined) {\\n        params.order = this._order.join(\\\",\\\");\\n      }\\n\\n      Parse._objectEach(this._extraOptions, function(v, k) {\\n        params[k] = v;\\n      });\\n\\n      return params;\\n    },\\n\\n    /**\\n     * Retrieves a list of ParseObjects that satisfy this query.\\n     * Either options.success or options.error is called when the find\\n     * completes.\\n     *\\n     * @param {Object} options A Backbone-style options object. Valid options\\n     * are:<ul>\\n     *   <li>success: Function to call when the find completes successfully.\\n     *   <li>error: Function to call when the find fails.\\n     *   <li>useMasterKey: In Cloud Code and Node only, causes the Master Key to\\n     *     be used for this request.\\n     * </ul>\\n     *\\n     * @return {Parse.Promise} A promise that is resolved with the results when\\n     * the query completes.\\n     */\\n    find: function(options) {\\n      var self = this;\\n      options = options || {};\\n\\n      var request = Parse._request({\\n        route: \\\"classes\\\",\\n        className: this.className,\\n        method: \\\"GET\\\",\\n        useMasterKey: options.useMasterKey,\\n        data: this.toJSON()\\n      });\\n\\n      return request.then(function(response) {\\n        return _.map(response.results, function(json) {\\n          var obj;\\n          if (response.className) {\\n            obj = new Parse.Object(response.className);\\n          } else {\\n            obj = new self.objectClass();\\n          }\\n          obj._finishFetch(json, true);\\n          return obj;\\n        });\\n      })._thenRunCallbacks(options);\\n    },\\n\\n    /**\\n     * Counts the number of objects that match this query.\\n     * Either options.success or options.error is called when the count\\n     * completes.\\n     *\\n     * @param {Object} options A Backbone-style options object. Valid options\\n     * are:<ul>\\n     *   <li>success: Function to call when the count completes successfully.\\n     *   <li>error: Function to call when the find fails.\\n     *   <li>useMasterKey: In Cloud Code and Node only, causes the Master Key to\\n     *     be used for this request.\\n     * </ul>\\n     *\\n     * @return {Parse.Promise} A promise that is resolved with the count when\\n     * the query completes.\\n     */\\n    count: function(options) {\\n      var self = this;\\n      options = options || {};\\n\\n      var params = this.toJSON();\\n      params.limit = 0;\\n      params.count = 1;\\n      var request = Parse._request({\\n        route: \\\"classes\\\",\\n        className: self.className,\\n        method: \\\"GET\\\",\\n        useMasterKey: options.useMasterKey,\\n        data: params\\n      });\\n\\n      return request.then(function(response) {\\n        return response.count;\\n      })._thenRunCallbacks(options);\\n    },\\n\\n    /**\\n     * Retrieves at most one Parse.Object that satisfies this query.\\n     *\\n     * Either options.success or options.error is called when it completes.\\n     * success is passed the object if there is one. otherwise, undefined.\\n     *\\n     * @param {Object} options A Backbone-style options object. Valid options\\n     * are:<ul>\\n     *   <li>success: Function to call when the find completes successfully.\\n     *   <li>error: Function to call when the find fails.\\n     *   <li>useMasterKey: In Cloud Code and Node only, causes the Master Key to\\n     *     be used for this request.\\n     * </ul>\\n     *\\n     * @return {Parse.Promise} A promise that is resolved with the object when\\n     * the query completes.\\n     */\\n    first: function(options) {\\n      var self = this;\\n      options = options || {};\\n\\n      var params = this.toJSON();\\n      params.limit = 1;\\n      var request = Parse._request({\\n        route: \\\"classes\\\",\\n        className: this.className,\\n        method: \\\"GET\\\",\\n        useMasterKey: options.useMasterKey,\\n        data: params\\n      });\\n\\n      return request.then(function(response) {\\n        return _.map(response.results, function(json) {\\n          var obj = new self.objectClass();\\n          obj._finishFetch(json, true);\\n          return obj;\\n        })[0];\\n      })._thenRunCallbacks(options);\\n    },\\n\\n    /**\\n     * Returns a new instance of Parse.Collection backed by this query.\\n     * @param {Array} items An array of instances of <code>Parse.Object</code>\\n     *     with which to start this Collection.\\n     * @param {Object} options An optional object with Backbone-style options.\\n     * Valid options are:<ul>\\n     *   <li>model: The Parse.Object subclass that this collection contains.\\n     *   <li>query: An instance of Parse.Query to use when fetching items.\\n     *   <li>comparator: A string property name or function to sort by.\\n     * </ul>\\n     * @return {Parse.Collection}\\n     */\\n    collection: function(items, options) {\\n      options = options || {};\\n      return new Parse.Collection(items, _.extend(options, {\\n        model: this.objectClass,\\n        query: this\\n      }));\\n    },\\n\\n    /**\\n     * Sets the number of results to skip before returning any results.\\n     * This is useful for pagination.\\n     * Default is to skip zero results.\\n     * @param {Number} n the number of results to skip.\\n     * @return {Parse.Query} Returns the query, so you can chain this call.\\n     */\\n    skip: function(n) {\\n      this._skip = n;\\n      return this;\\n    },\\n\\n    /**\\n     * Sets the limit of the number of results to return. The default limit is\\n     * 100, with a maximum of 1000 results being returned at a time.\\n     * @param {Number} n the number of results to limit to.\\n     * @return {Parse.Query} Returns the query, so you can chain this call.\\n     */\\n    limit: function(n) {\\n      this._limit = n;\\n      return this;\\n    },\\n\\n    /**\\n     * Add a constraint to the query that requires a particular key's value to\\n     * be equal to the provided value.\\n     * @param {String} key The key to check.\\n     * @param value The value that the Parse.Object must contain.\\n     * @return {Parse.Query} Returns the query, so you can chain this call.\\n     */\\n    equalTo: function(key, value) {\\n      if (_.isUndefined(value)) {\\n        return this.doesNotExist(key);\\n      }\\n\\n      this._where[key] = Parse._encode(value);\\n      return this;\\n    },\\n\\n    /**\\n     * Helper for condition queries\\n     */\\n    _addCondition: function(key, condition, value) {\\n      // Check if we already have a condition\\n      if (!this._where[key]) {\\n        this._where[key] = {};\\n      }\\n      this._where[key][condition] = Parse._encode(value);\\n      return this;\\n    },\\n\\n    /**\\n     * Add a constraint to the query that requires a particular key's value to\\n     * be not equal to the provided value.\\n     * @param {String} key The key to check.\\n     * @param value The value that must not be equalled.\\n     * @return {Parse.Query} Returns the query, so you can chain this call.\\n     */\\n    notEqualTo: function(key, value) {\\n      this._addCondition(key, \\\"$ne\\\", value);\\n      return this;\\n    },\\n\\n    /**\\n     * Add a constraint to the query that requires a particular key's value to\\n     * be less than the provided value.\\n     * @param {String} key The key to check.\\n     * @param value The value that provides an upper bound.\\n     * @return {Parse.Query} Returns the query, so you can chain this call.\\n     */\\n    lessThan: function(key, value) {\\n      this._addCondition(key, \\\"$lt\\\", value);\\n      return this;\\n    },\\n\\n    /**\\n     * Add a constraint to the query that requires a particular key's value to\\n     * be greater than the provided value.\\n     * @param {String} key The key to check.\\n     * @param value The value that provides an lower bound.\\n     * @return {Parse.Query} Returns the query, so you can chain this call.\\n     */\\n    greaterThan: function(key, value) {\\n      this._addCondition(key, \\\"$gt\\\", value);\\n      return this;\\n    },\\n\\n    /**\\n     * Add a constraint to the query that requires a particular key's value to\\n     * be less than or equal to the provided value.\\n     * @param {String} key The key to check.\\n     * @param value The value that provides an upper bound.\\n     * @return {Parse.Query} Returns the query, so you can chain this call.\\n     */\\n    lessThanOrEqualTo: function(key, value) {\\n      this._addCondition(key, \\\"$lte\\\", value);\\n      return this;\\n    },\\n\\n    /**\\n     * Add a constraint to the query that requires a particular key's value to\\n     * be greater than or equal to the provided value.\\n     * @param {String} key The key to check.\\n     * @param value The value that provides an lower bound.\\n     * @return {Parse.Query} Returns the query, so you can chain this call.\\n     */\\n    greaterThanOrEqualTo: function(key, value) {\\n      this._addCondition(key, \\\"$gte\\\", value);\\n      return this;\\n    },\\n\\n    /**\\n     * Add a constraint to the query that requires a particular key's value to\\n     * be contained in the provided list of values.\\n     * @param {String} key The key to check.\\n     * @param {Array} values The values that will match.\\n     * @return {Parse.Query} Returns the query, so you can chain this call.\\n     */\\n    containedIn: function(key, values) {\\n      this._addCondition(key, \\\"$in\\\", values);\\n      return this;\\n    },\\n\\n    /**\\n     * Add a constraint to the query that requires a particular key's value to\\n     * not be contained in the provided list of values.\\n     * @param {String} key The key to check.\\n     * @param {Array} values The values that will not match.\\n     * @return {Parse.Query} Returns the query, so you can chain this call.\\n     */\\n    notContainedIn: function(key, values) {\\n      this._addCondition(key, \\\"$nin\\\", values);\\n      return this;\\n    },\\n\\n    /**\\n     * Add a constraint to the query that requires a particular key's value to\\n     * contain each one of the provided list of values.\\n     * @param {String} key The key to check.  This key's value must be an array.\\n     * @param {Array} values The values that will match.\\n     * @return {Parse.Query} Returns the query, so you can chain this call.\\n     */\\n    containsAll: function(key, values) {\\n      this._addCondition(key, \\\"$all\\\", values);\\n      return this;\\n    },\\n\\n\\n    /**\\n     * Add a constraint for finding objects that contain the given key.\\n     * @param {String} key The key that should exist.\\n     * @return {Parse.Query} Returns the query, so you can chain this call.\\n     */\\n    exists: function(key) {\\n      this._addCondition(key, \\\"$exists\\\", true);\\n      return this;\\n    },\\n\\n    /**\\n     * Add a constraint for finding objects that do not contain a given key.\\n     * @param {String} key The key that should not exist\\n     * @return {Parse.Query} Returns the query, so you can chain this call.\\n     */\\n    doesNotExist: function(key) {\\n      this._addCondition(key, \\\"$exists\\\", false);\\n      return this;\\n    },\\n\\n    /**\\n     * Add a regular expression constraint for finding string values that match\\n     * the provided regular expression.\\n     * This may be slow for large datasets.\\n     * @param {String} key The key that the string to match is stored in.\\n     * @param {RegExp} regex The regular expression pattern to match.\\n     * @return {Parse.Query} Returns the query, so you can chain this call.\\n     */\\n    matches: function(key, regex, modifiers) {\\n      this._addCondition(key, \\\"$regex\\\", regex);\\n      if (!modifiers) { modifiers = \\\"\\\"; }\\n      // Javascript regex options support mig as inline options but store them\\n      // as properties of the object. We support mi & should migrate them to\\n      // modifiers\\n      if (regex.ignoreCase) { modifiers += 'i'; }\\n      if (regex.multiline) { modifiers += 'm'; }\\n\\n      if (modifiers && modifiers.length) {\\n        this._addCondition(key, \\\"$options\\\", modifiers);\\n      }\\n      return this;\\n    },\\n\\n    /**\\n     * Add a constraint that requires that a key's value matches a Parse.Query\\n     * constraint.\\n     * @param {String} key The key that the contains the object to match the\\n     *                     query.\\n     * @param {Parse.Query} query The query that should match.\\n     * @return {Parse.Query} Returns the query, so you can chain this call.\\n     */\\n    matchesQuery: function(key, query) {\\n      var queryJSON = query.toJSON();\\n      queryJSON.className = query.className;\\n      this._addCondition(key, \\\"$inQuery\\\", queryJSON);\\n      return this;\\n    },\\n\\n   /**\\n     * Add a constraint that requires that a key's value not matches a\\n     * Parse.Query constraint.\\n     * @param {String} key The key that the contains the object to match the\\n     *                     query.\\n     * @param {Parse.Query} query The query that should not match.\\n     * @return {Parse.Query} Returns the query, so you can chain this call.\\n     */\\n    doesNotMatchQuery: function(key, query) {\\n      var queryJSON = query.toJSON();\\n      queryJSON.className = query.className;\\n      this._addCondition(key, \\\"$notInQuery\\\", queryJSON);\\n      return this;\\n    },\\n\\n\\n    /**\\n     * Add a constraint that requires that a key's value matches a value in\\n     * an object returned by a different Parse.Query.\\n     * @param {String} key The key that contains the value that is being\\n     *                     matched.\\n     * @param {String} queryKey The key in the objects returned by the query to\\n     *                          match against.\\n     * @param {Parse.Query} query The query to run.\\n     * @return {Parse.Query} Returns the query, so you can chain this call.\\n     */\\n    matchesKeyInQuery: function(key, queryKey, query) {\\n      var queryJSON = query.toJSON();\\n      queryJSON.className = query.className;\\n      this._addCondition(key, \\\"$select\\\",\\n                         { key: queryKey, query: queryJSON });\\n      return this;\\n    },\\n\\n    /**\\n     * Add a constraint that requires that a key's value not match a value in\\n     * an object returned by a different Parse.Query.\\n     * @param {String} key The key that contains the value that is being\\n     *                     excluded.\\n     * @param {String} queryKey The key in the objects returned by the query to\\n     *                          match against.\\n     * @param {Parse.Query} query The query to run.\\n     * @return {Parse.Query} Returns the query, so you can chain this call.\\n     */\\n    doesNotMatchKeyInQuery: function(key, queryKey, query) {\\n      var queryJSON = query.toJSON();\\n      queryJSON.className = query.className;\\n      this._addCondition(key, \\\"$dontSelect\\\",\\n                         { key: queryKey, query: queryJSON });\\n      return this;\\n    },\\n\\n    /**\\n     * Add constraint that at least one of the passed in queries matches.\\n     * @param {Array} queries\\n     * @return {Parse.Query} Returns the query, so you can chain this call.\\n     */\\n    _orQuery: function(queries) {\\n      var queryJSON = _.map(queries, function(q) {\\n        return q.toJSON().where;\\n      });\\n\\n      this._where.$or = queryJSON;\\n      return this;\\n    },\\n\\n    /**\\n     * Converts a string into a regex that matches it.\\n     * Surrounding with \\\\Q .. \\\\E does this, we just need to escape \\\\E's in\\n     * the text separately.\\n     */\\n    _quote: function(s) {\\n      return \\\"\\\\\\\\Q\\\" + s.replace(\\\"\\\\\\\\E\\\", \\\"\\\\\\\\E\\\\\\\\\\\\\\\\E\\\\\\\\Q\\\") + \\\"\\\\\\\\E\\\";\\n    },\\n\\n    /**\\n     * Add a constraint for finding string values that contain a provided\\n     * string.  This may be slow for large datasets.\\n     * @param {String} key The key that the string to match is stored in.\\n     * @param {String} substring The substring that the value must contain.\\n     * @return {Parse.Query} Returns the query, so you can chain this call.\\n     */\\n    contains: function(key, value) {\\n      this._addCondition(key, \\\"$regex\\\", this._quote(value));\\n      return this;\\n    },\\n\\n    /**\\n     * Add a constraint for finding string values that start with a provided\\n     * string.  This query will use the backend index, so it will be fast even\\n     * for large datasets.\\n     * @param {String} key The key that the string to match is stored in.\\n     * @param {String} prefix The substring that the value must start with.\\n     * @return {Parse.Query} Returns the query, so you can chain this call.\\n     */\\n    startsWith: function(key, value) {\\n      this._addCondition(key, \\\"$regex\\\", \\\"^\\\" + this._quote(value));\\n      return this;\\n    },\\n\\n    /**\\n     * Add a constraint for finding string values that end with a provided\\n     * string.  This will be slow for large datasets.\\n     * @param {String} key The key that the string to match is stored in.\\n     * @param {String} suffix The substring that the value must end with.\\n     * @return {Parse.Query} Returns the query, so you can chain this call.\\n     */\\n    endsWith: function(key, value) {\\n      this._addCondition(key, \\\"$regex\\\", this._quote(value) + \\\"$\\\");\\n      return this;\\n    },\\n\\n    /**\\n     * Sorts the results in ascending order by the given key.\\n     *\\n     * @param {(String|String[]|...String} key The key to order by, which is a\\n     * string of comma separated values, or an Array of keys, or multiple keys.\\n     * @return {Parse.Query} Returns the query, so you can chain this call.\\n     */\\n    ascending: function() {\\n      this._order = [];\\n      return this.addAscending.apply(this, arguments);\\n    },\\n\\n    /**\\n     * Sorts the results in ascending order by the given key,\\n     * but can also add secondary sort descriptors without overwriting _order.\\n     *\\n     * @param {(String|String[]|...String} key The key to order by, which is a\\n     * string of comma separated values, or an Array of keys, or multiple keys.\\n     * @return {Parse.Query} Returns the query, so you can chain this call.\\n     */\\n    addAscending: function(key) {\\n      var self = this;\\n      if (!this._order) {\\n        this._order = [];\\n      }\\n      Parse._arrayEach(arguments, function(key) {\\n        if (Array.isArray(key)) {\\n          key = key.join();\\n        }\\n        self._order = self._order.concat(key.replace(/\\\\s/g, \\\"\\\").split(\\\",\\\"));\\n      });\\n      return this;\\n    },\\n\\n    /**\\n     * Sorts the results in descending order by the given key.\\n     *\\n     * @param {(String|String[]|...String} key The key to order by, which is a\\n     * string of comma separated values, or an Array of keys, or multiple keys.\\n     * @return {Parse.Query} Returns the query, so you can chain this call.\\n     */\\n    descending: function(key) {\\n      this._order = [];\\n      return this.addDescending.apply(this, arguments);\\n    },\\n\\n    /**\\n     * Sorts the results in descending order by the given key,\\n     * but can also add secondary sort descriptors without overwriting _order.\\n     *\\n     * @param {(String|String[]|...String} key The key to order by, which is a\\n     * string of comma separated values, or an Array of keys, or multiple keys.\\n     * @return {Parse.Query} Returns the query, so you can chain this call.\\n     */\\n    addDescending: function(key) {\\n      var self = this;\\n      if (!this._order) {\\n        this._order = [];\\n      }\\n      Parse._arrayEach(arguments, function(key) {\\n        if (Array.isArray(key)) {\\n          key = key.join();\\n        }\\n        self._order = self._order.concat(\\n          _.map(key.replace(/\\\\s/g, \\\"\\\").split(\\\",\\\"),\\n            function(k) { return \\\"-\\\" + k; }));\\n      });\\n      return this;\\n    },\\n\\n    /**\\n     * Add a proximity based constraint for finding objects with key point\\n     * values near the point given.\\n     * @param {String} key The key that the Parse.GeoPoint is stored in.\\n     * @param {Parse.GeoPoint} point The reference Parse.GeoPoint that is used.\\n     * @return {Parse.Query} Returns the query, so you can chain this call.\\n     */\\n    near: function(key, point) {\\n      if (!(point instanceof Parse.GeoPoint)) {\\n        // Try to cast it to a GeoPoint, so that near(\\\"loc\\\", [20,30]) works.\\n        point = new Parse.GeoPoint(point);\\n      }\\n      this._addCondition(key, \\\"$nearSphere\\\", point);\\n      return this;\\n    },\\n\\n    /**\\n     * Add a proximity based constraint for finding objects with key point\\n     * values near the point given and within the maximum distance given.\\n     * @param {String} key The key that the Parse.GeoPoint is stored in.\\n     * @param {Parse.GeoPoint} point The reference Parse.GeoPoint that is used.\\n     * @param {Number} maxDistance Maximum distance (in radians) of results to\\n     *   return.\\n     * @return {Parse.Query} Returns the query, so you can chain this call.\\n     */\\n    withinRadians: function(key, point, distance) {\\n      this.near(key, point);\\n      this._addCondition(key, \\\"$maxDistance\\\", distance);\\n      return this;\\n    },\\n\\n    /**\\n     * Add a proximity based constraint for finding objects with key point\\n     * values near the point given and within the maximum distance given.\\n     * Radius of earth used is 3958.8 miles.\\n     * @param {String} key The key that the Parse.GeoPoint is stored in.\\n     * @param {Parse.GeoPoint} point The reference Parse.GeoPoint that is used.\\n     * @param {Number} maxDistance Maximum distance (in miles) of results to\\n     *     return.\\n     * @return {Parse.Query} Returns the query, so you can chain this call.\\n     */\\n    withinMiles: function(key, point, distance) {\\n      return this.withinRadians(key, point, distance / 3958.8);\\n    },\\n\\n    /**\\n     * Add a proximity based constraint for finding objects with key point\\n     * values near the point given and within the maximum distance given.\\n     * Radius of earth used is 6371.0 kilometers.\\n     * @param {String} key The key that the Parse.GeoPoint is stored in.\\n     * @param {Parse.GeoPoint} point The reference Parse.GeoPoint that is used.\\n     * @param {Number} maxDistance Maximum distance (in kilometers) of results\\n     *     to return.\\n     * @return {Parse.Query} Returns the query, so you can chain this call.\\n     */\\n    withinKilometers: function(key, point, distance) {\\n      return this.withinRadians(key, point, distance / 6371.0);\\n    },\\n\\n    /**\\n     * Add a constraint to the query that requires a particular key's\\n     * coordinates be contained within a given rectangular geographic bounding\\n     * box.\\n     * @param {String} key The key to be constrained.\\n     * @param {Parse.GeoPoint} southwest\\n     *     The lower-left inclusive corner of the box.\\n     * @param {Parse.GeoPoint} northeast\\n     *     The upper-right inclusive corner of the box.\\n     * @return {Parse.Query} Returns the query, so you can chain this call.\\n     */\\n    withinGeoBox: function(key, southwest, northeast) {\\n      if (!(southwest instanceof Parse.GeoPoint)) {\\n        southwest = new Parse.GeoPoint(southwest);\\n      }\\n      if (!(northeast instanceof Parse.GeoPoint)) {\\n        northeast = new Parse.GeoPoint(northeast);\\n      }\\n      this._addCondition(key, '$within', { '$box': [southwest, northeast] });\\n      return this;\\n    },\\n\\n    /**\\n     * Include nested Parse.Objects for the provided key.  You can use dot\\n     * notation to specify which fields in the included object are also fetch.\\n     * @param {String} key The name of the key to include.\\n     * @return {Parse.Query} Returns the query, so you can chain this call.\\n     */\\n    include: function() {\\n      var self = this;\\n      Parse._arrayEach(arguments, function(key) {\\n        if (_.isArray(key)) {\\n          self._include = self._include.concat(key);\\n        } else {\\n          self._include.push(key);\\n        }\\n      });\\n      return this;\\n    },\\n\\n    /**\\n     * Restrict the fields of the returned Parse.Objects to include only the\\n     * provided keys.  If this is called multiple times, then all of the keys\\n     * specified in each of the calls will be included.\\n     * @param {Array} keys The names of the keys to include.\\n     * @return {Parse.Query} Returns the query, so you can chain this call.\\n     */\\n    select: function() {\\n      var self = this;\\n      this._select = this._select || [];\\n      Parse._arrayEach(arguments, function(key) {\\n        if (_.isArray(key)) {\\n          self._select = self._select.concat(key);\\n        } else {\\n          self._select.push(key);\\n        }\\n      });\\n      return this;\\n    },\\n\\n    /**\\n     * Iterates over each result of a query, calling a callback for each one. If\\n     * the callback returns a promise, the iteration will not continue until\\n     * that promise has been fulfilled. If the callback returns a rejected\\n     * promise, then iteration will stop with that error. The items are\\n     * processed in an unspecified order. The query may not have any sort order,\\n     * and may not use limit or skip.\\n     * @param {Function} callback Callback that will be called with each result\\n     *     of the query.\\n     * @param {Object} options An optional Backbone-like options object with\\n     *     success and error callbacks that will be invoked once the iteration\\n     *     has finished.\\n     * @return {Parse.Promise} A promise that will be fulfilled once the\\n     *     iteration has completed.\\n     */\\n    each: function(callback, options) {\\n      options = options || {};\\n\\n      if (this._order || this._skip || (this._limit >= 0)) {\\n        var error =\\n          \\\"Cannot iterate on a query with sort, skip, or limit.\\\";\\n        return Parse.Promise.error(error)._thenRunCallbacks(options);\\n      }\\n\\n      var promise = new Parse.Promise();\\n\\n      var query = new Parse.Query(this.objectClass);\\n      // We can override the batch size from the options.\\n      // This is undocumented, but useful for testing.\\n      query._limit = options.batchSize || 100;\\n      query._where = _.clone(this._where);\\n      query._include = _.clone(this._include);\\n\\n      query.ascending('objectId');\\n\\n      var finished = false;\\n      return Parse.Promise._continueWhile(function() {\\n        return !finished;\\n\\n      }, function() {\\n        return query.find().then(function(results) {\\n          var callbacksDone = Parse.Promise.as();\\n          Parse._.each(results, function(result) {\\n            callbacksDone = callbacksDone.then(function() {\\n              return callback(result);\\n            });\\n          });\\n\\n          return callbacksDone.then(function() {\\n            if (results.length >= query._limit) {\\n              query.greaterThan(\\\"objectId\\\", results[results.length - 1].id);\\n            } else {\\n              finished = true;\\n            }\\n          });\\n        });\\n      })._thenRunCallbacks(options);\\n    }\\n  };\\n\\n}(this));\\n\\n/*global FB: false , console: false*/\\n(function(root) {\\n  root.Parse = root.Parse || {};\\n  var Parse = root.Parse;\\n  var _ = Parse._;\\n\\n  var PUBLIC_KEY = \\\"*\\\";\\n\\n  var initialized = false;\\n  var requestedPermissions;\\n  var initOptions;\\n  var provider = {\\n    authenticate: function(options) {\\n      var self = this;\\n      FB.login(function(response) {\\n        if (response.authResponse) {\\n          if (options.success) {\\n            options.success(self, {\\n              id: response.authResponse.userID,\\n              access_token: response.authResponse.accessToken,\\n              expiration_date: new Date(response.authResponse.expiresIn * 1000 +\\n                  (new Date()).getTime()).toJSON()\\n            });\\n          }\\n        } else {\\n          if (options.error) {\\n            options.error(self, response);\\n          }\\n        }\\n      }, {\\n        scope: requestedPermissions\\n      });\\n    },\\n    restoreAuthentication: function(authData) {\\n      if (authData) {\\n        var authResponse = {\\n          userID: authData.id,\\n          accessToken: authData.access_token,\\n          expiresIn: (Parse._parseDate(authData.expiration_date).getTime() -\\n              (new Date()).getTime()) / 1000\\n        };\\n        var newOptions = _.clone(initOptions);\\n        newOptions.authResponse = authResponse;\\n\\n        // Suppress checks for login status from the browser.\\n        newOptions.status = false;\\n\\n        // If the user doesn't match the one known by the FB SDK, log out.\\n        // Most of the time, the users will match -- it's only in cases where\\n        // the FB SDK knows of a different user than the one being restored\\n        // from a Parse User that logged in with username/password.\\n        var existingResponse = FB.getAuthResponse();\\n        if (existingResponse &&\\n            existingResponse.userID !== authResponse.userID) {\\n          FB.logout();\\n        }\\n\\n        FB.init(newOptions);\\n      }\\n      return true;\\n    },\\n    getAuthType: function() {\\n      return \\\"facebook\\\";\\n    },\\n    deauthenticate: function() {\\n      this.restoreAuthentication(null);\\n    }\\n  };\\n\\n  /**\\n   * Provides a set of utilities for using Parse with Facebook.\\n   * @namespace\\n   * Provides a set of utilities for using Parse with Facebook.\\n   */\\n  Parse.FacebookUtils = {\\n    /**\\n     * Initializes Parse Facebook integration.  Call this function after you\\n     * have loaded the Facebook Javascript SDK with the same parameters\\n     * as you would pass to<code>\\n     * <a href=\\n     * \\\"https://developers.facebook.com/docs/reference/javascript/FB.init/\\\">\\n     * FB.init()</a></code>.  Parse.FacebookUtils will invoke FB.init() for you\\n     * with these arguments.\\n     *\\n     * @param {Object} options Facebook options argument as described here:\\n     *   <a href=\\n     *   \\\"https://developers.facebook.com/docs/reference/javascript/FB.init/\\\">\\n     *   FB.init()</a>. The status flag will be coerced to 'false' because it\\n     *   interferes with Parse Facebook integration. Call FB.getLoginStatus()\\n     *   explicitly if this behavior is required by your application.\\n     */\\n    init: function(options) {\\n      if (typeof(FB) === 'undefined') {\\n        throw \\\"The Facebook JavaScript SDK must be loaded before calling init.\\\";\\n      }\\n      initOptions = _.clone(options) || {};\\n      if (initOptions.status && typeof(console) !== \\\"undefined\\\") {\\n        var warn = console.warn || console.log || function() {};\\n        warn.call(console, \\\"The 'status' flag passed into\\\" +\\n          \\\" FB.init, when set to true, can interfere with Parse Facebook\\\" +\\n          \\\" integration, so it has been suppressed. Please call\\\" +\\n          \\\" FB.getLoginStatus() explicitly if you require this behavior.\\\");\\n      }\\n      initOptions.status = false;\\n      FB.init(initOptions);\\n      Parse.User._registerAuthenticationProvider(provider);\\n      initialized = true;\\n    },\\n\\n    /**\\n     * Gets whether the user has their account linked to Facebook.\\n     *\\n     * @param {Parse.User} user User to check for a facebook link.\\n     *     The user must be logged in on this device.\\n     * @return {Boolean} <code>true</code> if the user has their account\\n     *     linked to Facebook.\\n     */\\n    isLinked: function(user) {\\n      return user._isLinked(\\\"facebook\\\");\\n    },\\n\\n    /**\\n     * Logs in a user using Facebook. This method delegates to the Facebook\\n     * SDK to authenticate the user, and then automatically logs in (or\\n     * creates, in the case where it is a new user) a Parse.User.\\n     *\\n     * @param {String, Object} permissions The permissions required for Facebook\\n     *    log in.  This is a comma-separated string of permissions.\\n     *    Alternatively, supply a Facebook authData object as described in our\\n     *    REST API docs if you want to handle getting facebook auth tokens\\n     *    yourself.\\n     * @param {Object} options Standard options object with success and error\\n     *    callbacks.\\n     */\\n    logIn: function(permissions, options) {\\n      if (!permissions || _.isString(permissions)) {\\n        if (!initialized) {\\n          throw \\\"You must initialize FacebookUtils before calling logIn.\\\";\\n        }\\n        requestedPermissions = permissions;\\n        return Parse.User._logInWith(\\\"facebook\\\", options);\\n      } else {\\n        var newOptions = _.clone(options) || {};\\n        newOptions.authData = permissions;\\n        return Parse.User._logInWith(\\\"facebook\\\", newOptions);\\n      }\\n    },\\n\\n    /**\\n     * Links Facebook to an existing PFUser. This method delegates to the\\n     * Facebook SDK to authenticate the user, and then automatically links\\n     * the account to the Parse.User.\\n     *\\n     * @param {Parse.User} user User to link to Facebook. This must be the\\n     *     current user.\\n     * @param {String, Object} permissions The permissions required for Facebook\\n     *    log in.  This is a comma-separated string of permissions.\\n     *    Alternatively, supply a Facebook authData object as described in our\\n     *    REST API docs if you want to handle getting facebook auth tokens\\n     *    yourself.\\n     * @param {Object} options Standard options object with success and error\\n     *    callbacks.\\n     */\\n    link: function(user, permissions, options) {\\n      if (!permissions || _.isString(permissions)) {\\n        if (!initialized) {\\n          throw \\\"You must initialize FacebookUtils before calling link.\\\";\\n        }\\n        requestedPermissions = permissions;\\n        return user._linkWith(\\\"facebook\\\", options);\\n      } else {\\n        var newOptions = _.clone(options) || {};\\n        newOptions.authData = permissions;\\n        return user._linkWith(\\\"facebook\\\", newOptions);\\n      }\\n    },\\n\\n    /**\\n     * Unlinks the Parse.User from a Facebook account.\\n     *\\n     * @param {Parse.User} user User to unlink from Facebook. This must be the\\n     *     current user.\\n     * @param {Object} options Standard options object with success and error\\n     *    callbacks.\\n     */\\n    unlink: function(user, options) {\\n      if (!initialized) {\\n        throw \\\"You must initialize FacebookUtils before calling unlink.\\\";\\n      }\\n      return user._unlinkFrom(\\\"facebook\\\", options);\\n    }\\n  };\\n\\n}(this));\\n\\n/*global _: false, document: false, window: false, navigator: false */\\n(function(root) {\\n  root.Parse = root.Parse || {};\\n  var Parse = root.Parse;\\n  var _ = Parse._;\\n\\n  /**\\n   * History serves as a global router (per frame) to handle hashchange\\n   * events or pushState, match the appropriate route, and trigger\\n   * callbacks. You shouldn't ever have to create one of these yourself\\n   *  you should use the reference to <code>Parse.history</code>\\n   * that will be created for you automatically if you make use of\\n   * Routers with routes.\\n   * @class\\n   *\\n   * <p>A fork of Backbone.History, provided for your convenience.  If you\\n   * use this class, you must also include jQuery, or another library\\n   * that provides a jQuery-compatible $ function.  For more information,\\n   * see the <a href=\\\"http://documentcloud.github.com/backbone/#History\\\">\\n   * Backbone documentation</a>.</p>\\n   * <p><strong><em>Available in the client SDK only.</em></strong></p>\\n   */\\n  Parse.History = function() {\\n    this.handlers = [];\\n    _.bindAll(this, 'checkUrl');\\n  };\\n\\n  // Cached regex for cleaning leading hashes and slashes .\\n  var routeStripper = /^[#\\\\/]/;\\n\\n  // Cached regex for detecting MSIE.\\n  var isExplorer = /msie [\\\\w.]+/;\\n\\n  // Has the history handling already been started?\\n  Parse.History.started = false;\\n\\n  // Set up all inheritable **Parse.History** properties and methods.\\n  _.extend(Parse.History.prototype, Parse.Events,\\n           /** @lends Parse.History.prototype */ {\\n\\n    // The default interval to poll for hash changes, if necessary, is\\n    // twenty times a second.\\n    interval: 50,\\n\\n    // Gets the true hash value. Cannot use location.hash directly due to bug\\n    // in Firefox where location.hash will always be decoded.\\n    getHash: function(windowOverride) {\\n      var loc = windowOverride ? windowOverride.location : window.location;\\n      var match = loc.href.match(/#(.*)$/);\\n      return match ? match[1] : '';\\n    },\\n\\n    // Get the cross-browser normalized URL fragment, either from the URL,\\n    // the hash, or the override.\\n    getFragment: function(fragment, forcePushState) {\\n      if (Parse._isNullOrUndefined(fragment)) {\\n        if (this._hasPushState || forcePushState) {\\n          fragment = window.location.pathname;\\n          var search = window.location.search;\\n          if (search) {\\n            fragment += search;\\n          }\\n        } else {\\n          fragment = this.getHash();\\n        }\\n      }\\n      if (!fragment.indexOf(this.options.root)) {\\n        fragment = fragment.substr(this.options.root.length);\\n      }\\n      return fragment.replace(routeStripper, '');\\n    },\\n\\n    /**\\n     * Start the hash change handling, returning `true` if the current\\n     * URL matches an existing route, and `false` otherwise.\\n     */\\n    start: function(options) {\\n      if (Parse.History.started) {\\n        throw new Error(\\\"Parse.history has already been started\\\");\\n      }\\n      Parse.History.started = true;\\n\\n      // Figure out the initial configuration. Do we need an iframe?\\n      // Is pushState desired ... is it available?\\n      this.options = _.extend({}, {root: '/'}, this.options, options);\\n      this._wantsHashChange = this.options.hashChange !== false;\\n      this._wantsPushState = !!this.options.pushState;\\n      this._hasPushState = !!(this.options.pushState &&\\n                              window.history &&\\n                              window.history.pushState);\\n      var fragment = this.getFragment();\\n      var docMode = document.documentMode;\\n      var oldIE = (isExplorer.exec(navigator.userAgent.toLowerCase()) &&\\n                   (!docMode || docMode <= 7));\\n\\n      if (oldIE) {\\n        this.iframe = Parse.$('<iframe src=\\\"javascript:0\\\" tabindex=\\\"-1\\\" />')\\n                      .hide().appendTo('body')[0].contentWindow;\\n        this.navigate(fragment);\\n      }\\n\\n      // Depending on whether we're using pushState or hashes, and whether\\n      // 'onhashchange' is supported, determine how we check the URL state.\\n      if (this._hasPushState) {\\n        Parse.$(window).bind('popstate', this.checkUrl);\\n      } else if (this._wantsHashChange &&\\n                 ('onhashchange' in window) &&\\n                 !oldIE) {\\n        Parse.$(window).bind('hashchange', this.checkUrl);\\n      } else if (this._wantsHashChange) {\\n        this._checkUrlInterval = window.setInterval(this.checkUrl,\\n                                                    this.interval);\\n      }\\n\\n      // Determine if we need to change the base url, for a pushState link\\n      // opened by a non-pushState browser.\\n      this.fragment = fragment;\\n      var loc = window.location;\\n      var atRoot  = loc.pathname === this.options.root;\\n\\n      // If we've started off with a route from a `pushState`-enabled browser,\\n      // but we're currently in a browser that doesn't support it...\\n      if (this._wantsHashChange &&\\n          this._wantsPushState &&\\n          !this._hasPushState &&\\n          !atRoot) {\\n        this.fragment = this.getFragment(null, true);\\n        window.location.replace(this.options.root + '#' + this.fragment);\\n        // Return immediately as browser will do redirect to new url\\n        return true;\\n\\n      // Or if we've started out with a hash-based route, but we're currently\\n      // in a browser where it could be `pushState`-based instead...\\n      } else if (this._wantsPushState &&\\n                 this._hasPushState &&\\n                 atRoot &&\\n                 loc.hash) {\\n        this.fragment = this.getHash().replace(routeStripper, '');\\n        window.history.replaceState({}, document.title,\\n            loc.protocol + '//' + loc.host + this.options.root + this.fragment);\\n      }\\n\\n      if (!this.options.silent) {\\n        return this.loadUrl();\\n      }\\n    },\\n\\n    // Disable Parse.history, perhaps temporarily. Not useful in a real app,\\n    // but possibly useful for unit testing Routers.\\n    stop: function() {\\n      Parse.$(window).unbind('popstate', this.checkUrl)\\n                     .unbind('hashchange', this.checkUrl);\\n      window.clearInterval(this._checkUrlInterval);\\n      Parse.History.started = false;\\n    },\\n\\n    // Add a route to be tested when the fragment changes. Routes added later\\n    // may override previous routes.\\n    route: function(route, callback) {\\n      this.handlers.unshift({route: route, callback: callback});\\n    },\\n\\n    // Checks the current URL to see if it has changed, and if it has,\\n    // calls `loadUrl`, normalizing across the hidden iframe.\\n    checkUrl: function(e) {\\n      var current = this.getFragment();\\n      if (current === this.fragment && this.iframe) {\\n        current = this.getFragment(this.getHash(this.iframe));\\n      }\\n      if (current === this.fragment) {\\n        return false;\\n      }\\n      if (this.iframe) {\\n        this.navigate(current);\\n      }\\n      if (!this.loadUrl()) {\\n        this.loadUrl(this.getHash());\\n      }\\n    },\\n\\n    // Attempt to load the current URL fragment. If a route succeeds with a\\n    // match, returns `true`. If no defined routes matches the fragment,\\n    // returns `false`.\\n    loadUrl: function(fragmentOverride) {\\n      var fragment = this.fragment = this.getFragment(fragmentOverride);\\n      var matched = _.any(this.handlers, function(handler) {\\n        if (handler.route.test(fragment)) {\\n          handler.callback(fragment);\\n          return true;\\n        }\\n      });\\n      return matched;\\n    },\\n\\n    // Save a fragment into the hash history, or replace the URL state if the\\n    // 'replace' option is passed. You are responsible for properly URL-encoding\\n    // the fragment in advance.\\n    //\\n    // The options object can contain `trigger: true` if you wish to have the\\n    // route callback be fired (not usually desirable), or `replace: true`, if\\n    // you wish to modify the current URL without adding an entry to the\\n    // history.\\n    navigate: function(fragment, options) {\\n      if (!Parse.History.started) {\\n        return false;\\n      }\\n      if (!options || options === true) {\\n        options = {trigger: options};\\n      }\\n      var frag = (fragment || '').replace(routeStripper, '');\\n      if (this.fragment === frag) {\\n        return;\\n      }\\n\\n      // If pushState is available, we use it to set the fragment as a real URL.\\n      if (this._hasPushState) {\\n        if (frag.indexOf(this.options.root) !== 0) {\\n          frag = this.options.root + frag;\\n        }\\n        this.fragment = frag;\\n        var replaceOrPush = options.replace ? 'replaceState' : 'pushState';\\n        window.history[replaceOrPush]({}, document.title, frag);\\n\\n      // If hash changes haven't been explicitly disabled, update the hash\\n      // fragment to store history.\\n      } else if (this._wantsHashChange) {\\n        this.fragment = frag;\\n        this._updateHash(window.location, frag, options.replace);\\n        if (this.iframe &&\\n            (frag !== this.getFragment(this.getHash(this.iframe)))) {\\n          // Opening and closing the iframe tricks IE7 and earlier\\n          // to push a history entry on hash-tag change.\\n          // When replace is true, we don't want this.\\n          if (!options.replace) {\\n            this.iframe.document.open().close();\\n          }\\n          this._updateHash(this.iframe.location, frag, options.replace);\\n        }\\n\\n      // If you've told us that you explicitly don't want fallback hashchange-\\n      // based history, then `navigate` becomes a page refresh.\\n      } else {\\n        window.location.assign(this.options.root + fragment);\\n      }\\n      if (options.trigger) {\\n        this.loadUrl(fragment);\\n      }\\n    },\\n\\n    // Update the hash location, either replacing the current entry, or adding\\n    // a new one to the browser history.\\n    _updateHash: function(location, fragment, replace) {\\n      if (replace) {\\n        var s = location.toString().replace(/(javascript:|#).*$/, '');\\n        location.replace(s + '#' + fragment);\\n      } else {\\n        location.hash = fragment;\\n      }\\n    }\\n  });\\n}(this));\\n\\n/*global _: false*/\\n(function(root) {\\n  root.Parse = root.Parse || {};\\n  var Parse = root.Parse;\\n  var _ = Parse._;\\n\\n  /**\\n   * Routers map faux-URLs to actions, and fire events when routes are\\n   * matched. Creating a new one sets its `routes` hash, if not set statically.\\n   * @class\\n   *\\n   * <p>A fork of Backbone.Router, provided for your convenience.\\n   * For more information, see the\\n   * <a href=\\\"http://documentcloud.github.com/backbone/#Router\\\">Backbone\\n   * documentation</a>.</p>\\n   * <p><strong><em>Available in the client SDK only.</em></strong></p>\\n   */\\n  Parse.Router = function(options) {\\n    options = options || {};\\n    if (options.routes) {\\n      this.routes = options.routes;\\n    }\\n    this._bindRoutes();\\n    this.initialize.apply(this, arguments);\\n  };\\n\\n  // Cached regular expressions for matching named param parts and splatted\\n  // parts of route strings.\\n  var namedParam    = /:\\\\w+/g;\\n  var splatParam    = /\\\\*\\\\w+/g;\\n  var escapeRegExp  = /[\\\\-\\\\[\\\\]{}()+?.,\\\\\\\\\\\\^\\\\$\\\\|#\\\\s]/g;\\n\\n  // Set up all inheritable **Parse.Router** properties and methods.\\n  _.extend(Parse.Router.prototype, Parse.Events,\\n           /** @lends Parse.Router.prototype */ {\\n\\n    /**\\n     * Initialize is an empty function by default. Override it with your own\\n     * initialization logic.\\n     */\\n    initialize: function(){},\\n\\n    /**\\n     * Manually bind a single named route to a callback. For example:\\n     *\\n     * <pre>this.route('search/:query/p:num', 'search', function(query, num) {\\n     *       ...\\n     *     });</pre>\\n     */\\n    route: function(route, name, callback) {\\n      Parse.history = Parse.history || new Parse.History();\\n      if (!_.isRegExp(route)) {\\n        route = this._routeToRegExp(route);\\n      }\\n      if (!callback) {\\n        callback = this[name];\\n      }\\n      Parse.history.route(route, _.bind(function(fragment) {\\n        var args = this._extractParameters(route, fragment);\\n        if (callback) {\\n          callback.apply(this, args);\\n        }\\n        this.trigger.apply(this, ['route:' + name].concat(args));\\n        Parse.history.trigger('route', this, name, args);\\n      }, this));\\n      return this;\\n    },\\n\\n    /**\\n     * Whenever you reach a point in your application that you'd\\n     * like to save as a URL, call navigate in order to update the\\n     * URL. If you wish to also call the route function, set the\\n     * trigger option to true. To update the URL without creating\\n     * an entry in the browser's history, set the replace option\\n     * to true.\\n     */\\n    navigate: function(fragment, options) {\\n      Parse.history.navigate(fragment, options);\\n    },\\n\\n    // Bind all defined routes to `Parse.history`. We have to reverse the\\n    // order of the routes here to support behavior where the most general\\n    // routes can be defined at the bottom of the route map.\\n    _bindRoutes: function() {\\n      if (!this.routes) {\\n        return;\\n      }\\n      var routes = [];\\n      for (var route in this.routes) {\\n        if (this.routes.hasOwnProperty(route)) {\\n          routes.unshift([route, this.routes[route]]);\\n        }\\n      }\\n      for (var i = 0, l = routes.length; i < l; i++) {\\n        this.route(routes[i][0], routes[i][1], this[routes[i][1]]);\\n      }\\n    },\\n\\n    // Convert a route string into a regular expression, suitable for matching\\n    // against the current location hash.\\n    _routeToRegExp: function(route) {\\n      route = route.replace(escapeRegExp, '\\\\\\\\$&')\\n                   .replace(namedParam, '([^\\\\/]+)')\\n                   .replace(splatParam, '(.*?)');\\n      return new RegExp('^' + route + '$');\\n    },\\n\\n    // Given a route, and a URL fragment that it matches, return the array of\\n    // extracted parameters.\\n    _extractParameters: function(route, fragment) {\\n      return route.exec(fragment).slice(1);\\n    }\\n  });\\n\\n  /**\\n   * @function\\n   * @param {Object} instanceProps Instance properties for the router.\\n   * @param {Object} classProps Class properies for the router.\\n   * @return {Class} A new subclass of <code>Parse.Router</code>.\\n   */\\n  Parse.Router.extend = Parse._extend;\\n}(this));\\n(function(root) {\\n  root.Parse = root.Parse || {};\\n  var Parse = root.Parse;\\n  var _ = Parse._;\\n\\n  /**\\n   * @namespace Contains functions for calling and declaring\\n   * <a href=\\\"/docs/cloud_code_guide#functions\\\">cloud functions</a>.\\n   * <p><strong><em>\\n   *   Some functions are only available from Cloud Code.\\n   * </em></strong></p>\\n   */\\n  Parse.Cloud = Parse.Cloud || {};\\n\\n  _.extend(Parse.Cloud, /** @lends Parse.Cloud */ {\\n    /**\\n     * Makes a call to a cloud function.\\n     * @param {String} name The function name.\\n     * @param {Object} data The parameters to send to the cloud function.\\n     * @param {Object} options A Backbone-style options object\\n     * options.success, if set, should be a function to handle a successful\\n     * call to a cloud function.  options.error should be a function that\\n     * handles an error running the cloud function.  Both functions are\\n     * optional.  Both functions take a single argument.\\n     * @return {Parse.Promise} A promise that will be resolved with the result\\n     * of the function.\\n     */\\n    run: function(name, data, options) {\\n      options = options || {};\\n\\n      var request = Parse._request({\\n        route: \\\"functions\\\",\\n        className: name,\\n        method: 'POST',\\n        useMasterKey: options.useMasterKey,\\n        data: Parse._encode(data, null, true)\\n      });\\n\\n      return request.then(function(resp) {\\n        return Parse._decode(null, resp).result;\\n      })._thenRunCallbacks(options);\\n    }\\n  });\\n}(this));\\n\\n(function(root) {\\n  root.Parse = root.Parse || {};\\n  var Parse = root.Parse;\\n\\n  Parse.Installation = Parse.Object.extend(\\\"_Installation\\\");\\n\\n  /**\\n   * Contains functions to deal with Push in Parse\\n   * @name Parse.Push\\n   * @namespace\\n   */\\n  Parse.Push = Parse.Push || {};\\n\\n  /**\\n   * Sends a push notification.\\n   * @param {Object} data -  The data of the push notification.  Valid fields\\n   * are:\\n   *   <ol>\\n   *     <li>channels - An Array of channels to push to.</li>\\n   *     <li>push_time - A Date object for when to send the push.</li>\\n   *     <li>expiration_time -  A Date object for when to expire\\n   *         the push.</li>\\n   *     <li>expiration_interval - The seconds from now to expire the push.</li>\\n   *     <li>where - A Parse.Query over Parse.Installation that is used to match\\n   *         a set of installations to push to.</li>\\n   *     <li>data - The data to send as part of the push</li>\\n   *   <ol>\\n   * @param {Object} options An object that has an optional success function,\\n   * that takes no arguments and will be called on a successful push, and\\n   * an error function that takes a Parse.Error and will be called if the push\\n   * failed.\\n   */\\n  Parse.Push.send = function(data, options) {\\n    options = options || {};\\n\\n    if (data.where) {\\n      data.where = data.where.toJSON().where;\\n    }\\n\\n    if (data.push_time) {\\n      data.push_time = data.push_time.toJSON();\\n    }\\n\\n    if (data.expiration_time) {\\n      data.expiration_time = data.expiration_time.toJSON();\\n    }\\n\\n    if (data.expiration_time && data.expiration_interval) {\\n      throw \\\"Both expiration_time and expiration_interval can't be set\\\";\\n    }\\n\\n    var request = Parse._request({\\n      route: 'push',\\n      method: 'POST',\\n      data: data,\\n      useMasterKey: options.useMasterKey\\n    });\\n    return request._thenRunCallbacks(options);\\n  };\\n}(this));\\n\"\n\n/***/ },\n/* 47 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// style-loader: Adds some css to the DOM by adding a <style> tag\n\tvar dispose = __webpack_require__(8)\n\t\t// The css code:\n\t\t(__webpack_require__(39))\n\tif(false) {\n\t\tmodule.hot.accept();\n\t\tmodule.hot.dispose(dispose);\n\t}\n\n/***/ },\n/* 48 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// style-loader: Adds some css to the DOM by adding a <style> tag\n\tvar dispose = __webpack_require__(8)\n\t\t// The css code:\n\t\t(__webpack_require__(40))\n\tif(false) {\n\t\tmodule.hot.accept();\n\t\tmodule.hot.dispose(dispose);\n\t}\n\n/***/ },\n/* 49 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// style-loader: Adds some css to the DOM by adding a <style> tag\n\tvar dispose = __webpack_require__(8)\n\t\t// The css code:\n\t\t(__webpack_require__(41))\n\tif(false) {\n\t\tmodule.hot.accept();\n\t\tmodule.hot.dispose(dispose);\n\t}\n\n/***/ },\n/* 50 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// style-loader: Adds some css to the DOM by adding a <style> tag\n\tvar dispose = __webpack_require__(8)\n\t\t// The css code:\n\t\t(__webpack_require__(42))\n\tif(false) {\n\t\tmodule.hot.accept();\n\t\tmodule.hot.dispose(dispose);\n\t}\n\n/***/ },\n/* 51 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// style-loader: Adds some css to the DOM by adding a <style> tag\n\tvar dispose = __webpack_require__(8)\n\t\t// The css code:\n\t\t(__webpack_require__(43))\n\tif(false) {\n\t\tmodule.hot.accept();\n\t\tmodule.hot.dispose(dispose);\n\t}\n\n/***/ }\n/******/ ])","\n// The module cache\nvar installedModules = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tif(installedModules[moduleId])\n\t\treturn installedModules[moduleId].exports;\n\t\n\t// Create a new module (and put it into the cache)\n\tvar module = installedModules[moduleId] = {\n\t\texports: {},\n\t\tid: moduleId,\n\t\tloaded: false\n\t};\n\t\n\t// Execute the module function\n\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\t\n\t// Flag the module as loaded\n\tmodule.loaded = true;\n\t\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n\n// expose the modules object (__webpack_modules__)\n__webpack_require__.m = modules;\n\n// expose the module cache\n__webpack_require__.c = installedModules;\n\n// __webpack_public_path__\n__webpack_require__.p = \"dist/\";\n\n\n// Load entry module and return exports\nreturn __webpack_require__(0);","# CSS\nrequire 'css/app'\nrequire 'famous/core/famous.css'\n\n# Polyfills\nrequire 'famous-polyfills/functionPrototypeBind'\nrequire 'famous-polyfills/classList'\nrequire 'famous-polyfills/requestAnimationFrame'\n\n# Famous\nEngine = require 'famous/core/Engine'\n\n# Views\nAppView = require 'views/AppView'\nFpsMeter = require 'widgets/FpsMeter'\nMascot = require 'widgets/Mascot'\n\n# Create the main context\nmainContext = Engine.createContext()\n\n# Set perspective for 3D effects\n# Lower values make effects more pronounced and extreme\nmainContext.setPerspective 2000\n\nmainContext.add new AppView\n# mainContext.add new Mascot\nmainContext.add new FpsMeter\n\n# questions = new Questions\n# query = new Parse.Query Question\n# query.exists 'title'\n# #query.limit 1\n# query.skip 10\n# questions.query = query;\n# questions.fetch success: (collection) ->\n#   console.log collection.toJSON()\n#   #listQuestions = new ListQuestionsView questions\n#   question = new QuestionView collection\n\n\n#   content.sequenceFrom [\n#     #editQuestion\n#     #imageUpload\n#     #listQuestions\n#     #imageEdit\n#     question\n#   ]\n\n#   # Add views to context\n#   mainContext.add layout\n","/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n *\n * Owner: mark@famo.us\n * @license MPL 2.0\n * @copyright Famous Industries, Inc. 2014\n */\n\ndefine(function(require, exports, module) {\n\n    /**\n     *  A high-performance static matrix math library used to calculate\n     *    affine transforms on surfaces and other renderables.\n     *    Famo.us uses 4x4 matrices corresponding directly to\n     *    WebKit matrices (column-major order).\n     *\n     *    The internal \"type\" of a Matrix is a 16-long float array in\n     *    row-major order, with:\n     *    elements [0],[1],[2],[4],[5],[6],[8],[9],[10] forming the 3x3\n     *          transformation matrix;\n     *    elements [12], [13], [14] corresponding to the t_x, t_y, t_z\n     *           translation;\n     *    elements [3], [7], [11] set to 0;\n     *    element [15] set to 1.\n     *    All methods are static.\n     *\n     * @static\n     *\n     * @class Transform\n     */\n    var Transform = {};\n\n    // WARNING: these matrices correspond to WebKit matrices, which are\n    //    transposed from their math counterparts\n    Transform.precision = 1e-6;\n    Transform.identity = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];\n\n    /**\n     * Multiply two or more Transform matrix types to return a Transform matrix.\n     *\n     * @method multiply4x4\n     * @static\n     * @param {Transform} a left matrix\n     * @param {Transform} b right matrix\n     * @return {Transform} the resulting matrix\n     */\n    Transform.multiply4x4 = function multiply4x4(a, b) {\n        return [\n            a[0] * b[0] + a[4] * b[1] + a[8] * b[2] + a[12] * b[3],\n            a[1] * b[0] + a[5] * b[1] + a[9] * b[2] + a[13] * b[3],\n            a[2] * b[0] + a[6] * b[1] + a[10] * b[2] + a[14] * b[3],\n            a[3] * b[0] + a[7] * b[1] + a[11] * b[2] + a[15] * b[3],\n            a[0] * b[4] + a[4] * b[5] + a[8] * b[6] + a[12] * b[7],\n            a[1] * b[4] + a[5] * b[5] + a[9] * b[6] + a[13] * b[7],\n            a[2] * b[4] + a[6] * b[5] + a[10] * b[6] + a[14] * b[7],\n            a[3] * b[4] + a[7] * b[5] + a[11] * b[6] + a[15] * b[7],\n            a[0] * b[8] + a[4] * b[9] + a[8] * b[10] + a[12] * b[11],\n            a[1] * b[8] + a[5] * b[9] + a[9] * b[10] + a[13] * b[11],\n            a[2] * b[8] + a[6] * b[9] + a[10] * b[10] + a[14] * b[11],\n            a[3] * b[8] + a[7] * b[9] + a[11] * b[10] + a[15] * b[11],\n            a[0] * b[12] + a[4] * b[13] + a[8] * b[14] + a[12] * b[15],\n            a[1] * b[12] + a[5] * b[13] + a[9] * b[14] + a[13] * b[15],\n            a[2] * b[12] + a[6] * b[13] + a[10] * b[14] + a[14] * b[15],\n            a[3] * b[12] + a[7] * b[13] + a[11] * b[14] + a[15] * b[15]\n        ];\n    };\n\n    /**\n     * Fast-multiply two or more Transform matrix types to return a\n     *    Matrix, assuming bottom row on each is [0 0 0 1].\n     *\n     * @method multiply\n     * @static\n     * @param {Transform} a left matrix\n     * @param {Transform} b right matrix\n     * @return {Transform} the resulting matrix\n     */\n    Transform.multiply = function multiply(a, b) {\n        return [\n            a[0] * b[0] + a[4] * b[1] + a[8] * b[2],\n            a[1] * b[0] + a[5] * b[1] + a[9] * b[2],\n            a[2] * b[0] + a[6] * b[1] + a[10] * b[2],\n            0,\n            a[0] * b[4] + a[4] * b[5] + a[8] * b[6],\n            a[1] * b[4] + a[5] * b[5] + a[9] * b[6],\n            a[2] * b[4] + a[6] * b[5] + a[10] * b[6],\n            0,\n            a[0] * b[8] + a[4] * b[9] + a[8] * b[10],\n            a[1] * b[8] + a[5] * b[9] + a[9] * b[10],\n            a[2] * b[8] + a[6] * b[9] + a[10] * b[10],\n            0,\n            a[0] * b[12] + a[4] * b[13] + a[8] * b[14] + a[12],\n            a[1] * b[12] + a[5] * b[13] + a[9] * b[14] + a[13],\n            a[2] * b[12] + a[6] * b[13] + a[10] * b[14] + a[14],\n            1\n        ];\n    };\n\n    /**\n     * Return a Transform translated by additional amounts in each\n     *    dimension. This is equivalent to the result of\n     *\n     *    Matrix.multiply(Matrix.translate(t[0], t[1], t[2]), m).\n     *\n     * @method thenMove\n     * @static\n     * @param {Transform} m a matrix\n     * @param {Array.Number} t floats delta vector of length 2 or 3\n     * @return {Transform} the resulting translated matrix\n     */\n    Transform.thenMove = function thenMove(m, t) {\n        if (!t[2]) t[2] = 0;\n        return [m[0], m[1], m[2], 0, m[4], m[5], m[6], 0, m[8], m[9], m[10], 0, m[12] + t[0], m[13] + t[1], m[14] + t[2], 1];\n    };\n\n    /**\n     * Return a Transform atrix which represents the result of a transform matrix\n     *    applied after a move. This is faster than the equivalent multiply.\n     *    This is equivalent to the result of:\n     *\n     *    Transform.multiply(m, Transform.translate(t[0], t[1], t[2])).\n     *\n     * @method moveThen\n     * @static\n     * @param {Array.Number} v vector representing initial movement\n     * @param {Transform} m matrix to apply afterwards\n     * @return {Transform} the resulting matrix\n     */\n    Transform.moveThen = function moveThen(v, m) {\n        if (!v[2]) v[2] = 0;\n        var t0 = v[0] * m[0] + v[1] * m[4] + v[2] * m[8];\n        var t1 = v[0] * m[1] + v[1] * m[5] + v[2] * m[9];\n        var t2 = v[0] * m[2] + v[1] * m[6] + v[2] * m[10];\n        return Transform.thenMove(m, [t0, t1, t2]);\n    };\n\n    /**\n     * Return a Transform which represents a translation by specified\n     *    amounts in each dimension.\n     *\n     * @method translate\n     * @static\n     * @param {Number} x x translation\n     * @param {Number} y y translation\n     * @param {Number} z z translation\n     * @return {Transform} the resulting matrix\n     */\n    Transform.translate = function translate(x, y, z) {\n        if (z === undefined) z = 0;\n        return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, x, y, z, 1];\n    };\n\n    /**\n     * Return a Transform scaled by a vector in each\n     *    dimension. This is a more performant equivalent to the result of\n     *\n     *    Transform.multiply(Transform.scale(s[0], s[1], s[2]), m).\n     *\n     * @method thenScale\n     * @static\n     * @param {Transform} m a matrix\n     * @param {Array.Number} s delta vector (array of floats &&\n     *    array.length == 3)\n     * @return {Transform} the resulting translated matrix\n     */\n    Transform.thenScale = function thenScale(m, s) {\n        return [\n            s[0] * m[0], s[1] * m[1], s[2] * m[2], 0,\n            s[0] * m[4], s[1] * m[5], s[2] * m[6], 0,\n            s[0] * m[8], s[1] * m[9], s[2] * m[10], 0,\n            s[0] * m[12], s[1] * m[13], s[2] * m[14], 1\n        ];\n    };\n\n    /**\n     * Return a Transform which represents a scale by specified amounts\n     *    in each dimension.\n     *\n     * @method scale\n     * @static\n     * @param {Number} x x scale factor\n     * @param {Number} y y scale factor\n     * @param {Number} z z scale factor\n     * @return {Transform} the resulting matrix\n     */\n    Transform.scale = function scale(x, y, z) {\n        if (z === undefined) z = 1;\n        return [x, 0, 0, 0, 0, y, 0, 0, 0, 0, z, 0, 0, 0, 0, 1];\n    };\n\n    /**\n     * Return a Transform which represents a clockwise\n     *    rotation around the x axis.\n     *\n     * @method rotateX\n     * @static\n     * @param {Number} theta radians\n     * @return {Transform} the resulting matrix\n     */\n    Transform.rotateX = function rotateX(theta) {\n        var cosTheta = Math.cos(theta);\n        var sinTheta = Math.sin(theta);\n        return [1, 0, 0, 0, 0, cosTheta, sinTheta, 0, 0, -sinTheta, cosTheta, 0, 0, 0, 0, 1];\n    };\n\n    /**\n     * Return a Transform which represents a clockwise\n     *    rotation around the y axis.\n     *\n     * @method rotateY\n     * @static\n     * @param {Number} theta radians\n     * @return {Transform} the resulting matrix\n     */\n    Transform.rotateY = function rotateY(theta) {\n        var cosTheta = Math.cos(theta);\n        var sinTheta = Math.sin(theta);\n        return [cosTheta, 0, -sinTheta, 0, 0, 1, 0, 0, sinTheta, 0, cosTheta, 0, 0, 0, 0, 1];\n    };\n\n    /**\n     * Return a Transform which represents a clockwise\n     *    rotation around the z axis.\n     *\n     * @method rotateZ\n     * @static\n     * @param {Number} theta radians\n     * @return {Transform} the resulting matrix\n     */\n    Transform.rotateZ = function rotateZ(theta) {\n        var cosTheta = Math.cos(theta);\n        var sinTheta = Math.sin(theta);\n        return [cosTheta, sinTheta, 0, 0, -sinTheta, cosTheta, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];\n    };\n\n    /**\n     * Return a Transform which represents composed clockwise\n     *    rotations along each of the axes. Equivalent to the result of\n     *    Matrix.multiply(rotateX(phi), rotateY(theta), rotateZ(psi)).\n     *\n     * @method rotate\n     * @static\n     * @param {Number} phi radians to rotate about the positive x axis\n     * @param {Number} theta radians to rotate about the positive y axis\n     * @param {Number} psi radians to rotate about the positive z axis\n     * @return {Transform} the resulting matrix\n     */\n    Transform.rotate = function rotate(phi, theta, psi) {\n        var cosPhi = Math.cos(phi);\n        var sinPhi = Math.sin(phi);\n        var cosTheta = Math.cos(theta);\n        var sinTheta = Math.sin(theta);\n        var cosPsi = Math.cos(psi);\n        var sinPsi = Math.sin(psi);\n        var result = [\n            cosTheta * cosPsi,\n            cosPhi * sinPsi + sinPhi * sinTheta * cosPsi,\n            sinPhi * sinPsi - cosPhi * sinTheta * cosPsi,\n            0,\n            -cosTheta * sinPsi,\n            cosPhi * cosPsi - sinPhi * sinTheta * sinPsi,\n            sinPhi * cosPsi + cosPhi * sinTheta * sinPsi,\n            0,\n            sinTheta,\n            -sinPhi * cosTheta,\n            cosPhi * cosTheta,\n            0,\n            0, 0, 0, 1\n        ];\n        return result;\n    };\n\n    /**\n     * Return a Transform which represents an axis-angle rotation\n     *\n     * @method rotateAxis\n     * @static\n     * @param {Array.Number} v unit vector representing the axis to rotate about\n     * @param {Number} theta radians to rotate clockwise about the axis\n     * @return {Transform} the resulting matrix\n     */\n    Transform.rotateAxis = function rotateAxis(v, theta) {\n        var sinTheta = Math.sin(theta);\n        var cosTheta = Math.cos(theta);\n        var verTheta = 1 - cosTheta; // versine of theta\n\n        var xxV = v[0] * v[0] * verTheta;\n        var xyV = v[0] * v[1] * verTheta;\n        var xzV = v[0] * v[2] * verTheta;\n        var yyV = v[1] * v[1] * verTheta;\n        var yzV = v[1] * v[2] * verTheta;\n        var zzV = v[2] * v[2] * verTheta;\n        var xs = v[0] * sinTheta;\n        var ys = v[1] * sinTheta;\n        var zs = v[2] * sinTheta;\n\n        var result = [\n            xxV + cosTheta, xyV + zs, xzV - ys, 0,\n            xyV - zs, yyV + cosTheta, yzV + xs, 0,\n            xzV + ys, yzV - xs, zzV + cosTheta, 0,\n            0, 0, 0, 1\n        ];\n        return result;\n    };\n\n    /**\n     * Return a Transform which represents a transform matrix applied about\n     * a separate origin point.\n     *\n     * @method aboutOrigin\n     * @static\n     * @param {Array.Number} v origin point to apply matrix\n     * @param {Transform} m matrix to apply\n     * @return {Transform} the resulting matrix\n     */\n    Transform.aboutOrigin = function aboutOrigin(v, m) {\n        var t0 = v[0] - (v[0] * m[0] + v[1] * m[4] + v[2] * m[8]);\n        var t1 = v[1] - (v[0] * m[1] + v[1] * m[5] + v[2] * m[9]);\n        var t2 = v[2] - (v[0] * m[2] + v[1] * m[6] + v[2] * m[10]);\n        return Transform.thenMove(m, [t0, t1, t2]);\n    };\n\n    /**\n     * Return a Transform representation of a skew transformation\n     *\n     * @method skew\n     * @static\n     * @param {Number} phi scale factor skew in the x axis\n     * @param {Number} theta scale factor skew in the y axis\n     * @param {Number} psi scale factor skew in the z axis\n     * @return {Transform} the resulting matrix\n     */\n    Transform.skew = function skew(phi, theta, psi) {\n        return [1, 0, 0, 0, Math.tan(psi), 1, 0, 0, Math.tan(theta), Math.tan(phi), 1, 0, 0, 0, 0, 1];\n    };\n\n    /**\n     * Returns a perspective Transform matrix\n     *\n     * @method perspective\n     * @static\n     * @param {Number} focusZ z position of focal point\n     * @return {Transform} the resulting matrix\n     */\n    Transform.perspective = function perspective(focusZ) {\n        return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, -1 / focusZ, 0, 0, 0, 1];\n    };\n\n    /**\n     * Return translation vector component of given Transform\n     *\n     * @method getTranslate\n     * @static\n     * @param {Transform} m matrix\n     * @return {Array.Number} the translation vector [t_x, t_y, t_z]\n     */\n    Transform.getTranslate = function getTranslate(m) {\n        return [m[12], m[13], m[14]];\n    };\n\n    /**\n     * Return inverse affine matrix for given Transform.\n     *   Note: This assumes m[3] = m[7] = m[11] = 0, and m[15] = 1.\n     *   Will provide incorrect results if not invertible or preconditions not met.\n     *\n     * @method inverse\n     * @static\n     * @param {Transform} m matrix\n     * @return {Transform} the resulting inverted matrix\n     */\n    Transform.inverse = function inverse(m) {\n        // only need to consider 3x3 section for affine\n        var c0 = m[5] * m[10] - m[6] * m[9];\n        var c1 = m[4] * m[10] - m[6] * m[8];\n        var c2 = m[4] * m[9] - m[5] * m[8];\n        var c4 = m[1] * m[10] - m[2] * m[9];\n        var c5 = m[0] * m[10] - m[2] * m[8];\n        var c6 = m[0] * m[9] - m[1] * m[8];\n        var c8 = m[1] * m[6] - m[2] * m[5];\n        var c9 = m[0] * m[6] - m[2] * m[4];\n        var c10 = m[0] * m[5] - m[1] * m[4];\n        var detM = m[0] * c0 - m[1] * c1 + m[2] * c2;\n        var invD = 1 / detM;\n        var result = [\n            invD * c0, -invD * c4, invD * c8, 0,\n            -invD * c1, invD * c5, -invD * c9, 0,\n            invD * c2, -invD * c6, invD * c10, 0,\n            0, 0, 0, 1\n        ];\n        result[12] = -m[12] * result[0] - m[13] * result[4] - m[14] * result[8];\n        result[13] = -m[12] * result[1] - m[13] * result[5] - m[14] * result[9];\n        result[14] = -m[12] * result[2] - m[13] * result[6] - m[14] * result[10];\n        return result;\n    };\n\n    /**\n     * Returns the transpose of a 4x4 matrix\n     *\n     * @method transpose\n     * @static\n     * @param {Transform} m matrix\n     * @return {Transform} the resulting transposed matrix\n     */\n    Transform.transpose = function transpose(m) {\n        return [m[0], m[4], m[8], m[12], m[1], m[5], m[9], m[13], m[2], m[6], m[10], m[14], m[3], m[7], m[11], m[15]];\n    };\n\n    function _normSquared(v) {\n        return (v.length === 2) ? v[0] * v[0] + v[1] * v[1] : v[0] * v[0] + v[1] * v[1] + v[2] * v[2];\n    }\n    function _norm(v) {\n        return Math.sqrt(_normSquared(v));\n    }\n    function _sign(n) {\n        return (n < 0) ? -1 : 1;\n    }\n\n    /**\n     * Decompose Transform into separate .translate, .rotate, .scale,\n     *    and .skew components.\n     *\n     * @method interpret\n     * @static\n     * @param {Transform} M tranform matrix\n     * @return {Object} matrix spec object with component matrices .translate,\n     *    .rotate, .scale, .skew\n     */\n    Transform.interpret = function interpret(M) {\n\n        // QR decomposition via Householder reflections\n        //FIRST ITERATION\n\n        //default Q1 to the identity matrix;\n        var x = [M[0], M[1], M[2]];                // first column vector\n        var sgn = _sign(x[0]);                     // sign of first component of x (for stability)\n        var xNorm = _norm(x);                      // norm of first column vector\n        var v = [x[0] + sgn * xNorm, x[1], x[2]];  // v = x + sign(x[0])|x|e1\n        var mult = 2 / _normSquared(v);            // mult = 2/v'v\n\n        //bail out if our Matrix is singular\n        if (mult >= Infinity) {\n            return {translate: Transform.getTranslate(M), rotate: [0, 0, 0], scale: [0, 0, 0], skew: [0, 0, 0]};\n        }\n\n        //evaluate Q1 = I - 2vv'/v'v\n        var Q1 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1];\n\n        //diagonals\n        Q1[0]  = 1 - mult * v[0] * v[0];    // 0,0 entry\n        Q1[5]  = 1 - mult * v[1] * v[1];    // 1,1 entry\n        Q1[10] = 1 - mult * v[2] * v[2];    // 2,2 entry\n\n        //upper diagonal\n        Q1[1] = -mult * v[0] * v[1];        // 0,1 entry\n        Q1[2] = -mult * v[0] * v[2];        // 0,2 entry\n        Q1[6] = -mult * v[1] * v[2];        // 1,2 entry\n\n        //lower diagonal\n        Q1[4] = Q1[1];                      // 1,0 entry\n        Q1[8] = Q1[2];                      // 2,0 entry\n        Q1[9] = Q1[6];                      // 2,1 entry\n\n        //reduce first column of M\n        var MQ1 = Transform.multiply(Q1, M);\n\n        //SECOND ITERATION on (1,1) minor\n        var x2 = [MQ1[5], MQ1[6]];\n        var sgn2 = _sign(x2[0]);                    // sign of first component of x (for stability)\n        var x2Norm = _norm(x2);                     // norm of first column vector\n        var v2 = [x2[0] + sgn2 * x2Norm, x2[1]];    // v = x + sign(x[0])|x|e1\n        var mult2 = 2 / _normSquared(v2);           // mult = 2/v'v\n\n        //evaluate Q2 = I - 2vv'/v'v\n        var Q2 = [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1];\n\n        //diagonal\n        Q2[5]  = 1 - mult2 * v2[0] * v2[0]; // 1,1 entry\n        Q2[10] = 1 - mult2 * v2[1] * v2[1]; // 2,2 entry\n\n        //off diagonals\n        Q2[6] = -mult2 * v2[0] * v2[1];     // 2,1 entry\n        Q2[9] = Q2[6];                      // 1,2 entry\n\n        //calc QR decomposition. Q = Q1*Q2, R = Q'*M\n        var Q = Transform.multiply(Q2, Q1);      //note: really Q transpose\n        var R = Transform.multiply(Q, M);\n\n        //remove negative scaling\n        var remover = Transform.scale(R[0] < 0 ? -1 : 1, R[5] < 0 ? -1 : 1, R[10] < 0 ? -1 : 1);\n        R = Transform.multiply(R, remover);\n        Q = Transform.multiply(remover, Q);\n\n        //decompose into rotate/scale/skew matrices\n        var result = {};\n        result.translate = Transform.getTranslate(M);\n        result.rotate = [Math.atan2(-Q[6], Q[10]), Math.asin(Q[2]), Math.atan2(-Q[1], Q[0])];\n        if (!result.rotate[0]) {\n            result.rotate[0] = 0;\n            result.rotate[2] = Math.atan2(Q[4], Q[5]);\n        }\n        result.scale = [R[0], R[5], R[10]];\n        result.skew = [Math.atan2(R[9], result.scale[2]), Math.atan2(R[8], result.scale[2]), Math.atan2(R[4], result.scale[0])];\n\n        //double rotation workaround\n        if (Math.abs(result.rotate[0]) + Math.abs(result.rotate[2]) > 1.5 * Math.PI) {\n            result.rotate[1] = Math.PI - result.rotate[1];\n            if (result.rotate[1] > Math.PI) result.rotate[1] -= 2 * Math.PI;\n            if (result.rotate[1] < -Math.PI) result.rotate[1] += 2 * Math.PI;\n            if (result.rotate[0] < 0) result.rotate[0] += Math.PI;\n            else result.rotate[0] -= Math.PI;\n            if (result.rotate[2] < 0) result.rotate[2] += Math.PI;\n            else result.rotate[2] -= Math.PI;\n        }\n\n        return result;\n    };\n\n    /**\n     * Weighted average between two matrices by averaging their\n     *     translation, rotation, scale, skew components.\n     *     f(M1,M2,t) = (1 - t) * M1 + t * M2\n     *\n     * @method average\n     * @static\n     * @param {Transform} M1 f(M1,M2,0) = M1\n     * @param {Transform} M2 f(M1,M2,1) = M2\n     * @param {Number} t\n     * @return {Transform} resulting matrix\n     */\n    Transform.average = function average(M1, M2, t) {\n        t = (t === undefined) ? 0.5 : t;\n        var specM1 = Transform.interpret(M1);\n        var specM2 = Transform.interpret(M2);\n\n        var specAvg = {\n            translate: [0, 0, 0],\n            rotate: [0, 0, 0],\n            scale: [0, 0, 0],\n            skew: [0, 0, 0]\n        };\n\n        for (var i = 0; i < 3; i++) {\n            specAvg.translate[i] = (1 - t) * specM1.translate[i] + t * specM2.translate[i];\n            specAvg.rotate[i] = (1 - t) * specM1.rotate[i] + t * specM2.rotate[i];\n            specAvg.scale[i] = (1 - t) * specM1.scale[i] + t * specM2.scale[i];\n            specAvg.skew[i] = (1 - t) * specM1.skew[i] + t * specM2.skew[i];\n        }\n        return Transform.build(specAvg);\n    };\n\n    /**\n     * Compose .translate, .rotate, .scale, .skew components into\n     * Transform matrix\n     *\n     * @method build\n     * @static\n     * @param {matrixSpec} spec object with component matrices .translate,\n     *    .rotate, .scale, .skew\n     * @return {Transform} composed martix\n     */\n    Transform.build = function build(spec) {\n        var scaleMatrix = Transform.scale(spec.scale[0], spec.scale[1], spec.scale[2]);\n        var skewMatrix = Transform.skew(spec.skew[0], spec.skew[1], spec.skew[2]);\n        var rotateMatrix = Transform.rotate(spec.rotate[0], spec.rotate[1], spec.rotate[2]);\n        return Transform.thenMove(Transform.multiply(Transform.multiply(rotateMatrix, skewMatrix), scaleMatrix), spec.translate);\n    };\n\n    /**\n     * Determine if two Transforms are component-wise equal\n     *   Warning: breaks on perspective Transforms\n     *\n     * @method equals\n     * @static\n     * @param {Transform} a matrix\n     * @param {Transform} b matrix\n     * @return {boolean}\n     */\n    Transform.equals = function equals(a, b) {\n        return !Transform.notEquals(a, b);\n    };\n\n    /**\n     * Determine if two Transforms are component-wise unequal\n     *   Warning: breaks on perspective Transforms\n     *\n     * @method notEquals\n     * @static\n     * @param {Transform} a matrix\n     * @param {Transform} b matrix\n     * @return {boolean}\n     */\n    Transform.notEquals = function notEquals(a, b) {\n        if (a === b) return false;\n        if (!(a && b)) return true;\n\n        // shortci\n        return !(a && b) ||\n            a[12] !== b[12] || a[13] !== b[13] || a[14] !== b[14] ||\n            a[0] !== b[0] || a[1] !== b[1] || a[2] !== b[2] ||\n            a[4] !== b[4] || a[5] !== b[5] || a[6] !== b[6] ||\n            a[8] !== b[8] || a[9] !== b[9] || a[10] !== b[10];\n    };\n\n    /**\n     * Constrain angle-trio components to range of [-pi, pi).\n     *\n     * @method normalizeRotation\n     * @static\n     * @param {Array.Number} rotation phi, theta, psi (array of floats\n     *    && array.length == 3)\n     * @return {Array.Number} new phi, theta, psi triplet\n     *    (array of floats && array.length == 3)\n     */\n    Transform.normalizeRotation = function normalizeRotation(rotation) {\n        var result = rotation.slice(0);\n        if (result[0] === Math.PI * 0.5 || result[0] === -Math.PI * 0.5) {\n            result[0] = -result[0];\n            result[1] = Math.PI - result[1];\n            result[2] -= Math.PI;\n        }\n        if (result[0] > Math.PI * 0.5) {\n            result[0] = result[0] - Math.PI;\n            result[1] = Math.PI - result[1];\n            result[2] -= Math.PI;\n        }\n        if (result[0] < -Math.PI * 0.5) {\n            result[0] = result[0] + Math.PI;\n            result[1] = -Math.PI - result[1];\n            result[2] -= Math.PI;\n        }\n        while (result[1] < -Math.PI) result[1] += 2 * Math.PI;\n        while (result[1] >= Math.PI) result[1] -= 2 * Math.PI;\n        while (result[2] < -Math.PI) result[2] += 2 * Math.PI;\n        while (result[2] >= Math.PI) result[2] -= 2 * Math.PI;\n        return result;\n    };\n\n    /**\n     * (Property) Array defining a translation forward in z by 1\n     *\n     * @property {array} inFront\n     * @static\n     * @final\n     */\n    Transform.inFront = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1e-3, 1];\n\n    /**\n     * (Property) Array defining a translation backwards in z by 1\n     *\n     * @property {array} behind\n     * @static\n     * @final\n     */\n    Transform.behind = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, -1e-3, 1];\n\n    module.exports = Transform;\n});\n","/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n *\n * Owner: mark@famo.us\n * @license MPL 2.0\n * @copyright Famous Industries, Inc. 2014\n */\n\ndefine(function(require, exports, module) {\n    var Entity = require('./Entity');\n    var EventHandler = require('./EventHandler');\n    var Transform = require('./Transform');\n\n    var usePrefix = document.body.style.webkitTransform !== undefined;\n    var devicePixelRatio = window.devicePixelRatio || 1;\n\n    /**\n     * A base class for viewable content and event\n     *   targets inside a Famo.us application, containing a renderable document\n     *   fragment. Like an HTML div, it can accept internal markup,\n     *   properties, classes, and handle events.\n     *\n     * @class Surface\n     * @constructor\n     *\n     * @param {Object} [options] default option overrides\n     * @param {Array.Number} [options.size] [width, height] in pixels\n     * @param {Array.string} [options.classes] CSS classes to set on inner content\n     * @param {Array} [options.properties] string dictionary of HTML attributes to set on target div\n     * @param {string} [options.content] inner (HTML) content of surface\n     */\n    function Surface(options) {\n        this.options = {};\n\n        this.properties = {};\n        this.content = '';\n        this.classList = [];\n        this.size = null;\n\n        this._classesDirty = true;\n        this._stylesDirty = true;\n        this._sizeDirty = true;\n        this._contentDirty = true;\n\n        this._dirtyClasses = [];\n\n        this._matrix = null;\n        this._opacity = 1;\n        this._origin = null;\n        this._size = null;\n\n        /** @ignore */\n        this.eventForwarder = function eventForwarder(event) {\n            this.emit(event.type, event);\n        }.bind(this);\n        this.eventHandler = new EventHandler();\n        this.eventHandler.bindThis(this);\n\n        this.id = Entity.register(this);\n\n        if (options) this.setOptions(options);\n\n        this._currTarget = null;\n    }\n    Surface.prototype.elementType = 'div';\n    Surface.prototype.elementClass = 'famous-surface';\n\n    /**\n     * Bind a callback function to an event type handled by this object.\n     *\n     * @method \"on\"\n     *\n     * @param {string} type event type key (for example, 'click')\n     * @param {function(string, Object)} fn handler callback\n     * @return {EventHandler} this\n     */\n    Surface.prototype.on = function on(type, fn) {\n        if (this._currTarget) this._currTarget.addEventListener(type, this.eventForwarder);\n        this.eventHandler.on(type, fn);\n    };\n\n    /**\n     * Unbind an event by type and handler.\n     *   This undoes the work of \"on\"\n     *\n     * @method removeListener\n     * @param {string} type event type key (for example, 'click')\n     * @param {function(string, Object)} fn handler\n     */\n    Surface.prototype.removeListener = function removeListener(type, fn) {\n        this.eventHandler.removeListener(type, fn);\n    };\n\n    /**\n     * Trigger an event, sending to all downstream handlers\n     *   listening for provided 'type' key.\n     *\n     * @method emit\n     *\n     * @param {string} type event type key (for example, 'click')\n     * @param {Object} [event] event data\n     * @return {EventHandler} this\n     */\n    Surface.prototype.emit = function emit(type, event) {\n        if (event && !event.origin) event.origin = this;\n        var handled = this.eventHandler.emit(type, event);\n        if (handled && event && event.stopPropagation) event.stopPropagation();\n        return handled;\n    };\n\n    /**\n     * Add event handler object to set of downstream handlers.\n     *\n     * @method pipe\n     *\n     * @param {EventHandler} target event handler target object\n     * @return {EventHandler} passed event handler\n     */\n    Surface.prototype.pipe = function pipe(target) {\n        return this.eventHandler.pipe(target);\n    };\n\n    /**\n     * Remove handler object from set of downstream handlers.\n     *   Undoes work of \"pipe\"\n     *\n     * @method unpipe\n     *\n     * @param {EventHandler} target target handler object\n     * @return {EventHandler} provided target\n     */\n    Surface.prototype.unpipe = function unpipe(target) {\n        return this.eventHandler.unpipe(target);\n    };\n\n    /**\n     * Return spec for this surface. Note that for a base surface, this is\n     *    simply an id.\n     *\n     * @method render\n     * @private\n     * @return {Object} render spec for this surface (spec id)\n     */\n    Surface.prototype.render = function render() {\n        return this.id;\n    };\n\n    /**\n     * Set CSS-style properties on this Surface. Note that this will cause\n     *    dirtying and thus re-rendering, even if values do not change.\n     *\n     * @method setProperties\n     * @param {Object} properties property dictionary of \"key\" => \"value\"\n     */\n    Surface.prototype.setProperties = function setProperties(properties) {\n        for (var n in properties) {\n            this.properties[n] = properties[n];\n        }\n        this._stylesDirty = true;\n    };\n\n    /**\n     * Get CSS-style properties on this Surface.\n     *\n     * @method getProperties\n     *\n     * @return {Object} Dictionary of this Surface's properties.\n     */\n    Surface.prototype.getProperties = function getProperties() {\n        return this.properties;\n    };\n\n    /**\n     * Add CSS-style class to the list of classes on this Surface. Note\n     *   this will map directly to the HTML property of the actual\n     *   corresponding rendered <div>.\n     *\n     * @method addClass\n     * @param {string} className name of class to add\n     */\n    Surface.prototype.addClass = function addClass(className) {\n        if (this.classList.indexOf(className) < 0) {\n            this.classList.push(className);\n            this._classesDirty = true;\n        }\n    };\n\n    /**\n     * Remove CSS-style class from the list of classes on this Surface.\n     *   Note this will map directly to the HTML property of the actual\n     *   corresponding rendered <div>.\n     *\n     * @method removeClass\n     * @param {string} className name of class to remove\n     */\n    Surface.prototype.removeClass = function removeClass(className) {\n        var i = this.classList.indexOf(className);\n        if (i >= 0) {\n            this._dirtyClasses.push(this.classList.splice(i, 1)[0]);\n            this._classesDirty = true;\n        }\n    };\n\n    /**\n     * Reset class list to provided dictionary.\n     * @method setClasses\n     * @param {Array.string} classList\n     */\n    Surface.prototype.setClasses = function setClasses(classList) {\n        var i = 0;\n        var removal = [];\n        for (i = 0; i < this.classList.length; i++) {\n            if (classList.indexOf(this.classList[i]) < 0) removal.push(this.classList[i]);\n        }\n        for (i = 0; i < removal.length; i++) this.removeClass(removal[i]);\n        // duplicates are already checked by addClass()\n        for (i = 0; i < classList.length; i++) this.addClass(classList[i]);\n    };\n\n    /**\n     * Get array of CSS-style classes attached to this div.\n     *\n     * @method getClasslist\n     * @return {Array.string} array of class names\n     */\n    Surface.prototype.getClassList = function getClassList() {\n        return this.classList;\n    };\n\n    /**\n     * Set or overwrite inner (HTML) content of this surface. Note that this\n     *    causes a re-rendering if the content has changed.\n     *\n     * @method setContent\n     * @param {string} content HTML content\n     */\n    Surface.prototype.setContent = function setContent(content) {\n        if (this.content !== content) {\n            this.content = content;\n            this._contentDirty = true;\n        }\n    };\n\n    /**\n     * Return inner (HTML) content of this surface.\n     *\n     * @method getContent\n     *\n     * @return {string} inner (HTML) content\n     */\n    Surface.prototype.getContent = function getContent() {\n        return this.content;\n    };\n\n    /**\n     * Set options for this surface\n     *\n     * @method setOptions\n     * @param {Object} [options] overrides for default options.  See constructor.\n     */\n    Surface.prototype.setOptions = function setOptions(options) {\n        if (options.size) this.setSize(options.size);\n        if (options.classes) this.setClasses(options.classes);\n        if (options.properties) this.setProperties(options.properties);\n        if (options.content) this.setContent(options.content);\n    };\n\n    //  Attach Famous event handling to document events emanating from target\n    //    document element.  This occurs just after deployment to the document.\n    //    Calling this enables methods like #on and #pipe.\n    function _addEventListeners(target) {\n        for (var i in this.eventHandler.listeners) {\n            target.addEventListener(i, this.eventForwarder);\n        }\n    }\n\n    //  Detach Famous event handling from document events emanating from target\n    //  document element.  This occurs just before recall from the document.\n    function _removeEventListeners(target) {\n        for (var i in this.eventHandler.listeners) {\n            target.removeEventListener(i, this.eventForwarder);\n        }\n    }\n\n     //  Apply to document all changes from removeClass() since last setup().\n    function _cleanupClasses(target) {\n        for (var i = 0; i < this._dirtyClasses.length; i++) target.classList.remove(this._dirtyClasses[i]);\n        this._dirtyClasses = [];\n    }\n\n    // Apply values of all Famous-managed styles to the document element.\n    //  These will be deployed to the document on call to #setup().\n    function _applyStyles(target) {\n        for (var n in this.properties) {\n            target.style[n] = this.properties[n];\n        }\n    }\n\n    // Clear all Famous-managed styles from the document element.\n    // These will be deployed to the document on call to #setup().\n    function _cleanupStyles(target) {\n        for (var n in this.properties) {\n            target.style[n] = '';\n        }\n    }\n\n    /**\n     * Return a Matrix's webkit css representation to be used with the\n     *    CSS3 -webkit-transform style.\n     *    Example: -webkit-transform: matrix3d(1,0,0,0,0,1,0,0,0,0,1,0,716,243,0,1)\n     *\n     * @method _formatCSSTransform\n     * @private\n     * @param {FamousMatrix} m matrix\n     * @return {string} matrix3d CSS style representation of the transform\n     */\n    function _formatCSSTransform(m) {\n        m[12] = Math.round(m[12] * devicePixelRatio) / devicePixelRatio;\n        m[13] = Math.round(m[13] * devicePixelRatio) / devicePixelRatio;\n\n        var result = 'matrix3d(';\n        for (var i = 0; i < 15; i++) {\n            result += (m[i] < 0.000001 && m[i] > -0.000001) ? '0,' : m[i] + ',';\n        }\n        result += m[15] + ')';\n        return result;\n    }\n\n    /**\n     * Directly apply given FamousMatrix to the document element as the\n     *   appropriate webkit CSS style.\n     *\n     * @method setMatrix\n     *\n     * @static\n     * @private\n     * @param {Element} element document element\n     * @param {FamousMatrix} matrix\n     */\n\n    var _setMatrix;\n    if (navigator.userAgent.toLowerCase().indexOf('firefox') > -1) {\n        _setMatrix = function(element, matrix) {\n            element.style.zIndex = (matrix[14] * 1000000) | 0;    // fix for Firefox z-buffer issues\n            element.style.transform = _formatCSSTransform(matrix);\n        };\n    }\n    else if (usePrefix) {\n        _setMatrix = function(element, matrix) {\n            element.style.webkitTransform = _formatCSSTransform(matrix);\n        };\n    }\n    else {\n        _setMatrix = function(element, matrix) {\n            element.style.transform = _formatCSSTransform(matrix);\n        };\n    }\n\n    // format origin as CSS percentage string\n    function _formatCSSOrigin(origin) {\n        return (100 * origin[0]).toFixed(6) + '% ' + (100 * origin[1]).toFixed(6) + '%';\n    }\n\n     // Directly apply given origin coordinates to the document element as the\n     // appropriate webkit CSS style.\n    var _setOrigin = usePrefix ? function(element, origin) {\n        element.style.webkitTransformOrigin = _formatCSSOrigin(origin);\n    } : function(element, origin) {\n        element.style.transformOrigin = _formatCSSOrigin(origin);\n    };\n\n     // Shrink given document element until it is effectively invisible.\n    var _setInvisible = usePrefix ? function(element) {\n        element.style.webkitTransform = 'scale3d(0.0001,0.0001,1)';\n        element.style.opacity = 0;\n    } : function(element) {\n        element.style.transform = 'scale3d(0.0001,0.0001,1)';\n        element.style.opacity = 0;\n    };\n\n    function _xyNotEquals(a, b) {\n        return (a && b) ? (a[0] !== b[0] || a[1] !== b[1]) : a !== b;\n    }\n\n    /**\n     * One-time setup for an element to be ready for commits to document.\n     *\n     * @private\n     * @method setup\n     *\n     * @param {ElementAllocator} allocator document element pool for this context\n     */\n    Surface.prototype.setup = function setup(allocator) {\n        var target = allocator.allocate(this.elementType);\n        if (this.elementClass) {\n            if (this.elementClass instanceof Array) {\n                for (var i = 0; i < this.elementClass.length; i++) {\n                    target.classList.add(this.elementClass[i]);\n                }\n            }\n            else {\n                target.classList.add(this.elementClass);\n            }\n        }\n        target.style.display = '';\n        _addEventListeners.call(this, target);\n        _setOrigin(target, [0, 0]); // handled internally\n        this._currTarget = target;\n        this._stylesDirty = true;\n        this._classesDirty = true;\n        this._sizeDirty = true;\n        this._contentDirty = true;\n        this._matrix = null;\n        this._opacity = undefined;\n        this._origin = null;\n        this._size = null;\n    };\n\n    /**\n     * Apply changes from this component to the corresponding document element.\n     * This includes changes to classes, styles, size, content, opacity, origin,\n     * and matrix transforms.\n     *\n     * @private\n     * @method commit\n     * @param {Context} context commit context\n     */\n    Surface.prototype.commit = function commit(context) {\n        if (!this._currTarget) this.setup(context.allocator);\n        var target = this._currTarget;\n\n        var matrix = context.transform;\n        var opacity = context.opacity;\n        var origin = context.origin;\n        var size = context.size;\n\n        if (this.size) {\n            var origSize = size;\n            size = [this.size[0], this.size[1]];\n            if (size[0] === undefined && origSize[0]) size[0] = origSize[0];\n            if (size[1] === undefined && origSize[1]) size[1] = origSize[1];\n        }\n\n        if (_xyNotEquals(this._size, size)) {\n            this._size = [size[0], size[1]];\n            this._sizeDirty = true;\n        }\n\n        if (!matrix && this._matrix) {\n            this._matrix = null;\n            this._opacity = 0;\n            _setInvisible(target);\n            return;\n        }\n\n        if (this._opacity !== opacity) {\n            this._opacity = opacity;\n            target.style.opacity = (opacity >= 1) ? '0.999999' : opacity;\n        }\n\n        if (_xyNotEquals(this._origin, origin) || Transform.notEquals(this._matrix, matrix)) {\n            if (!matrix) matrix = Transform.identity;\n            this._matrix = matrix;\n            var aaMatrix = matrix;\n            if (origin) {\n                if (!this._origin) this._origin = [0, 0];\n                this._origin[0] = origin[0];\n                this._origin[1] = origin[1];\n                aaMatrix = Transform.moveThen([-this._size[0] * origin[0], -this._size[1] * origin[1], 0], matrix);\n            }\n            _setMatrix(target, aaMatrix);\n        }\n\n        if (!(this._classesDirty || this._stylesDirty || this._sizeDirty || this._contentDirty)) return;\n\n        if (this._classesDirty) {\n            _cleanupClasses.call(this, target);\n            var classList = this.getClassList();\n            for (var i = 0; i < classList.length; i++) target.classList.add(classList[i]);\n            this._classesDirty = false;\n        }\n        if (this._stylesDirty) {\n            _applyStyles.call(this, target);\n            this._stylesDirty = false;\n        }\n        if (this._sizeDirty) {\n            if (this._size) {\n                target.style.width = (this._size[0] !== true) ? this._size[0] + 'px' : '';\n                target.style.height = (this._size[1] !== true) ? this._size[1] + 'px' : '';\n            }\n            this._sizeDirty = false;\n        }\n        if (this._contentDirty) {\n            this.deploy(target);\n            this.eventHandler.emit('deploy');\n            this._contentDirty = false;\n        }\n    };\n\n    /**\n     *  Remove all Famous-relevant attributes from a document element.\n     *    This is called by SurfaceManager's detach().\n     *    This is in some sense the reverse of .deploy().\n     *\n     * @private\n     * @method cleanup\n     * @param {ElementAllocator} allocator\n     */\n    Surface.prototype.cleanup = function cleanup(allocator) {\n        var i = 0;\n        var target = this._currTarget;\n        this.eventHandler.emit('recall');\n        this.recall(target);\n        target.style.display = 'none';\n        target.style.width = '';\n        target.style.height = '';\n        this._size = null;\n        _cleanupStyles.call(this, target);\n        var classList = this.getClassList();\n        _cleanupClasses.call(this, target);\n        for (i = 0; i < classList.length; i++) target.classList.remove(classList[i]);\n        if (this.elementClass) {\n            if (this.elementClass instanceof Array) {\n                for (i = 0; i < this.elementClass.length; i++) {\n                    target.classList.remove(this.elementClass[i]);\n                }\n            }\n            else {\n                target.classList.remove(this.elementClass);\n            }\n        }\n        _removeEventListeners.call(this, target);\n        this._currTarget = null;\n        allocator.deallocate(target);\n        _setInvisible(target);\n    };\n\n    /**\n     * Place the document element that this component manages into the document.\n     *\n     * @private\n     * @method deploy\n     * @param {Node} target document parent of this container\n     */\n    Surface.prototype.deploy = function deploy(target) {\n        var content = this.getContent();\n        if (content instanceof Node) {\n            while (target.hasChildNodes()) target.removeChild(target.firstChild);\n            target.appendChild(content);\n        }\n        else target.innerHTML = content;\n    };\n\n    /**\n     * Remove any contained document content associated with this surface\n     *   from the actual document.\n     *\n     * @private\n     * @method recall\n     */\n    Surface.prototype.recall = function recall(target) {\n        var df = document.createDocumentFragment();\n        while (target.hasChildNodes()) df.appendChild(target.firstChild);\n        this.setContent(df);\n    };\n\n    /**\n     *  Get the x and y dimensions of the surface.\n     *\n     * @method getSize\n     * @param {boolean} actual return computed size rather than provided\n     * @return {Array.Number} [x,y] size of surface\n     */\n    Surface.prototype.getSize = function getSize(actual) {\n        return actual ? this._size : (this.size || this._size);\n    };\n\n    /**\n     * Set x and y dimensions of the surface.\n     *\n     * @method setSize\n     * @param {Array.Number} size as [width, height]\n     */\n    Surface.prototype.setSize = function setSize(size) {\n        this.size = size ? [size[0], size[1]] : null;\n        this._sizeDirty = true;\n    };\n\n    module.exports = Surface;\n});\n","/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n *\n * Owner: mark@famo.us\n * @license MPL 2.0\n * @copyright Famous Industries, Inc. 2014\n */\n\ndefine(function(require, exports, module) {\n    var Transform = require('./Transform');\n\n    /* TODO: remove these dependencies when deprecation complete */\n    var Transitionable = require('famous/transitions/Transitionable');\n    var TransitionableTransform = require('famous/transitions/TransitionableTransform');\n\n    /**\n     *\n     *  A collection of visual changes to be\n     *    applied to another renderable component. This collection includes a\n     *    transform matrix, an opacity constant, a size, an origin specifier.\n     *    Modifier objects can be added to any RenderNode or object\n     *    capable of displaying renderables.  The Modifier's children and descendants\n     *    are transformed by the amounts specified in the Modifier's properties.\n     *\n     * @class Modifier\n     * @constructor\n     * @param {Object} [options] overrides of default options\n     * @param {Transform} [options.transform] affine transformation matrix\n     * @param {Number} [options.opacity]\n     * @param {Array.Number} [options.origin] origin adjustment\n     * @param {Array.Number} [options.size] size to apply to descendants\n     */\n    function Modifier(options) {\n        this._transformGetter = null;\n        this._opacityGetter = null;\n        this._originGetter = null;\n        this._sizeGetter = null;\n\n        /* TODO: remove this when deprecation complete */\n        this._legacyStates = {};\n\n        this._output = {\n            transform: Transform.identity,\n            opacity: 1,\n            origin: null,\n            size: null,\n            target: null\n        };\n\n        if (options) {\n            if (options.transform) this.transformFrom(options.transform);\n            if (options.opacity !== undefined) this.opacityFrom(options.opacity);\n            if (options.origin) this.originFrom(options.origin);\n            if (options.size) this.sizeFrom(options.size);\n        }\n    }\n\n    /**\n     * Function, object, or static transform matrix which provides the transform.\n     *   This is evaluated on every tick of the engine.\n     *\n     * @method transformFrom\n     *\n     * @param {Object} transform transform provider object\n     * @return {Modifier} this\n     */\n    Modifier.prototype.transformFrom = function transformFrom(transform) {\n        if (transform instanceof Function) this._transformGetter = transform;\n        else if (transform instanceof Object && transform.get) this._transformGetter = transform.get.bind(transform);\n        else {\n            this._transformGetter = null;\n            this._output.transform = transform;\n        }\n        return this;\n    };\n\n    /**\n     * Set function, object, or number to provide opacity, in range [0,1].\n     *\n     * @method opacityFrom\n     *\n     * @param {Object} opacity provider object\n     * @return {Modifier} this\n     */\n    Modifier.prototype.opacityFrom = function opacityFrom(opacity) {\n        if (opacity instanceof Function) this._opacityGetter = opacity;\n        else if (opacity instanceof Object && opacity.get) this._opacityGetter = opacity.get.bind(opacity);\n        else {\n            this._opacityGetter = null;\n            this._output.opacity = opacity;\n        }\n        return this;\n    };\n\n    /**\n     * Set function, object, or numerical array to provide origin, as [x,y],\n     *   where x and y are in the range [0,1].\n     *\n     * @method originFrom\n     *\n     * @param {Object} origin provider object\n     * @return {Modifier} this\n     */\n\n    Modifier.prototype.originFrom = function originFrom(origin) {\n        if (origin instanceof Function) this._originGetter = origin;\n        else if (origin instanceof Object && origin.get) this._originGetter = origin.get.bind(origin);\n        else {\n            this._originGetter = null;\n            this._output.origin = origin;\n        }\n        return this;\n    };\n\n    /**\n     * Set function, object, or numerical array to provide size, as [width, height].\n     *\n     * @method sizeFrom\n     *\n     * @param {Object} size provider object\n     * @return {Modifier} this\n     */\n    Modifier.prototype.sizeFrom = function sizeFrom(size) {\n        if (size instanceof Function) this._sizeGetter = size;\n        else if (size instanceof Object && size.get) this._sizeGetter = size.get.bind(size);\n        else {\n            this._sizeGetter = null;\n            this._output.size = size;\n        }\n        return this;\n    };\n\n     /**\n     * Deprecated: Prefer transformFrom with static Transform, or use a TransitionableTransform.\n     * @deprecated\n     * @method setTransform\n     *\n     * @param {Transform} transform Transform to transition to\n     * @param {Transitionable} transition Valid transitionable object\n     * @param {Function} callback callback to call after transition completes\n     * @return {Modifier} this\n     */\n    Modifier.prototype.setTransform = function setTransform(transform, transition, callback) {\n        if (transition || this._legacyStates.transform) {\n            if (!this._legacyStates.transform) {\n                this._legacyStates.transform = new TransitionableTransform(this._output.transform);\n            }\n            if (!this._transformGetter) this.transformFrom(this._legacyStates.transform);\n\n            this._legacyStates.transform.set(transform, transition, callback);\n            return this;\n        }\n        else return this.transformFrom(transform);\n    };\n\n    /**\n     * Deprecated: Prefer opacityFrom with static opacity array, or use a Transitionable with that opacity.\n     * @deprecated\n     * @method setOpacity\n     *\n     * @param {Number} opacity Opacity value to transition to.\n     * @param {Transitionable} transition Valid transitionable object\n     * @param {Function} callback callback to call after transition completes\n     * @return {Modifier} this\n     */\n    Modifier.prototype.setOpacity = function setOpacity(opacity, transition, callback) {\n        if (transition || this._legacyStates.opacity) {\n            if (!this._legacyStates.opacity) {\n                this._legacyStates.opacity = new Transitionable(this._output.opacity);\n            }\n            if (!this._opacityGetter) this.opacityFrom(this._legacyStates.opacity);\n\n            return this._legacyStates.opacity.set(opacity, transition, callback);\n        }\n        else return this.opacityFrom(opacity);\n    };\n\n    /**\n     * Deprecated: Prefer originFrom with static origin array, or use a Transitionable with that origin.\n     * @deprecated\n     * @method setOrigin\n     *\n     * @param {Array.Number} origin two element array with values between 0 and 1.\n     * @param {Transitionable} transition Valid transitionable object\n     * @param {Function} callback callback to call after transition completes\n     * @return {Modifier} this\n     */\n    Modifier.prototype.setOrigin = function setOrigin(origin, transition, callback) {\n        /* TODO: remove this if statement when deprecation complete */\n        if (transition || this._legacyStates.origin) {\n\n            if (!this._legacyStates.origin) {\n                this._legacyStates.origin = new Transitionable(this._output.origin || [0, 0]);\n            }\n            if (!this._originGetter) this.originFrom(this._legacyStates.origin);\n\n            this._legacyStates.origin.set(origin, transition, callback);\n            return this;\n        }\n        else return this.originFrom(origin);\n    };\n\n    /**\n     * Deprecated: Prefer sizeFrom with static origin array, or use a Transitionable with that size.\n     * @deprecated\n     * @method setSize\n     * @param {Array.Number} size two element array of [width, height]\n     * @param {Transitionable} transition Valid transitionable object\n     * @param {Function} callback callback to call after transition completes\n     * @return {Modifier} this\n     */\n    Modifier.prototype.setSize = function setSize(size, transition, callback) {\n        if (size && (transition || this._legacyStates.size)) {\n            if (!this._legacyStates.size) {\n                this._legacyStates.size = new Transitionable(this._output.size || [0, 0]);\n            }\n            if (!this._sizeGetter) this.sizeFrom(this._legacyStates.size);\n\n            this._legacyStates.size.set(size, transition, callback);\n            return this;\n        }\n        else return this.sizeFrom(size);\n    };\n\n    /**\n     * Deprecated: Prefer to stop transform in your provider object.\n     * @deprecated\n     * @method halt\n     */\n    Modifier.prototype.halt = function halt() {\n        if (this._legacyStates.transform) this._legacyStates.transform.halt();\n        if (this._legacyStates.opacity) this._legacyStates.opacity.halt();\n        if (this._legacyStates.origin) this._legacyStates.origin.halt();\n        if (this._legacyStates.size) this._legacyStates.size.halt();\n        this._transformGetter = null;\n        this._opacityGetter = null;\n        this._originGetter = null;\n        this._sizeGetter = null;\n    };\n\n    /**\n     * Deprecated: Prefer to use your provided transform or output of your transform provider.\n     * @deprecated\n     * @method getTransform\n     * @return {Object} transform provider object\n     */\n    Modifier.prototype.getTransform = function getTransform() {\n        return this._transformGetter();\n    };\n\n    /**\n     * Deprecated: Prefer to determine the end state of your transform from your transform provider\n     * @deprecated\n     * @method getFinalTransform\n     * @return {Transform} transform matrix\n     */\n    Modifier.prototype.getFinalTransform = function getFinalTransform() {\n        return this._legacyStates.transform ? this._legacyStates.transform.getFinal() : this._output.transform;\n    };\n\n    /**\n     * Deprecated: Prefer to use your provided opacity or output of your opacity provider.\n     * @deprecated\n     * @method getOpacity\n     * @return {Object} opacity provider object\n     */\n    Modifier.prototype.getOpacity = function getOpacity() {\n        return this._opacityGetter();\n    };\n    /**\n     * Deprecated: Prefer to use your provided origin or output of your origin provider.\n     * @deprecated\n     * @method getOrigin\n     * @return {Object} origin provider object\n     */\n    Modifier.prototype.getOrigin = function getOrigin() {\n        return this._originGetter();\n    };\n\n    /**\n     * Deprecated: Prefer to use your provided size or output of your size provider.\n     * @deprecated\n     * @method getSize\n     * @return {Object} size provider object\n     */\n    Modifier.prototype.getSize = function getSize() {\n        return this._sizeGetter ? this._sizeGetter() : this._output.size;\n    };\n\n    // call providers on tick to receive render spec elements to apply\n    function _update() {\n        if (this._transformGetter) this._output.transform = this._transformGetter();\n        if (this._opacityGetter) this._output.opacity = this._opacityGetter();\n        if (this._originGetter) this._output.origin = this._originGetter();\n        if (this._sizeGetter) this._output.size = this._sizeGetter();\n    }\n\n    /**\n     * Return render spec for this Modifier, applying to the provided\n     *    target component.  This is similar to render() for Surfaces.\n     *\n     * @private\n     * @method modify\n     *\n     * @param {Object} target (already rendered) render spec to\n     *    which to apply the transform.\n     * @return {Object} render spec for this Modifier, including the\n     *    provided target\n     */\n    Modifier.prototype.modify = function modify(target) {\n        _update.call(this);\n        this._output.target = target;\n        return this._output;\n    };\n\n    module.exports = Modifier;\n});\n","/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n *\n * Owner: mark@famo.us\n * @license MPL 2.0\n * @copyright Famous Industries, Inc. 2014\n */\n\ndefine(function(require, exports, module) {\n    var EventHandler = require('./EventHandler');\n    var OptionsManager = require('./OptionsManager');\n    var RenderNode = require('./RenderNode');\n\n    /**\n     * Useful for quickly creating elements within applications\n     *   with large event systems.  Consists of a RenderNode paired with\n     *   an input EventHandler and an output EventHandler.\n     *   Meant to be extended by the developer.\n     *\n     * @class View\n     * @uses EventHandler\n     * @uses OptionsManager\n     * @uses RenderNode\n     * @constructor\n     */\n    function View(options) {\n        this._node = new RenderNode();\n\n        this._eventInput = new EventHandler();\n        this._eventOutput = new EventHandler();\n        EventHandler.setInputHandler(this, this._eventInput);\n        EventHandler.setOutputHandler(this, this._eventOutput);\n\n        this.options = Object.create(this.constructor.DEFAULT_OPTIONS || View.DEFAULT_OPTIONS);\n        this._optionsManager = new OptionsManager(this.options);\n\n        if (options) this.setOptions(options);\n    }\n\n    View.DEFAULT_OPTIONS = {}; // no defaults\n\n    /**\n     * Look up options value by key\n     * @method getOptions\n     *\n     * @param {string} key key\n     * @return {Object} associated object\n     */\n    View.prototype.getOptions = function getOptions() {\n        return this._optionsManager.value();\n    };\n\n    /*\n     *  Set internal options.\n     *  No defaults options are set in View.\n     *\n     *  @method setOptions\n     *  @param {Object} options\n     */\n    View.prototype.setOptions = function setOptions(options) {\n        this._optionsManager.patch(options);\n    };\n\n    /**\n     * Add a child renderable to the view.\n     *   Note: This is meant to be used by an inheriting class\n     *   rather than from outside the prototype chain.\n     *\n     * @method add\n     * @return {RenderNode}\n     * @protected\n     */\n    View.prototype.add = function add() {\n        return this._node.add.apply(this._node, arguments);\n    };\n\n    /**\n     * Alias for add\n     * @method _add\n     */\n    View.prototype._add = View.prototype.add;\n\n    /**\n     * Generate a render spec from the contents of this component.\n     *\n     * @private\n     * @method render\n     * @return {number} Render spec for this component\n     */\n    View.prototype.render = function render() {\n        return this._node.render();\n    };\n\n    /**\n     * Return size of contained element.\n     *\n     * @method getSize\n     * @return {Array.Number} [width, height]\n     */\n    View.prototype.getSize = function getSize() {\n        if (this._node && this._node.getSize) {\n            return this._node.getSize.apply(this._node, arguments) || this.options.size;\n        }\n        else return this.options.size;\n    };\n\n    module.exports = View;\n});\n","/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n *\n * Owner: mark@famo.us\n * @license MPL 2.0\n * @copyright Famous Industries, Inc. 2014\n */\n\ndefine(function(require, exports, module) {\n    var EventEmitter = require('./EventEmitter');\n\n    /**\n     * EventHandler forwards received events to a set of provided callback functions.\n     * It allows events to be captured, processed, and optionally piped through to other event handlers.\n     *\n     * @class EventHandler\n     * @extends EventEmitter\n     * @constructor\n     */\n    function EventHandler() {\n        EventEmitter.apply(this, arguments);\n\n        this.downstream = []; // downstream event handlers\n        this.downstreamFn = []; // downstream functions\n\n        this.upstream = []; // upstream event handlers\n        this.upstreamListeners = {}; // upstream listeners\n    }\n    EventHandler.prototype = Object.create(EventEmitter.prototype);\n    EventHandler.prototype.constructor = EventHandler;\n\n    /**\n     * Assign an event handler to receive an object's input events.\n     *\n     * @method setInputHandler\n     * @static\n     *\n     * @param {Object} object object to mix trigger, subscribe, and unsubscribe functions into\n     * @param {EventHandler} handler assigned event handler\n     */\n    EventHandler.setInputHandler = function setInputHandler(object, handler) {\n        object.trigger = handler.trigger.bind(handler);\n        if (handler.subscribe && handler.unsubscribe) {\n            object.subscribe = handler.subscribe.bind(handler);\n            object.unsubscribe = handler.unsubscribe.bind(handler);\n        }\n    };\n\n    /**\n     * Assign an event handler to receive an object's output events.\n     *\n     * @method setOutputHandler\n     * @static\n     *\n     * @param {Object} object object to mix pipe, unpipe, on, addListener, and removeListener functions into\n     * @param {EventHandler} handler assigned event handler\n     */\n    EventHandler.setOutputHandler = function setOutputHandler(object, handler) {\n        if (handler instanceof EventHandler) handler.bindThis(object);\n        object.pipe = handler.pipe.bind(handler);\n        object.unpipe = handler.unpipe.bind(handler);\n        object.on = handler.on.bind(handler);\n        object.addListener = handler.on;\n        object.removeListener = handler.removeListener.bind(handler);\n    };\n\n    /**\n     * Trigger an event, sending to all downstream handlers\n     *   listening for provided 'type' key.\n     *\n     * @method emit\n     *\n     * @param {string} type event type key (for example, 'click')\n     * @param {Object} event event data\n     * @return {EventHandler} this\n     */\n    EventHandler.prototype.emit = function emit(type, event) {\n        EventEmitter.prototype.emit.apply(this, arguments);\n        var i = 0;\n        for (i = 0; i < this.downstream.length; i++) {\n            if (this.downstream[i].trigger) this.downstream[i].trigger(type, event);\n        }\n        for (i = 0; i < this.downstreamFn.length; i++) {\n            this.downstreamFn[i](type, event);\n        }\n        return this;\n    };\n\n    /**\n     * Alias for emit\n     * @method addListener\n     */\n    EventHandler.prototype.trigger = EventHandler.prototype.emit;\n\n    /**\n     * Add event handler object to set of downstream handlers.\n     *\n     * @method pipe\n     *\n     * @param {EventHandler} target event handler target object\n     * @return {EventHandler} passed event handler\n     */\n    EventHandler.prototype.pipe = function pipe(target) {\n        if (target.subscribe instanceof Function) return target.subscribe(this);\n\n        var downstreamCtx = (target instanceof Function) ? this.downstreamFn : this.downstream;\n        var index = downstreamCtx.indexOf(target);\n        if (index < 0) downstreamCtx.push(target);\n\n        if (target instanceof Function) target('pipe', null);\n        else if (target.trigger) target.trigger('pipe', null);\n\n        return target;\n    };\n\n    /**\n     * Remove handler object from set of downstream handlers.\n     *   Undoes work of \"pipe\".\n     *\n     * @method unpipe\n     *\n     * @param {EventHandler} target target handler object\n     * @return {EventHandler} provided target\n     */\n    EventHandler.prototype.unpipe = function unpipe(target) {\n        if (target.unsubscribe instanceof Function) return target.unsubscribe(this);\n\n        var downstreamCtx = (target instanceof Function) ? this.downstreamFn : this.downstream;\n        var index = downstreamCtx.indexOf(target);\n        if (index >= 0) {\n            downstreamCtx.splice(index, 1);\n            if (target instanceof Function) target('unpipe', null);\n            else if (target.trigger) target.trigger('unpipe', null);\n            return target;\n        }\n        else return false;\n    };\n\n    /**\n     * Bind a callback function to an event type handled by this object.\n     *\n     * @method \"on\"\n     *\n     * @param {string} type event type key (for example, 'click')\n     * @param {function(string, Object)} handler callback\n     * @return {EventHandler} this\n     */\n    EventHandler.prototype.on = function on(type, handler) {\n        EventEmitter.prototype.on.apply(this, arguments);\n        if (!(type in this.upstreamListeners)) {\n            var upstreamListener = this.trigger.bind(this, type);\n            this.upstreamListeners[type] = upstreamListener;\n            for (var i = 0; i < this.upstream.length; i++) {\n                this.upstream[i].on(type, upstreamListener);\n            }\n        }\n        return this;\n    };\n\n    /**\n     * Alias for \"on\"\n     * @method addListener\n     */\n    EventHandler.prototype.addListener = EventHandler.prototype.on;\n\n    /**\n     * Listen for events from an upstream event handler.\n     *\n     * @method subscribe\n     *\n     * @param {EventEmitter} source source emitter object\n     * @return {EventHandler} this\n     */\n    EventHandler.prototype.subscribe = function subscribe(source) {\n        var index = this.upstream.indexOf(source);\n        if (index < 0) {\n            this.upstream.push(source);\n            for (var type in this.upstreamListeners) {\n                source.on(type, this.upstreamListeners[type]);\n            }\n        }\n        return this;\n    };\n\n    /**\n     * Stop listening to events from an upstream event handler.\n     *\n     * @method unsubscribe\n     *\n     * @param {EventEmitter} source source emitter object\n     * @return {EventHandler} this\n     */\n    EventHandler.prototype.unsubscribe = function unsubscribe(source) {\n        var index = this.upstream.indexOf(source);\n        if (index >= 0) {\n            this.upstream.splice(index, 1);\n            for (var type in this.upstreamListeners) {\n                source.removeListener(type, this.upstreamListeners[type]);\n            }\n        }\n        return this;\n    };\n\n    module.exports = EventHandler;\n});\n","/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n *\n * Owner: david@famo.us\n * @license MPL 2.0\n * @copyright Famous Industries, Inc. 2014\n */\n\ndefine(function(require, exports, module) {\n    var MultipleTransition = require('./MultipleTransition');\n    var TweenTransition = require('./TweenTransition');\n\n    /**\n     * A state maintainer for a smooth transition between\n     *    numerically-specified states. Example numeric states include floats or\n     *    Transform objects.\n     *\n     * An initial state is set with the constructor or set(startState). A\n     *    corresponding end state and transition are set with set(endState,\n     *    transition). Subsequent calls to set(endState, transition) begin at\n     *    the last state. Calls to get(timestamp) provide the interpolated state\n     *    along the way.\n     *\n     * Note that there is no event loop here - calls to get() are the only way\n     *    to find state projected to the current (or provided) time and are\n     *    the only way to trigger callbacks. Usually this kind of object would\n     *    be part of the render() path of a visible component.\n     *\n     * @class Transitionable\n     * @constructor\n     * @param {number|Array.Number|Object.<number|string, number>} start\n     *    beginning state\n     */\n    function Transitionable(start) {\n        this.currentAction = null;\n        this.actionQueue = [];\n        this.callbackQueue = [];\n\n        this.state = 0;\n        this.velocity = undefined;\n        this._callback = undefined;\n        this._engineInstance = null;\n        this._currentMethod = null;\n\n        this.set(start);\n    }\n\n    var transitionMethods = {};\n\n    Transitionable.registerMethod = function registerMethod(name, engineClass) {\n        if (!(name in transitionMethods)) {\n            transitionMethods[name] = engineClass;\n            return true;\n        }\n        else return false;\n    };\n\n    Transitionable.unregisterMethod = function unregisterMethod(name) {\n        if (name in transitionMethods) {\n            delete transitionMethods[name];\n            return true;\n        }\n        else return false;\n    };\n\n    function _loadNext() {\n        if (this._callback) {\n            var callback = this._callback;\n            this._callback = undefined;\n            callback();\n        }\n        if (this.actionQueue.length <= 0) {\n            this.set(this.get()); // no update required\n            return;\n        }\n        this.currentAction = this.actionQueue.shift();\n        this._callback = this.callbackQueue.shift();\n\n        var method = null;\n        var endValue = this.currentAction[0];\n        var transition = this.currentAction[1];\n        if (transition instanceof Object && transition.method) {\n            method = transition.method;\n            if (typeof method === 'string') method = transitionMethods[method];\n        }\n        else {\n            method = TweenTransition;\n        }\n\n        if (this._currentMethod !== method) {\n            if (!(endValue instanceof Object) || method.SUPPORTS_MULTIPLE === true || endValue.length <= method.SUPPORTS_MULTIPLE) {\n                this._engineInstance = new method();\n            }\n            else {\n                this._engineInstance = new MultipleTransition(method);\n            }\n            this._currentMethod = method;\n        }\n\n        this._engineInstance.reset(this.state, this.velocity);\n        if (this.velocity !== undefined) transition.velocity = this.velocity;\n        this._engineInstance.set(endValue, transition, _loadNext.bind(this));\n    }\n\n    /**\n     * Add transition to end state to the queue of pending transitions. Special\n     *    Use: calling without a transition resets the object to that state with\n     *    no pending actions\n     *\n     * @method set\n     *\n     * @param {number|FamousMatrix|Array.Number|Object.<number, number>} endState\n     *    end state to which we interpolate\n     * @param {transition=} transition object of type {duration: number, curve:\n     *    f[0,1] -> [0,1] or name}. If transition is omitted, change will be\n     *    instantaneous.\n     * @param {function()=} callback Zero-argument function to call on observed\n     *    completion (t=1)\n     */\n    Transitionable.prototype.set = function set(endState, transition, callback) {\n        if (!transition) {\n            this.reset(endState);\n            if (callback) callback();\n            return this;\n        }\n\n        var action = [endState, transition];\n        this.actionQueue.push(action);\n        this.callbackQueue.push(callback);\n        if (!this.currentAction) _loadNext.call(this);\n        return this;\n    };\n\n    /**\n     * Cancel all transitions and reset to a stable state\n     *\n     * @method reset\n     *\n     * @param {number|Array.Number|Object.<number, number>} startState\n     *    stable state to set to\n     */\n    Transitionable.prototype.reset = function reset(startState, startVelocity) {\n        this._currentMethod = null;\n        this._engineInstance = null;\n        this.state = startState;\n        this.velocity = startVelocity;\n        this.currentAction = null;\n        this.actionQueue = [];\n        this.callbackQueue = [];\n    };\n\n    /**\n     * Add delay action to the pending action queue queue.\n     *\n     * @method delay\n     *\n     * @param {number} duration delay time (ms)\n     * @param {function} callback Zero-argument function to call on observed\n     *    completion (t=1)\n     */\n    Transitionable.prototype.delay = function delay(duration, callback) {\n        this.set(this._engineInstance.get(), {duration: duration,\n            curve: function() {\n                return 0;\n            }},\n            callback);\n    };\n\n    /**\n     * Get interpolated state of current action at provided time. If the last\n     *    action has completed, invoke its callback.\n     *\n     * @method get\n     *\n     * @param {number=} timestamp Evaluate the curve at a normalized version of this\n     *    time. If omitted, use current time. (Unix epoch time)\n     * @return {number|Object.<number|string, number>} beginning state\n     *    interpolated to this point in time.\n     */\n    Transitionable.prototype.get = function get(timestamp) {\n        if (this._engineInstance) {\n            if (this._engineInstance.getVelocity)\n                this.velocity = this._engineInstance.getVelocity();\n            this.state = this._engineInstance.get(timestamp);\n        }\n        return this.state;\n    };\n\n    /**\n     * Is there at least one action pending completion?\n     *\n     * @method isActive\n     *\n     * @return {boolean}\n     */\n    Transitionable.prototype.isActive = function isActive() {\n        return !!this.currentAction;\n    };\n\n    /**\n     * Halt transition at current state and erase all pending actions.\n     *\n     * @method halt\n     */\n    Transitionable.prototype.halt = function halt() {\n        this.set(this.get());\n    };\n\n    module.exports = Transitionable;\n});\n","/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n *\n * Owner: mark@famo.us\n * @license MPL 2.0\n * @copyright Famous Industries, Inc. 2014\n */\n\ndefine(function(require, exports, module) {\n    /**\n     * This namespace holds standalone functionality.\n     *  Currently includes name mapping for transition curves,\n     *  name mapping for origin pairs, and the after() function.\n     *\n     * @class Utility\n     * @static\n     */\n    var Utility = {};\n\n    /**\n     * Table of direction array positions\n     *\n     * @property {object} Direction\n     * @final\n     */\n    Utility.Direction = {\n        X: 0,\n        Y: 1,\n        Z: 2\n    };\n\n    /**\n     * Return wrapper around callback function. Once the wrapper is called N\n     *   times, invoke the callback function. Arguments and scope preserved.\n     *\n     * @method after\n     *\n     * @param {number} count number of calls before callback function invoked\n     * @param {Function} callback wrapped callback function\n     *\n     * @return {function} wrapped callback with coundown feature\n     */\n    Utility.after = function after(count, callback) {\n        var counter = count;\n        return function() {\n            counter--;\n            if (counter === 0) callback.apply(this, arguments);\n        };\n    };\n\n    /**\n     * Load a URL and return its contents in a callback\n     *\n     * @method loadURL\n     *\n     * @param {string} url URL of object\n     * @param {function} callback callback to dispatch with content\n     */\n    Utility.loadURL = function loadURL(url, callback) {\n        var xhr = new XMLHttpRequest();\n        xhr.onreadystatechange = function onreadystatechange() {\n            if (this.readyState === 4) {\n                if (callback) callback(this.responseText);\n            }\n        };\n        xhr.open('GET', url);\n        xhr.send();\n    };\n\n    /**\n     * Create a document fragment from a string of HTML\n     *\n     * @method createDocumentFragmentFromHTML\n     *\n     * @param {string} html HTML to convert to DocumentFragment\n     *\n     * @return {DocumentFragment} DocumentFragment representing input HTML\n     */\n    Utility.createDocumentFragmentFromHTML = function createDocumentFragmentFromHTML(html) {\n        var element = document.createElement('div');\n        element.innerHTML = html;\n        var result = document.createDocumentFragment();\n        while (element.hasChildNodes()) result.appendChild(element.firstChild);\n        return result;\n    };\n\n    module.exports = Utility;\n});\n","/*\r\n\tMIT License http://www.opensource.org/licenses/mit-license.php\r\n\tAuthor Tobias Koppers @sokra\r\n*/\r\nmodule.exports = function addStyle(cssCode) {\r\n\tif(typeof DEBUG !== \"undefined\" && DEBUG) {\r\n\t\tif(typeof document !== \"object\") throw new Error(\"The style-loader cannot be used in a non-browser environment\");\r\n\t}\r\n\tvar styleElement = document.createElement(\"style\");\r\n\tstyleElement.type = \"text/css\";\r\n\tif (styleElement.styleSheet) {\r\n\t\tstyleElement.styleSheet.cssText = cssCode;\r\n\t} else {\r\n\t\tstyleElement.appendChild(document.createTextNode(cssCode));\r\n\t}\r\n\tvar head = document.getElementsByTagName(\"head\")[0];\r\n\thead.appendChild(styleElement);\r\n\treturn function() {\r\n\t\thead.removeChild(styleElement);\r\n\t};\r\n}","/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n *\n * Owner: mark@famo.us\n * @license MPL 2.0\n * @copyright Famous Industries, Inc. 2014\n */\n\ndefine(function(require, exports, module) {\n\n    /**\n     * The singleton object initiated upon process\n     *   startup which manages all active Context instances, runs\n     *   the render dispatch loop, and acts as a listener and dispatcher\n     *   for events.  All methods are therefore static.\n     *\n     *   On static initialization, window.requestAnimationFrame is called with\n     *     the event loop function.\n     *\n     *   Note: Any window in which Engine runs will prevent default\n     *     scrolling behavior on the 'touchmove' event.\n     *\n     * @static\n     * @class Engine\n     */\n    var Context = require('./Context');\n    var EventHandler = require('./EventHandler');\n    var OptionsManager = require('./OptionsManager');\n\n    var Engine = {};\n\n    var contexts = [];\n    var nextTickQueue = [];\n    var deferQueue = [];\n\n    var lastTime = Date.now();\n    var frameTime;\n    var frameTimeLimit;\n    var loopEnabled = true;\n    var eventForwarders = {};\n    var eventHandler = new EventHandler();\n\n    var options = {\n        containerType: 'div',\n        containerClass: 'famous-container',\n        fpsCap: undefined,\n        runLoop: true\n    };\n    var optionsManager = new OptionsManager(options);\n\n    /** @const */\n    var MAX_DEFER_FRAME_TIME = 10;\n\n    /**\n     * Inside requestAnimationFrame loop, step() is called, which:\n     *   calculates current FPS (throttling loop if it is over limit set in setFPSCap),\n     *   emits dataless 'prerender' event on start of loop,\n     *   calls in order any one-shot functions registered by nextTick on last loop,\n     *   calls Context.update on all Context objects registered,\n     *   and emits dataless 'postrender' event on end of loop.\n     *\n     * @static\n     * @private\n     * @method step\n     */\n    Engine.step = function step() {\n        var currentTime = Date.now();\n\n        // skip frame if we're over our framerate cap\n        if (frameTimeLimit && currentTime - lastTime < frameTimeLimit) return;\n\n        var i = 0;\n\n        frameTime = currentTime - lastTime;\n        lastTime = currentTime;\n\n        eventHandler.emit('prerender');\n\n        // empty the queue\n        for (i = 0; i < nextTickQueue.length; i++) nextTickQueue[i].call(this);\n        nextTickQueue.splice(0);\n\n        // limit total execution time for deferrable functions\n        while (deferQueue.length && (Date.now() - currentTime) < MAX_DEFER_FRAME_TIME) {\n            deferQueue.shift().call(this);\n        }\n\n        for (i = 0; i < contexts.length; i++) contexts[i].update();\n\n        eventHandler.emit('postrender');\n    };\n\n    // engage requestAnimationFrame\n    function loop() {\n        if (options.runLoop) {\n            Engine.step();\n            requestAnimationFrame(loop);\n        }\n        else loopEnabled = false;\n    }\n    requestAnimationFrame(loop);\n\n    //\n    // Upon main document window resize (unless on an \"input\" HTML element):\n    //   scroll to the top left corner of the window,\n    //   and for each managed Context: emit the 'resize' event and update its size.\n    // @param {Object=} event document event\n    //\n    function handleResize(event) {\n        for (var i = 0; i < contexts.length; i++) {\n            contexts[i].emit('resize');\n        }\n        eventHandler.emit('resize');\n    }\n    window.addEventListener('resize', handleResize, false);\n    handleResize();\n\n    // prevent scrolling via browser\n    window.addEventListener('touchmove', function(event) {\n        event.preventDefault();\n    }, true);\n\n    /**\n     * Add event handler object to set of downstream handlers.\n     *\n     * @method pipe\n     *\n     * @param {EventHandler} target event handler target object\n     * @return {EventHandler} passed event handler\n     */\n    Engine.pipe = function pipe(target) {\n        if (target.subscribe instanceof Function) return target.subscribe(Engine);\n        else return eventHandler.pipe(target);\n    };\n\n    /**\n     * Remove handler object from set of downstream handlers.\n     *   Undoes work of \"pipe\".\n     *\n     * @method unpipe\n     *\n     * @param {EventHandler} target target handler object\n     * @return {EventHandler} provided target\n     */\n    Engine.unpipe = function unpipe(target) {\n        if (target.unsubscribe instanceof Function) return target.unsubscribe(Engine);\n        else return eventHandler.unpipe(target);\n    };\n\n    /**\n     * Bind a callback function to an event type handled by this object.\n     *\n     * @static\n     * @method \"on\"\n     *\n     * @param {string} type event type key (for example, 'click')\n     * @param {function(string, Object)} handler callback\n     * @return {EventHandler} this\n     */\n    Engine.on = function on(type, handler) {\n        if (!(type in eventForwarders)) {\n            eventForwarders[type] = eventHandler.emit.bind(eventHandler, type);\n            document.body.addEventListener(type, eventForwarders[type]);\n        }\n        return eventHandler.on(type, handler);\n    };\n\n    /**\n     * Trigger an event, sending to all downstream handlers\n     *   listening for provided 'type' key.\n     *\n     * @method emit\n     *\n     * @param {string} type event type key (for example, 'click')\n     * @param {Object} event event data\n     * @return {EventHandler} this\n     */\n    Engine.emit = function emit(type, event) {\n        return eventHandler.emit(type, event);\n    };\n\n    /**\n     * Unbind an event by type and handler.\n     *   This undoes the work of \"on\".\n     *\n     * @static\n     * @method removeListener\n     *\n     * @param {string} type event type key (for example, 'click')\n     * @param {function} handler function object to remove\n     * @return {EventHandler} internal event handler object (for chaining)\n     */\n    Engine.removeListener = function removeListener(type, handler) {\n        return eventHandler.removeListener(type, handler);\n    };\n\n    /**\n     * Return the current calculated frames per second of the Engine.\n     *\n     * @static\n     * @method getFPS\n     *\n     * @return {Number} calculated fps\n     */\n    Engine.getFPS = function getFPS() {\n        return 1000 / frameTime;\n    };\n\n    /**\n     * Set the maximum fps at which the system should run. If internal render\n     *    loop is called at a greater frequency than this FPSCap, Engine will\n     *    throttle render and update until this rate is achieved.\n     *\n     * @static\n     * @method setFPSCap\n     *\n     * @param {Number} fps maximum frames per second\n     */\n    Engine.setFPSCap = function setFPSCap(fps) {\n        frameTimeLimit = Math.floor(1000 / fps);\n    };\n\n    /**\n     * Return engine options.\n     *\n     * @static\n     * @method getOptions\n     * @param {string} key\n     * @return {Object} engine options\n     */\n    Engine.getOptions = function getOptions() {\n        return optionsManager.getOptions.apply(optionsManager, arguments);\n    };\n\n    /**\n     * Set engine options\n     *\n     * @static\n     * @method setOptions\n     *\n     * @param {Object} [options] overrides of default options\n     * @param {Number} [options.fpsCap]  maximum fps at which the system should run\n     * @param {boolean} [options.runLoop=true] whether the run loop should continue\n     * @param {string} [options.containerType=\"div\"] type of container element.  Defaults to 'div'.\n     * @param {string} [options.containerClass=\"famous-container\"] type of container element.  Defaults to 'famous-container'.\n     */\n    Engine.setOptions = function setOptions(options) {\n        return optionsManager.setOptions.apply(optionsManager, arguments);\n    };\n\n    /**\n     * Creates a new Context for rendering and event handling with\n     *    provided document element as top of each tree. This will be tracked by the\n     *    process-wide Engine.\n     *\n     * @static\n     * @method createContext\n     *\n     * @param {Node} el will be top of Famo.us document element tree\n     * @return {Context} new Context within el\n     */\n    Engine.createContext = function createContext(el) {\n        if (el === undefined) {\n            el = document.createElement(options.containerType);\n            el.classList.add(options.containerClass);\n            document.body.appendChild(el);\n        }\n        else if (!(el instanceof Element)) {\n            el = document.createElement(options.containerType);\n            throw new Error('Tried to create context on non-existent element');\n        }\n        var context = new Context(el);\n        Engine.registerContext(context);\n        return context;\n    };\n\n    /**\n     * Registers an existing context to be updated within the run loop.\n     *\n     * @static\n     * @method registerContext\n     *\n     * @param {Context} context Context to register\n     * @return {FamousContext} provided context\n     */\n    Engine.registerContext = function registerContext(context) {\n        contexts.push(context);\n        return context;\n    };\n\n    /**\n     * Queue a function to be executed on the next tick of the\n     *    Engine.\n     *\n     * @static\n     * @method nextTick\n     *\n     * @param {function(Object)} fn function accepting window object\n     */\n    Engine.nextTick = function nextTick(fn) {\n        nextTickQueue.push(fn);\n    };\n\n    /**\n     * Queue a function to be executed sometime soon, at a time that is\n     *    unlikely to affect frame rate.\n     *\n     * @static\n     * @method defer\n     *\n     * @param {Function} fn\n     */\n    Engine.defer = function defer(fn) {\n        deferQueue.push(fn);\n    };\n\n    optionsManager.on('change', function(data) {\n        if (data.id === 'fpsCap') Engine.setFPSCap(data.value);\n        else if (data.id === 'runLoop') {\n            // kick off the loop only if it was stopped\n            if (!loopEnabled && data.value) {\n                loopEnabled = true;\n                requestAnimationFrame(loop);\n            }\n        }\n    });\n\n    module.exports = Engine;\n});\n","/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n *\n * Owner: mark@famo.us\n * @license MPL 2.0\n * @copyright Famous Industries, Inc. 2014\n */\n\ndefine(function(require, exports, module) {\n    /**\n     * A singleton that maintains a global registry of Surfaces.\n     *   Private.\n     *\n     * @private\n     * @static\n     * @class Entity\n     */\n\n    var entities = [];\n\n    /**\n     * Get entity from global index.\n     *\n     * @private\n     * @method get\n     * @param {Number} id entity reigstration id\n     * @return {Surface} entity in the global index\n     */\n    function get(id) {\n        return entities[id];\n    }\n\n    /**\n     * Overwrite entity in the global index\n     *\n     * @private\n     * @method set\n     * @param {Number} id entity reigstration id\n     * @return {Surface} entity to add to the global index\n     */\n    function set(id, entity) {\n        entities[id] = entity;\n    }\n\n    /**\n     * Add entity to global index\n     *\n     * @private\n     * @method register\n     * @param {Surface} entity to add to global index\n     * @return {Number} new id\n     */\n    function register(entity) {\n        var id = entities.length;\n        set(id, entity);\n        return id;\n    }\n\n    /**\n     * Remove entity from global index\n     *\n     * @private\n     * @method unregister\n     * @param {Number} id entity reigstration id\n     */\n    function unregister(id) {\n        set(id, null);\n    }\n\n    module.exports = {\n        register: register,\n        unregister: unregister,\n        get: get,\n        set: set\n    };\n});\n","/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n *\n * Owner: mark@famo.us\n * @license MPL 2.0\n * @copyright Famous Industries, Inc. 2014\n */\n\ndefine(function(require, exports, module) {\n    var EventHandler = require('./EventHandler');\n\n    /**\n     *  A collection of methods for setting options which can be extended\n     *  onto other classes.\n     *\n     *\n     *  **** WARNING ****\n     *  You can only pass through objects that will compile into valid JSON.\n     *\n     *  Valid options:\n     *      Strings,\n     *      Arrays,\n     *      Objects,\n     *      Numbers,\n     *      Nested Objects,\n     *      Nested Arrays.\n     *\n     *    This excludes:\n     *        Document Fragments,\n     *        Functions\n     * @class OptionsManager\n     * @constructor\n     * @param {Object} value options dictionary\n     */\n    function OptionsManager(value) {\n        this._value = value;\n        this.eventOutput = null;\n    }\n\n    /**\n     * Create options manager from source dictionary with arguments overriden by patch dictionary.\n     *\n     * @static\n     * @method OptionsManager.patch\n     *\n     * @param {Object} source source arguments\n     * @param {...Object} data argument additions and overwrites\n     * @return {Object} source object\n     */\n    OptionsManager.patch = function patchObject(source, data) {\n        var manager = new OptionsManager(source);\n        for (var i = 1; i < arguments.length; i++) manager.patch(arguments[i]);\n        return source;\n    };\n\n    function _createEventOutput() {\n        this.eventOutput = new EventHandler();\n        this.eventOutput.bindThis(this);\n        EventHandler.setOutputHandler(this, this.eventOutput);\n    }\n\n    /**\n     * Create OptionsManager from source with arguments overriden by patches.\n     *   Triggers 'change' event on this object's event handler if the state of\n     *   the OptionsManager changes as a result.\n     *\n     * @method patch\n     *\n     * @param {...Object} arguments list of patch objects\n     * @return {OptionsManager} this\n     */\n    OptionsManager.prototype.patch = function patch() {\n        var myState = this._value;\n        for (var i = 0; i < arguments.length; i++) {\n            var data = arguments[i];\n            for (var k in data) {\n                if ((k in myState) && (data[k] && data[k].constructor === Object) && (myState[k] && myState[k].constructor === Object)) {\n                    if (!myState.hasOwnProperty(k)) myState[k] = Object.create(myState[k]);\n                    this.key(k).patch(data[k]);\n                    if (this.eventOutput) this.eventOutput.emit('change', {id: k, value: this.key(k).value()});\n                }\n                else this.set(k, data[k]);\n            }\n        }\n        return this;\n    };\n\n    /**\n     * Alias for patch\n     *\n     * @method setOptions\n     *\n     */\n    OptionsManager.prototype.setOptions = OptionsManager.prototype.patch;\n\n    /**\n     * Return OptionsManager based on sub-object retrieved by key\n     *\n     * @method key\n     *\n     * @param {string} identifier key\n     * @return {OptionsManager} new options manager with the value\n     */\n    OptionsManager.prototype.key = function key(identifier) {\n        var result = new OptionsManager(this._value[identifier]);\n        if (!(result._value instanceof Object) || result._value instanceof Array) result._value = {};\n        return result;\n    };\n\n    /**\n     * Look up value by key\n     * @method get\n     *\n     * @param {string} key key\n     * @return {Object} associated object\n     */\n    OptionsManager.prototype.get = function get(key) {\n        return this._value[key];\n    };\n\n    /**\n     * Alias for get\n     * @method getOptions\n     */\n    OptionsManager.prototype.getOptions = OptionsManager.prototype.get;\n\n    /**\n     * Set key to value.  Outputs 'change' event if a value is overwritten.\n     *\n     * @method set\n     *\n     * @param {string} key key string\n     * @param {Object} value value object\n     * @return {OptionsManager} new options manager based on the value object\n     */\n    OptionsManager.prototype.set = function set(key, value) {\n        var originalValue = this.get(key);\n        this._value[key] = value;\n        if (this.eventOutput && value !== originalValue) this.eventOutput.emit('change', {id: key, value: value});\n        return this;\n    };\n\n    /**\n     * Return entire object contents of this OptionsManager.\n     *\n     * @method value\n     *\n     * @return {Object} current state of options\n     */\n    OptionsManager.prototype.value = function value() {\n        return this._value;\n    };\n\n    /**\n     * Bind a callback function to an event type handled by this object.\n     *\n     * @method \"on\"\n     *\n     * @param {string} type event type key (for example, 'change')\n     * @param {function(string, Object)} handler callback\n     * @return {EventHandler} this\n     */\n    OptionsManager.prototype.on = function on() {\n        _createEventOutput.call(this);\n        return this.on.apply(this, arguments);\n    };\n\n    /**\n     * Unbind an event by type and handler.\n     *   This undoes the work of \"on\".\n     *\n     * @method removeListener\n     *\n     * @param {string} type event type key (for example, 'change')\n     * @param {function} handler function object to remove\n     * @return {EventHandler} internal event handler object (for chaining)\n     */\n    OptionsManager.prototype.removeListener = function removeListener() {\n        _createEventOutput.call(this);\n        return this.removeListener.apply(this, arguments);\n    };\n\n    /**\n     * Add event handler object to set of downstream handlers.\n     *\n     * @method pipe\n     *\n     * @param {EventHandler} target event handler target object\n     * @return {EventHandler} passed event handler\n     */\n    OptionsManager.prototype.pipe = function pipe() {\n        _createEventOutput.call(this);\n        return this.pipe.apply(this, arguments);\n    };\n\n    /**\n     * Remove handler object from set of downstream handlers.\n     * Undoes work of \"pipe\"\n     *\n     * @method unpipe\n     *\n     * @param {EventHandler} target target handler object\n     * @return {EventHandler} provided target\n     */\n    OptionsManager.prototype.unpipe = function unpipe() {\n        _createEventOutput.call(this);\n        return this.unpipe.apply(this, arguments);\n    };\n\n    module.exports = OptionsManager;\n});\n","/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n *\n * Owner: mark@famo.us\n * @license MPL 2.0\n * @copyright Famous Industries, Inc. 2014\n */\n\ndefine(function(require, exports, module) {\n    var Entity = require('./Entity');\n    var SpecParser = require('./SpecParser');\n\n    /**\n     * A wrapper for inserting a renderable component (like a Modifer or\n     *   Surface) into the render tree.\n     *\n     * @class RenderNode\n     * @constructor\n     *\n     * @param {Object} object Target renderable component\n     */\n    function RenderNode(object) {\n        this._object = null;\n        this._child = null;\n        this._hasMultipleChildren = false;\n        this._isRenderable = false;\n        this._isModifier = false;\n\n        this._resultCache = {};\n        this._prevResults = {};\n\n        this._childResult = null;\n\n        if (object) this.set(object);\n    }\n\n    /**\n     * Append a renderable to the list of this node's children.\n     *   This produces a new RenderNode in the tree.\n     *   Note: Does not double-wrap if child is a RenderNode already.\n     *\n     * @method add\n     * @param {Object} child renderable object\n     * @return {RenderNode} new render node wrapping child\n     */\n    RenderNode.prototype.add = function add(child) {\n        var childNode = (child instanceof RenderNode) ? child : new RenderNode(child);\n        if (this._child instanceof Array) this._child.push(childNode);\n        else if (this._child) {\n            this._child = [this._child, childNode];\n            this._hasMultipleChildren = true;\n            this._childResult = []; // to be used later\n        }\n        else this._child = childNode;\n\n        return childNode;\n    };\n\n    /**\n     * Return the single wrapped object.  Returns null if this node has multiple child nodes.\n     *\n     * @method get\n     *\n     * @return {Ojbect} contained renderable object\n     */\n    RenderNode.prototype.get = function get() {\n        return this._object || (this._hasMultipleChildren ? null : (this._child ? this._child.get() : null));\n    };\n\n    /**\n     * Overwrite the list of children to contain the single provided object\n     *\n     * @method set\n     * @param {Object} child renderable object\n     * @return {RenderNode} this render node, or child if it is a RenderNode\n     */\n    RenderNode.prototype.set = function set(child) {\n        this._childResult = null;\n        this._hasMultipleChildren = false;\n        this._isRenderable = child.render ? true : false;\n        this._isModifier = child.modify ? true : false;\n        this._object = child;\n        this._child = null;\n        if (child instanceof RenderNode) return child;\n        else return this;\n    };\n\n    /**\n     * Get render size of contained object.\n     *\n     * @method getSize\n     * @return {Array.Number} size of this or size of single child.\n     */\n    RenderNode.prototype.getSize = function getSize() {\n        var result = null;\n        var target = this.get();\n        if (target && target.getSize) result = target.getSize();\n        if (!result && this._child && this._child.getSize) result = this._child.getSize();\n        return result;\n    };\n\n    // apply results of rendering this subtree to the document\n    function _applyCommit(spec, context, cacheStorage) {\n        var result = SpecParser.parse(spec, context);\n        var keys = Object.keys(result);\n        for (var i = 0; i < keys.length; i++) {\n            var id = keys[i];\n            var childNode = Entity.get(id);\n            var commitParams = result[id];\n            commitParams.allocator = context.allocator;\n            var commitResult = childNode.commit(commitParams);\n            if (commitResult) _applyCommit(commitResult, context, cacheStorage);\n            else cacheStorage[id] = commitParams;\n        }\n    }\n\n    /**\n     * Commit the content change from this node to the document.\n     *\n     * @private\n     * @method commit\n     * @param {Context} context render context\n     */\n    RenderNode.prototype.commit = function commit(context) {\n        // free up some divs from the last loop\n        var prevKeys = Object.keys(this._prevResults);\n        for (var i = 0; i < prevKeys.length; i++) {\n            var id = prevKeys[i];\n            if (this._resultCache[id] === undefined) {\n                var object = Entity.get(id);\n                if (object.cleanup) object.cleanup(context.allocator);\n            }\n        }\n\n        this._prevResults = this._resultCache;\n        this._resultCache = {};\n        _applyCommit(this.render(), context, this._resultCache);\n    };\n\n    /**\n     * Generate a render spec from the contents of the wrapped component.\n     *\n     * @private\n     * @method render\n     *\n     * @return {Object} render specification for the component subtree\n     *    only under this node.\n     */\n    RenderNode.prototype.render = function render() {\n        if (this._isRenderable) return this._object.render();\n\n        var result = null;\n        if (this._hasMultipleChildren) {\n            result = this._childResult;\n            var children = this._child;\n            for (var i = 0; i < children.length; i++) {\n                result[i] = children[i].render();\n            }\n        }\n        else if (this._child) result = this._child.render();\n\n        return this._isModifier ? this._object.modify(result) : result;\n    };\n\n    module.exports = RenderNode;\n});\n","/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n *\n * Owner: mark@famo.us\n * @license MPL 2.0\n * @copyright Famous Industries, Inc. 2014\n */\n\ndefine(function(require, exports, module) {\n    var Modifier = require('famous/core/Modifier');\n    var Transform = require('famous/core/Transform');\n    var Transitionable = require('famous/transitions/Transitionable');\n    var TransitionableTransform = require('famous/transitions/TransitionableTransform');\n\n    /**\n     *  A collection of visual changes to be\n     *    applied to another renderable component, strongly coupled with the state that defines\n     *    those changes. This collection includes a\n     *    transform matrix, an opacity constant, a size, an origin specifier.\n     *    StateModifier objects can be added to any RenderNode or object\n     *    capable of displaying renderables.  The StateModifier's children and descendants\n     *    are transformed by the amounts specified in the modifier's properties.\n     *\n     * @class StateModifier\n     * @constructor\n     * @param {Object} [options] overrides of default options\n     * @param {Transform} [options.transform] affine transformation matrix\n     * @param {Number} [options.opacity]\n     * @param {Array.Number} [options.origin] origin adjustment\n     * @param {Array.Number} [options.size] size to apply to descendants\n     */\n    function StateModifier(options) {\n        this._transformState = new TransitionableTransform(Transform.identity);\n        this._opacityState = new Transitionable(1);\n        this._originState = new Transitionable([0, 0]);\n        this._sizeState = new Transitionable([0, 0]);\n\n        this._modifier = new Modifier({\n            transform: this._transformState,\n            opacity: this._opacityState,\n            origin: null,\n            size: null\n        });\n\n        this._hasOrigin = false;\n        this._hasSize = false;\n\n        if (options) {\n            if (options.transform) this.setTransform(options.transform);\n            if (options.opacity !== undefined) this.setOpacity(options.opacity);\n            if (options.origin) this.setOrigin(options.origin);\n            if (options.size) this.setSize(options.size);\n        }\n    }\n\n    /**\n     * Set the transform matrix of this modifier, either statically or\n     *   through a provided Transitionable.\n     *\n     * @method setTransform\n     *\n     * @param {Transform} transform Transform to transition to.\n     * @param {Transitionable} [transition] Valid transitionable object\n     * @param {Function} [callback] callback to call after transition completes\n     * @return {StateModifier} this\n     */\n    StateModifier.prototype.setTransform = function setTransform(transform, transition, callback) {\n        this._transformState.set(transform, transition, callback);\n        return this;\n    };\n\n    /**\n     * Set the opacity of this modifier, either statically or\n     *   through a provided Transitionable.\n     *\n     * @method setOpacity\n     *\n     * @param {Number} opacity Opacity value to transition to.\n     * @param {Transitionable} transition Valid transitionable object\n     * @param {Function} callback callback to call after transition completes\n     * @return {StateModifier} this\n     */\n    StateModifier.prototype.setOpacity = function setOpacity(opacity, transition, callback) {\n        this._opacityState.set(opacity, transition, callback);\n        return this;\n    };\n\n    /**\n     * Set the origin of this modifier, either statically or\n     *   through a provided Transitionable.\n     *\n     * @method setOrigin\n     *\n     * @param {Array.Number} origin two element array with values between 0 and 1.\n     * @param {Transitionable} transition Valid transitionable object\n     * @param {Function} callback callback to call after transition completes\n     * @return {StateModifier} this\n     */\n    StateModifier.prototype.setOrigin = function setOrigin(origin, transition, callback) {\n        if (origin === null) {\n            if (this._hasOrigin) {\n                this._modifier.originFrom(null);\n                this._hasOrigin = false;\n            }\n            return this;\n        }\n        else if (!this._hasOrigin) {\n            this._hasOrigin = true;\n            this._modifier.originFrom(this._originState);\n        }\n        this._originState.set(origin, transition, callback);\n        return this;\n    };\n\n    /**\n     * Set the size of this modifier, either statically or\n     *   through a provided Transitionable.\n     *\n     * @method setSize\n     *\n     * @param {Array.Number} size two element array with values between 0 and 1.\n     * @param {Transitionable} transition Valid transitionable object\n     * @param {Function} callback callback to call after transition completes\n     * @return {StateModifier} this\n     */\n    StateModifier.prototype.setSize = function setSize(size, transition, callback) {\n        if (size === null) {\n            if (this._hasSize) {\n                this._modifier.sizeFrom(null);\n                this._hasSize = false;\n            }\n            return this;\n        }\n        else if (!this._hasSize) {\n            this._hasSize = true;\n            this._modifier.sizeFrom(this._sizeState);\n        }\n        this._sizeState.set(size, transition, callback);\n        return this;\n    };\n\n    /**\n     * Stop the transition.\n     *\n     * @method halt\n     */\n    StateModifier.prototype.halt = function halt() {\n        this._transformState.halt();\n        this._opacityState.halt();\n        this._originState.halt();\n        this._sizeState.halt();\n    };\n\n    /**\n     * Get the current state of the transform matrix component.\n     *\n     * @method getTransform\n     * @return {Object} transform provider object\n     */\n    StateModifier.prototype.getTransform = function getTransform() {\n        return this._transformState.get();\n    };\n\n    /**\n     * Get the destination state of the transform component.\n     *\n     * @method getFinalTransform\n     * @return {Transform} transform matrix\n     */\n    StateModifier.prototype.getFinalTransform = function getFinalTransform() {\n        return this._transformState.getFinal();\n    };\n\n    /**\n     * Get the current state of the opacity component.\n     *\n     * @method getOpacity\n     * @return {Object} opacity provider object\n     */\n    StateModifier.prototype.getOpacity = function getOpacity() {\n        return this._opacityState.get();\n    };\n\n    /**\n     * Get the current state of the origin component.\n     *\n     * @method getOrigin\n     * @return {Object} origin provider object\n     */\n    StateModifier.prototype.getOrigin = function getOrigin() {\n        return this._hasOrigin ? this._originState.get() : null;\n    };\n\n    /**\n     * Get the current state of the size component.\n     *\n     * @method getSize\n     * @return {Object} size provider object\n     */\n    StateModifier.prototype.getSize = function getSize() {\n        return this._hasSize ? this._sizeState.get() : null;\n    };\n\n    /**\n     * Return render spec for this StateModifier, applying to the provided\n     *    target component.  This is similar to render() for Surfaces.\n     *\n     * @private\n     * @method modify\n     *\n     * @param {Object} target (already rendered) render spec to\n     *    which to apply the transform.\n     * @return {Object} render spec for this StateModifier, including the\n     *    provided target\n     */\n    StateModifier.prototype.modify = function modify(target) {\n        return this._modifier.modify(target);\n    };\n\n    module.exports = StateModifier;\n});\n","\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n *\n * Owner: mark@famo.us\n * @license MPL 2.0\n * @copyright Famous Industries, Inc. 2014\n */\n\ndefine(function(require, exports, module) {\n    var Surface = require('famous/core/Surface');\n\n    /**\n     * A surface containing image content.\n     *   This extends the Surface class.\n     *\n     * @class ImageSurface\n     *\n     * @extends Surface\n     * @constructor\n     * @param {Object} [options] overrides of default options\n     */\n    function ImageSurface(options) {\n        this._imageUrl = undefined;\n        Surface.apply(this, arguments);\n    }\n\n    ImageSurface.prototype = Object.create(Surface.prototype);\n    ImageSurface.prototype.constructor = ImageSurface;\n    ImageSurface.prototype.elementType = 'img';\n    ImageSurface.prototype.elementClass = 'famous-surface';\n\n    /**\n     * Set content URL.  This will cause a re-rendering.\n     * @method setContent\n     * @param {string} imageUrl\n     */\n    ImageSurface.prototype.setContent = function setContent(imageUrl) {\n        this._imageUrl = imageUrl;\n        this._contentDirty = true;\n    };\n\n    /**\n     * Place the document element that this component manages into the document.\n     *\n     * @private\n     * @method deploy\n     * @param {Node} target document parent of this container\n     */\n    ImageSurface.prototype.deploy = function deploy(target) {\n        target.src = this._imageUrl || '';\n    };\n\n    /**\n     * Remove this component and contained content from the document\n     *\n     * @private\n     * @method recall\n     *\n     * @param {Node} target node to which the component was deployed\n     */\n    ImageSurface.prototype.recall = function recall(target) {\n        target.src = '';\n    };\n\n    module.exports = ImageSurface;\n});\n","/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n *\n * Owner: david@famo.us\n * @license MPL 2.0\n * @copyright Famous Industries, Inc. 2014\n */\n\ndefine(function(require, exports, module) {\n    var Transitionable = require('./Transitionable');\n    var Transform = require('famous/core/Transform');\n    var Utility = require('famous/utilities/Utility');\n\n    /**\n     * A class for transitioning the state of a Transform by transitioning\n     * its translate, scale, skew and rotate components independently.\n     *\n     * @class TransitionableTransform\n     * @constructor\n     *\n     * @param [transform=Transform.identity] {Transform} The initial transform state\n     */\n    function TransitionableTransform(transform) {\n        this._final = Transform.identity.slice();\n        this.translate = new Transitionable([0, 0, 0]);\n        this.rotate = new Transitionable([0, 0, 0]);\n        this.skew = new Transitionable([0, 0, 0]);\n        this.scale = new Transitionable([1, 1, 1]);\n\n        if (transform) this.set(transform);\n    }\n\n    function _build() {\n        return Transform.build({\n            translate: this.translate.get(),\n            rotate: this.rotate.get(),\n            skew: this.skew.get(),\n            scale: this.scale.get()\n        });\n    }\n\n    /**\n     * An optimized way of setting only the translation component of a Transform\n     *\n     * @method setTranslate\n     * @chainable\n     *\n     * @param translate {Array}     New translation state\n     * @param [transition] {Object} Transition definition\n     * @param [callback] {Function} Callback\n     * @return {TransitionableTransform}\n     */\n    TransitionableTransform.prototype.setTranslate = function setTranslate(translate, transition, callback) {\n        this.translate.set(translate, transition, callback);\n        this._final = this._final.slice();\n        this._final[12] = translate[0];\n        this._final[13] = translate[1];\n        if (translate[2] !== undefined) this._final[14] = translate[2];\n        return this;\n    };\n\n    /**\n     * An optimized way of setting only the scale component of a Transform\n     *\n     * @method setTranslate\n     * @chainable\n     *\n     * @param scale {Array}         New scale state\n     * @param [transition] {Object} Transition definition\n     * @param [callback] {Function} Callback\n     * @return {TransitionableTransform}\n     */\n    TransitionableTransform.prototype.setScale = function setScale(scale, transition, callback) {\n        this.scale.set(scale, transition, callback);\n        this._final = this._final.slice();\n        this._final[0] = scale[0];\n        this._final[5] = scale[1];\n        if (scale[2] !== undefined) this._final[10] = scale[2];\n        return this;\n    };\n\n    /**\n     * An optimized way of setting only the rotational component of a Transform\n     *\n     * @method setTranslate\n     * @chainable\n     *\n     * @param eulerAngles {Array}   Euler angles for new rotation state\n     * @param [transition] {Object} Transition definition\n     * @param [callback] {Function} Callback\n     * @return {TransitionableTransform}\n     */\n    TransitionableTransform.prototype.setRotate = function setRotate(eulerAngles, transition, callback) {\n        this.rotate.set(eulerAngles, transition, callback);\n        this._final = _build.call(this);\n        this._final = Transform.build({\n            translate: this.translate.get(),\n            rotate: eulerAngles,\n            scale: this.scale.get(),\n            skew: this.skew.get()\n        });\n        return this;\n    };\n\n    /**\n     * An optimized way of setting only the skew component of a Transform\n     *\n     * @method setTranslate\n     * @chainable\n     *\n     * @param skewAngles {Array}    New skew state\n     * @param [transition] {Object} Transition definition\n     * @param [callback] {Function} Callback\n     * @return {TransitionableTransform}\n     */\n    TransitionableTransform.prototype.setSkew = function setSkew(skewAngles, transition, callback) {\n        this.skew.set(skewAngles, transition, callback);\n        this._final = Transform.build({\n            translate: this.translate.get(),\n            rotate: this.rotate.get(),\n            scale: this.scale.get(),\n            skew: skewAngles\n        });\n        return this;\n    };\n\n    /**\n     * Setter for a TransitionableTransform with optional parameters to transition\n     * between Transforms\n     *\n     * @method setTranslate\n     * @chainable\n     *\n     * @param transform {Array}     New transform state\n     * @param [transition] {Object} Transition definition\n     * @param [callback] {Function} Callback\n     * @return {TransitionableTransform}\n     */\n    TransitionableTransform.prototype.set = function set(transform, transition, callback) {\n        this._final = transform;\n        var components = Transform.interpret(transform);\n\n        var _callback = callback ? Utility.after(4, callback) : null;\n        this.translate.set(components.translate, transition, _callback);\n        this.rotate.set(components.rotate, transition, _callback);\n        this.skew.set(components.skew, transition, _callback);\n        this.scale.set(components.scale, transition, _callback);\n        return this;\n    };\n\n    /**\n     * Sets the default transition to use for transitioning betwen Transform states\n     *\n     * @method setDefaultTransition\n     *\n     * @param transition {Object} Transition definition\n     */\n    TransitionableTransform.prototype.setDefaultTransition = function setDefaultTransition(transition) {\n        this.translate.setDefault(transition);\n        this.rotate.setDefault(transition);\n        this.skew.setDefault(transition);\n        this.scale.setDefault(transition);\n    };\n\n    /**\n     * Getter. Returns the current state of the Transform\n     *\n     * @method get\n     *\n     * @return {Transform}\n     */\n    TransitionableTransform.prototype.get = function get() {\n        if (this.isActive()) {\n            return _build.call(this);\n        }\n        else return this._final;\n    };\n\n    /**\n     * Get the destination state of the Transform\n     *\n     * @method getFinal\n     *\n     * @return Transform {Transform}\n     */\n    TransitionableTransform.prototype.getFinal = function getFinal() {\n        return this._final;\n    };\n\n    /**\n     * Determine if the TransitionalTransform is currently transitioning\n     *\n     * @method isActive\n     *\n     * @return {Boolean}\n     */\n    TransitionableTransform.prototype.isActive = function isActive() {\n        return this.translate.isActive() || this.rotate.isActive() || this.scale.isActive() || this.skew.isActive();\n    };\n\n    /**\n     * Halts the transition\n     *\n     * @method halt\n     */\n    TransitionableTransform.prototype.halt = function halt() {\n        this._final = this.get();\n        this.translate.halt();\n        this.rotate.halt();\n        this.skew.halt();\n        this.scale.halt();\n    };\n\n    module.exports = TransitionableTransform;\n});\n","/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n *\n * Owner: mark@famo.us\n * @license MPL 2.0\n * @copyright Famous Industries, Inc. 2014\n */\n// TODO fix func-style\n/*eslint func-style: [0, \"declaration\"] */\n\ndefine(function(require, exports, module) {\n    /**\n     * An internal library to reproduce javascript time-based scheduling.\n     *   Using standard javascript setTimeout methods can have a negative performance impact\n     *   when combined with the Famous rendering process, so instead require Timer and call\n     *   Timer.setTimeout, Timer.setInterval, etc.\n     *\n     * @class Timer\n     * @constructor\n     */\n    var FamousEngine = require('famous/core/Engine');\n\n    var _event  = 'prerender';\n\n    var getTime = (window.performance) ?\n        function() {\n            return window.performance.now();\n        }\n        : function() {\n            return Date.now();\n        };\n\n    /**\n     * Add a function to be run on every prerender\n     *\n     * @method addTimerFunction\n     *\n     * @param {function} fn function to be run every prerender\n     *\n     * @return {function} function passed in as parameter\n     */\n    function addTimerFunction(fn) {\n        FamousEngine.on(_event, fn);\n        return fn;\n    }\n\n    /**\n     * Wraps a function to be invoked after a certain amount of time.\n     *  After a set duration has passed, it executes the function and\n     *  removes it as a listener to 'prerender'.\n     *\n     * @method setTimeout\n     *\n     * @param {function} fn function to be run after a specified duration\n     * @param {number} duration milliseconds from now to execute the function\n     *\n     * @return {function} function passed in as parameter\n     */\n    function setTimeout(fn, duration) {\n        var t = getTime();\n        var callback = function() {\n            var t2 = getTime();\n            if (t2 - t >= duration) {\n                fn.apply(this, arguments);\n                FamousEngine.removeListener(_event, callback);\n            }\n        };\n        return addTimerFunction(callback);\n    }\n\n    /**\n     * Wraps a function to be invoked after a certain amount of time.\n     *  After a set duration has passed, it executes the function and\n     *  resets the execution time.\n     *\n     * @method setInterval\n     *\n     * @param {function} fn function to be run after a specified duration\n     * @param {number} duration interval to execute function in milliseconds\n     *\n     * @return {function} function passed in as parameter\n     */\n    function setInterval(fn, duration) {\n        var t = getTime();\n        var callback = function() {\n            var t2 = getTime();\n            if (t2 - t >= duration) {\n                fn.apply(this, arguments);\n                t = getTime();\n            }\n        };\n        return addTimerFunction(callback);\n    }\n\n    /**\n     * Wraps a function to be invoked after a certain amount of prerender ticks.\n     *  Similar use to setTimeout but tied to the engine's run speed.\n     *\n     * @method after\n     *\n     * @param {function} fn function to be run after a specified amount of ticks\n     * @param {number} numTicks number of prerender frames to wait\n     *\n     * @return {function} function passed in as parameter\n     */\n    function after(fn, numTicks) {\n        if (numTicks === undefined) return undefined;\n        var callback = function() {\n            numTicks--;\n            if (numTicks <= 0) { //in case numTicks is fraction or negative\n                fn.apply(this, arguments);\n                clear(callback);\n            }\n        };\n        return addTimerFunction(callback);\n    }\n\n    /**\n     * Wraps a function to be continually invoked after a certain amount of prerender ticks.\n     *  Similar use to setInterval but tied to the engine's run speed.\n     *\n     * @method every\n     *\n     * @param {function} fn function to be run after a specified amount of ticks\n     * @param {number} numTicks number of prerender frames to wait\n     *\n     * @return {function} function passed in as parameter\n     */\n    function every(fn, numTicks) {\n        numTicks = numTicks || 1;\n        var initial = numTicks;\n        var callback = function() {\n            numTicks--;\n            if (numTicks <= 0) { //in case numTicks is fraction or negative\n                fn.apply(this, arguments);\n                numTicks = initial;\n            }\n        };\n        return addTimerFunction(callback);\n    }\n\n    /**\n     * Remove a function that gets called every prerender\n     *\n     * @method clear\n     *\n     * @param {function} fn event linstener\n     */\n    function clear(fn) {\n        FamousEngine.removeListener(_event, fn);\n    }\n\n    /**\n     * Executes a function after a certain amount of time. Makes sure\n     *  the function is not run multiple times.\n     *\n     * @method debounce\n     *\n     * @param {function} func function to run after certain amount of time\n     * @param {number} wait amount of time\n     *\n     * @return {function} function that is not able to debounce\n     */\n    function debounce(func, wait) {\n        var timeout;\n        var ctx;\n        var timestamp;\n        var result;\n        var args;\n        return function() {\n            ctx = this;\n            args = arguments;\n            timestamp = getTime();\n\n            var fn = function() {\n                var last = getTime - timestamp;\n\n                if (last < wait) {\n                    timeout = setTimeout(fn, wait - last);\n                } else {\n                    timeout = null;\n                    result = func.apply(ctx, args);\n                }\n            };\n\n            if (!timeout) {\n                timeout = setTimeout(fn, wait);\n            }\n\n            return result;\n        };\n    }\n\n    module.exports = {\n        setTimeout : setTimeout,\n        setInterval : setInterval,\n        debounce : debounce,\n        after : after,\n        every : every,\n        clear : clear\n    };\n\n});\n","\nclass Question extends Parse.Object\n  defaults:\n    question: ''\n    mood: ''\n  className: \"Sets\"\n\nmodule.exports = Question\n","var Question,\n  __hasProp = {}.hasOwnProperty,\n  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };\n\nQuestion = (function(_super) {\n  __extends(Question, _super);\n\n  function Question() {\n    return Question.__super__.constructor.apply(this, arguments);\n  }\n\n  Question.prototype.defaults = {\n    question: '',\n    mood: ''\n  };\n\n  Question.prototype.className = \"Sets\";\n\n  return Question;\n\n})(Parse.Object);\n\nmodule.exports = Question;\n","\n/*\n * classList.js: Cross-browser full element.classList implementation.\n * 2011-06-15\n *\n * By Eli Grey, http://eligrey.com\n * Public Domain.\n * NO WARRANTY EXPRESSED OR IMPLIED. USE AT YOUR OWN RISK.\n */\n\n/*global self, document, DOMException */\n\n/*! @source http://purl.eligrey.com/github/classList.js/blob/master/classList.js*/\n\nif (typeof document !== \"undefined\" && !(\"classList\" in document.createElement(\"a\"))) {\n\n(function (view) {\n\n\"use strict\";\n\nvar\n      classListProp = \"classList\"\n    , protoProp = \"prototype\"\n    , elemCtrProto = (view.HTMLElement || view.Element)[protoProp]\n    , objCtr = Object\n    , strTrim = String[protoProp].trim || function () {\n        return this.replace(/^\\s+|\\s+$/g, \"\");\n    }\n    , arrIndexOf = Array[protoProp].indexOf || function (item) {\n        var\n              i = 0\n            , len = this.length\n        ;\n        for (; i < len; i++) {\n            if (i in this && this[i] === item) {\n                return i;\n            }\n        }\n        return -1;\n    }\n    // Vendors: please allow content code to instantiate DOMExceptions\n    , DOMEx = function (type, message) {\n        this.name = type;\n        this.code = DOMException[type];\n        this.message = message;\n    }\n    , checkTokenAndGetIndex = function (classList, token) {\n        if (token === \"\") {\n            throw new DOMEx(\n                  \"SYNTAX_ERR\"\n                , \"An invalid or illegal string was specified\"\n            );\n        }\n        if (/\\s/.test(token)) {\n            throw new DOMEx(\n                  \"INVALID_CHARACTER_ERR\"\n                , \"String contains an invalid character\"\n            );\n        }\n        return arrIndexOf.call(classList, token);\n    }\n    , ClassList = function (elem) {\n        var\n              trimmedClasses = strTrim.call(elem.className)\n            , classes = trimmedClasses ? trimmedClasses.split(/\\s+/) : []\n            , i = 0\n            , len = classes.length\n        ;\n        for (; i < len; i++) {\n            this.push(classes[i]);\n        }\n        this._updateClassName = function () {\n            elem.className = this.toString();\n        };\n    }\n    , classListProto = ClassList[protoProp] = []\n    , classListGetter = function () {\n        return new ClassList(this);\n    }\n;\n// Most DOMException implementations don't allow calling DOMException's toString()\n// on non-DOMExceptions. Error's toString() is sufficient here.\nDOMEx[protoProp] = Error[protoProp];\nclassListProto.item = function (i) {\n    return this[i] || null;\n};\nclassListProto.contains = function (token) {\n    token += \"\";\n    return checkTokenAndGetIndex(this, token) !== -1;\n};\nclassListProto.add = function (token) {\n    token += \"\";\n    if (checkTokenAndGetIndex(this, token) === -1) {\n        this.push(token);\n        this._updateClassName();\n    }\n};\nclassListProto.remove = function (token) {\n    token += \"\";\n    var index = checkTokenAndGetIndex(this, token);\n    if (index !== -1) {\n        this.splice(index, 1);\n        this._updateClassName();\n    }\n};\nclassListProto.toggle = function (token) {\n    token += \"\";\n    if (checkTokenAndGetIndex(this, token) === -1) {\n        this.add(token);\n    } else {\n        this.remove(token);\n    }\n};\nclassListProto.toString = function () {\n    return this.join(\" \");\n};\n\nif (objCtr.defineProperty) {\n    var classListPropDesc = {\n          get: classListGetter\n        , enumerable: true\n        , configurable: true\n    };\n    try {\n        objCtr.defineProperty(elemCtrProto, classListProp, classListPropDesc);\n    } catch (ex) { // IE 8 doesn't support enumerable:true\n        if (ex.number === -0x7FF5EC54) {\n            classListPropDesc.enumerable = false;\n            objCtr.defineProperty(elemCtrProto, classListProp, classListPropDesc);\n        }\n    }\n} else if (objCtr[protoProp].__defineGetter__) {\n    elemCtrProto.__defineGetter__(classListProp, classListGetter);\n}\n\n}(self));\n\n}\n","if (!Function.prototype.bind) {\n    Function.prototype.bind = function (oThis) {\n        if (typeof this !== \"function\") {\n            // closest thing possible to the ECMAScript 5 internal IsCallable function\n            throw new TypeError(\"Function.prototype.bind - what is trying to be bound is not callable\");\n        }\n\n        var aArgs = Array.prototype.slice.call(arguments, 1),\n        fToBind = this,\n        fNOP = function () {},\n        fBound = function () {\n            return fToBind.apply(this instanceof fNOP && oThis\n                ? this\n                : oThis,\n                aArgs.concat(Array.prototype.slice.call(arguments)));\n        };\n\n        fNOP.prototype = this.prototype;\n        fBound.prototype = new fNOP();\n\n        return fBound;\n    };\n}\n","// adds requestAnimationFrame functionality\n// Source: http://strd6.com/2011/05/better-window-requestanimationframe-shim/\n\nwindow.requestAnimationFrame || (window.requestAnimationFrame =\n  window.webkitRequestAnimationFrame ||\n  window.mozRequestAnimationFrame    ||\n  window.oRequestAnimationFrame      ||\n  window.msRequestAnimationFrame     ||\n  function(callback, element) {\n    return window.setTimeout(function() {\n      callback(+new Date());\n  }, 1000 / 60);\n});\n","/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n *\n * Owner: mark@famo.us\n * @license MPL 2.0\n * @copyright Famous Industries, Inc. 2014\n */\n\ndefine(function(require, exports, module) {\n    var RenderNode = require('./RenderNode');\n    var EventHandler = require('./EventHandler');\n    var ElementAllocator = require('./ElementAllocator');\n    var Transform = require('./Transform');\n    var Transitionable = require('famous/transitions/Transitionable');\n\n    var _originZeroZero = [0, 0];\n\n    function _getElementSize(element) {\n        return [element.clientWidth, element.clientHeight];\n    }\n\n    /**\n     * The top-level container for a Famous-renderable piece of the document.\n     *   It is directly updated by the process-wide Engine object, and manages one\n     *   render tree root, which can contain other renderables.\n     *\n     * @class Context\n     * @constructor\n     * @private\n     * @param {Node} container Element in which content will be inserted\n     */\n    function Context(container) {\n        this.container = container;\n        this._allocator = new ElementAllocator(container);\n\n        this._node = new RenderNode();\n        this._eventOutput = new EventHandler();\n        this._size = _getElementSize(this.container);\n\n        this._perspectiveState = new Transitionable(0);\n        this._perspective = undefined;\n\n        this._nodeContext = {\n            allocator: this._allocator,\n            transform: Transform.identity,\n            opacity: 1,\n            origin: _originZeroZero,\n            size: this._size\n        };\n\n        this._eventOutput.on('resize', function() {\n            this.setSize(_getElementSize(this.container));\n        }.bind(this));\n\n    }\n\n    // Note: Unused\n    Context.prototype.getAllocator = function getAllocator() {\n        return this._allocator;\n    };\n\n    /**\n     * Add renderables to this Context's render tree.\n     *\n     * @method add\n     *\n     * @param {Object} obj renderable object\n     * @return {RenderNode} RenderNode wrapping this object, if not already a RenderNode\n     */\n    Context.prototype.add = function add(obj) {\n        return this._node.add(obj);\n    };\n\n    /**\n     * Move this Context to another containing document element.\n     *\n     * @method migrate\n     *\n     * @param {Node} container Element to which content will be migrated\n     */\n    Context.prototype.migrate = function migrate(container) {\n        if (container === this.container) return;\n        this.container = container;\n        this._allocator.migrate(container);\n    };\n\n    /**\n     * Gets viewport size for Context.\n     *\n     * @method getSize\n     *\n     * @return {Array.Number} viewport size as [width, height]\n     */\n    Context.prototype.getSize = function getSize() {\n        return this._size;\n    };\n\n    /**\n     * Sets viewport size for Context.\n     *\n     * @method setSize\n     *\n     * @param {Array.Number} size [width, height].  If unspecified, use size of root document element.\n     */\n    Context.prototype.setSize = function setSize(size) {\n        if (!size) size = _getElementSize(this.container);\n        this._size[0] = size[0];\n        this._size[1] = size[1];\n    };\n\n    /**\n     * Commit this Context's content changes to the document.\n     *\n     * @private\n     * @method update\n     * @param {Object} contextParameters engine commit specification\n     */\n    Context.prototype.update = function update(contextParameters) {\n        if (contextParameters) {\n            if (contextParameters.transform) this._nodeContext.transform = contextParameters.transform;\n            if (contextParameters.opacity) this._nodeContext.opacity = contextParameters.opacity;\n            if (contextParameters.origin) this._nodeContext.origin = contextParameters.origin;\n            if (contextParameters.size) this._nodeContext.size = contextParameters.size;\n        }\n        var perspective = this._perspectiveState.get();\n        if (perspective !== this._perspective) {\n            this.container.style.perspective = perspective ? perspective.toFixed() + 'px' : '';\n            this.container.style.webkitPerspective = perspective ? perspective.toFixed() : '';\n            this._perspective = perspective;\n        }\n\n        this._node.commit(this._nodeContext);\n    };\n\n    /**\n     * Get current perspective of this context in pixels.\n     *\n     * @method getPerspective\n     * @return {Number} depth perspective in pixels\n     */\n    Context.prototype.getPerspective = function getPerspective() {\n        return this._perspectiveState.get();\n    };\n\n    /**\n     * Set current perspective of this context in pixels.\n     *\n     * @method setPerspective\n     * @param {Number} perspective in pixels\n     * @param {Object} [transition] Transitionable object for applying the change\n     * @param {function(Object)} callback function called on completion of transition\n     */\n    Context.prototype.setPerspective = function setPerspective(perspective, transition, callback) {\n        return this._perspectiveState.set(perspective, transition, callback);\n    };\n\n    /**\n     * Trigger an event, sending to all downstream handlers\n     *   listening for provided 'type' key.\n     *\n     * @method emit\n     *\n     * @param {string} type event type key (for example, 'click')\n     * @param {Object} event event data\n     * @return {EventHandler} this\n     */\n    Context.prototype.emit = function emit(type, event) {\n        return this._eventOutput.emit(type, event);\n    };\n\n    /**\n     * Bind a callback function to an event type handled by this object.\n     *\n     * @method \"on\"\n     *\n     * @param {string} type event type key (for example, 'click')\n     * @param {function(string, Object)} handler callback\n     * @return {EventHandler} this\n     */\n    Context.prototype.on = function on(type, handler) {\n        return this._eventOutput.on(type, handler);\n    };\n\n    /**\n     * Unbind an event by type and handler.\n     *   This undoes the work of \"on\".\n     *\n     * @method removeListener\n     *\n     * @param {string} type event type key (for example, 'click')\n     * @param {function} handler function object to remove\n     * @return {EventHandler} internal event handler object (for chaining)\n     */\n    Context.prototype.removeListener = function removeListener(type, handler) {\n        return this._eventOutput.removeListener(type, handler);\n    };\n\n    /**\n     * Add event handler object to set of downstream handlers.\n     *\n     * @method pipe\n     *\n     * @param {EventHandler} target event handler target object\n     * @return {EventHandler} passed event handler\n     */\n    Context.prototype.pipe = function pipe(target) {\n        return this._eventOutput.pipe(target);\n    };\n\n    /**\n     * Remove handler object from set of downstream handlers.\n     *   Undoes work of \"pipe\".\n     *\n     * @method unpipe\n     *\n     * @param {EventHandler} target target handler object\n     * @return {EventHandler} provided target\n     */\n    Context.prototype.unpipe = function unpipe(target) {\n        return this._eventOutput.unpipe(target);\n    };\n\n    module.exports = Context;\n});\n","/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n *\n * Owner: mark@famo.us\n * @license MPL 2.0\n * @copyright Famous Industries, Inc. 2014\n */\n\ndefine(function(require, exports, module) {\n\n    /**\n     * Internal helper object to Context that handles the process of\n     *   creating and allocating DOM elements within a managed div.\n     *   Private.\n     *\n     * @class ElementAllocator\n     * @constructor\n     * @private\n     * @param {Node} container document element in which Famo.us content will be inserted\n     */\n    function ElementAllocator(container) {\n        if (!container) container = document.createDocumentFragment();\n        this.container = container;\n        this.detachedNodes = {};\n        this.nodeCount = 0;\n    }\n\n    /**\n     * Move the document elements from their original container to a new one.\n     *\n     * @private\n     * @method migrate\n     *\n     * @param {Node} container document element to which Famo.us content will be migrated\n     */\n    ElementAllocator.prototype.migrate = function migrate(container) {\n        var oldContainer = this.container;\n        if (container === oldContainer) return;\n\n        if (oldContainer instanceof DocumentFragment) {\n            container.appendChild(oldContainer);\n        }\n        else {\n            while (oldContainer.hasChildNodes()) {\n                container.appendChild(oldContainer.removeChild(oldContainer.firstChild));\n            }\n        }\n\n        this.container = container;\n    };\n\n    /**\n     * Allocate an element of specified type from the pool.\n     *\n     * @private\n     * @method allocate\n     *\n     * @param {string} type type of element, e.g. 'div'\n     * @return {Node} allocated document element\n     */\n    ElementAllocator.prototype.allocate = function allocate(type) {\n        type = type.toLowerCase();\n        if (!(type in this.detachedNodes)) this.detachedNodes[type] = [];\n        var nodeStore = this.detachedNodes[type];\n        var result;\n        if (nodeStore.length > 0) {\n            result = nodeStore.pop();\n        }\n        else {\n            result = document.createElement(type);\n            this.container.appendChild(result);\n        }\n        this.nodeCount++;\n        return result;\n    };\n\n    /**\n     * De-allocate an element of specified type to the pool.\n     *\n     * @private\n     * @method deallocate\n     *\n     * @param {Node} element document element to deallocate\n     */\n    ElementAllocator.prototype.deallocate = function deallocate(element) {\n        var nodeType = element.nodeName.toLowerCase();\n        var nodeStore = this.detachedNodes[nodeType];\n        nodeStore.push(element);\n        this.nodeCount--;\n    };\n\n    /**\n     * Get count of total allocated nodes in the document.\n     *\n     * @private\n     * @method getNodeCount\n     *\n     * @return {Number} total node count\n     */\n    ElementAllocator.prototype.getNodeCount = function getNodeCount() {\n        return this.nodeCount;\n    };\n\n    module.exports = ElementAllocator;\n});\n","/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n *\n * Owner: mark@famo.us\n * @license MPL 2.0\n * @copyright Famous Industries, Inc. 2014\n */\n\ndefine(function(require, exports, module) {\n    /**\n     * EventEmitter represents a channel for events.\n     *\n     * @class EventEmitter\n     * @constructor\n     */\n    function EventEmitter() {\n        this.listeners = {};\n        this._owner = this;\n    }\n\n    /**\n     * Trigger an event, sending to all downstream handlers\n     *   listening for provided 'type' key.\n     *\n     * @method emit\n     *\n     * @param {string} type event type key (for example, 'click')\n     * @param {Object} event event data\n     * @return {EventHandler} this\n     */\n    EventEmitter.prototype.emit = function emit(type, event) {\n        var handlers = this.listeners[type];\n        if (handlers) {\n            for (var i = 0; i < handlers.length; i++) {\n                handlers[i].call(this._owner, event);\n            }\n        }\n        return this;\n    };\n\n    /**\n     * Bind a callback function to an event type handled by this object.\n     *\n     * @method \"on\"\n     *\n     * @param {string} type event type key (for example, 'click')\n     * @param {function(string, Object)} handler callback\n     * @return {EventHandler} this\n     */\n   EventEmitter.prototype.on = function on(type, handler) {\n        if (!(type in this.listeners)) this.listeners[type] = [];\n        var index = this.listeners[type].indexOf(handler);\n        if (index < 0) this.listeners[type].push(handler);\n        return this;\n    };\n\n    /**\n     * Alias for \"on\".\n     * @method addListener\n     */\n    EventEmitter.prototype.addListener = EventEmitter.prototype.on;\n\n   /**\n     * Unbind an event by type and handler.\n     *   This undoes the work of \"on\".\n     *\n     * @method removeListener\n     *\n     * @param {string} type event type key (for example, 'click')\n     * @param {function} handler function object to remove\n     * @return {EventEmitter} this\n     */\n    EventEmitter.prototype.removeListener = function removeListener(type, handler) {\n        var index = this.listeners[type].indexOf(handler);\n        if (index >= 0) this.listeners[type].splice(index, 1);\n        return this;\n    };\n\n    /**\n     * Call event handlers with this set to owner.\n     *\n     * @method bindThis\n     *\n     * @param {Object} owner object this EventEmitter belongs to\n     */\n    EventEmitter.prototype.bindThis = function bindThis(owner) {\n        this._owner = owner;\n    };\n\n    module.exports = EventEmitter;\n});\n","\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n *\n * Owner: mark@famo.us\n * @license MPL 2.0\n * @copyright Famous Industries, Inc. 2014\n */\n\ndefine(function(require, exports, module) {\n    var Transform = require('./Transform');\n\n    /**\n     *\n     * This object translates the rendering instructions (\"render specs\")\n     *   that renderable components generate into document update\n     *   instructions (\"update specs\").  Private.\n     *\n     * @private\n     * @class SpecParser\n     * @constructor\n     */\n    function SpecParser() {\n        this.result = {};\n    }\n    SpecParser._instance = new SpecParser();\n\n    /**\n     * Convert a render spec coming from the context's render chain to an\n     *    update spec for the update chain. This is the only major entry point\n     *    for a consumer of this class.\n     *\n     * @method parse\n     * @static\n     * @private\n     *\n     * @param {renderSpec} spec input render spec\n     * @param {Object} context context to do the parse in\n     * @return {Object} the resulting update spec (if no callback\n     *   specified, else none)\n     */\n    SpecParser.parse = function parse(spec, context) {\n        return SpecParser._instance.parse(spec, context);\n    };\n\n    /**\n     * Convert a renderSpec coming from the context's render chain to an update\n     *    spec for the update chain. This is the only major entrypoint for a\n     *    consumer of this class.\n     *\n     * @method parse\n     *\n     * @private\n     * @param {renderSpec} spec input render spec\n     * @param {Context} context\n     * @return {updateSpec} the resulting update spec\n     */\n    SpecParser.prototype.parse = function parse(spec, context) {\n        this.reset();\n        this._parseSpec(spec, context, Transform.identity);\n        return this.result;\n    };\n\n    /**\n     * Prepare SpecParser for re-use (or first use) by setting internal state\n     *  to blank.\n     *\n     * @private\n     * @method reset\n     */\n    SpecParser.prototype.reset = function reset() {\n        this.result = {};\n    };\n\n    // Multiply matrix M by vector v\n    function _vecInContext(v, m) {\n        return [\n            v[0] * m[0] + v[1] * m[4] + v[2] * m[8],\n            v[0] * m[1] + v[1] * m[5] + v[2] * m[9],\n            v[0] * m[2] + v[1] * m[6] + v[2] * m[10]\n        ];\n    }\n\n    var _originZeroZero = [0, 0];\n\n    // From the provided renderSpec tree, recursively compose opacities,\n    //    origins, transforms, and sizes corresponding to each surface id from\n    //    the provided renderSpec tree structure. On completion, those\n    //    properties of 'this' object should be ready to use to build an\n    //    updateSpec.\n    SpecParser.prototype._parseSpec = function _parseSpec(spec, parentContext, sizeContext) {\n        var id;\n        var target;\n        var transform;\n        var opacity;\n        var origin;\n        var size;\n\n        if (typeof spec === 'number') {\n            id = spec;\n            transform = parentContext.transform;\n            if (parentContext.size && parentContext.origin && (parentContext.origin[0] || parentContext.origin[1])) {\n                var originAdjust = [parentContext.origin[0] * parentContext.size[0], parentContext.origin[1] * parentContext.size[1], 0];\n                transform = Transform.thenMove(transform, _vecInContext(originAdjust, sizeContext));\n            }\n            this.result[id] = {\n                transform: transform,\n                opacity: parentContext.opacity,\n                origin: parentContext.origin || _originZeroZero,\n                size: parentContext.size\n            };\n        }\n        else if (!spec) { // placed here so 0 will be cached earlier\n            return;\n        }\n        else if (spec instanceof Array) {\n            for (var i = 0; i < spec.length; i++) {\n                this._parseSpec(spec[i], parentContext, sizeContext);\n            }\n        }\n        else {\n            target = spec.target;\n            transform = parentContext.transform;\n            opacity = parentContext.opacity;\n            origin = parentContext.origin;\n            size = parentContext.size;\n            var nextSizeContext = sizeContext;\n\n            if (spec.opacity !== undefined) opacity = parentContext.opacity * spec.opacity;\n            if (spec.transform) transform = Transform.multiply(parentContext.transform, spec.transform);\n            if (spec.origin) {\n                origin = spec.origin;\n                nextSizeContext = parentContext.transform;\n            }\n            if (spec.size) {\n                var parentSize = parentContext.size;\n                size = [\n                    spec.size[0] !== undefined ? spec.size[0] : parentSize[0],\n                    spec.size[1] !== undefined ? spec.size[1] : parentSize[1]\n                ];\n                if (parentSize && origin && (origin[0] || origin[1])) {\n                    transform = Transform.thenMove(transform, _vecInContext([origin[0] * parentSize[0], origin[1] * parentSize[1], 0], sizeContext));\n                    transform = Transform.moveThen([-origin[0] * size[0], -origin[1] * size[1], 0], transform);\n                }\n                nextSizeContext = parentContext.transform;\n                origin = null;\n            }\n\n            this._parseSpec(target, {\n                transform: transform,\n                opacity: opacity,\n                origin: origin,\n                size: size\n            }, nextSizeContext);\n        }\n    };\n\n    module.exports = SpecParser;\n});\n","/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n *\n * Owner: david@famo.us\n * @license MPL 2.0\n * @copyright Famous Industries, Inc. 2014\n */\n\ndefine(function(require, exports, module) {\n\n    /*\n     * A library of curves which map an animation explicitly as a function of time.\n     *\n     * @class Easing\n     */\n    var Easing = {\n\n        /**\n         * @property inQuad\n         * @static\n         */\n        inQuad: function(t) {\n            return t*t;\n        },\n\n        /**\n         * @property outQuad\n         * @static\n         */\n        outQuad: function(t) {\n            return -(t-=1)*t+1;\n        },\n\n        /**\n         * @property inOutQuad\n         * @static\n         */\n        inOutQuad: function(t) {\n            if ((t/=.5) < 1) return .5*t*t;\n            return -.5*((--t)*(t-2) - 1);\n        },\n\n        /**\n         * @property inCubic\n         * @static\n         */\n        inCubic: function(t) {\n            return t*t*t;\n        },\n\n        /**\n         * @property outCubic\n         * @static\n         */\n        outCubic: function(t) {\n            return ((--t)*t*t + 1);\n        },\n\n        /**\n         * @property inOutCubic\n         * @static\n         */\n        inOutCubic: function(t) {\n            if ((t/=.5) < 1) return .5*t*t*t;\n            return .5*((t-=2)*t*t + 2);\n        },\n\n        /**\n         * @property inQuart\n         * @static\n         */\n        inQuart: function(t) {\n            return t*t*t*t;\n        },\n\n        /**\n         * @property outQuart\n         * @static\n         */\n        outQuart: function(t) {\n            return -((--t)*t*t*t - 1);\n        },\n\n        /**\n         * @property inOutQuart\n         * @static\n         */\n        inOutQuart: function(t) {\n            if ((t/=.5) < 1) return .5*t*t*t*t;\n            return -.5 * ((t-=2)*t*t*t - 2);\n        },\n\n        /**\n         * @property inQuint\n         * @static\n         */\n        inQuint: function(t) {\n            return t*t*t*t*t;\n        },\n\n        /**\n         * @property outQuint\n         * @static\n         */\n        outQuint: function(t) {\n            return ((--t)*t*t*t*t + 1);\n        },\n\n        /**\n         * @property inOutQuint\n         * @static\n         */\n        inOutQuint: function(t) {\n            if ((t/=.5) < 1) return .5*t*t*t*t*t;\n            return .5*((t-=2)*t*t*t*t + 2);\n        },\n\n        /**\n         * @property inSine\n         * @static\n         */\n        inSine: function(t) {\n            return -1.0*Math.cos(t * (Math.PI/2)) + 1.0;\n        },\n\n        /**\n         * @property outSine\n         * @static\n         */\n        outSine: function(t) {\n            return Math.sin(t * (Math.PI/2));\n        },\n\n        /**\n         * @property inOutSine\n         * @static\n         */\n        inOutSine: function(t) {\n            return -.5*(Math.cos(Math.PI*t) - 1);\n        },\n\n        /**\n         * @property inExpo\n         * @static\n         */\n        inExpo: function(t) {\n            return (t===0) ? 0.0 : Math.pow(2, 10 * (t - 1));\n        },\n\n        /**\n         * @property outExpo\n         * @static\n         */\n        outExpo: function(t) {\n            return (t===1.0) ? 1.0 : (-Math.pow(2, -10 * t) + 1);\n        },\n\n        /**\n         * @property inOutExpo\n         * @static\n         */\n        inOutExpo: function(t) {\n            if (t===0) return 0.0;\n            if (t===1.0) return 1.0;\n            if ((t/=.5) < 1) return .5 * Math.pow(2, 10 * (t - 1));\n            return .5 * (-Math.pow(2, -10 * --t) + 2);\n        },\n\n        /**\n         * @property inCirc\n         * @static\n         */\n        inCirc: function(t) {\n            return -(Math.sqrt(1 - t*t) - 1);\n        },\n\n        /**\n         * @property outCirc\n         * @static\n         */\n        outCirc: function(t) {\n            return Math.sqrt(1 - (--t)*t);\n        },\n\n        /**\n         * @property inOutCirc\n         * @static\n         */\n        inOutCirc: function(t) {\n            if ((t/=.5) < 1) return -.5 * (Math.sqrt(1 - t*t) - 1);\n            return .5 * (Math.sqrt(1 - (t-=2)*t) + 1);\n        },\n\n        /**\n         * @property inElastic\n         * @static\n         */\n        inElastic: function(t) {\n            var s=1.70158;var p=0;var a=1.0;\n            if (t===0) return 0.0;  if (t===1) return 1.0;  if (!p) p=.3;\n            s = p/(2*Math.PI) * Math.asin(1.0/a);\n            return -(a*Math.pow(2,10*(t-=1)) * Math.sin((t-s)*(2*Math.PI)/ p));\n        },\n\n        /**\n         * @property outElastic\n         * @static\n         */\n        outElastic: function(t) {\n            var s=1.70158;var p=0;var a=1.0;\n            if (t===0) return 0.0;  if (t===1) return 1.0;  if (!p) p=.3;\n            s = p/(2*Math.PI) * Math.asin(1.0/a);\n            return a*Math.pow(2,-10*t) * Math.sin((t-s)*(2*Math.PI)/p) + 1.0;\n        },\n\n        /**\n         * @property inOutElastic\n         * @static\n         */\n        inOutElastic: function(t) {\n            var s=1.70158;var p=0;var a=1.0;\n            if (t===0) return 0.0;  if ((t/=.5)===2) return 1.0;  if (!p) p=(.3*1.5);\n            s = p/(2*Math.PI) * Math.asin(1.0/a);\n            if (t < 1) return -.5*(a*Math.pow(2,10*(t-=1)) * Math.sin((t-s)*(2*Math.PI)/p));\n            return a*Math.pow(2,-10*(t-=1)) * Math.sin((t-s)*(2*Math.PI)/p)*.5 + 1.0;\n        },\n\n        /**\n         * @property inBack\n         * @static\n         */\n        inBack: function(t, s) {\n            if (s === undefined) s = 1.70158;\n            return t*t*((s+1)*t - s);\n        },\n\n        /**\n         * @property outBack\n         * @static\n         */\n        outBack: function(t, s) {\n            if (s === undefined) s = 1.70158;\n            return ((--t)*t*((s+1)*t + s) + 1);\n        },\n\n        /**\n         * @property inOutBack\n         * @static\n         */\n        inOutBack: function(t, s) {\n            if (s === undefined) s = 1.70158;\n            if ((t/=.5) < 1) return .5*(t*t*(((s*=(1.525))+1)*t - s));\n            return .5*((t-=2)*t*(((s*=(1.525))+1)*t + s) + 2);\n        },\n\n        /**\n         * @property inBounce\n         * @static\n         */\n        inBounce: function(t) {\n            return 1.0 - Easing.outBounce(1.0-t);\n        },\n\n        /**\n         * @property outBounce\n         * @static\n         */\n        outBounce: function(t) {\n            if (t < (1/2.75)) {\n                return (7.5625*t*t);\n            } else if (t < (2/2.75)) {\n                return (7.5625*(t-=(1.5/2.75))*t + .75);\n            } else if (t < (2.5/2.75)) {\n                return (7.5625*(t-=(2.25/2.75))*t + .9375);\n            } else {\n                return (7.5625*(t-=(2.625/2.75))*t + .984375);\n            }\n        },\n\n        /**\n         * @property inOutBounce\n         * @static\n         */\n        inOutBounce: function(t) {\n            if (t < .5) return Easing.inBounce(t*2) * .5;\n            return Easing.outBounce(t*2-1.0) * .5 + .5;\n        }\n    };\n\n    module.exports = Easing;\n});\n","/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n *\n * Owner: david@famo.us\n * @license MPL 2.0\n * @copyright Famous Industries, Inc. 2014\n */\n\ndefine(function(require, exports, module) {\n    var Utility = require('famous/utilities/Utility');\n\n    /**\n     * Transition meta-method to support transitioning multiple\n     *   values with scalar-only methods.\n     *\n     *\n     * @class MultipleTransition\n     * @constructor\n     *\n     * @param {Object} method Transionable class to multiplex\n     */\n    function MultipleTransition(method) {\n        this.method = method;\n        this._instances = [];\n        this.state = [];\n    }\n\n    MultipleTransition.SUPPORTS_MULTIPLE = true;\n\n    /**\n     * Get the state of each transition.\n     *\n     * @method get\n     *\n     * @return state {Number|Array} state array\n     */\n    MultipleTransition.prototype.get = function get() {\n        for (var i = 0; i < this._instances.length; i++) {\n            this.state[i] = this._instances[i].get();\n        }\n        return this.state;\n    };\n\n    /**\n     * Set the end states with a shared transition, with optional callback.\n     *\n     * @method set\n     *\n     * @param {Number|Array} endState Final State.  Use a multi-element argument for multiple transitions.\n     * @param {Object} transition Transition definition, shared among all instances\n     * @param {Function} callback called when all endStates have been reached.\n     */\n    MultipleTransition.prototype.set = function set(endState, transition, callback) {\n        var _allCallback = Utility.after(endState.length, callback);\n        for (var i = 0; i < endState.length; i++) {\n            if (!this._instances[i]) this._instances[i] = new (this.method)();\n            this._instances[i].set(endState[i], transition, _allCallback);\n        }\n    };\n\n    /**\n     * Reset all transitions to start state.\n     *\n     * @method reset\n     *\n     * @param  {Number|Array} startState Start state\n     */\n    MultipleTransition.prototype.reset = function reset(startState) {\n        for (var i = 0; i < startState.length; i++) {\n            if (!this._instances[i]) this._instances[i] = new (this.method)();\n            this._instances[i].reset(startState[i]);\n        }\n    };\n\n    module.exports = MultipleTransition;\n});\n","/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n *\n * Owner: david@famo.us\n * @license MPL 2.0\n * @copyright Famous Industries, Inc. 2014\n */\n\ndefine(function(require, exports, module) {\n\n    /**\n     *\n     * A state maintainer for a smooth transition between\n     *    numerically-specified states.  Example numeric states include floats or\n     *    Transfornm objects.\n     *\n     *    An initial state is set with the constructor or set(startValue). A\n     *    corresponding end state and transition are set with set(endValue,\n     *    transition). Subsequent calls to set(endValue, transition) begin at\n     *    the last state. Calls to get(timestamp) provide the _interpolated state\n     *    along the way.\n     *\n     *   Note that there is no event loop here - calls to get() are the only way\n     *    to find out state projected to the current (or provided) time and are\n     *    the only way to trigger callbacks. Usually this kind of object would\n     *    be part of the render() path of a visible component.\n     *\n     * @class TweenTransition\n     * @constructor\n     *\n     * @param {Object} options TODO\n     *    beginning state\n     */\n    function TweenTransition(options) {\n        this.options = Object.create(TweenTransition.DEFAULT_OPTIONS);\n        if (options) this.setOptions(options);\n\n        this._startTime = 0;\n        this._startValue = 0;\n        this._updateTime = 0;\n        this._endValue = 0;\n        this._curve = undefined;\n        this._duration = 0;\n        this._active = false;\n        this._callback = undefined;\n        this.state = 0;\n        this.velocity = undefined;\n    }\n\n    /**\n     * Transition curves mapping independent variable t from domain [0,1] to a\n     *    range within [0,1]. Includes functions 'linear', 'easeIn', 'easeOut',\n     *    'easeInOut', 'easeOutBounce', 'spring'.\n     *\n     * @property {object} Curve\n     * @final\n     */\n    TweenTransition.Curves = {\n        linear: function(t) {\n            return t;\n        },\n        easeIn: function(t) {\n            return t*t;\n        },\n        easeOut: function(t) {\n            return t*(2-t);\n        },\n        easeInOut: function(t) {\n            if (t <= 0.5) return 2*t*t;\n            else return -2*t*t + 4*t - 1;\n        },\n        easeOutBounce: function(t) {\n            return t*(3 - 2*t);\n        },\n        spring: function(t) {\n            return (1 - t) * Math.sin(6 * Math.PI * t) + t;\n        }\n    };\n\n    TweenTransition.SUPPORTS_MULTIPLE = true;\n    TweenTransition.DEFAULT_OPTIONS = {\n        curve: TweenTransition.Curves.linear,\n        duration: 500,\n        speed: 0 /* considered only if positive */\n    };\n\n    var registeredCurves = {};\n\n    /**\n     * Add \"unit\" curve to internal dictionary of registered curves.\n     *\n     * @method registerCurve\n     *\n     * @static\n     *\n     * @param {string} curveName dictionary key\n     * @param {unitCurve} curve function of one numeric variable mapping [0,1]\n     *    to range inside [0,1]\n     * @return {boolean} false if key is taken, else true\n     */\n    TweenTransition.registerCurve = function registerCurve(curveName, curve) {\n        if (!registeredCurves[curveName]) {\n            registeredCurves[curveName] = curve;\n            return true;\n        }\n        else {\n            return false;\n        }\n    };\n\n    /**\n     * Remove object with key \"curveName\" from internal dictionary of registered\n     *    curves.\n     *\n     * @method unregisterCurve\n     *\n     * @static\n     *\n     * @param {string} curveName dictionary key\n     * @return {boolean} false if key has no dictionary value\n     */\n    TweenTransition.unregisterCurve = function unregisterCurve(curveName) {\n        if (registeredCurves[curveName]) {\n            delete registeredCurves[curveName];\n            return true;\n        }\n        else {\n            return false;\n        }\n    };\n\n    /**\n     * Retrieve function with key \"curveName\" from internal dictionary of\n     *    registered curves. Default curves are defined in the\n     *    TweenTransition.Curves array, where the values represent\n     *    unitCurve functions.\n     *\n     * @method getCurve\n     *\n     * @static\n     *\n     * @param {string} curveName dictionary key\n     * @return {unitCurve} curve function of one numeric variable mapping [0,1]\n     *    to range inside [0,1]\n     */\n    TweenTransition.getCurve = function getCurve(curveName) {\n        return registeredCurves[curveName];\n    };\n\n    /**\n     * Retrieve all available curves.\n     *\n     * @method getCurves\n     *\n     * @static\n     *\n     * @return {object} curve functions of one numeric variable mapping [0,1]\n     *    to range inside [0,1]\n     */\n    TweenTransition.getCurves = function getCurves() {\n        return registeredCurves;\n    };\n\n     // Interpolate: If a linear function f(0) = a, f(1) = b, then return f(t)\n    function _interpolate(a, b, t) {\n        return ((1 - t) * a) + (t * b);\n    }\n\n    function _clone(obj) {\n        if (obj instanceof Object) {\n            if (obj instanceof Array) return obj.slice(0);\n            else return Object.create(obj);\n        }\n        else return obj;\n    }\n\n    // Fill in missing properties in \"transition\" with those in defaultTransition, and\n    //   convert internal named curve to function object, returning as new\n    //   object.\n    function _normalize(transition, defaultTransition) {\n        var result = {curve: defaultTransition.curve};\n        if (defaultTransition.duration) result.duration = defaultTransition.duration;\n        if (defaultTransition.speed) result.speed = defaultTransition.speed;\n        if (transition instanceof Object) {\n            if (transition.duration !== undefined) result.duration = transition.duration;\n            if (transition.curve) result.curve = transition.curve;\n            if (transition.speed) result.speed = transition.speed;\n        }\n        if (typeof result.curve === 'string') result.curve = TweenTransition.getCurve(result.curve);\n        return result;\n    }\n\n    /**\n     * Set internal options, overriding any default options.\n     *\n     * @method setOptions\n     *\n     *\n     * @param {Object} options options object\n     * @param {Object} [options.curve] function mapping [0,1] to [0,1] or identifier\n     * @param {Number} [options.duration] duration in ms\n     * @param {Number} [options.speed] speed in pixels per ms\n     */\n    TweenTransition.prototype.setOptions = function setOptions(options) {\n        if (options.curve !== undefined) this.options.curve = options.curve;\n        if (options.duration !== undefined) this.options.duration = options.duration;\n        if (options.speed !== undefined) this.options.speed = options.speed;\n    };\n\n    /**\n     * Add transition to end state to the queue of pending transitions. Special\n     *    Use: calling without a transition resets the object to that state with\n     *    no pending actions\n     *\n     * @method set\n     *\n     *\n     * @param {number|FamousMatrix|Array.Number|Object.<number, number>} endValue\n     *    end state to which we _interpolate\n     * @param {transition=} transition object of type {duration: number, curve:\n     *    f[0,1] -> [0,1] or name}. If transition is omitted, change will be\n     *    instantaneous.\n     * @param {function()=} callback Zero-argument function to call on observed\n     *    completion (t=1)\n     */\n    TweenTransition.prototype.set = function set(endValue, transition, callback) {\n        if (!transition) {\n            this.reset(endValue);\n            if (callback) callback();\n            return;\n        }\n\n        this._startValue = _clone(this.get());\n        transition = _normalize(transition, this.options);\n        if (transition.speed) {\n            var startValue = this._startValue;\n            if (startValue instanceof Object) {\n                var variance = 0;\n                for (var i in startValue) variance += (endValue[i] - startValue[i]) * (endValue[i] - startValue[i]);\n                transition.duration = Math.sqrt(variance) / transition.speed;\n            }\n            else {\n                transition.duration = Math.abs(endValue - startValue) / transition.speed;\n            }\n        }\n\n        this._startTime = Date.now();\n        this._endValue = _clone(endValue);\n        this._startVelocity = _clone(transition.velocity);\n        this._duration = transition.duration;\n        this._curve = transition.curve;\n        this._active = true;\n        this._callback = callback;\n    };\n\n    /**\n     * Cancel all transitions and reset to a stable state\n     *\n     * @method reset\n     *\n     * @param {number|Array.Number|Object.<number, number>} startValue\n     *    starting state\n     * @param {number} startVelocity\n     *    starting velocity\n     */\n    TweenTransition.prototype.reset = function reset(startValue, startVelocity) {\n        if (this._callback) {\n            var callback = this._callback;\n            this._callback = undefined;\n            callback();\n        }\n        this.state = _clone(startValue);\n        this.velocity = _clone(startVelocity);\n        this._startTime = 0;\n        this._duration = 0;\n        this._updateTime = 0;\n        this._startValue = this.state;\n        this._startVelocity = this.velocity;\n        this._endValue = this.state;\n        this._active = false;\n    };\n\n    /**\n     * Get current velocity\n     *\n     * @method getVelocity\n     *\n     * @returns {Number} velocity\n     */\n    TweenTransition.prototype.getVelocity = function getVelocity() {\n        return this.velocity;\n    };\n\n    /**\n     * Get interpolated state of current action at provided time. If the last\n     *    action has completed, invoke its callback.\n     *\n     * @method get\n     *\n     *\n     * @param {number=} timestamp Evaluate the curve at a normalized version of this\n     *    time. If omitted, use current time. (Unix epoch time)\n     * @return {number|Object.<number|string, number>} beginning state\n     *    _interpolated to this point in time.\n     */\n    TweenTransition.prototype.get = function get(timestamp) {\n        this.update(timestamp);\n        return this.state;\n    };\n\n    function _calculateVelocity(current, start, curve, duration, t) {\n        var velocity;\n        var eps = 1e-7;\n        var speed = (curve(t) - curve(t - eps)) / eps;\n        if (current instanceof Array) {\n            velocity = [];\n            for (var i = 0; i < current.length; i++)\n                velocity[i] = speed * (current[i] - start[i]) / duration;\n        }\n        else velocity = speed * (current - start) / duration;\n        return velocity;\n    }\n\n    function _calculateState(start, end, t) {\n        var state;\n        if (start instanceof Array) {\n            state = [];\n            for (var i = 0; i < start.length; i++)\n                state[i] = _interpolate(start[i], end[i], t);\n        }\n        else state = _interpolate(start, end, t);\n        return state;\n    }\n\n    /**\n     * Update internal state to the provided timestamp. This may invoke the last\n     *    callback and begin a new action.\n     *\n     * @method update\n     *\n     *\n     * @param {number=} timestamp Evaluate the curve at a normalized version of this\n     *    time. If omitted, use current time. (Unix epoch time)\n     */\n    TweenTransition.prototype.update = function update(timestamp) {\n        if (!this._active) {\n            if (this._callback) {\n                var callback = this._callback;\n                this._callback = undefined;\n                callback();\n            }\n            return;\n        }\n\n        if (!timestamp) timestamp = Date.now();\n        if (this._updateTime >= timestamp) return;\n        this._updateTime = timestamp;\n\n        var timeSinceStart = timestamp - this._startTime;\n        if (timeSinceStart >= this._duration) {\n            this.state = this._endValue;\n            this.velocity = _calculateVelocity(this.state, this._startValue, this._curve, this._duration, 1);\n            this._active = false;\n        }\n        else if (timeSinceStart < 0) {\n            this.state = this._startValue;\n            this.velocity = this._startVelocity;\n        }\n        else {\n            var t = timeSinceStart / this._duration;\n            this.state = _calculateState(this._startValue, this._endValue, this._curve(t));\n            this.velocity = _calculateVelocity(this.state, this._startValue, this._curve, this._duration, t);\n        }\n    };\n\n    /**\n     * Is there at least one action pending completion?\n     *\n     * @method isActive\n     *\n     *\n     * @return {boolean}\n     */\n    TweenTransition.prototype.isActive = function isActive() {\n        return this._active;\n    };\n\n    /**\n     * Halt transition at current state and erase all pending actions.\n     *\n     * @method halt\n     *\n     */\n    TweenTransition.prototype.halt = function halt() {\n        this.reset(this.get());\n    };\n\n    // Register all the default curves\n    TweenTransition.registerCurve('linear', TweenTransition.Curves.linear);\n    TweenTransition.registerCurve('easeIn', TweenTransition.Curves.easeIn);\n    TweenTransition.registerCurve('easeOut', TweenTransition.Curves.easeOut);\n    TweenTransition.registerCurve('easeInOut', TweenTransition.Curves.easeInOut);\n    TweenTransition.registerCurve('easeOutBounce', TweenTransition.Curves.easeOutBounce);\n    TweenTransition.registerCurve('spring', TweenTransition.Curves.spring);\n\n    TweenTransition.customCurve = function customCurve(v1, v2) {\n        v1 = v1 || 0; v2 = v2 || 0;\n        return function(t) {\n            return v1*t + (-2*v1 - v2 + 3)*t*t + (v1 + v2 - 2)*t*t*t;\n        };\n    };\n\n    module.exports = TweenTransition;\n});\n","/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n *\n * Owner: felix@famo.us\n * @license MPL 2.0\n * @copyright Famous Industries, Inc. 2014\n */\n\ndefine(function(require, exports, module) {\n    var Entity = require('famous/core/Entity');\n    var RenderNode = require('famous/core/RenderNode');\n    var Transform = require('famous/core/Transform');\n    var OptionsManager = require('famous/core/OptionsManager');\n\n    /**\n     * A layout which will arrange three renderables into a header and footer area of defined size,\n      and a content area of flexible size.\n     * @class HeaderFooterLayout\n     * @constructor\n     * @param {Options} [options] An object of configurable options.\n     * @param {Number} [options.direction=HeaderFooterLayout.DIRECTION_Y] A direction of HeaderFooterLayout.DIRECTION_X\n     * lays your HeaderFooterLayout instance horizontally, and a direction of HeaderFooterLayout.DIRECTION_Y\n     * lays it out vertically.\n     * @param {Number} [options.headerSize=undefined]  The amount of pixels allocated to the header node\n     * in the HeaderFooterLayout instance's direction.\n     * @param {Number} [options.footerSize=undefined] The amount of pixels allocated to the footer node\n     * in the HeaderFooterLayout instance's direction.\n     */\n    function HeaderFooterLayout(options) {\n        this.options = Object.create(HeaderFooterLayout.DEFAULT_OPTIONS);\n        this._optionsManager = new OptionsManager(this.options);\n        if (options) this.setOptions(options);\n\n        this._entityId = Entity.register(this);\n\n        this.header = new RenderNode();\n        this.footer = new RenderNode();\n        this.content = new RenderNode();\n    }\n\n    /**\n     *  When used as a value for your HeaderFooterLayout's direction option, causes it to lay out horizontally.\n     *\n     *  @attribute DIRECTION_X\n     *  @type Number\n     *  @static\n     *  @default 0\n     *  @protected\n     */\n    HeaderFooterLayout.DIRECTION_X = 0;\n\n    /**\n     *  When used as a value for your HeaderFooterLayout's direction option, causes it to lay out vertically.\n     *\n     *  @attribute DIRECTION_Y\n     *  @type Number\n     *  @static\n     *  @default 1\n     *  @protected\n     */\n    HeaderFooterLayout.DIRECTION_Y = 1;\n\n    HeaderFooterLayout.DEFAULT_OPTIONS = {\n        direction: HeaderFooterLayout.DIRECTION_Y,\n        headerSize: undefined,\n        footerSize: undefined,\n        defaultHeaderSize: 0,\n        defaultFooterSize: 0\n    };\n\n    /**\n     * Generate a render spec from the contents of this component.\n     *\n     * @private\n     * @method render\n     * @return {Object} Render spec for this component\n     */\n    HeaderFooterLayout.prototype.render = function render() {\n        return this._entityId;\n    };\n\n    /**\n     * Patches the HeaderFooterLayout instance's options with the passed-in ones.\n     *\n     * @method setOptions\n     * @param {Options} options An object of configurable options for the HeaderFooterLayout instance.\n     */\n    HeaderFooterLayout.prototype.setOptions = function setOptions(options) {\n        return this._optionsManager.setOptions(options);\n    };\n\n    function _resolveNodeSize(node, defaultSize) {\n        var nodeSize = node.getSize();\n        return nodeSize ? nodeSize[this.options.direction] : defaultSize;\n    }\n\n    function _outputTransform(offset) {\n        if (this.options.direction === HeaderFooterLayout.DIRECTION_X) return Transform.translate(offset, 0, 0);\n        else return Transform.translate(0, offset, 0);\n    }\n\n    function _finalSize(directionSize, size) {\n        if (this.options.direction === HeaderFooterLayout.DIRECTION_X) return [directionSize, size[1]];\n        else return [size[0], directionSize];\n    }\n\n    /**\n     * Apply changes from this component to the corresponding document element.\n     * This includes changes to classes, styles, size, content, opacity, origin,\n     * and matrix transforms.\n     *\n     * @private\n     * @method commit\n     * @param {Context} context commit context\n     */\n    HeaderFooterLayout.prototype.commit = function commit(context) {\n        var transform = context.transform;\n        var origin = context.origin;\n        var size = context.size;\n        var opacity = context.opacity;\n\n        var headerSize = (this.options.headerSize !== undefined) ? this.options.headerSize : _resolveNodeSize.call(this, this.header, this.options.defaultHeaderSize);\n        var footerSize = (this.options.footerSize !== undefined) ? this.options.footerSize : _resolveNodeSize.call(this, this.footer, this.options.defaultFooterSize);\n        var contentSize = size[this.options.direction] - headerSize - footerSize;\n\n        if (size) transform = Transform.moveThen([-size[0]*origin[0], -size[1]*origin[1], 0], transform);\n\n        var result = [\n            {\n                size: _finalSize.call(this, headerSize, size),\n                target: this.header.render()\n            },\n            {\n                transform: _outputTransform.call(this, headerSize),\n                size: _finalSize.call(this, contentSize, size),\n                target: this.content.render()\n            },\n            {\n                transform: _outputTransform.call(this, headerSize + contentSize),\n                size: _finalSize.call(this, footerSize, size),\n                target: this.footer.render()\n            }\n        ];\n\n        return {\n            transform: transform,\n            opacity: opacity,\n            size: size,\n            target: result\n        };\n    };\n\n    module.exports = HeaderFooterLayout;\n});\n","Parse = require 'parse'\nQuestion = require 'models/Question'\n\nclass Questions extends Parse.Collection\n  model: Question\n\nmodule.exports = Questions","var Parse, Question, Questions,\n  __hasProp = {}.hasOwnProperty,\n  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };\n\nParse = require('parse');\n\nQuestion = require('models/Question');\n\nQuestions = (function(_super) {\n  __extends(Questions, _super);\n\n  function Questions() {\n    return Questions.__super__.constructor.apply(this, arguments);\n  }\n\n  Questions.prototype.model = Question;\n\n  return Questions;\n\n})(Parse.Collection);\n\nmodule.exports = Questions;\n","# AppView\n#\n# Main entry point of the app. Manages global views and events.\n\n\nView = require 'famous/core/View'\nUtility = require 'famous/utilities/Utility'\nHeaderFooterLayout = require 'famous/views/HeaderFooterLayout'\nSurface = require 'famous/core/Surface'\nTransform = require 'famous/core/Transform'\nTransitionable  = require 'famous/transitions/Transitionable'\nModifier = require 'famous/core/Modifier'\n\n# Models\nQuestions = require 'collections/Questions'\nQuestion = require 'models/Question'\n\n# Views\nHeaderView = require 'views/HeaderView'\nMenuView = require 'views/MenuView'\nCardView = require 'views/CardView'\n\n# EditQuestionView = require 'views/EditQuestionView'\n# ListQuestionsView = require 'views/ListQuestionsView'\n# QuestionView = require 'views/QuestionView'\n# ImageUploadView = require 'views/ImageUploadView'\n# ImageEditView = require 'views/ImageEditView'\n\n\nclass AppView extends View\n  @DEFAULT_OPTIONS:\n    menu:\n      width: 280\n      transition:\n        duration: 300\n        curve: 'easeOut'\n\n  menuOpen: false\n\n  constructor: ->\n    super\n    @page = new HeaderFooterLayout\n      headerSize: 60\n      footerSize: 50\n    @initHeader()\n    @initMenu()\n    @initContent()\n\n  initHeader: ->\n    @header = new HeaderView\n    @header.on 'toggleMenu', @toggleMenu\n    @page.header.add @header\n\n  initMenu: ->\n    @menuPosition = new Transitionable 0\n    @menu = new MenuView\n    @menu.on 'toggleMenu', @toggleMenu\n\n  initContent: ->\n    @content = new CardView\n    modifier = new Modifier\n      origin: [0.5, 0.5]\n    @page.content.add(modifier).add @content\n\n  toggleMenu: =>\n    if @menuOpen\n      @closeMenu()\n    else\n      @openMenu()\n\n  closeMenu: ->\n    @menuPosition.set 0, @options.menu.transition, =>\n      @menuOpen = false\n\n  openMenu: ->\n    @menuPosition.set @options.menu.width, @options.menu.transition, =>\n      @menuOpen = true\n\n  render: ->\n    [\n        transform: Transform.translate 0, 0, -1\n        target: @menu.render()\n      ,\n        transform: Transform.translate @menuPosition.get(), 0, 0\n        target: @page.render()\n    ]\n\nmodule.exports = AppView\n","var AppView, CardView, HeaderFooterLayout, HeaderView, MenuView, Modifier, Question, Questions, Surface, Transform, Transitionable, Utility, View,\n  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },\n  __hasProp = {}.hasOwnProperty,\n  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };\n\nView = require('famous/core/View');\n\nUtility = require('famous/utilities/Utility');\n\nHeaderFooterLayout = require('famous/views/HeaderFooterLayout');\n\nSurface = require('famous/core/Surface');\n\nTransform = require('famous/core/Transform');\n\nTransitionable = require('famous/transitions/Transitionable');\n\nModifier = require('famous/core/Modifier');\n\nQuestions = require('collections/Questions');\n\nQuestion = require('models/Question');\n\nHeaderView = require('views/HeaderView');\n\nMenuView = require('views/MenuView');\n\nCardView = require('views/CardView');\n\nAppView = (function(_super) {\n  __extends(AppView, _super);\n\n  AppView.DEFAULT_OPTIONS = {\n    menu: {\n      width: 280,\n      transition: {\n        duration: 300,\n        curve: 'easeOut'\n      }\n    }\n  };\n\n  AppView.prototype.menuOpen = false;\n\n  function AppView() {\n    this.toggleMenu = __bind(this.toggleMenu, this);\n    AppView.__super__.constructor.apply(this, arguments);\n    this.page = new HeaderFooterLayout({\n      headerSize: 60,\n      footerSize: 50\n    });\n    this.initHeader();\n    this.initMenu();\n    this.initContent();\n  }\n\n  AppView.prototype.initHeader = function() {\n    this.header = new HeaderView;\n    this.header.on('toggleMenu', this.toggleMenu);\n    return this.page.header.add(this.header);\n  };\n\n  AppView.prototype.initMenu = function() {\n    this.menuPosition = new Transitionable(0);\n    this.menu = new MenuView;\n    return this.menu.on('toggleMenu', this.toggleMenu);\n  };\n\n  AppView.prototype.initContent = function() {\n    var modifier;\n    this.content = new CardView;\n    modifier = new Modifier({\n      origin: [0.5, 0.5]\n    });\n    return this.page.content.add(modifier).add(this.content);\n  };\n\n  AppView.prototype.toggleMenu = function() {\n    if (this.menuOpen) {\n      return this.closeMenu();\n    } else {\n      return this.openMenu();\n    }\n  };\n\n  AppView.prototype.closeMenu = function() {\n    return this.menuPosition.set(0, this.options.menu.transition, (function(_this) {\n      return function() {\n        return _this.menuOpen = false;\n      };\n    })(this));\n  };\n\n  AppView.prototype.openMenu = function() {\n    return this.menuPosition.set(this.options.menu.width, this.options.menu.transition, (function(_this) {\n      return function() {\n        return _this.menuOpen = true;\n      };\n    })(this));\n  };\n\n  AppView.prototype.render = function() {\n    return [\n      {\n        transform: Transform.translate(0, 0, -1),\n        target: this.menu.render()\n      }, {\n        transform: Transform.translate(this.menuPosition.get(), 0, 0),\n        target: this.page.render()\n      }\n    ];\n  };\n\n  return AppView;\n\n})(View);\n\nmodule.exports = AppView;\n","# CardView\n#\n# Flip between front and back side of card.\n\nrequire 'css/card'\n\nView = require 'famous/core/View'\nSurface = require 'famous/core/Surface'\nModifier = require 'famous/core/Modifier'\nStateModifer = require 'famous/modifiers/StateModifier'\nTransform = require 'famous/core/Transform'\nUtility = require 'famous/utilities/Utility'\n\n\nclass CardView extends View\n  @DEFAULT_OPTIONS:\n    width: 400\n    height: 600\n    depth: 10\n    borderRadius: 30\n\n  constructor: ->\n    super\n    @init()\n\n  init: ->\n    width = @options.width\n    height = @options.height\n    depth = @options.depth\n\n    @state = new StateModifer\n    @mainNode = @add @state\n\n    # Front\n    @addSurface\n      size: [ width, height ]\n      content: \"<h2>Front of card.</h2>\"\n      classes: ['card__front']\n      properties:\n        borderRadius: \"#{@options.borderRadius}px\"\n      transform: Transform.translate 0, 0, depth/2\n    # Front Backing\n    @addSurface\n      size: [ width, height ]\n      classes: ['card__backing']\n      properties:\n        borderRadius: \"#{@options.borderRadius}px\"\n      transform: Transform.multiply(\n        Transform.translate 0, 0, depth/2-1\n        Transform.multiply(\n          Transform.rotateZ Math.PI\n          Transform.rotateX Math.PI\n        )\n      )\n    # Shim\n    @addSurface\n      size: [depth-2, height]\n      classes: ['card__shim']\n      transform: Transform.multiply(\n        Transform.translate -width/2+@options.borderRadius, 0, 1\n        Transform.rotateY -Math.PI/2\n      )\n    # Back\n    @addSurface\n      size: [ width, height ]\n      content: \"<h3>Back of card</h3>\"\n      classes: ['card__back']\n      properties:\n        borderRadius: \"#{@options.borderRadius}px\"\n      transform: Transform.multiply(\n        Transform.translate(0, 0, -depth/2)\n        Transform.multiply(\n          Transform.rotateZ Math.PI\n          Transform.rotateX Math.PI\n        )\n      )\n    # Back Backing\n    @addSurface\n      size: [ width, height ]\n      classes: ['card__backing']\n      properties:\n        borderRadius: \"#{@options.borderRadius}px\"\n      transform: Transform.translate 0, 0, -depth/2+1\n\n\n  addSurface: (params) ->\n    surface = new Surface\n      size: params.size\n      content: params.content\n      classes: params.classes\n      properties: params.properties\n    modifier = new Modifier\n      transform: params.transform\n    surface.on 'click', @flip\n    @mainNode.add(modifier).add surface\n\n  flip: (side) =>\n    @currentSide ?= 0\n    if side is 0 or side is 1\n      @currentSide = side\n    else\n      @currentSide = if @currentSide is 1 then 0 else 1\n\n    @state.setTransform(\n      Transform.rotateY Math.PI * @currentSide\n      duration : 500\n      curve: 'easeInOut'\n    )\n\n\nmodule.exports = CardView\n\n\n\n#\n# FOR REFERENCE ON HOW TO ADD SIDES\n#\n\n# // Top\n# addSurface({\n#     size: [width - borderRadius*2, depth],\n#     content: 'I\\'m on Top! Just a shimmy and a shake',\n#     properties: {\n#         lineHeight: depth + 'px',\n#         textAlign: 'center',\n#         backgroundColor: '#0cf',\n#         overflow: 'hidden',\n#         color: '#666'\n#     },\n#     transform: Transform.multiply(Transform.translate(0, -height / 2, 0), Transform.rotateX(Math.PI/2)),\n# });\n\n# // Bottom\n# addSurface({\n#     size: [width - borderRadius*2, depth],\n#     content: 'I\\'m the bottom!',\n#     properties: {\n#         lineHeight: depth + 'px',\n#         textAlign: 'center',\n#         backgroundColor: '#fc0',\n#         overflow: 'hidden',\n#         color: '#777'\n#     },\n#     transform: Transform.multiply(Transform.translate(0, height / 2, 0), Transform.multiply(Transform.rotateX(-Math.PI/2), Transform.rotateZ(Math.PI))),\n# });\n\n# // Left\n# addSurface({\n#     size: [depth, height - borderRadius*2],\n#     content: 'I\\'m the Left! I\\'m content',\n#     properties: {\n#         lineHeight: height + 'px',\n#         textAlign: 'center',\n#         backgroundColor: '#f0c',\n#         overflow: 'hidden',\n#         color: '#777'\n#     },\n#     transform: Transform.multiply(Transform.translate(-width / 2, 0, 0), Transform.rotateY(-Math.PI/2))\n# });\n\n# // Right\n# addSurface({\n#     size: [depth, height - borderRadius*2],\n#     content: 'I\\'m always Right!',\n#     properties: {\n#         lineHeight: height + 'px',\n#         textAlign: 'center',\n#         backgroundColor: '#c0f',\n#         overflow: 'hidden',\n#         color: '#777'\n#     },\n#     transform: Transform.multiply(Transform.translate(width / 2, 0, 0), Transform.rotateY(Math.PI/2))\n# });\n","var CardView, Modifier, StateModifer, Surface, Transform, Utility, View,\n  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },\n  __hasProp = {}.hasOwnProperty,\n  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };\n\nrequire('css/card');\n\nView = require('famous/core/View');\n\nSurface = require('famous/core/Surface');\n\nModifier = require('famous/core/Modifier');\n\nStateModifer = require('famous/modifiers/StateModifier');\n\nTransform = require('famous/core/Transform');\n\nUtility = require('famous/utilities/Utility');\n\nCardView = (function(_super) {\n  __extends(CardView, _super);\n\n  CardView.DEFAULT_OPTIONS = {\n    width: 400,\n    height: 600,\n    depth: 10,\n    borderRadius: 30\n  };\n\n  function CardView() {\n    this.flip = __bind(this.flip, this);\n    CardView.__super__.constructor.apply(this, arguments);\n    this.init();\n  }\n\n  CardView.prototype.init = function() {\n    var depth, height, width;\n    width = this.options.width;\n    height = this.options.height;\n    depth = this.options.depth;\n    this.state = new StateModifer;\n    this.mainNode = this.add(this.state);\n    this.addSurface({\n      size: [width, height],\n      content: \"<h2>Front of card.</h2>\",\n      classes: ['card__front'],\n      properties: {\n        borderRadius: \"\" + this.options.borderRadius + \"px\"\n      },\n      transform: Transform.translate(0, 0, depth / 2)\n    });\n    this.addSurface({\n      size: [width, height],\n      classes: ['card__backing'],\n      properties: {\n        borderRadius: \"\" + this.options.borderRadius + \"px\"\n      },\n      transform: Transform.multiply(Transform.translate(0, 0, depth / 2 - 1), Transform.multiply(Transform.rotateZ(Math.PI), Transform.rotateX(Math.PI)))\n    });\n    this.addSurface({\n      size: [depth - 2, height],\n      classes: ['card__shim'],\n      transform: Transform.multiply(Transform.translate(-width / 2 + this.options.borderRadius, 0, 1), Transform.rotateY(-Math.PI / 2))\n    });\n    this.addSurface({\n      size: [width, height],\n      content: \"<h3>Back of card</h3>\",\n      classes: ['card__back'],\n      properties: {\n        borderRadius: \"\" + this.options.borderRadius + \"px\"\n      },\n      transform: Transform.multiply(Transform.translate(0, 0, -depth / 2), Transform.multiply(Transform.rotateZ(Math.PI), Transform.rotateX(Math.PI)))\n    });\n    return this.addSurface({\n      size: [width, height],\n      classes: ['card__backing'],\n      properties: {\n        borderRadius: \"\" + this.options.borderRadius + \"px\"\n      },\n      transform: Transform.translate(0, 0, -depth / 2 + 1)\n    });\n  };\n\n  CardView.prototype.addSurface = function(params) {\n    var modifier, surface;\n    surface = new Surface({\n      size: params.size,\n      content: params.content,\n      classes: params.classes,\n      properties: params.properties\n    });\n    modifier = new Modifier({\n      transform: params.transform\n    });\n    surface.on('click', this.flip);\n    return this.mainNode.add(modifier).add(surface);\n  };\n\n  CardView.prototype.flip = function(side) {\n    if (this.currentSide == null) {\n      this.currentSide = 0;\n    }\n    if (side === 0 || side === 1) {\n      this.currentSide = side;\n    } else {\n      this.currentSide = this.currentSide === 1 ? 0 : 1;\n    }\n    return this.state.setTransform(Transform.rotateY(Math.PI * this.currentSide), {\n      duration: 500,\n      curve: 'easeInOut'\n    });\n  };\n\n  return CardView;\n\n})(View);\n\nmodule.exports = CardView;\n","# TODO: use NavigationBar widget when it's fixed https://github.com/Famous/widgets/pull/1\n\nrequire 'css/header'\n\nView = require 'famous/core/View'\nUtility = require 'famous/utilities/Utility'\nSurface = require 'famous/core/Surface'\nImageSurface = require 'famous/surfaces/ImageSurface'\nModifier  = require 'famous/core/Modifier'\nTransform = require 'famous/core/Transform'\n\n\nclass HeaderView extends View\n  title: 'Pegg'\n  cssPrefix: 'header'\n\n  constructor: ->\n    super\n    @build()\n    @initEvents()\n\n  # Build view\n  build: ->\n    @background = new Surface\n      classes: [\"#{@cssPrefix}__background\"]\n\n    @logo = new ImageSurface\n      size: [55, 40]\n      classes: [\"#{@cssPrefix}__logo\"]\n      content: 'images/mark_tiny.png'\n\n    @title = new Surface\n      content: @title\n      classes: [\"#{@cssPrefix}__title\"]\n\n    @add @background\n\n    @add new Modifier\n      origin: [0, 0]\n      transform: Transform.multiply(\n        Transform.inFront\n        Transform.translate 10, 10\n      )\n    .add @logo\n\n    @add new Modifier\n      transform: Transform.translate 0, 10\n    .add @title\n\n  initEvents: ->\n    @logo.on 'click', =>\n      @_eventOutput.emit 'toggleMenu'\n\nmodule.exports = HeaderView\n","var HeaderView, ImageSurface, Modifier, Surface, Transform, Utility, View,\n  __hasProp = {}.hasOwnProperty,\n  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };\n\nrequire('css/header');\n\nView = require('famous/core/View');\n\nUtility = require('famous/utilities/Utility');\n\nSurface = require('famous/core/Surface');\n\nImageSurface = require('famous/surfaces/ImageSurface');\n\nModifier = require('famous/core/Modifier');\n\nTransform = require('famous/core/Transform');\n\nHeaderView = (function(_super) {\n  __extends(HeaderView, _super);\n\n  HeaderView.prototype.title = 'Pegg';\n\n  HeaderView.prototype.cssPrefix = 'header';\n\n  function HeaderView() {\n    HeaderView.__super__.constructor.apply(this, arguments);\n    this.build();\n    this.initEvents();\n  }\n\n  HeaderView.prototype.build = function() {\n    this.background = new Surface({\n      classes: [\"\" + this.cssPrefix + \"__background\"]\n    });\n    this.logo = new ImageSurface({\n      size: [55, 40],\n      classes: [\"\" + this.cssPrefix + \"__logo\"],\n      content: 'images/mark_tiny.png'\n    });\n    this.title = new Surface({\n      content: this.title,\n      classes: [\"\" + this.cssPrefix + \"__title\"]\n    });\n    this.add(this.background);\n    this.add(new Modifier({\n      origin: [0, 0],\n      transform: Transform.multiply(Transform.inFront, Transform.translate(10, 10))\n    })).add(this.logo);\n    return this.add(new Modifier({\n      transform: Transform.translate(0, 10)\n    })).add(this.title);\n  };\n\n  HeaderView.prototype.initEvents = function() {\n    return this.logo.on('click', (function(_this) {\n      return function() {\n        return _this._eventOutput.emit('toggleMenu');\n      };\n    })(this));\n  };\n\n  return HeaderView;\n\n})(View);\n\nmodule.exports = HeaderView;\n","View = require 'famous/core/View'\nSurface = require 'famous/core/Surface'\n\n\nclass MenuView extends View\n  constructor: ->\n    super\n    @background = new Surface\n      size: [280, undefined]\n      content: 'MENU!!!'\n    @add @background\n    @background.on 'click', =>\n      @_eventOutput.emit 'toggleMenu'\n\n\nmodule.exports = MenuView\n","var MenuView, Surface, View,\n  __hasProp = {}.hasOwnProperty,\n  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };\n\nView = require('famous/core/View');\n\nSurface = require('famous/core/Surface');\n\nMenuView = (function(_super) {\n  __extends(MenuView, _super);\n\n  function MenuView() {\n    MenuView.__super__.constructor.apply(this, arguments);\n    this.background = new Surface({\n      size: [280, void 0],\n      content: 'MENU!!!'\n    });\n    this.add(this.background);\n    this.background.on('click', (function(_this) {\n      return function() {\n        return _this._eventOutput.emit('toggleMenu');\n      };\n    })(this));\n  }\n\n  return MenuView;\n\n})(View);\n\nmodule.exports = MenuView;\n","require 'css/widgets/fpsmeter'\n\nView = require 'famous/core/View'\nSurface = require 'famous/core/Surface'\nModifier = require 'famous/core/Modifier'\nEngine = require 'famous/core/Engine'\nTimer = require 'famous/utilities/Timer'\nTransform = require 'famous/core/Transform'\n\n\nclass FpsMeter extends View\n  currTime: 0\n  lastTime: 0\n  frameTime: 0\n  state: true\n\n  # How much to normalize frame rate readings\n  # Bigger number means more normalization\n  filterStrength: 10\n\n  # How many milliseconds between updating FPS\n  updateFrequency: 100\n\n  constructor: ->\n    super\n    @initTime()\n\n    @surface = new Surface\n      size: [100, 20]\n      classes: ['fpsmeter']\n      content: ''\n\n    @add new Modifier\n      origin: [1, 1]\n      transform: Transform.inFront\n    .add @surface\n\n    @surface.on 'click', @toggleState\n\n    @start()\n\n  initTime: ->\n    perf = window.performance;\n    if perf and (perf.now or perf.webkitNow)\n      perfNow = if perf.now then 'now' else 'webkitNow'\n      @getTime = perf[perfNow].bind(perf)\n\n    @lastTime = @getTime()\n\n  tick: =>\n    @currTime = @getTime()\n    thisFrameTime = @currTime - @lastTime\n    @frameTime += (thisFrameTime - @frameTime) / @filterStrength\n    @lastTime = @currTime\n\n  toggleState: =>\n    if @state\n      @stop()\n    else\n      @start()\n    @state = not @state\n\n  start: ->\n    Engine.on 'prerender', @tick\n    @interval = Timer.setInterval @update, @updateFrequency\n\n  stop: ->\n    Engine.removeListener 'prerender', @tick\n    Timer.clear @interval\n\n  update: =>\n    @surface.setContent \"#{ (1000 / @frameTime).toFixed 1} fps\"\n\n  getTime: ->\n    +new Date()\n\n\nmodule.exports = FpsMeter\n","var Engine, FpsMeter, Modifier, Surface, Timer, Transform, View,\n  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },\n  __hasProp = {}.hasOwnProperty,\n  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };\n\nrequire('css/widgets/fpsmeter');\n\nView = require('famous/core/View');\n\nSurface = require('famous/core/Surface');\n\nModifier = require('famous/core/Modifier');\n\nEngine = require('famous/core/Engine');\n\nTimer = require('famous/utilities/Timer');\n\nTransform = require('famous/core/Transform');\n\nFpsMeter = (function(_super) {\n  __extends(FpsMeter, _super);\n\n  FpsMeter.prototype.currTime = 0;\n\n  FpsMeter.prototype.lastTime = 0;\n\n  FpsMeter.prototype.frameTime = 0;\n\n  FpsMeter.prototype.state = true;\n\n  FpsMeter.prototype.filterStrength = 10;\n\n  FpsMeter.prototype.updateFrequency = 100;\n\n  function FpsMeter() {\n    this.update = __bind(this.update, this);\n    this.toggleState = __bind(this.toggleState, this);\n    this.tick = __bind(this.tick, this);\n    FpsMeter.__super__.constructor.apply(this, arguments);\n    this.initTime();\n    this.surface = new Surface({\n      size: [100, 20],\n      classes: ['fpsmeter'],\n      content: ''\n    });\n    this.add(new Modifier({\n      origin: [1, 1],\n      transform: Transform.inFront\n    })).add(this.surface);\n    this.surface.on('click', this.toggleState);\n    this.start();\n  }\n\n  FpsMeter.prototype.initTime = function() {\n    var perf, perfNow;\n    perf = window.performance;\n    if (perf && (perf.now || perf.webkitNow)) {\n      perfNow = perf.now ? 'now' : 'webkitNow';\n      this.getTime = perf[perfNow].bind(perf);\n    }\n    return this.lastTime = this.getTime();\n  };\n\n  FpsMeter.prototype.tick = function() {\n    var thisFrameTime;\n    this.currTime = this.getTime();\n    thisFrameTime = this.currTime - this.lastTime;\n    this.frameTime += (thisFrameTime - this.frameTime) / this.filterStrength;\n    return this.lastTime = this.currTime;\n  };\n\n  FpsMeter.prototype.toggleState = function() {\n    if (this.state) {\n      this.stop();\n    } else {\n      this.start();\n    }\n    return this.state = !this.state;\n  };\n\n  FpsMeter.prototype.start = function() {\n    Engine.on('prerender', this.tick);\n    return this.interval = Timer.setInterval(this.update, this.updateFrequency);\n  };\n\n  FpsMeter.prototype.stop = function() {\n    Engine.removeListener('prerender', this.tick);\n    return Timer.clear(this.interval);\n  };\n\n  FpsMeter.prototype.update = function() {\n    return this.surface.setContent(\"\" + ((1000 / this.frameTime).toFixed(1)) + \" fps\");\n  };\n\n  FpsMeter.prototype.getTime = function() {\n    return +new Date();\n  };\n\n  return FpsMeter;\n\n})(View);\n\nmodule.exports = FpsMeter;\n","View = require 'famous/core/View'\nSurface = require 'famous/core/Surface'\nImageSurface = require 'famous/surfaces/ImageSurface'\nModifier  = require 'famous/core/Modifier'\nStateModifier = require 'famous/modifiers/StateModifier'\nTransform = require 'famous/core/Transform'\nEasing = require 'famous/transitions/Easing'\nTimer = require 'famous/utilities/Timer'\n\n\nclass Mascot extends View\n  constructor: ->\n    super\n\n    @stateModifier = new StateModifier\n\n    @modifier = @add(@stateModifier)\n\n    @modifier.add new ImageSurface\n      size: [417, 800]\n      content: '/images/mascot_medium.png'\n\n    @stateModifier.setTransform(\n      Transform.translate 0, 300\n      duration : 1000\n      curve: Easing.inExpo\n    )\n\n    @stateModifier.setTransform(\n      Transform.translate 100, 300\n      {\n        duration : 800\n        curve: Easing.outElastic\n      }\n      =>\n        # Talk bubble\n        @modifier.add new Modifier\n          transform: Transform.translate 400, 0\n        .add new ImageSurface\n          size: [192, 200]\n          content: 'images/talk_medium.png'\n        @modifier.add new Modifier\n          transform: Transform.translate 480, 60\n        .add new Surface\n          content: 'Sup?'\n        Timer.setTimeout =>\n          @fadeOut()\n        , 1000\n\n    )\n\n  fadeOut: ->\n    @stateModifier.setOpacity(\n      0\n      duration: 500\n      curve: Easing.outCubic\n    )\n\nmodule.exports = Mascot\n\n","var Easing, ImageSurface, Mascot, Modifier, StateModifier, Surface, Timer, Transform, View,\n  __hasProp = {}.hasOwnProperty,\n  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };\n\nView = require('famous/core/View');\n\nSurface = require('famous/core/Surface');\n\nImageSurface = require('famous/surfaces/ImageSurface');\n\nModifier = require('famous/core/Modifier');\n\nStateModifier = require('famous/modifiers/StateModifier');\n\nTransform = require('famous/core/Transform');\n\nEasing = require('famous/transitions/Easing');\n\nTimer = require('famous/utilities/Timer');\n\nMascot = (function(_super) {\n  __extends(Mascot, _super);\n\n  function Mascot() {\n    Mascot.__super__.constructor.apply(this, arguments);\n    this.stateModifier = new StateModifier;\n    this.modifier = this.add(this.stateModifier);\n    this.modifier.add(new ImageSurface({\n      size: [417, 800],\n      content: '/images/mascot_medium.png'\n    }));\n    this.stateModifier.setTransform(Transform.translate(0, 300), {\n      duration: 1000,\n      curve: Easing.inExpo\n    });\n    this.stateModifier.setTransform(Transform.translate(100, 300), {\n      duration: 800,\n      curve: Easing.outElastic\n    }, (function(_this) {\n      return function() {\n        _this.modifier.add(new Modifier({\n          transform: Transform.translate(400, 0)\n        })).add(new ImageSurface({\n          size: [192, 200],\n          content: 'images/talk_medium.png'\n        }));\n        _this.modifier.add(new Modifier({\n          transform: Transform.translate(480, 60)\n        })).add(new Surface({\n          content: 'Sup?'\n        }));\n        return Timer.setTimeout(function() {\n          return _this.fadeOut();\n        }, 1000);\n      };\n    })(this));\n  }\n\n  Mascot.prototype.fadeOut = function() {\n    return this.stateModifier.setOpacity(0, {\n      duration: 500,\n      curve: Easing.outCubic\n    });\n  };\n\n  return Mascot;\n\n})(View);\n\nmodule.exports = Mascot;\n","module.exports =\n  public: require 'config/public'\n\n","# Public config vars and tokens.\n# This file is committed to git and available to the client.\n\nmodule.exports =\n  # Parse client credentials\n  parse:\n    appId: 'sMSeqS1EP23z0vo3TgZKd38MBiP9qzrvnv0OHMk8'\n    jsKey: 'XrA5EweJyzPmhxQZY6DqE8qotDmAk13s5JKhkyql'\n\n  facebook:\n    appId: '1410524409215955'\n\n  # 3rd party authentication server\n  gatekeeper:\n    server: 'http://localhost:9999'\n\n  # Image upload server\n  upload:\n    server: 'http://localhost:9998'\n    s3bucket: 'http://pegg.s3.amazonaws.com'\n\n  aviary:\n    apiKey: 'cdef40f2d4f076a2'\n","# Modularize Parse\n\nrequire('script!parse-1.2.18_fixed-parsedate')\nConfig = require('config').public.parse\n\nParse.initialize Config.appId, Config.jsKey\n\nmodule.exports = window.Parse\n","/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n *\n * Owner: mark@famo.us\n * @license MPL 2.0\n * @copyright Famous Industries, Inc. 2014\n */\n\n\nhtml {\n    width: 100%;\n    height: 100%;\n    margin: 0px;\n    padding: 0px;\n    overflow: hidden;\n    -webkit-transform-style: preserve-3d;\n    transform-style: preserve-3d;\n}\n\nbody {\n    position: absolute;\n    width: 100%;\n    height: 100%;\n    margin: 0px;\n    padding: 0px;\n    -webkit-transform-style: preserve-3d;\n    transform-style: preserve-3d;\n    -webkit-font-smoothing: antialiased;\n    -webkit-tap-highlight-color: transparent;\n    -webkit-perspective: 0;\n    perspective: none;\n    overflow: hidden;\n}\n\n.famous-container, .famous-group {\n    position: absolute;\n    top: 0px;\n    left: 0px;\n    bottom: 0px;\n    right: 0px;\n    overflow: visible;\n    -webkit-transform-style: preserve-3d;\n    transform-style: preserve-3d;\n    -webkit-backface-visibility: visible;\n    backface-visibility: visible;\n    pointer-events: none;\n}\n\n.famous-group {\n    width: 0px;\n    height: 0px;\n    margin: 0px;\n    padding: 0px;\n    -webkit-transform-style: preserve-3d;\n    transform-style: preserve-3d;\n}\n\n.famous-surface {\n    position: absolute;\n    -webkit-transform-origin: center center;\n    transform-origin: center center;\n    -webkit-backface-visibility: hidden;\n    backface-visibility: hidden;\n    -webkit-transform-style: flat;\n    transform-style: preserve-3d; /* performance */\n    -webkit-box-sizing: border-box;\n    -moz-box-sizing: border-box;\n    -webkit-tap-highlight-color: transparent;\n    pointer-events: auto;\n}\n\n.famous-container-group {\n    position: relative;\n    width: 100%;\n    height: 100%;\n}\n","module.exports = \"body {\\n  font-family: \\\"Helvetica Neue\\\", \\\"Helvetica\\\", Helvetica, Arial, sans-serif; }\\n\\nbutton {\\n  width: 100%;\\n  height: 100%; }\\n\\n.answer {\\n  background-color: #00a5ff;\\n  padding: 10px;\\n  border: 10px solid white;\\n  text-align: center; }\\n\"","module.exports = \".backface-visible, .card__shim {\\n  backface-visibility: visible;\\n  -webkit-backface-visibility: visible;\\n  -moz-backface-visibility: visible;\\n  -ms-backface-visibility: visible; }\\n\\n.card__front, .card__middle, .card__back {\\n  text-align: center;\\n  cursor: pointer; }\\n\\n.card__front {\\n  background-color: #9fcacf; }\\n\\n.card__backing {\\n  background-color: #000; }\\n\\n.card__shim {\\n  background-color: #000; }\\n\\n.card__back {\\n  background-color: #ffd500; }\\n\"","module.exports = \".header__background, .footer {\\n  background-color: #0c0d2a;\\n  color: #fff;\\n  line-height: 100px;\\n  text-align: center; }\\n\\n.header__title {\\n  font-weight: bold;\\n  font-size: 30px;\\n  text-align: center;\\n  color: #fff; }\\n\\n.header__logo {\\n  cursor: pointer; }\\n\"","module.exports = \".fpsmeter {\\n  color: #000;\\n  cursor: pointer; }\\n\"","/*\r\n\tMIT License http://www.opensource.org/licenses/mit-license.php\r\n\tAuthor Tobias Koppers @sokra\r\n*/\r\nmodule.exports = function(src) {\r\n\tif (window.execScript)\r\n\t\twindow.execScript(src);\r\n\telse\r\n\t\teval.call(null, src);\r\n}","require(\"!/Users/joe/Documents/_projects/gratzi/pegg/dev/pegg/node_modules/script-loader/addScript.js\")(require(\"!/Users/joe/Documents/_projects/gratzi/pegg/dev/pegg/node_modules/script-loader/node_modules/raw-loader/index.js!/Users/joe/Documents/_projects/gratzi/pegg/dev/pegg/src/lib/parse-1.2.18_fixed-parsedate.js\"))","module.exports = \"/*!\\n * Parse JavaScript SDK\\n * Version: 1.2.18\\n * Built: Wed Mar 12 2014 15:36:03\\n * http://parse.com\\n *\\n * Copyright 2014 Parse, Inc.\\n * The Parse JavaScript SDK is freely distributable under the MIT license.\\n *\\n * Includes: Underscore.js\\n * Copyright 2009-2012 Jeremy Ashkenas, DocumentCloud Inc.\\n * Released under the MIT license.\\n */\\n(function(root) {\\n  root.Parse = root.Parse || {};\\n  root.Parse.VERSION = \\\"js1.2.18\\\";\\n}(this));\\n//     Underscore.js 1.4.4\\n//     http://underscorejs.org\\n//     (c) 2009-2013 Jeremy Ashkenas, DocumentCloud Inc.\\n//     Underscore may be freely distributed under the MIT license.\\n\\n(function() {\\n\\n  // Baseline setup\\n  // --------------\\n\\n  // Establish the root object, `window` in the browser, or `global` on the server.\\n  var root = this;\\n\\n  // Save the previous value of the `_` variable.\\n  var previousUnderscore = root._;\\n\\n  // Establish the object that gets returned to break out of a loop iteration.\\n  var breaker = {};\\n\\n  // Save bytes in the minified (but not gzipped) version:\\n  var ArrayProto = Array.prototype, ObjProto = Object.prototype, FuncProto = Function.prototype;\\n\\n  // Create quick reference variables for speed access to core prototypes.\\n  var push             = ArrayProto.push,\\n      slice            = ArrayProto.slice,\\n      concat           = ArrayProto.concat,\\n      toString         = ObjProto.toString,\\n      hasOwnProperty   = ObjProto.hasOwnProperty;\\n\\n  // All **ECMAScript 5** native function implementations that we hope to use\\n  // are declared here.\\n  var\\n    nativeForEach      = ArrayProto.forEach,\\n    nativeMap          = ArrayProto.map,\\n    nativeReduce       = ArrayProto.reduce,\\n    nativeReduceRight  = ArrayProto.reduceRight,\\n    nativeFilter       = ArrayProto.filter,\\n    nativeEvery        = ArrayProto.every,\\n    nativeSome         = ArrayProto.some,\\n    nativeIndexOf      = ArrayProto.indexOf,\\n    nativeLastIndexOf  = ArrayProto.lastIndexOf,\\n    nativeIsArray      = Array.isArray,\\n    nativeKeys         = Object.keys,\\n    nativeBind         = FuncProto.bind;\\n\\n  // Create a safe reference to the Underscore object for use below.\\n  var _ = function(obj) {\\n    if (obj instanceof _) return obj;\\n    if (!(this instanceof _)) return new _(obj);\\n    this._wrapped = obj;\\n  };\\n\\n  // Export the Underscore object for **Node.js**, with\\n  // backwards-compatibility for the old `require()` API. If we're in\\n  // the browser, add `_` as a global object via a string identifier,\\n  // for Closure Compiler \\\"advanced\\\" mode.\\n  if (typeof exports !== 'undefined') {\\n    if (typeof module !== 'undefined' && module.exports) {\\n      exports = module.exports = _;\\n    }\\n    exports._ = _;\\n  } else {\\n    root._ = _;\\n  }\\n\\n  // Current version.\\n  _.VERSION = '1.4.4';\\n\\n  // Collection Functions\\n  // --------------------\\n\\n  // The cornerstone, an `each` implementation, aka `forEach`.\\n  // Handles objects with the built-in `forEach`, arrays, and raw objects.\\n  // Delegates to **ECMAScript 5**'s native `forEach` if available.\\n  var each = _.each = _.forEach = function(obj, iterator, context) {\\n    if (obj == null) return;\\n    if (nativeForEach && obj.forEach === nativeForEach) {\\n      obj.forEach(iterator, context);\\n    } else if (obj.length === +obj.length) {\\n      for (var i = 0, l = obj.length; i < l; i++) {\\n        if (iterator.call(context, obj[i], i, obj) === breaker) return;\\n      }\\n    } else {\\n      for (var key in obj) {\\n        if (_.has(obj, key)) {\\n          if (iterator.call(context, obj[key], key, obj) === breaker) return;\\n        }\\n      }\\n    }\\n  };\\n\\n  // Return the results of applying the iterator to each element.\\n  // Delegates to **ECMAScript 5**'s native `map` if available.\\n  _.map = _.collect = function(obj, iterator, context) {\\n    var results = [];\\n    if (obj == null) return results;\\n    if (nativeMap && obj.map === nativeMap) return obj.map(iterator, context);\\n    each(obj, function(value, index, list) {\\n      results[results.length] = iterator.call(context, value, index, list);\\n    });\\n    return results;\\n  };\\n\\n  var reduceError = 'Reduce of empty array with no initial value';\\n\\n  // **Reduce** builds up a single result from a list of values, aka `inject`,\\n  // or `foldl`. Delegates to **ECMAScript 5**'s native `reduce` if available.\\n  _.reduce = _.foldl = _.inject = function(obj, iterator, memo, context) {\\n    var initial = arguments.length > 2;\\n    if (obj == null) obj = [];\\n    if (nativeReduce && obj.reduce === nativeReduce) {\\n      if (context) iterator = _.bind(iterator, context);\\n      return initial ? obj.reduce(iterator, memo) : obj.reduce(iterator);\\n    }\\n    each(obj, function(value, index, list) {\\n      if (!initial) {\\n        memo = value;\\n        initial = true;\\n      } else {\\n        memo = iterator.call(context, memo, value, index, list);\\n      }\\n    });\\n    if (!initial) throw new TypeError(reduceError);\\n    return memo;\\n  };\\n\\n  // The right-associative version of reduce, also known as `foldr`.\\n  // Delegates to **ECMAScript 5**'s native `reduceRight` if available.\\n  _.reduceRight = _.foldr = function(obj, iterator, memo, context) {\\n    var initial = arguments.length > 2;\\n    if (obj == null) obj = [];\\n    if (nativeReduceRight && obj.reduceRight === nativeReduceRight) {\\n      if (context) iterator = _.bind(iterator, context);\\n      return initial ? obj.reduceRight(iterator, memo) : obj.reduceRight(iterator);\\n    }\\n    var length = obj.length;\\n    if (length !== +length) {\\n      var keys = _.keys(obj);\\n      length = keys.length;\\n    }\\n    each(obj, function(value, index, list) {\\n      index = keys ? keys[--length] : --length;\\n      if (!initial) {\\n        memo = obj[index];\\n        initial = true;\\n      } else {\\n        memo = iterator.call(context, memo, obj[index], index, list);\\n      }\\n    });\\n    if (!initial) throw new TypeError(reduceError);\\n    return memo;\\n  };\\n\\n  // Return the first value which passes a truth test. Aliased as `detect`.\\n  _.find = _.detect = function(obj, iterator, context) {\\n    var result;\\n    any(obj, function(value, index, list) {\\n      if (iterator.call(context, value, index, list)) {\\n        result = value;\\n        return true;\\n      }\\n    });\\n    return result;\\n  };\\n\\n  // Return all the elements that pass a truth test.\\n  // Delegates to **ECMAScript 5**'s native `filter` if available.\\n  // Aliased as `select`.\\n  _.filter = _.select = function(obj, iterator, context) {\\n    var results = [];\\n    if (obj == null) return results;\\n    if (nativeFilter && obj.filter === nativeFilter) return obj.filter(iterator, context);\\n    each(obj, function(value, index, list) {\\n      if (iterator.call(context, value, index, list)) results[results.length] = value;\\n    });\\n    return results;\\n  };\\n\\n  // Return all the elements for which a truth test fails.\\n  _.reject = function(obj, iterator, context) {\\n    return _.filter(obj, function(value, index, list) {\\n      return !iterator.call(context, value, index, list);\\n    }, context);\\n  };\\n\\n  // Determine whether all of the elements match a truth test.\\n  // Delegates to **ECMAScript 5**'s native `every` if available.\\n  // Aliased as `all`.\\n  _.every = _.all = function(obj, iterator, context) {\\n    iterator || (iterator = _.identity);\\n    var result = true;\\n    if (obj == null) return result;\\n    if (nativeEvery && obj.every === nativeEvery) return obj.every(iterator, context);\\n    each(obj, function(value, index, list) {\\n      if (!(result = result && iterator.call(context, value, index, list))) return breaker;\\n    });\\n    return !!result;\\n  };\\n\\n  // Determine if at least one element in the object matches a truth test.\\n  // Delegates to **ECMAScript 5**'s native `some` if available.\\n  // Aliased as `any`.\\n  var any = _.some = _.any = function(obj, iterator, context) {\\n    iterator || (iterator = _.identity);\\n    var result = false;\\n    if (obj == null) return result;\\n    if (nativeSome && obj.some === nativeSome) return obj.some(iterator, context);\\n    each(obj, function(value, index, list) {\\n      if (result || (result = iterator.call(context, value, index, list))) return breaker;\\n    });\\n    return !!result;\\n  };\\n\\n  // Determine if the array or object contains a given value (using `===`).\\n  // Aliased as `include`.\\n  _.contains = _.include = function(obj, target) {\\n    if (obj == null) return false;\\n    if (nativeIndexOf && obj.indexOf === nativeIndexOf) return obj.indexOf(target) != -1;\\n    return any(obj, function(value) {\\n      return value === target;\\n    });\\n  };\\n\\n  // Invoke a method (with arguments) on every item in a collection.\\n  _.invoke = function(obj, method) {\\n    var args = slice.call(arguments, 2);\\n    var isFunc = _.isFunction(method);\\n    return _.map(obj, function(value) {\\n      return (isFunc ? method : value[method]).apply(value, args);\\n    });\\n  };\\n\\n  // Convenience version of a common use case of `map`: fetching a property.\\n  _.pluck = function(obj, key) {\\n    return _.map(obj, function(value){ return value[key]; });\\n  };\\n\\n  // Convenience version of a common use case of `filter`: selecting only objects\\n  // containing specific `key:value` pairs.\\n  _.where = function(obj, attrs, first) {\\n    if (_.isEmpty(attrs)) return first ? null : [];\\n    return _[first ? 'find' : 'filter'](obj, function(value) {\\n      for (var key in attrs) {\\n        if (attrs[key] !== value[key]) return false;\\n      }\\n      return true;\\n    });\\n  };\\n\\n  // Convenience version of a common use case of `find`: getting the first object\\n  // containing specific `key:value` pairs.\\n  _.findWhere = function(obj, attrs) {\\n    return _.where(obj, attrs, true);\\n  };\\n\\n  // Return the maximum element or (element-based computation).\\n  // Can't optimize arrays of integers longer than 65,535 elements.\\n  // See: https://bugs.webkit.org/show_bug.cgi?id=80797\\n  _.max = function(obj, iterator, context) {\\n    if (!iterator && _.isArray(obj) && obj[0] === +obj[0] && obj.length < 65535) {\\n      return Math.max.apply(Math, obj);\\n    }\\n    if (!iterator && _.isEmpty(obj)) return -Infinity;\\n    var result = {computed : -Infinity, value: -Infinity};\\n    each(obj, function(value, index, list) {\\n      var computed = iterator ? iterator.call(context, value, index, list) : value;\\n      computed >= result.computed && (result = {value : value, computed : computed});\\n    });\\n    return result.value;\\n  };\\n\\n  // Return the minimum element (or element-based computation).\\n  _.min = function(obj, iterator, context) {\\n    if (!iterator && _.isArray(obj) && obj[0] === +obj[0] && obj.length < 65535) {\\n      return Math.min.apply(Math, obj);\\n    }\\n    if (!iterator && _.isEmpty(obj)) return Infinity;\\n    var result = {computed : Infinity, value: Infinity};\\n    each(obj, function(value, index, list) {\\n      var computed = iterator ? iterator.call(context, value, index, list) : value;\\n      computed < result.computed && (result = {value : value, computed : computed});\\n    });\\n    return result.value;\\n  };\\n\\n  // Shuffle an array.\\n  _.shuffle = function(obj) {\\n    var rand;\\n    var index = 0;\\n    var shuffled = [];\\n    each(obj, function(value) {\\n      rand = _.random(index++);\\n      shuffled[index - 1] = shuffled[rand];\\n      shuffled[rand] = value;\\n    });\\n    return shuffled;\\n  };\\n\\n  // An internal function to generate lookup iterators.\\n  var lookupIterator = function(value) {\\n    return _.isFunction(value) ? value : function(obj){ return obj[value]; };\\n  };\\n\\n  // Sort the object's values by a criterion produced by an iterator.\\n  _.sortBy = function(obj, value, context) {\\n    var iterator = lookupIterator(value);\\n    return _.pluck(_.map(obj, function(value, index, list) {\\n      return {\\n        value : value,\\n        index : index,\\n        criteria : iterator.call(context, value, index, list)\\n      };\\n    }).sort(function(left, right) {\\n      var a = left.criteria;\\n      var b = right.criteria;\\n      if (a !== b) {\\n        if (a > b || a === void 0) return 1;\\n        if (a < b || b === void 0) return -1;\\n      }\\n      return left.index < right.index ? -1 : 1;\\n    }), 'value');\\n  };\\n\\n  // An internal function used for aggregate \\\"group by\\\" operations.\\n  var group = function(obj, value, context, behavior) {\\n    var result = {};\\n    var iterator = lookupIterator(value || _.identity);\\n    each(obj, function(value, index) {\\n      var key = iterator.call(context, value, index, obj);\\n      behavior(result, key, value);\\n    });\\n    return result;\\n  };\\n\\n  // Groups the object's values by a criterion. Pass either a string attribute\\n  // to group by, or a function that returns the criterion.\\n  _.groupBy = function(obj, value, context) {\\n    return group(obj, value, context, function(result, key, value) {\\n      (_.has(result, key) ? result[key] : (result[key] = [])).push(value);\\n    });\\n  };\\n\\n  // Counts instances of an object that group by a certain criterion. Pass\\n  // either a string attribute to count by, or a function that returns the\\n  // criterion.\\n  _.countBy = function(obj, value, context) {\\n    return group(obj, value, context, function(result, key) {\\n      if (!_.has(result, key)) result[key] = 0;\\n      result[key]++;\\n    });\\n  };\\n\\n  // Use a comparator function to figure out the smallest index at which\\n  // an object should be inserted so as to maintain order. Uses binary search.\\n  _.sortedIndex = function(array, obj, iterator, context) {\\n    iterator = iterator == null ? _.identity : lookupIterator(iterator);\\n    var value = iterator.call(context, obj);\\n    var low = 0, high = array.length;\\n    while (low < high) {\\n      var mid = (low + high) >>> 1;\\n      iterator.call(context, array[mid]) < value ? low = mid + 1 : high = mid;\\n    }\\n    return low;\\n  };\\n\\n  // Safely convert anything iterable into a real, live array.\\n  _.toArray = function(obj) {\\n    if (!obj) return [];\\n    if (_.isArray(obj)) return slice.call(obj);\\n    if (obj.length === +obj.length) return _.map(obj, _.identity);\\n    return _.values(obj);\\n  };\\n\\n  // Return the number of elements in an object.\\n  _.size = function(obj) {\\n    if (obj == null) return 0;\\n    return (obj.length === +obj.length) ? obj.length : _.keys(obj).length;\\n  };\\n\\n  // Array Functions\\n  // ---------------\\n\\n  // Get the first element of an array. Passing **n** will return the first N\\n  // values in the array. Aliased as `head` and `take`. The **guard** check\\n  // allows it to work with `_.map`.\\n  _.first = _.head = _.take = function(array, n, guard) {\\n    if (array == null) return void 0;\\n    return (n != null) && !guard ? slice.call(array, 0, n) : array[0];\\n  };\\n\\n  // Returns everything but the last entry of the array. Especially useful on\\n  // the arguments object. Passing **n** will return all the values in\\n  // the array, excluding the last N. The **guard** check allows it to work with\\n  // `_.map`.\\n  _.initial = function(array, n, guard) {\\n    return slice.call(array, 0, array.length - ((n == null) || guard ? 1 : n));\\n  };\\n\\n  // Get the last element of an array. Passing **n** will return the last N\\n  // values in the array. The **guard** check allows it to work with `_.map`.\\n  _.last = function(array, n, guard) {\\n    if (array == null) return void 0;\\n    if ((n != null) && !guard) {\\n      return slice.call(array, Math.max(array.length - n, 0));\\n    } else {\\n      return array[array.length - 1];\\n    }\\n  };\\n\\n  // Returns everything but the first entry of the array. Aliased as `tail` and `drop`.\\n  // Especially useful on the arguments object. Passing an **n** will return\\n  // the rest N values in the array. The **guard**\\n  // check allows it to work with `_.map`.\\n  _.rest = _.tail = _.drop = function(array, n, guard) {\\n    return slice.call(array, (n == null) || guard ? 1 : n);\\n  };\\n\\n  // Trim out all falsy values from an array.\\n  _.compact = function(array) {\\n    return _.filter(array, _.identity);\\n  };\\n\\n  // Internal implementation of a recursive `flatten` function.\\n  var flatten = function(input, shallow, output) {\\n    each(input, function(value) {\\n      if (_.isArray(value)) {\\n        shallow ? push.apply(output, value) : flatten(value, shallow, output);\\n      } else {\\n        output.push(value);\\n      }\\n    });\\n    return output;\\n  };\\n\\n  // Return a completely flattened version of an array.\\n  _.flatten = function(array, shallow) {\\n    return flatten(array, shallow, []);\\n  };\\n\\n  // Return a version of the array that does not contain the specified value(s).\\n  _.without = function(array) {\\n    return _.difference(array, slice.call(arguments, 1));\\n  };\\n\\n  // Produce a duplicate-free version of the array. If the array has already\\n  // been sorted, you have the option of using a faster algorithm.\\n  // Aliased as `unique`.\\n  _.uniq = _.unique = function(array, isSorted, iterator, context) {\\n    if (_.isFunction(isSorted)) {\\n      context = iterator;\\n      iterator = isSorted;\\n      isSorted = false;\\n    }\\n    var initial = iterator ? _.map(array, iterator, context) : array;\\n    var results = [];\\n    var seen = [];\\n    each(initial, function(value, index) {\\n      if (isSorted ? (!index || seen[seen.length - 1] !== value) : !_.contains(seen, value)) {\\n        seen.push(value);\\n        results.push(array[index]);\\n      }\\n    });\\n    return results;\\n  };\\n\\n  // Produce an array that contains the union: each distinct element from all of\\n  // the passed-in arrays.\\n  _.union = function() {\\n    return _.uniq(concat.apply(ArrayProto, arguments));\\n  };\\n\\n  // Produce an array that contains every item shared between all the\\n  // passed-in arrays.\\n  _.intersection = function(array) {\\n    var rest = slice.call(arguments, 1);\\n    return _.filter(_.uniq(array), function(item) {\\n      return _.every(rest, function(other) {\\n        return _.indexOf(other, item) >= 0;\\n      });\\n    });\\n  };\\n\\n  // Take the difference between one array and a number of other arrays.\\n  // Only the elements present in just the first array will remain.\\n  _.difference = function(array) {\\n    var rest = concat.apply(ArrayProto, slice.call(arguments, 1));\\n    return _.filter(array, function(value){ return !_.contains(rest, value); });\\n  };\\n\\n  // Zip together multiple lists into a single array -- elements that share\\n  // an index go together.\\n  _.zip = function() {\\n    var args = slice.call(arguments);\\n    var length = _.max(_.pluck(args, 'length'));\\n    var results = new Array(length);\\n    for (var i = 0; i < length; i++) {\\n      results[i] = _.pluck(args, \\\"\\\" + i);\\n    }\\n    return results;\\n  };\\n\\n  // Converts lists into objects. Pass either a single array of `[key, value]`\\n  // pairs, or two parallel arrays of the same length -- one of keys, and one of\\n  // the corresponding values.\\n  _.object = function(list, values) {\\n    if (list == null) return {};\\n    var result = {};\\n    for (var i = 0, l = list.length; i < l; i++) {\\n      if (values) {\\n        result[list[i]] = values[i];\\n      } else {\\n        result[list[i][0]] = list[i][1];\\n      }\\n    }\\n    return result;\\n  };\\n\\n  // If the browser doesn't supply us with indexOf (I'm looking at you, **MSIE**),\\n  // we need this function. Return the position of the first occurrence of an\\n  // item in an array, or -1 if the item is not included in the array.\\n  // Delegates to **ECMAScript 5**'s native `indexOf` if available.\\n  // If the array is large and already in sort order, pass `true`\\n  // for **isSorted** to use binary search.\\n  _.indexOf = function(array, item, isSorted) {\\n    if (array == null) return -1;\\n    var i = 0, l = array.length;\\n    if (isSorted) {\\n      if (typeof isSorted == 'number') {\\n        i = (isSorted < 0 ? Math.max(0, l + isSorted) : isSorted);\\n      } else {\\n        i = _.sortedIndex(array, item);\\n        return array[i] === item ? i : -1;\\n      }\\n    }\\n    if (nativeIndexOf && array.indexOf === nativeIndexOf) return array.indexOf(item, isSorted);\\n    for (; i < l; i++) if (array[i] === item) return i;\\n    return -1;\\n  };\\n\\n  // Delegates to **ECMAScript 5**'s native `lastIndexOf` if available.\\n  _.lastIndexOf = function(array, item, from) {\\n    if (array == null) return -1;\\n    var hasIndex = from != null;\\n    if (nativeLastIndexOf && array.lastIndexOf === nativeLastIndexOf) {\\n      return hasIndex ? array.lastIndexOf(item, from) : array.lastIndexOf(item);\\n    }\\n    var i = (hasIndex ? from : array.length);\\n    while (i--) if (array[i] === item) return i;\\n    return -1;\\n  };\\n\\n  // Generate an integer Array containing an arithmetic progression. A port of\\n  // the native Python `range()` function. See\\n  // [the Python documentation](http://docs.python.org/library/functions.html#range).\\n  _.range = function(start, stop, step) {\\n    if (arguments.length <= 1) {\\n      stop = start || 0;\\n      start = 0;\\n    }\\n    step = arguments[2] || 1;\\n\\n    var len = Math.max(Math.ceil((stop - start) / step), 0);\\n    var idx = 0;\\n    var range = new Array(len);\\n\\n    while(idx < len) {\\n      range[idx++] = start;\\n      start += step;\\n    }\\n\\n    return range;\\n  };\\n\\n  // Function (ahem) Functions\\n  // ------------------\\n\\n  // Create a function bound to a given object (assigning `this`, and arguments,\\n  // optionally). Delegates to **ECMAScript 5**'s native `Function.bind` if\\n  // available.\\n  _.bind = function(func, context) {\\n    if (func.bind === nativeBind && nativeBind) return nativeBind.apply(func, slice.call(arguments, 1));\\n    var args = slice.call(arguments, 2);\\n    return function() {\\n      return func.apply(context, args.concat(slice.call(arguments)));\\n    };\\n  };\\n\\n  // Partially apply a function by creating a version that has had some of its\\n  // arguments pre-filled, without changing its dynamic `this` context.\\n  _.partial = function(func) {\\n    var args = slice.call(arguments, 1);\\n    return function() {\\n      return func.apply(this, args.concat(slice.call(arguments)));\\n    };\\n  };\\n\\n  // Bind all of an object's methods to that object. Useful for ensuring that\\n  // all callbacks defined on an object belong to it.\\n  _.bindAll = function(obj) {\\n    var funcs = slice.call(arguments, 1);\\n    if (funcs.length === 0) funcs = _.functions(obj);\\n    each(funcs, function(f) { obj[f] = _.bind(obj[f], obj); });\\n    return obj;\\n  };\\n\\n  // Memoize an expensive function by storing its results.\\n  _.memoize = function(func, hasher) {\\n    var memo = {};\\n    hasher || (hasher = _.identity);\\n    return function() {\\n      var key = hasher.apply(this, arguments);\\n      return _.has(memo, key) ? memo[key] : (memo[key] = func.apply(this, arguments));\\n    };\\n  };\\n\\n  // Delays a function for the given number of milliseconds, and then calls\\n  // it with the arguments supplied.\\n  _.delay = function(func, wait) {\\n    var args = slice.call(arguments, 2);\\n    return setTimeout(function(){ return func.apply(null, args); }, wait);\\n  };\\n\\n  // Defers a function, scheduling it to run after the current call stack has\\n  // cleared.\\n  _.defer = function(func) {\\n    return _.delay.apply(_, [func, 1].concat(slice.call(arguments, 1)));\\n  };\\n\\n  // Returns a function, that, when invoked, will only be triggered at most once\\n  // during a given window of time.\\n  _.throttle = function(func, wait) {\\n    var context, args, timeout, result;\\n    var previous = 0;\\n    var later = function() {\\n      previous = new Date;\\n      timeout = null;\\n      result = func.apply(context, args);\\n    };\\n    return function() {\\n      var now = new Date;\\n      var remaining = wait - (now - previous);\\n      context = this;\\n      args = arguments;\\n      if (remaining <= 0) {\\n        clearTimeout(timeout);\\n        timeout = null;\\n        previous = now;\\n        result = func.apply(context, args);\\n      } else if (!timeout) {\\n        timeout = setTimeout(later, remaining);\\n      }\\n      return result;\\n    };\\n  };\\n\\n  // Returns a function, that, as long as it continues to be invoked, will not\\n  // be triggered. The function will be called after it stops being called for\\n  // N milliseconds. If `immediate` is passed, trigger the function on the\\n  // leading edge, instead of the trailing.\\n  _.debounce = function(func, wait, immediate) {\\n    var timeout, result;\\n    return function() {\\n      var context = this, args = arguments;\\n      var later = function() {\\n        timeout = null;\\n        if (!immediate) result = func.apply(context, args);\\n      };\\n      var callNow = immediate && !timeout;\\n      clearTimeout(timeout);\\n      timeout = setTimeout(later, wait);\\n      if (callNow) result = func.apply(context, args);\\n      return result;\\n    };\\n  };\\n\\n  // Returns a function that will be executed at most one time, no matter how\\n  // often you call it. Useful for lazy initialization.\\n  _.once = function(func) {\\n    var ran = false, memo;\\n    return function() {\\n      if (ran) return memo;\\n      ran = true;\\n      memo = func.apply(this, arguments);\\n      func = null;\\n      return memo;\\n    };\\n  };\\n\\n  // Returns the first function passed as an argument to the second,\\n  // allowing you to adjust arguments, run code before and after, and\\n  // conditionally execute the original function.\\n  _.wrap = function(func, wrapper) {\\n    return function() {\\n      var args = [func];\\n      push.apply(args, arguments);\\n      return wrapper.apply(this, args);\\n    };\\n  };\\n\\n  // Returns a function that is the composition of a list of functions, each\\n  // consuming the return value of the function that follows.\\n  _.compose = function() {\\n    var funcs = arguments;\\n    return function() {\\n      var args = arguments;\\n      for (var i = funcs.length - 1; i >= 0; i--) {\\n        args = [funcs[i].apply(this, args)];\\n      }\\n      return args[0];\\n    };\\n  };\\n\\n  // Returns a function that will only be executed after being called N times.\\n  _.after = function(times, func) {\\n    if (times <= 0) return func();\\n    return function() {\\n      if (--times < 1) {\\n        return func.apply(this, arguments);\\n      }\\n    };\\n  };\\n\\n  // Object Functions\\n  // ----------------\\n\\n  // Retrieve the names of an object's properties.\\n  // Delegates to **ECMAScript 5**'s native `Object.keys`\\n  _.keys = nativeKeys || function(obj) {\\n    if (obj !== Object(obj)) throw new TypeError('Invalid object');\\n    var keys = [];\\n    for (var key in obj) if (_.has(obj, key)) keys[keys.length] = key;\\n    return keys;\\n  };\\n\\n  // Retrieve the values of an object's properties.\\n  _.values = function(obj) {\\n    var values = [];\\n    for (var key in obj) if (_.has(obj, key)) values.push(obj[key]);\\n    return values;\\n  };\\n\\n  // Convert an object into a list of `[key, value]` pairs.\\n  _.pairs = function(obj) {\\n    var pairs = [];\\n    for (var key in obj) if (_.has(obj, key)) pairs.push([key, obj[key]]);\\n    return pairs;\\n  };\\n\\n  // Invert the keys and values of an object. The values must be serializable.\\n  _.invert = function(obj) {\\n    var result = {};\\n    for (var key in obj) if (_.has(obj, key)) result[obj[key]] = key;\\n    return result;\\n  };\\n\\n  // Return a sorted list of the function names available on the object.\\n  // Aliased as `methods`\\n  _.functions = _.methods = function(obj) {\\n    var names = [];\\n    for (var key in obj) {\\n      if (_.isFunction(obj[key])) names.push(key);\\n    }\\n    return names.sort();\\n  };\\n\\n  // Extend a given object with all the properties in passed-in object(s).\\n  _.extend = function(obj) {\\n    each(slice.call(arguments, 1), function(source) {\\n      if (source) {\\n        for (var prop in source) {\\n          obj[prop] = source[prop];\\n        }\\n      }\\n    });\\n    return obj;\\n  };\\n\\n  // Return a copy of the object only containing the whitelisted properties.\\n  _.pick = function(obj) {\\n    var copy = {};\\n    var keys = concat.apply(ArrayProto, slice.call(arguments, 1));\\n    each(keys, function(key) {\\n      if (key in obj) copy[key] = obj[key];\\n    });\\n    return copy;\\n  };\\n\\n   // Return a copy of the object without the blacklisted properties.\\n  _.omit = function(obj) {\\n    var copy = {};\\n    var keys = concat.apply(ArrayProto, slice.call(arguments, 1));\\n    for (var key in obj) {\\n      if (!_.contains(keys, key)) copy[key] = obj[key];\\n    }\\n    return copy;\\n  };\\n\\n  // Fill in a given object with default properties.\\n  _.defaults = function(obj) {\\n    each(slice.call(arguments, 1), function(source) {\\n      if (source) {\\n        for (var prop in source) {\\n          if (obj[prop] == null) obj[prop] = source[prop];\\n        }\\n      }\\n    });\\n    return obj;\\n  };\\n\\n  // Create a (shallow-cloned) duplicate of an object.\\n  _.clone = function(obj) {\\n    if (!_.isObject(obj)) return obj;\\n    return _.isArray(obj) ? obj.slice() : _.extend({}, obj);\\n  };\\n\\n  // Invokes interceptor with the obj, and then returns obj.\\n  // The primary purpose of this method is to \\\"tap into\\\" a method chain, in\\n  // order to perform operations on intermediate results within the chain.\\n  _.tap = function(obj, interceptor) {\\n    interceptor(obj);\\n    return obj;\\n  };\\n\\n  // Internal recursive comparison function for `isEqual`.\\n  var eq = function(a, b, aStack, bStack) {\\n    // Identical objects are equal. `0 === -0`, but they aren't identical.\\n    // See the Harmony `egal` proposal: http://wiki.ecmascript.org/doku.php?id=harmony:egal.\\n    if (a === b) return a !== 0 || 1 / a == 1 / b;\\n    // A strict comparison is necessary because `null == undefined`.\\n    if (a == null || b == null) return a === b;\\n    // Unwrap any wrapped objects.\\n    if (a instanceof _) a = a._wrapped;\\n    if (b instanceof _) b = b._wrapped;\\n    // Compare `[[Class]]` names.\\n    var className = toString.call(a);\\n    if (className != toString.call(b)) return false;\\n    switch (className) {\\n      // Strings, numbers, dates, and booleans are compared by value.\\n      case '[object String]':\\n        // Primitives and their corresponding object wrappers are equivalent; thus, `\\\"5\\\"` is\\n        // equivalent to `new String(\\\"5\\\")`.\\n        return a == String(b);\\n      case '[object Number]':\\n        // `NaN`s are equivalent, but non-reflexive. An `egal` comparison is performed for\\n        // other numeric values.\\n        return a != +a ? b != +b : (a == 0 ? 1 / a == 1 / b : a == +b);\\n      case '[object Date]':\\n      case '[object Boolean]':\\n        // Coerce dates and booleans to numeric primitive values. Dates are compared by their\\n        // millisecond representations. Note that invalid dates with millisecond representations\\n        // of `NaN` are not equivalent.\\n        return +a == +b;\\n      // RegExps are compared by their source patterns and flags.\\n      case '[object RegExp]':\\n        return a.source == b.source &&\\n               a.global == b.global &&\\n               a.multiline == b.multiline &&\\n               a.ignoreCase == b.ignoreCase;\\n    }\\n    if (typeof a != 'object' || typeof b != 'object') return false;\\n    // Assume equality for cyclic structures. The algorithm for detecting cyclic\\n    // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.\\n    var length = aStack.length;\\n    while (length--) {\\n      // Linear search. Performance is inversely proportional to the number of\\n      // unique nested structures.\\n      if (aStack[length] == a) return bStack[length] == b;\\n    }\\n    // Add the first object to the stack of traversed objects.\\n    aStack.push(a);\\n    bStack.push(b);\\n    var size = 0, result = true;\\n    // Recursively compare objects and arrays.\\n    if (className == '[object Array]') {\\n      // Compare array lengths to determine if a deep comparison is necessary.\\n      size = a.length;\\n      result = size == b.length;\\n      if (result) {\\n        // Deep compare the contents, ignoring non-numeric properties.\\n        while (size--) {\\n          if (!(result = eq(a[size], b[size], aStack, bStack))) break;\\n        }\\n      }\\n    } else {\\n      // Objects with different constructors are not equivalent, but `Object`s\\n      // from different frames are.\\n      var aCtor = a.constructor, bCtor = b.constructor;\\n      if (aCtor !== bCtor && !(_.isFunction(aCtor) && (aCtor instanceof aCtor) &&\\n                               _.isFunction(bCtor) && (bCtor instanceof bCtor))) {\\n        return false;\\n      }\\n      // Deep compare objects.\\n      for (var key in a) {\\n        if (_.has(a, key)) {\\n          // Count the expected number of properties.\\n          size++;\\n          // Deep compare each member.\\n          if (!(result = _.has(b, key) && eq(a[key], b[key], aStack, bStack))) break;\\n        }\\n      }\\n      // Ensure that both objects contain the same number of properties.\\n      if (result) {\\n        for (key in b) {\\n          if (_.has(b, key) && !(size--)) break;\\n        }\\n        result = !size;\\n      }\\n    }\\n    // Remove the first object from the stack of traversed objects.\\n    aStack.pop();\\n    bStack.pop();\\n    return result;\\n  };\\n\\n  // Perform a deep comparison to check if two objects are equal.\\n  _.isEqual = function(a, b) {\\n    return eq(a, b, [], []);\\n  };\\n\\n  // Is a given array, string, or object empty?\\n  // An \\\"empty\\\" object has no enumerable own-properties.\\n  _.isEmpty = function(obj) {\\n    if (obj == null) return true;\\n    if (_.isArray(obj) || _.isString(obj)) return obj.length === 0;\\n    for (var key in obj) if (_.has(obj, key)) return false;\\n    return true;\\n  };\\n\\n  // Is a given value a DOM element?\\n  _.isElement = function(obj) {\\n    return !!(obj && obj.nodeType === 1);\\n  };\\n\\n  // Is a given value an array?\\n  // Delegates to ECMA5's native Array.isArray\\n  _.isArray = nativeIsArray || function(obj) {\\n    return toString.call(obj) == '[object Array]';\\n  };\\n\\n  // Is a given variable an object?\\n  _.isObject = function(obj) {\\n    return obj === Object(obj);\\n  };\\n\\n  // Add some isType methods: isArguments, isFunction, isString, isNumber, isDate, isRegExp.\\n  each(['Arguments', 'Function', 'String', 'Number', 'Date', 'RegExp'], function(name) {\\n    _['is' + name] = function(obj) {\\n      return toString.call(obj) == '[object ' + name + ']';\\n    };\\n  });\\n\\n  // Define a fallback version of the method in browsers (ahem, IE), where\\n  // there isn't any inspectable \\\"Arguments\\\" type.\\n  if (!_.isArguments(arguments)) {\\n    _.isArguments = function(obj) {\\n      return !!(obj && _.has(obj, 'callee'));\\n    };\\n  }\\n\\n  // Optimize `isFunction` if appropriate.\\n  if (typeof (/./) !== 'function') {\\n    _.isFunction = function(obj) {\\n      return typeof obj === 'function';\\n    };\\n  }\\n\\n  // Is a given object a finite number?\\n  _.isFinite = function(obj) {\\n    return isFinite(obj) && !isNaN(parseFloat(obj));\\n  };\\n\\n  // Is the given value `NaN`? (NaN is the only number which does not equal itself).\\n  _.isNaN = function(obj) {\\n    return _.isNumber(obj) && obj != +obj;\\n  };\\n\\n  // Is a given value a boolean?\\n  _.isBoolean = function(obj) {\\n    return obj === true || obj === false || toString.call(obj) == '[object Boolean]';\\n  };\\n\\n  // Is a given value equal to null?\\n  _.isNull = function(obj) {\\n    return obj === null;\\n  };\\n\\n  // Is a given variable undefined?\\n  _.isUndefined = function(obj) {\\n    return obj === void 0;\\n  };\\n\\n  // Shortcut function for checking if an object has a given property directly\\n  // on itself (in other words, not on a prototype).\\n  _.has = function(obj, key) {\\n    return hasOwnProperty.call(obj, key);\\n  };\\n\\n  // Utility Functions\\n  // -----------------\\n\\n  // Run Underscore.js in *noConflict* mode, returning the `_` variable to its\\n  // previous owner. Returns a reference to the Underscore object.\\n  _.noConflict = function() {\\n    root._ = previousUnderscore;\\n    return this;\\n  };\\n\\n  // Keep the identity function around for default iterators.\\n  _.identity = function(value) {\\n    return value;\\n  };\\n\\n  // Run a function **n** times.\\n  _.times = function(n, iterator, context) {\\n    var accum = Array(n);\\n    for (var i = 0; i < n; i++) accum[i] = iterator.call(context, i);\\n    return accum;\\n  };\\n\\n  // Return a random integer between min and max (inclusive).\\n  _.random = function(min, max) {\\n    if (max == null) {\\n      max = min;\\n      min = 0;\\n    }\\n    return min + Math.floor(Math.random() * (max - min + 1));\\n  };\\n\\n  // List of HTML entities for escaping.\\n  var entityMap = {\\n    escape: {\\n      '&': '&amp;',\\n      '<': '&lt;',\\n      '>': '&gt;',\\n      '\\\"': '&quot;',\\n      \\\"'\\\": '&#x27;',\\n      '/': '&#x2F;'\\n    }\\n  };\\n  entityMap.unescape = _.invert(entityMap.escape);\\n\\n  // Regexes containing the keys and values listed immediately above.\\n  var entityRegexes = {\\n    escape:   new RegExp('[' + _.keys(entityMap.escape).join('') + ']', 'g'),\\n    unescape: new RegExp('(' + _.keys(entityMap.unescape).join('|') + ')', 'g')\\n  };\\n\\n  // Functions for escaping and unescaping strings to/from HTML interpolation.\\n  _.each(['escape', 'unescape'], function(method) {\\n    _[method] = function(string) {\\n      if (string == null) return '';\\n      return ('' + string).replace(entityRegexes[method], function(match) {\\n        return entityMap[method][match];\\n      });\\n    };\\n  });\\n\\n  // If the value of the named property is a function then invoke it;\\n  // otherwise, return it.\\n  _.result = function(object, property) {\\n    if (object == null) return null;\\n    var value = object[property];\\n    return _.isFunction(value) ? value.call(object) : value;\\n  };\\n\\n  // Add your own custom functions to the Underscore object.\\n  _.mixin = function(obj) {\\n    each(_.functions(obj), function(name){\\n      var func = _[name] = obj[name];\\n      _.prototype[name] = function() {\\n        var args = [this._wrapped];\\n        push.apply(args, arguments);\\n        return result.call(this, func.apply(_, args));\\n      };\\n    });\\n  };\\n\\n  // Generate a unique integer id (unique within the entire client session).\\n  // Useful for temporary DOM ids.\\n  var idCounter = 0;\\n  _.uniqueId = function(prefix) {\\n    var id = ++idCounter + '';\\n    return prefix ? prefix + id : id;\\n  };\\n\\n  // By default, Underscore uses ERB-style template delimiters, change the\\n  // following template settings to use alternative delimiters.\\n  _.templateSettings = {\\n    evaluate    : /<%([\\\\s\\\\S]+?)%>/g,\\n    interpolate : /<%=([\\\\s\\\\S]+?)%>/g,\\n    escape      : /<%-([\\\\s\\\\S]+?)%>/g\\n  };\\n\\n  // When customizing `templateSettings`, if you don't want to define an\\n  // interpolation, evaluation or escaping regex, we need one that is\\n  // guaranteed not to match.\\n  var noMatch = /(.)^/;\\n\\n  // Certain characters need to be escaped so that they can be put into a\\n  // string literal.\\n  var escapes = {\\n    \\\"'\\\":      \\\"'\\\",\\n    '\\\\\\\\':     '\\\\\\\\',\\n    '\\\\r':     'r',\\n    '\\\\n':     'n',\\n    '\\\\t':     't',\\n    '\\\\u2028': 'u2028',\\n    '\\\\u2029': 'u2029'\\n  };\\n\\n  var escaper = /\\\\\\\\|'|\\\\r|\\\\n|\\\\t|\\\\u2028|\\\\u2029/g;\\n\\n  // JavaScript micro-templating, similar to John Resig's implementation.\\n  // Underscore templating handles arbitrary delimiters, preserves whitespace,\\n  // and correctly escapes quotes within interpolated code.\\n  _.template = function(text, data, settings) {\\n    var render;\\n    settings = _.defaults({}, settings, _.templateSettings);\\n\\n    // Combine delimiters into one regular expression via alternation.\\n    var matcher = new RegExp([\\n      (settings.escape || noMatch).source,\\n      (settings.interpolate || noMatch).source,\\n      (settings.evaluate || noMatch).source\\n    ].join('|') + '|$', 'g');\\n\\n    // Compile the template source, escaping string literals appropriately.\\n    var index = 0;\\n    var source = \\\"__p+='\\\";\\n    text.replace(matcher, function(match, escape, interpolate, evaluate, offset) {\\n      source += text.slice(index, offset)\\n        .replace(escaper, function(match) { return '\\\\\\\\' + escapes[match]; });\\n\\n      if (escape) {\\n        source += \\\"'+\\\\n((__t=(\\\" + escape + \\\"))==null?'':_.escape(__t))+\\\\n'\\\";\\n      }\\n      if (interpolate) {\\n        source += \\\"'+\\\\n((__t=(\\\" + interpolate + \\\"))==null?'':__t)+\\\\n'\\\";\\n      }\\n      if (evaluate) {\\n        source += \\\"';\\\\n\\\" + evaluate + \\\"\\\\n__p+='\\\";\\n      }\\n      index = offset + match.length;\\n      return match;\\n    });\\n    source += \\\"';\\\\n\\\";\\n\\n    // If a variable is not specified, place data values in local scope.\\n    if (!settings.variable) source = 'with(obj||{}){\\\\n' + source + '}\\\\n';\\n\\n    source = \\\"var __t,__p='',__j=Array.prototype.join,\\\" +\\n      \\\"print=function(){__p+=__j.call(arguments,'');};\\\\n\\\" +\\n      source + \\\"return __p;\\\\n\\\";\\n\\n    try {\\n      render = new Function(settings.variable || 'obj', '_', source);\\n    } catch (e) {\\n      e.source = source;\\n      throw e;\\n    }\\n\\n    if (data) return render(data, _);\\n    var template = function(data) {\\n      return render.call(this, data, _);\\n    };\\n\\n    // Provide the compiled function source as a convenience for precompilation.\\n    template.source = 'function(' + (settings.variable || 'obj') + '){\\\\n' + source + '}';\\n\\n    return template;\\n  };\\n\\n  // Add a \\\"chain\\\" function, which will delegate to the wrapper.\\n  _.chain = function(obj) {\\n    return _(obj).chain();\\n  };\\n\\n  // OOP\\n  // ---------------\\n  // If Underscore is called as a function, it returns a wrapped object that\\n  // can be used OO-style. This wrapper holds altered versions of all the\\n  // underscore functions. Wrapped objects may be chained.\\n\\n  // Helper function to continue chaining intermediate results.\\n  var result = function(obj) {\\n    return this._chain ? _(obj).chain() : obj;\\n  };\\n\\n  // Add all of the Underscore functions to the wrapper object.\\n  _.mixin(_);\\n\\n  // Add all mutator Array functions to the wrapper.\\n  each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function(name) {\\n    var method = ArrayProto[name];\\n    _.prototype[name] = function() {\\n      var obj = this._wrapped;\\n      method.apply(obj, arguments);\\n      if ((name == 'shift' || name == 'splice') && obj.length === 0) delete obj[0];\\n      return result.call(this, obj);\\n    };\\n  });\\n\\n  // Add all accessor Array functions to the wrapper.\\n  each(['concat', 'join', 'slice'], function(name) {\\n    var method = ArrayProto[name];\\n    _.prototype[name] = function() {\\n      return result.call(this, method.apply(this._wrapped, arguments));\\n    };\\n  });\\n\\n  _.extend(_.prototype, {\\n\\n    // Start chaining a wrapped Underscore object.\\n    chain: function() {\\n      this._chain = true;\\n      return this;\\n    },\\n\\n    // Extracts the result from a wrapped and chained object.\\n    value: function() {\\n      return this._wrapped;\\n    }\\n\\n  });\\n\\n}).call(this);\\n\\n/*global _: false, $: false, localStorage: false, process: true,\\n  XMLHttpRequest: false, XDomainRequest: false, exports: false,\\n  require: false */\\n(function(root) {\\n  root.Parse = root.Parse || {};\\n  /**\\n   * Contains all Parse API classes and functions.\\n   * @name Parse\\n   * @namespace\\n   *\\n   * Contains all Parse API classes and functions.\\n   */\\n  var Parse = root.Parse;\\n\\n  // Import Parse's local copy of underscore.\\n  if (typeof(exports) !== \\\"undefined\\\" && exports._) {\\n    // We're running in Node.js.  Pull in the dependencies.\\n    Parse._ = exports._.noConflict();\\n    Parse.localStorage = require('localStorage');\\n    Parse.XMLHttpRequest = require('xmlhttprequest').XMLHttpRequest;\\n    exports.Parse = Parse;\\n  } else {\\n    Parse._ = _.noConflict();\\n    if (typeof(localStorage) !== \\\"undefined\\\") {\\n      Parse.localStorage = localStorage;\\n    }\\n    if (typeof(XMLHttpRequest) !== \\\"undefined\\\") {\\n      Parse.XMLHttpRequest = XMLHttpRequest;\\n    }\\n  }\\n\\n  // If jQuery or Zepto has been included, grab a reference to it.\\n  if (typeof($) !== \\\"undefined\\\") {\\n    Parse.$ = $;\\n  }\\n\\n  // Helpers\\n  // -------\\n\\n  // Shared empty constructor function to aid in prototype-chain creation.\\n  var EmptyConstructor = function() {};\\n\\n\\n  // Helper function to correctly set up the prototype chain, for subclasses.\\n  // Similar to `goog.inherits`, but uses a hash of prototype properties and\\n  // class properties to be extended.\\n  var inherits = function(parent, protoProps, staticProps) {\\n    var child;\\n\\n    // The constructor function for the new subclass is either defined by you\\n    // (the \\\"constructor\\\" property in your `extend` definition), or defaulted\\n    // by us to simply call the parent's constructor.\\n    if (protoProps && protoProps.hasOwnProperty('constructor')) {\\n      child = protoProps.constructor;\\n    } else {\\n      /** @ignore */\\n      child = function(){ parent.apply(this, arguments); };\\n    }\\n\\n    // Inherit class (static) properties from parent.\\n    Parse._.extend(child, parent);\\n\\n    // Set the prototype chain to inherit from `parent`, without calling\\n    // `parent`'s constructor function.\\n    EmptyConstructor.prototype = parent.prototype;\\n    child.prototype = new EmptyConstructor();\\n\\n    // Add prototype properties (instance properties) to the subclass,\\n    // if supplied.\\n    if (protoProps) {\\n      Parse._.extend(child.prototype, protoProps);\\n    }\\n\\n    // Add static properties to the constructor function, if supplied.\\n    if (staticProps) {\\n      Parse._.extend(child, staticProps);\\n    }\\n\\n    // Correctly set child's `prototype.constructor`.\\n    child.prototype.constructor = child;\\n\\n    // Set a convenience property in case the parent's prototype is\\n    // needed later.\\n    child.__super__ = parent.prototype;\\n\\n    return child;\\n  };\\n\\n  // Set the server for Parse to talk to.\\n  Parse.serverURL = \\\"https://api.parse.com\\\";\\n\\n  // Check whether we are running in Node.js.\\n  if (typeof(process) !== \\\"undefined\\\" &&\\n      process.versions &&\\n      process.versions.node) {\\n    Parse._isNode = true;\\n  }\\n\\n  /**\\n   * Call this method first to set up your authentication tokens for Parse.\\n   * You can get your keys from the Data Browser on parse.com.\\n   * @param {String} applicationId Your Parse Application ID.\\n   * @param {String} javaScriptKey Your Parse JavaScript Key.\\n   * @param {String} masterKey (optional) Your Parse Master Key. (Node.js only!)\\n   */\\n  Parse.initialize = function(applicationId, javaScriptKey, masterKey) {\\n    if (masterKey) {\\n      throw \\\"Parse.initialize() was passed a Master Key, which is only \\\" +\\n        \\\"allowed from within Node.js.\\\";\\n    }\\n    Parse._initialize(applicationId, javaScriptKey);\\n  };\\n\\n  /**\\n   * Call this method first to set up master authentication tokens for Parse.\\n   * This method is for Parse's own private use.\\n   * @param {String} applicationId Your Parse Application ID.\\n   * @param {String} javaScriptKey Your Parse JavaScript Key.\\n   * @param {String} masterKey Your Parse Master Key.\\n   */\\n  Parse._initialize = function(applicationId, javaScriptKey, masterKey) {\\n    Parse.applicationId = applicationId;\\n    Parse.javaScriptKey = javaScriptKey;\\n    Parse.masterKey = masterKey;\\n    Parse._useMasterKey = false;\\n  };\\n\\n  // If we're running in node.js, allow using the master key.\\n  if (Parse._isNode) {\\n    Parse.initialize = Parse._initialize;\\n\\n    Parse.Cloud = Parse.Cloud || {};\\n    /**\\n     * Switches the Parse SDK to using the Master key.  The Master key grants\\n     * priveleged access to the data in Parse and can be used to bypass ACLs and\\n     * other restrictions that are applied to the client SDKs.\\n     * <p><strong><em>Available in Cloud Code and Node.js only.</em></strong>\\n     * </p>\\n     */\\n    Parse.Cloud.useMasterKey = function() {\\n      Parse._useMasterKey = true;\\n    };\\n  }\\n\\n  /**\\n   * Returns prefix for localStorage keys used by this instance of Parse.\\n   * @param {String} path The relative suffix to append to it.\\n   *     null or undefined is treated as the empty string.\\n   * @return {String} The full key name.\\n   */\\n  Parse._getParsePath = function(path) {\\n    if (!Parse.applicationId) {\\n      throw \\\"You need to call Parse.initialize before using Parse.\\\";\\n    }\\n    if (!path) {\\n      path = \\\"\\\";\\n    }\\n    if (!Parse._.isString(path)) {\\n      throw \\\"Tried to get a localStorage path that wasn't a String.\\\";\\n    }\\n    if (path[0] === \\\"/\\\") {\\n      path = path.substring(1);\\n    }\\n    return \\\"Parse/\\\" + Parse.applicationId + \\\"/\\\" + path;\\n  };\\n\\n  /**\\n   * Returns the unique string for this app on this machine.\\n   * Gets reset when localStorage is cleared.\\n   */\\n  Parse._installationId = null;\\n  Parse._getInstallationId = function() {\\n    // See if it's cached in RAM.\\n    if (Parse._installationId) {\\n      return Parse._installationId;\\n    }\\n\\n    // Try to get it from localStorage.\\n    var path = Parse._getParsePath(\\\"installationId\\\");\\n    Parse._installationId = Parse.localStorage.getItem(path);\\n\\n    if (!Parse._installationId || Parse._installationId === \\\"\\\") {\\n      // It wasn't in localStorage, so create a new one.\\n      var hexOctet = function() {\\n        return Math.floor((1+Math.random())*0x10000).toString(16).substring(1);\\n      };\\n      Parse._installationId = (\\n        hexOctet() + hexOctet() + \\\"-\\\" +\\n        hexOctet() + \\\"-\\\" +\\n        hexOctet() + \\\"-\\\" +\\n        hexOctet() + \\\"-\\\" +\\n        hexOctet() + hexOctet() + hexOctet());\\n      Parse.localStorage.setItem(path, Parse._installationId);\\n    }\\n\\n    return Parse._installationId;\\n  };\\n\\n  Parse._parseDate = function(iso8601) {\\n    var regexp = new RegExp(\\n      \\\"^([0-9]{1,4})-([0-9]{1,2})-([0-9]{1,2})\\\" + \\\"T\\\" +\\n      \\\"([0-9]{1,2}):([0-9]{1,2}):([0-9]{1,2})\\\" +\\n      \\\"(.([0-9]+))?\\\" + \\\"Z$\\\");\\n    var match = regexp.exec(iso8601);\\n    if (!match) {\\n      var date = new Date(iso8601);\\n      return date.getTime() === NaN ? null : date;\\n    }\\n\\n    var year = match[1] || 0;\\n    var month = (match[2] || 1) - 1;\\n    var day = match[3] || 0;\\n    var hour = match[4] || 0;\\n    var minute = match[5] || 0;\\n    var second = match[6] || 0;\\n    var milli = match[8] || 0;\\n\\n    return new Date(Date.UTC(year, month, day, hour, minute, second, milli));\\n  };\\n\\n  Parse._ajaxIE8 = function(method, url, data) {\\n    var promise = new Parse.Promise();\\n    var xdr = new XDomainRequest();\\n    xdr.onload = function() {\\n      var response;\\n      try {\\n        response = JSON.parse(xdr.responseText);\\n      } catch (e) {\\n        promise.reject(e);\\n      }\\n      if (response) {\\n        promise.resolve(response);\\n      }\\n    };\\n    xdr.onerror = xdr.ontimeout = function() {\\n      // Let's fake a real error message.\\n      var fakeResponse = {\\n        responseText: JSON.stringify({\\n          code: Parse.Error.X_DOMAIN_REQUEST,\\n          error: \\\"IE's XDomainRequest does not supply error info.\\\"\\n        })\\n      };\\n      promise.reject(fakeResponse);\\n    };\\n    xdr.onprogress = function() {};\\n    xdr.open(method, url);\\n    xdr.send(data);\\n    return promise;\\n  };\\n\\n  Parse._useXDomainRequest = function() {\\n    if (typeof(XDomainRequest) !== \\\"undefined\\\") {\\n      // We're in IE 8+.\\n      if ('withCredentials' in new XMLHttpRequest()) {\\n        // We're in IE 10+.\\n        return false;\\n      }\\n      return true;\\n    }\\n    return false;\\n  };\\n\\n\\n  Parse._ajax = function(method, url, data, success, error) {\\n    var options = {\\n      success: success,\\n      error: error\\n    };\\n\\n    if (Parse._useXDomainRequest()) {\\n      return Parse._ajaxIE8(method, url, data)._thenRunCallbacks(options);\\n    }\\n\\n    var promise = new Parse.Promise();\\n    var handled = false;\\n\\n    var xhr = new Parse.XMLHttpRequest();\\n    xhr.onreadystatechange = function() {\\n      if (xhr.readyState === 4) {\\n        if (handled) {\\n          return;\\n        }\\n        handled = true;\\n\\n        if (xhr.status >= 200 && xhr.status < 300) {\\n          var response;\\n          try {\\n            response = JSON.parse(xhr.responseText);\\n          } catch (e) {\\n            promise.reject(e);\\n          }\\n          if (response) {\\n            promise.resolve(response, xhr.status, xhr);\\n          }\\n        } else {\\n          promise.reject(xhr);\\n        }\\n      }\\n    };\\n    xhr.open(method, url, true);\\n    xhr.setRequestHeader(\\\"Content-Type\\\", \\\"text/plain\\\");  // avoid pre-flight.\\n    if (Parse._isNode) {\\n      // Add a special user agent just for request from node.js.\\n      xhr.setRequestHeader(\\\"User-Agent\\\",\\n                           \\\"Parse/\\\" + Parse.VERSION +\\n                           \\\" (NodeJS \\\" + process.versions.node + \\\")\\\");\\n    }\\n    xhr.send(data);\\n    return promise._thenRunCallbacks(options);\\n  };\\n\\n  // A self-propagating extend function.\\n  Parse._extend = function(protoProps, classProps) {\\n    var child = inherits(this, protoProps, classProps);\\n    child.extend = this.extend;\\n    return child;\\n  };\\n\\n  /**\\n   * Options:\\n   *   route: is classes, users, login, etc.\\n   *   objectId: null if there is no associated objectId.\\n   *   method: the http method for the REST API.\\n   *   dataObject: the payload as an object, or null if there is none.\\n   *   useMasterKey: overrides whether to use the master key if set.\\n   * @ignore\\n   */\\n  Parse._request = function(options) {\\n    var route = options.route;\\n    var className = options.className;\\n    var objectId = options.objectId;\\n    var method = options.method;\\n    var useMasterKey = options.useMasterKey;\\n    var sessionToken = options.sessionToken;\\n    var dataObject = options.data;\\n\\n    if (!Parse.applicationId) {\\n      throw \\\"You must specify your applicationId using Parse.initialize.\\\";\\n    }\\n\\n    if (!Parse.javaScriptKey && !Parse.masterKey) {\\n      throw \\\"You must specify a key using Parse.initialize.\\\";\\n    }\\n\\n\\n    if (!sessionToken) {\\n      // Use the current user session token if none was provided.\\n      var currentUser = Parse.User.current();\\n      if (currentUser && currentUser._sessionToken) {\\n        sessionToken = currentUser._sessionToken;\\n      }\\n    }\\n\\n\\n    if (route !== \\\"batch\\\" &&\\n        route !== \\\"classes\\\" &&\\n        route !== \\\"events\\\" &&\\n        route !== \\\"files\\\" &&\\n        route !== \\\"functions\\\" &&\\n        route !== \\\"login\\\" &&\\n        route !== \\\"push\\\" &&\\n        route !== \\\"requestPasswordReset\\\" &&\\n        route !== \\\"rest_verify_analytics\\\" &&\\n        route !== \\\"users\\\" &&\\n        route !== \\\"jobs\\\") {\\n      throw \\\"Bad route: '\\\" + route + \\\"'.\\\";\\n    }\\n\\n    var url = Parse.serverURL;\\n    if (url.charAt(url.length - 1) !== \\\"/\\\") {\\n      url += \\\"/\\\";\\n    }\\n    url += \\\"1/\\\" + route;\\n    if (className) {\\n      url += \\\"/\\\" + className;\\n    }\\n    if (objectId) {\\n      url += \\\"/\\\" + objectId;\\n    }\\n\\n    dataObject = Parse._.clone(dataObject || {});\\n    if (method !== \\\"POST\\\") {\\n      dataObject._method = method;\\n      method = \\\"POST\\\";\\n    }\\n\\n    if (Parse._.isUndefined(useMasterKey)) {\\n      useMasterKey = Parse._useMasterKey;\\n    }\\n\\n    dataObject._ApplicationId = Parse.applicationId;\\n    if (!useMasterKey) {\\n      dataObject._JavaScriptKey = Parse.javaScriptKey;\\n    } else {\\n      dataObject._MasterKey = Parse.masterKey;\\n    }\\n\\n    dataObject._ClientVersion = Parse.VERSION;\\n    dataObject._InstallationId = Parse._getInstallationId();\\n    if (sessionToken) {\\n      dataObject._SessionToken = sessionToken;\\n    }\\n    var data = JSON.stringify(dataObject);\\n\\n    return Parse._ajax(method, url, data).then(null, function(response) {\\n      // Transform the error into an instance of Parse.Error by trying to parse\\n      // the error string as JSON.\\n      var error;\\n      if (response && response.responseText) {\\n        try {\\n          var errorJSON = JSON.parse(response.responseText);\\n          error = new Parse.Error(errorJSON.code, errorJSON.error);\\n        } catch (e) {\\n          // If we fail to parse the error text, that's okay.\\n          error = new Parse.Error(\\n              Parse.Error.INVALID_JSON,\\n              \\\"Received an error with invalid JSON from Parse: \\\" +\\n                  response.responseText);\\n        }\\n      } else {\\n        error = new Parse.Error(\\n            Parse.Error.CONNECTION_FAILED,\\n            \\\"XMLHttpRequest failed: \\\" + JSON.stringify(response));\\n      }\\n      // By explicitly returning a rejected Promise, this will work with\\n      // either jQuery or Promises/A semantics.\\n      return Parse.Promise.error(error);\\n    });\\n  };\\n\\n  // Helper function to get a value from a Backbone object as a property\\n  // or as a function.\\n  Parse._getValue = function(object, prop) {\\n    if (!(object && object[prop])) {\\n      return null;\\n    }\\n    return Parse._.isFunction(object[prop]) ? object[prop]() : object[prop];\\n  };\\n\\n  /**\\n   * Converts a value in a Parse Object into the appropriate representation.\\n   * This is the JS equivalent of Java's Parse.maybeReferenceAndEncode(Object)\\n   * if seenObjects is falsey. Otherwise any Parse.Objects not in\\n   * seenObjects will be fully embedded rather than encoded\\n   * as a pointer.  This array will be used to prevent going into an infinite\\n   * loop because we have circular references.  If seenObjects\\n   * is set, then none of the Parse Objects that are serialized can be dirty.\\n   */\\n  Parse._encode = function(value, seenObjects, disallowObjects) {\\n    var _ = Parse._;\\n    if (value instanceof Parse.Object) {\\n      if (disallowObjects) {\\n        throw \\\"Parse.Objects not allowed here\\\";\\n      }\\n      if (!seenObjects || _.include(seenObjects, value) || !value._hasData) {\\n        return value._toPointer();\\n      }\\n      if (!value.dirty()) {\\n        seenObjects = seenObjects.concat(value);\\n        return Parse._encode(value._toFullJSON(seenObjects),\\n                             seenObjects,\\n                             disallowObjects);\\n      }\\n      throw \\\"Tried to save an object with a pointer to a new, unsaved object.\\\";\\n    }\\n    if (value instanceof Parse.ACL) {\\n      return value.toJSON();\\n    }\\n    if (_.isDate(value)) {\\n      return { \\\"__type\\\": \\\"Date\\\", \\\"iso\\\": value.toJSON() };\\n    }\\n    if (value instanceof Parse.GeoPoint) {\\n      return value.toJSON();\\n    }\\n    if (_.isArray(value)) {\\n      return _.map(value, function(x) {\\n        return Parse._encode(x, seenObjects, disallowObjects);\\n      });\\n    }\\n    if (_.isRegExp(value)) {\\n      return value.source;\\n    }\\n    if (value instanceof Parse.Relation) {\\n      return value.toJSON();\\n    }\\n    if (value instanceof Parse.Op) {\\n      return value.toJSON();\\n    }\\n    if (value instanceof Parse.File) {\\n      if (!value.url()) {\\n        throw \\\"Tried to save an object containing an unsaved file.\\\";\\n      }\\n      return {\\n        __type: \\\"File\\\",\\n        name: value.name(),\\n        url: value.url()\\n      };\\n    }\\n    if (_.isObject(value)) {\\n      var output = {};\\n      Parse._objectEach(value, function(v, k) {\\n        output[k] = Parse._encode(v, seenObjects, disallowObjects);\\n      });\\n      return output;\\n    }\\n    return value;\\n  };\\n\\n  /**\\n   * The inverse function of Parse._encode.\\n   * TODO: make decode not mutate value.\\n   */\\n  Parse._decode = function(key, value) {\\n    var _ = Parse._;\\n    if (!_.isObject(value)) {\\n      return value;\\n    }\\n    if (_.isArray(value)) {\\n      Parse._arrayEach(value, function(v, k) {\\n        value[k] = Parse._decode(k, v);\\n      });\\n      return value;\\n    }\\n    if (value instanceof Parse.Object) {\\n      return value;\\n    }\\n    if (value instanceof Parse.File) {\\n      return value;\\n    }\\n    if (value instanceof Parse.Op) {\\n      return value;\\n    }\\n    if (value.__op) {\\n      return Parse.Op._decode(value);\\n    }\\n    if (value.__type === \\\"Pointer\\\") {\\n      var pointer = Parse.Object._create(value.className);\\n      pointer._finishFetch({ objectId: value.objectId }, false);\\n      return pointer;\\n    }\\n    if (value.__type === \\\"Object\\\") {\\n      // It's an Object included in a query result.\\n      var className = value.className;\\n      delete value.__type;\\n      delete value.className;\\n      var object = Parse.Object._create(className);\\n      object._finishFetch(value, true);\\n      return object;\\n    }\\n    if (value.__type === \\\"Date\\\") {\\n      return Parse._parseDate(value.iso);\\n    }\\n    if (value.__type === \\\"GeoPoint\\\") {\\n      return new Parse.GeoPoint({\\n        latitude: value.latitude,\\n        longitude: value.longitude\\n      });\\n    }\\n    if (key === \\\"ACL\\\") {\\n      if (value instanceof Parse.ACL) {\\n        return value;\\n      }\\n      return new Parse.ACL(value);\\n    }\\n    if (value.__type === \\\"Relation\\\") {\\n      var relation = new Parse.Relation(null, key);\\n      relation.targetClassName = value.className;\\n      return relation;\\n    }\\n    if (value.__type === \\\"File\\\") {\\n      var file = new Parse.File(value.name);\\n      file._url = value.url;\\n      return file;\\n    }\\n    Parse._objectEach(value, function(v, k) {\\n      value[k] = Parse._decode(k, v);\\n    });\\n    return value;\\n  };\\n\\n  Parse._arrayEach = Parse._.each;\\n\\n  /**\\n   * Does a deep traversal of every item in object, calling func on every one.\\n   * @param {Object} object The object or array to traverse deeply.\\n   * @param {Function} func The function to call for every item. It will\\n   *     be passed the item as an argument. If it returns a truthy value, that\\n   *     value will replace the item in its parent container.\\n   * @returns {} the result of calling func on the top-level object itself.\\n   */\\n  Parse._traverse = function(object, func, seen) {\\n    if (object instanceof Parse.Object) {\\n      seen = seen || [];\\n      if (Parse._.indexOf(seen, object) >= 0) {\\n        // We've already visited this object in this call.\\n        return;\\n      }\\n      seen.push(object);\\n      Parse._traverse(object.attributes, func, seen);\\n      return func(object);\\n    }\\n    if (object instanceof Parse.Relation || object instanceof Parse.File) {\\n      // Nothing needs to be done, but we don't want to recurse into the\\n      // object's parent infinitely, so we catch this case.\\n      return func(object);\\n    }\\n    if (Parse._.isArray(object)) {\\n      Parse._.each(object, function(child, index) {\\n        var newChild = Parse._traverse(child, func, seen);\\n        if (newChild) {\\n          object[index] = newChild;\\n        }\\n      });\\n      return func(object);\\n    }\\n    if (Parse._.isObject(object)) {\\n      Parse._each(object, function(child, key) {\\n        var newChild = Parse._traverse(child, func, seen);\\n        if (newChild) {\\n          object[key] = newChild;\\n        }\\n      });\\n      return func(object);\\n    }\\n    return func(object);\\n  };\\n\\n  /**\\n   * This is like _.each, except:\\n   * * it doesn't work for so-called array-like objects,\\n   * * it does work for dictionaries with a \\\"length\\\" attribute.\\n   */\\n  Parse._objectEach = Parse._each = function(obj, callback) {\\n    var _ = Parse._;\\n    if (_.isObject(obj)) {\\n      _.each(_.keys(obj), function(key) {\\n        callback(obj[key], key);\\n      });\\n    } else {\\n      _.each(obj, callback);\\n    }\\n  };\\n\\n  // Helper function to check null or undefined.\\n  Parse._isNullOrUndefined = function(x) {\\n    return Parse._.isNull(x) || Parse._.isUndefined(x);\\n  };\\n}(this));\\n\\n(function(root) {\\n  root.Parse = root.Parse || {};\\n  var Parse = root.Parse;\\n  var _ = Parse._;\\n\\n  /**\\n   * @namespace Provides an interface to Parse's logging and analytics backend.\\n   */\\n  Parse.Analytics = Parse.Analytics || {};\\n\\n  _.extend(Parse.Analytics, /** @lends Parse.Analytics */ {\\n    /**\\n     * Tracks the occurrence of a custom event with additional dimensions.\\n     * Parse will store a data point at the time of invocation with the given\\n     * event name.\\n     *\\n     * Dimensions will allow segmentation of the occurrences of this custom\\n     * event. Keys and values should be {@code String}s, and will throw\\n     * otherwise.\\n     *\\n     * To track a user signup along with additional metadata, consider the\\n     * following:\\n     * <pre>\\n     * var dimensions = {\\n     *  gender: 'm',\\n     *  source: 'web',\\n     *  dayType: 'weekend'\\n     * };\\n     * Parse.Analytics.track('signup', dimensions);\\n     * </pre>\\n     *\\n     * There is a default limit of 4 dimensions per event tracked.\\n     *\\n     * @param {String} name The name of the custom event to report to Parse as\\n     * having happened.\\n     * @param {Object} dimensions The dictionary of information by which to\\n     * segment this event.\\n     * @return {Parse.Promise} A promise that is resolved when the round-trip\\n     * to the server completes.\\n     */\\n    track: function(name, dimensions) {\\n      name = name || '';\\n      name = name.replace(/^\\\\s*/, '');\\n      name = name.replace(/\\\\s*$/, '');\\n      if (name.length === 0) {\\n        throw 'A name for the custom event must be provided';\\n      }\\n\\n      _.each(dimensions, function(val, key) {\\n        if (!_.isString(key) || !_.isString(val)) {\\n          throw 'track() dimensions expects keys and values of type \\\"string\\\".';\\n        }\\n      });\\n\\n      return Parse._request({\\n        route: 'events',\\n        className: name,\\n        method: 'POST',\\n        data: { dimensions: dimensions }\\n      });\\n    }\\n  });\\n}(this));\\n\\n(function(root) {\\n  root.Parse = root.Parse || {};\\n  var Parse = root.Parse;\\n  var _ = Parse._;\\n\\n  /**\\n   * Constructs a new Parse.Error object with the given code and message.\\n   * @param {Number} code An error code constant from <code>Parse.Error</code>.\\n   * @param {String} message A detailed description of the error.\\n   * @class\\n   *\\n   * <p>Class used for all objects passed to error callbacks.</p>\\n   */\\n  Parse.Error = function(code, message) {\\n    this.code = code;\\n    this.message = message;\\n  };\\n\\n  _.extend(Parse.Error, /** @lends Parse.Error */ {\\n    /**\\n     * Error code indicating some error other than those enumerated here.\\n     * @constant\\n     */\\n    OTHER_CAUSE: -1,\\n\\n    /**\\n     * Error code indicating that something has gone wrong with the server.\\n     * If you get this error code, it is Parse's fault. Contact us at\\n     * https://parse.com/help\\n     * @constant\\n     */\\n    INTERNAL_SERVER_ERROR: 1,\\n\\n    /**\\n     * Error code indicating the connection to the Parse servers failed.\\n     * @constant\\n     */\\n    CONNECTION_FAILED: 100,\\n\\n    /**\\n     * Error code indicating the specified object doesn't exist.\\n     * @constant\\n     */\\n    OBJECT_NOT_FOUND: 101,\\n\\n    /**\\n     * Error code indicating you tried to query with a datatype that doesn't\\n     * support it, like exact matching an array or object.\\n     * @constant\\n     */\\n    INVALID_QUERY: 102,\\n\\n    /**\\n     * Error code indicating a missing or invalid classname. Classnames are\\n     * case-sensitive. They must start with a letter, and a-zA-Z0-9_ are the\\n     * only valid characters.\\n     * @constant\\n     */\\n    INVALID_CLASS_NAME: 103,\\n\\n    /**\\n     * Error code indicating an unspecified object id.\\n     * @constant\\n     */\\n    MISSING_OBJECT_ID: 104,\\n\\n    /**\\n     * Error code indicating an invalid key name. Keys are case-sensitive. They\\n     * must start with a letter, and a-zA-Z0-9_ are the only valid characters.\\n     * @constant\\n     */\\n    INVALID_KEY_NAME: 105,\\n\\n    /**\\n     * Error code indicating a malformed pointer. You should not see this unless\\n     * you have been mucking about changing internal Parse code.\\n     * @constant\\n     */\\n    INVALID_POINTER: 106,\\n\\n    /**\\n     * Error code indicating that badly formed JSON was received upstream. This\\n     * either indicates you have done something unusual with modifying how\\n     * things encode to JSON, or the network is failing badly.\\n     * @constant\\n     */\\n    INVALID_JSON: 107,\\n\\n    /**\\n     * Error code indicating that the feature you tried to access is only\\n     * available internally for testing purposes.\\n     * @constant\\n     */\\n    COMMAND_UNAVAILABLE: 108,\\n\\n    /**\\n     * You must call Parse.initialize before using the Parse library.\\n     * @constant\\n     */\\n    NOT_INITIALIZED: 109,\\n\\n    /**\\n     * Error code indicating that a field was set to an inconsistent type.\\n     * @constant\\n     */\\n    INCORRECT_TYPE: 111,\\n\\n    /**\\n     * Error code indicating an invalid channel name. A channel name is either\\n     * an empty string (the broadcast channel) or contains only a-zA-Z0-9_\\n     * characters and starts with a letter.\\n     * @constant\\n     */\\n    INVALID_CHANNEL_NAME: 112,\\n\\n    /**\\n     * Error code indicating that push is misconfigured.\\n     * @constant\\n     */\\n    PUSH_MISCONFIGURED: 115,\\n\\n    /**\\n     * Error code indicating that the object is too large.\\n     * @constant\\n     */\\n    OBJECT_TOO_LARGE: 116,\\n\\n    /**\\n     * Error code indicating that the operation isn't allowed for clients.\\n     * @constant\\n     */\\n    OPERATION_FORBIDDEN: 119,\\n\\n    /**\\n     * Error code indicating the result was not found in the cache.\\n     * @constant\\n     */\\n    CACHE_MISS: 120,\\n\\n    /**\\n     * Error code indicating that an invalid key was used in a nested\\n     * JSONObject.\\n     * @constant\\n     */\\n    INVALID_NESTED_KEY: 121,\\n\\n    /**\\n     * Error code indicating that an invalid filename was used for ParseFile.\\n     * A valid file name contains only a-zA-Z0-9_. characters and is between 1\\n     * and 128 characters.\\n     * @constant\\n     */\\n    INVALID_FILE_NAME: 122,\\n\\n    /**\\n     * Error code indicating an invalid ACL was provided.\\n     * @constant\\n     */\\n    INVALID_ACL: 123,\\n\\n    /**\\n     * Error code indicating that the request timed out on the server. Typically\\n     * this indicates that the request is too expensive to run.\\n     * @constant\\n     */\\n    TIMEOUT: 124,\\n\\n    /**\\n     * Error code indicating that the email address was invalid.\\n     * @constant\\n     */\\n    INVALID_EMAIL_ADDRESS: 125,\\n\\n    /**\\n     * Error code indicating a missing content type.\\n     * @constant\\n     */\\n    MISSING_CONTENT_TYPE: 126,\\n\\n    /**\\n     * Error code indicating a missing content length.\\n     * @constant\\n     */\\n    MISSING_CONTENT_LENGTH: 127,\\n\\n    /**\\n     * Error code indicating an invalid content length.\\n     * @constant\\n     */\\n    INVALID_CONTENT_LENGTH: 128,\\n\\n    /**\\n     * Error code indicating a file that was too large.\\n     * @constant\\n     */\\n    FILE_TOO_LARGE: 129,\\n\\n    /**\\n     * Error code indicating an error saving a file.\\n     * @constant\\n     */\\n    FILE_SAVE_ERROR: 130,\\n\\n    /**\\n     * Error code indicating an error deleting a file.\\n     * @constant\\n     */\\n    FILE_DELETE_ERROR: 153,\\n\\n    /**\\n     * Error code indicating that a unique field was given a value that is\\n     * already taken.\\n     * @constant\\n     */\\n    DUPLICATE_VALUE: 137,\\n\\n    /**\\n     * Error code indicating that a role's name is invalid.\\n     * @constant\\n     */\\n    INVALID_ROLE_NAME: 139,\\n\\n    /**\\n     * Error code indicating that an application quota was exceeded.  Upgrade to\\n     * resolve.\\n     * @constant\\n     */\\n    EXCEEDED_QUOTA: 140,\\n\\n    /**\\n     * Error code indicating that a Cloud Code script failed.\\n     * @constant\\n     */\\n    SCRIPT_FAILED: 141,\\n\\n    /**\\n     * Error code indicating that a Cloud Code validation failed.\\n     * @constant\\n     */\\n    VALIDATION_ERROR: 142,\\n\\n    /**\\n     * Error code indicating that invalid image data was provided.\\n     * @constant\\n     */\\n    INVALID_IMAGE_DATA: 150,\\n\\n    /**\\n     * Error code indicating an unsaved file.\\n     * @constant\\n     */\\n    UNSAVED_FILE_ERROR: 151,\\n\\n    /**\\n     * Error code indicating an invalid push time.\\n     */\\n    INVALID_PUSH_TIME_ERROR: 152,\\n\\n    /**\\n     * Error code indicating that the username is missing or empty.\\n     * @constant\\n     */\\n    USERNAME_MISSING: 200,\\n\\n    /**\\n     * Error code indicating that the password is missing or empty.\\n     * @constant\\n     */\\n    PASSWORD_MISSING: 201,\\n\\n    /**\\n     * Error code indicating that the username has already been taken.\\n     * @constant\\n     */\\n    USERNAME_TAKEN: 202,\\n\\n    /**\\n     * Error code indicating that the email has already been taken.\\n     * @constant\\n     */\\n    EMAIL_TAKEN: 203,\\n\\n    /**\\n     * Error code indicating that the email is missing, but must be specified.\\n     * @constant\\n     */\\n    EMAIL_MISSING: 204,\\n\\n    /**\\n     * Error code indicating that a user with the specified email was not found.\\n     * @constant\\n     */\\n    EMAIL_NOT_FOUND: 205,\\n\\n    /**\\n     * Error code indicating that a user object without a valid session could\\n     * not be altered.\\n     * @constant\\n     */\\n    SESSION_MISSING: 206,\\n\\n    /**\\n     * Error code indicating that a user can only be created through signup.\\n     * @constant\\n     */\\n    MUST_CREATE_USER_THROUGH_SIGNUP: 207,\\n\\n    /**\\n     * Error code indicating that an an account being linked is already linked\\n     * to another user.\\n     * @constant\\n     */\\n    ACCOUNT_ALREADY_LINKED: 208,\\n\\n    /**\\n     * Error code indicating that a user cannot be linked to an account because\\n     * that account's id could not be found.\\n     * @constant\\n     */\\n    LINKED_ID_MISSING: 250,\\n\\n    /**\\n     * Error code indicating that a user with a linked (e.g. Facebook) account\\n     * has an invalid session.\\n     * @constant\\n     */\\n    INVALID_LINKED_SESSION: 251,\\n\\n    /**\\n     * Error code indicating that a service being linked (e.g. Facebook or\\n     * Twitter) is unsupported.\\n     * @constant\\n     */\\n    UNSUPPORTED_SERVICE: 252,\\n\\n    /**\\n     * Error code indicating that there were multiple errors. Aggregate errors\\n     * have an \\\"errors\\\" property, which is an array of error objects with more\\n     * detail about each error that occurred.\\n     * @constant\\n     */\\n    AGGREGATE_ERROR: 600,\\n\\n    /**\\n     * Error code indicating the client was unable to read an input file.\\n     * @constant\\n     */\\n    FILE_READ_ERROR: 601,\\n\\n    /**\\n     * Error code indicating a real error code is unavailable because\\n     * we had to use an XDomainRequest object to allow CORS requests in\\n     * Internet Explorer, which strips the body from HTTP responses that have\\n     * a non-2XX status code.\\n     * @constant\\n     */\\n    X_DOMAIN_REQUEST: 602\\n  });\\n\\n}(this));\\n\\n/*global _: false */\\n(function() {\\n  var root = this;\\n  var Parse = (root.Parse || (root.Parse = {}));\\n  var eventSplitter = /\\\\s+/;\\n  var slice = Array.prototype.slice;\\n\\n  /**\\n   * @class\\n   *\\n   * <p>Parse.Events is a fork of Backbone's Events module, provided for your\\n   * convenience.</p>\\n   *\\n   * <p>A module that can be mixed in to any object in order to provide\\n   * it with custom events. You may bind callback functions to an event\\n   * with `on`, or remove these functions with `off`.\\n   * Triggering an event fires all callbacks in the order that `on` was\\n   * called.\\n   *\\n   * <pre>\\n   *     var object = {};\\n   *     _.extend(object, Parse.Events);\\n   *     object.on('expand', function(){ alert('expanded'); });\\n   *     object.trigger('expand');</pre></p>\\n   *\\n   * <p>For more information, see the\\n   * <a href=\\\"http://documentcloud.github.com/backbone/#Events\\\">Backbone\\n   * documentation</a>.</p>\\n   */\\n  Parse.Events = {\\n    /**\\n     * Bind one or more space separated events, `events`, to a `callback`\\n     * function. Passing `\\\"all\\\"` will bind the callback to all events fired.\\n     */\\n    on: function(events, callback, context) {\\n\\n      var calls, event, node, tail, list;\\n      if (!callback) {\\n        return this;\\n      }\\n      events = events.split(eventSplitter);\\n      calls = this._callbacks || (this._callbacks = {});\\n\\n      // Create an immutable callback list, allowing traversal during\\n      // modification.  The tail is an empty object that will always be used\\n      // as the next node.\\n      event = events.shift();\\n      while (event) {\\n        list = calls[event];\\n        node = list ? list.tail : {};\\n        node.next = tail = {};\\n        node.context = context;\\n        node.callback = callback;\\n        calls[event] = {tail: tail, next: list ? list.next : node};\\n        event = events.shift();\\n      }\\n\\n      return this;\\n    },\\n\\n    /**\\n     * Remove one or many callbacks. If `context` is null, removes all callbacks\\n     * with that function. If `callback` is null, removes all callbacks for the\\n     * event. If `events` is null, removes all bound callbacks for all events.\\n     */\\n    off: function(events, callback, context) {\\n      var event, calls, node, tail, cb, ctx;\\n\\n      // No events, or removing *all* events.\\n      if (!(calls = this._callbacks)) {\\n        return;\\n      }\\n      if (!(events || callback || context)) {\\n        delete this._callbacks;\\n        return this;\\n      }\\n\\n      // Loop through the listed events and contexts, splicing them out of the\\n      // linked list of callbacks if appropriate.\\n      events = events ? events.split(eventSplitter) : _.keys(calls);\\n      event = events.shift();\\n      while (event) {\\n        node = calls[event];\\n        delete calls[event];\\n        if (!node || !(callback || context)) {\\n          continue;\\n        }\\n        // Create a new list, omitting the indicated callbacks.\\n        tail = node.tail;\\n        node = node.next;\\n        while (node !== tail) {\\n          cb = node.callback;\\n          ctx = node.context;\\n          if ((callback && cb !== callback) || (context && ctx !== context)) {\\n            this.on(event, cb, ctx);\\n          }\\n          node = node.next;\\n        }\\n        event = events.shift();\\n      }\\n\\n      return this;\\n    },\\n\\n    /**\\n     * Trigger one or many events, firing all bound callbacks. Callbacks are\\n     * passed the same arguments as `trigger` is, apart from the event name\\n     * (unless you're listening on `\\\"all\\\"`, which will cause your callback to\\n     * receive the true name of the event as the first argument).\\n     */\\n    trigger: function(events) {\\n      var event, node, calls, tail, args, all, rest;\\n      if (!(calls = this._callbacks)) {\\n        return this;\\n      }\\n      all = calls.all;\\n      events = events.split(eventSplitter);\\n      rest = slice.call(arguments, 1);\\n\\n      // For each event, walk through the linked list of callbacks twice,\\n      // first to trigger the event, then to trigger any `\\\"all\\\"` callbacks.\\n      event = events.shift();\\n      while (event) {\\n        node = calls[event];\\n        if (node) {\\n          tail = node.tail;\\n          while ((node = node.next) !== tail) {\\n            node.callback.apply(node.context || this, rest);\\n          }\\n        }\\n        node = all;\\n        if (node) {\\n          tail = node.tail;\\n          args = [event].concat(rest);\\n          while ((node = node.next) !== tail) {\\n            node.callback.apply(node.context || this, args);\\n          }\\n        }\\n        event = events.shift();\\n      }\\n\\n      return this;\\n    }\\n  };\\n\\n  /**\\n   * @function\\n   */\\n  Parse.Events.bind = Parse.Events.on;\\n\\n  /**\\n   * @function\\n   */\\n  Parse.Events.unbind = Parse.Events.off;\\n}.call(this));\\n\\n\\n/*global navigator: false */\\n(function(root) {\\n  root.Parse = root.Parse || {};\\n  var Parse = root.Parse;\\n  var _ = Parse._;\\n\\n  /**\\n   * Creates a new GeoPoint with any of the following forms:<br>\\n   *   <pre>\\n   *   new GeoPoint(otherGeoPoint)\\n   *   new GeoPoint(30, 30)\\n   *   new GeoPoint([30, 30])\\n   *   new GeoPoint({latitude: 30, longitude: 30})\\n   *   new GeoPoint()  // defaults to (0, 0)\\n   *   </pre>\\n   * @class\\n   *\\n   * <p>Represents a latitude / longitude point that may be associated\\n   * with a key in a ParseObject or used as a reference point for geo queries.\\n   * This allows proximity-based queries on the key.</p>\\n   *\\n   * <p>Only one key in a class may contain a GeoPoint.</p>\\n   *\\n   * <p>Example:<pre>\\n   *   var point = new Parse.GeoPoint(30.0, -20.0);\\n   *   var object = new Parse.Object(\\\"PlaceObject\\\");\\n   *   object.set(\\\"location\\\", point);\\n   *   object.save();</pre></p>\\n   */\\n  Parse.GeoPoint = function(arg1, arg2) {\\n    if (_.isArray(arg1)) {\\n      Parse.GeoPoint._validate(arg1[0], arg1[1]);\\n      this.latitude = arg1[0];\\n      this.longitude = arg1[1];\\n    } else if (_.isObject(arg1)) {\\n      Parse.GeoPoint._validate(arg1.latitude, arg1.longitude);\\n      this.latitude = arg1.latitude;\\n      this.longitude = arg1.longitude;\\n    } else if (_.isNumber(arg1) && _.isNumber(arg2)) {\\n      Parse.GeoPoint._validate(arg1, arg2);\\n      this.latitude = arg1;\\n      this.longitude = arg2;\\n    } else {\\n      this.latitude = 0;\\n      this.longitude = 0;\\n    }\\n\\n    // Add properties so that anyone using Webkit or Mozilla will get an error\\n    // if they try to set values that are out of bounds.\\n    var self = this;\\n    if (this.__defineGetter__ && this.__defineSetter__) {\\n      // Use _latitude and _longitude to actually store the values, and add\\n      // getters and setters for latitude and longitude.\\n      this._latitude = this.latitude;\\n      this._longitude = this.longitude;\\n      this.__defineGetter__(\\\"latitude\\\", function() {\\n        return self._latitude;\\n      });\\n      this.__defineGetter__(\\\"longitude\\\", function() {\\n        return self._longitude;\\n      });\\n      this.__defineSetter__(\\\"latitude\\\", function(val) {\\n        Parse.GeoPoint._validate(val, self.longitude);\\n        self._latitude = val;\\n      });\\n      this.__defineSetter__(\\\"longitude\\\", function(val) {\\n        Parse.GeoPoint._validate(self.latitude, val);\\n        self._longitude = val;\\n      });\\n    }\\n  };\\n\\n  /**\\n   * @lends Parse.GeoPoint.prototype\\n   * @property {float} latitude North-south portion of the coordinate, in range\\n   *   [-90, 90].  Throws an exception if set out of range in a modern browser.\\n   * @property {float} longitude East-west portion of the coordinate, in range\\n   *   [-180, 180].  Throws if set out of range in a modern browser.\\n   */\\n\\n  /**\\n   * Throws an exception if the given lat-long is out of bounds.\\n   */\\n  Parse.GeoPoint._validate = function(latitude, longitude) {\\n    if (latitude < -90.0) {\\n      throw \\\"Parse.GeoPoint latitude \\\" + latitude + \\\" < -90.0.\\\";\\n    }\\n    if (latitude > 90.0) {\\n      throw \\\"Parse.GeoPoint latitude \\\" + latitude + \\\" > 90.0.\\\";\\n    }\\n    if (longitude < -180.0) {\\n      throw \\\"Parse.GeoPoint longitude \\\" + longitude + \\\" < -180.0.\\\";\\n    }\\n    if (longitude > 180.0) {\\n      throw \\\"Parse.GeoPoint longitude \\\" + longitude + \\\" > 180.0.\\\";\\n    }\\n  };\\n\\n  /**\\n   * Creates a GeoPoint with the user's current location, if available.\\n   * Calls options.success with a new GeoPoint instance or calls options.error.\\n   * @param {Object} options An object with success and error callbacks.\\n   */\\n  Parse.GeoPoint.current = function(options) {\\n    var promise = new Parse.Promise();\\n    navigator.geolocation.getCurrentPosition(function(location) {\\n      promise.resolve(new Parse.GeoPoint({\\n        latitude: location.coords.latitude,\\n        longitude: location.coords.longitude\\n      }));\\n\\n    }, function(error) {\\n      promise.reject(error);\\n    });\\n\\n    return promise._thenRunCallbacks(options);\\n  };\\n\\n  Parse.GeoPoint.prototype = {\\n    /**\\n     * Returns a JSON representation of the GeoPoint, suitable for Parse.\\n     * @return {Object}\\n     */\\n    toJSON: function() {\\n      Parse.GeoPoint._validate(this.latitude, this.longitude);\\n      return {\\n        \\\"__type\\\": \\\"GeoPoint\\\",\\n        latitude: this.latitude,\\n        longitude: this.longitude\\n      };\\n    },\\n\\n    /**\\n     * Returns the distance from this GeoPoint to another in radians.\\n     * @param {Parse.GeoPoint} point the other Parse.GeoPoint.\\n     * @return {Number}\\n     */\\n    radiansTo: function(point) {\\n      var d2r = Math.PI / 180.0;\\n      var lat1rad = this.latitude * d2r;\\n      var long1rad = this.longitude * d2r;\\n      var lat2rad = point.latitude * d2r;\\n      var long2rad = point.longitude * d2r;\\n      var deltaLat = lat1rad - lat2rad;\\n      var deltaLong = long1rad - long2rad;\\n      var sinDeltaLatDiv2 = Math.sin(deltaLat / 2);\\n      var sinDeltaLongDiv2 = Math.sin(deltaLong / 2);\\n      // Square of half the straight line chord distance between both points.\\n      var a = ((sinDeltaLatDiv2 * sinDeltaLatDiv2) +\\n               (Math.cos(lat1rad) * Math.cos(lat2rad) *\\n                sinDeltaLongDiv2 * sinDeltaLongDiv2));\\n      a = Math.min(1.0, a);\\n      return 2 * Math.asin(Math.sqrt(a));\\n    },\\n\\n    /**\\n     * Returns the distance from this GeoPoint to another in kilometers.\\n     * @param {Parse.GeoPoint} point the other Parse.GeoPoint.\\n     * @return {Number}\\n     */\\n    kilometersTo: function(point) {\\n      return this.radiansTo(point) * 6371.0;\\n    },\\n\\n    /**\\n     * Returns the distance from this GeoPoint to another in miles.\\n     * @param {Parse.GeoPoint} point the other Parse.GeoPoint.\\n     * @return {Number}\\n     */\\n    milesTo: function(point) {\\n      return this.radiansTo(point) * 3958.8;\\n    }\\n  };\\n}(this));\\n\\n/*global navigator: false */\\n(function(root) {\\n  root.Parse = root.Parse || {};\\n  var Parse = root.Parse;\\n  var _ = Parse._;\\n\\n  var PUBLIC_KEY = \\\"*\\\";\\n\\n  /**\\n   * Creates a new ACL.\\n   * If no argument is given, the ACL has no permissions for anyone.\\n   * If the argument is a Parse.User, the ACL will have read and write\\n   *   permission for only that user.\\n   * If the argument is any other JSON object, that object will be interpretted\\n   *   as a serialized ACL created with toJSON().\\n   * @see Parse.Object#setACL\\n   * @class\\n   *\\n   * <p>An ACL, or Access Control List can be added to any\\n   * <code>Parse.Object</code> to restrict access to only a subset of users\\n   * of your application.</p>\\n   */\\n  Parse.ACL = function(arg1) {\\n    var self = this;\\n    self.permissionsById = {};\\n    if (_.isObject(arg1)) {\\n      if (arg1 instanceof Parse.User) {\\n        self.setReadAccess(arg1, true);\\n        self.setWriteAccess(arg1, true);\\n      } else {\\n        if (_.isFunction(arg1)) {\\n          throw \\\"Parse.ACL() called with a function.  Did you forget ()?\\\";\\n        }\\n        Parse._objectEach(arg1, function(accessList, userId) {\\n          if (!_.isString(userId)) {\\n            throw \\\"Tried to create an ACL with an invalid userId.\\\";\\n          }\\n          self.permissionsById[userId] = {};\\n          Parse._objectEach(accessList, function(allowed, permission) {\\n            if (permission !== \\\"read\\\" && permission !== \\\"write\\\") {\\n              throw \\\"Tried to create an ACL with an invalid permission type.\\\";\\n            }\\n            if (!_.isBoolean(allowed)) {\\n              throw \\\"Tried to create an ACL with an invalid permission value.\\\";\\n            }\\n            self.permissionsById[userId][permission] = allowed;\\n          });\\n        });\\n      }\\n    }\\n  };\\n\\n  /**\\n   * Returns a JSON-encoded version of the ACL.\\n   * @return {Object}\\n   */\\n  Parse.ACL.prototype.toJSON = function() {\\n    return _.clone(this.permissionsById);\\n  };\\n\\n  Parse.ACL.prototype._setAccess = function(accessType, userId, allowed) {\\n    if (userId instanceof Parse.User) {\\n      userId = userId.id;\\n    } else if (userId instanceof Parse.Role) {\\n      userId = \\\"role:\\\" + userId.getName();\\n    }\\n    if (!_.isString(userId)) {\\n      throw \\\"userId must be a string.\\\";\\n    }\\n    if (!_.isBoolean(allowed)) {\\n      throw \\\"allowed must be either true or false.\\\";\\n    }\\n    var permissions = this.permissionsById[userId];\\n    if (!permissions) {\\n      if (!allowed) {\\n        // The user already doesn't have this permission, so no action needed.\\n        return;\\n      } else {\\n        permissions = {};\\n        this.permissionsById[userId] = permissions;\\n      }\\n    }\\n\\n    if (allowed) {\\n      this.permissionsById[userId][accessType] = true;\\n    } else {\\n      delete permissions[accessType];\\n      if (_.isEmpty(permissions)) {\\n        delete permissions[userId];\\n      }\\n    }\\n  };\\n\\n  Parse.ACL.prototype._getAccess = function(accessType, userId) {\\n    if (userId instanceof Parse.User) {\\n      userId = userId.id;\\n    } else if (userId instanceof Parse.Role) {\\n      userId = \\\"role:\\\" + userId.getName();\\n    }\\n    var permissions = this.permissionsById[userId];\\n    if (!permissions) {\\n      return false;\\n    }\\n    return permissions[accessType] ? true : false;\\n  };\\n\\n  /**\\n   * Set whether the given user is allowed to read this object.\\n   * @param userId An instance of Parse.User or its objectId.\\n   * @param {Boolean} allowed Whether that user should have read access.\\n   */\\n  Parse.ACL.prototype.setReadAccess = function(userId, allowed) {\\n    this._setAccess(\\\"read\\\", userId, allowed);\\n  };\\n\\n  /**\\n   * Get whether the given user id is *explicitly* allowed to read this object.\\n   * Even if this returns false, the user may still be able to access it if\\n   * getPublicReadAccess returns true or a role that the user belongs to has\\n   * write access.\\n   * @param userId An instance of Parse.User or its objectId, or a Parse.Role.\\n   * @return {Boolean}\\n   */\\n  Parse.ACL.prototype.getReadAccess = function(userId) {\\n    return this._getAccess(\\\"read\\\", userId);\\n  };\\n\\n  /**\\n   * Set whether the given user id is allowed to write this object.\\n   * @param userId An instance of Parse.User or its objectId, or a Parse.Role..\\n   * @param {Boolean} allowed Whether that user should have write access.\\n   */\\n  Parse.ACL.prototype.setWriteAccess = function(userId, allowed) {\\n    this._setAccess(\\\"write\\\", userId, allowed);\\n  };\\n\\n  /**\\n   * Get whether the given user id is *explicitly* allowed to write this object.\\n   * Even if this returns false, the user may still be able to write it if\\n   * getPublicWriteAccess returns true or a role that the user belongs to has\\n   * write access.\\n   * @param userId An instance of Parse.User or its objectId, or a Parse.Role.\\n   * @return {Boolean}\\n   */\\n  Parse.ACL.prototype.getWriteAccess = function(userId) {\\n    return this._getAccess(\\\"write\\\", userId);\\n  };\\n\\n  /**\\n   * Set whether the public is allowed to read this object.\\n   * @param {Boolean} allowed\\n   */\\n  Parse.ACL.prototype.setPublicReadAccess = function(allowed) {\\n    this.setReadAccess(PUBLIC_KEY, allowed);\\n  };\\n\\n  /**\\n   * Get whether the public is allowed to read this object.\\n   * @return {Boolean}\\n   */\\n  Parse.ACL.prototype.getPublicReadAccess = function() {\\n    return this.getReadAccess(PUBLIC_KEY);\\n  };\\n\\n  /**\\n   * Set whether the public is allowed to write this object.\\n   * @param {Boolean} allowed\\n   */\\n  Parse.ACL.prototype.setPublicWriteAccess = function(allowed) {\\n    this.setWriteAccess(PUBLIC_KEY, allowed);\\n  };\\n\\n  /**\\n   * Get whether the public is allowed to write this object.\\n   * @return {Boolean}\\n   */\\n  Parse.ACL.prototype.getPublicWriteAccess = function() {\\n    return this.getWriteAccess(PUBLIC_KEY);\\n  };\\n\\n  /**\\n   * Get whether users belonging to the given role are allowed\\n   * to read this object. Even if this returns false, the role may\\n   * still be able to write it if a parent role has read access.\\n   *\\n   * @param role The name of the role, or a Parse.Role object.\\n   * @return {Boolean} true if the role has read access. false otherwise.\\n   * @throws {String} If role is neither a Parse.Role nor a String.\\n   */\\n  Parse.ACL.prototype.getRoleReadAccess = function(role) {\\n    if (role instanceof Parse.Role) {\\n      // Normalize to the String name\\n      role = role.getName();\\n    }\\n    if (_.isString(role)) {\\n      return this.getReadAccess(\\\"role:\\\" + role);\\n    }\\n    throw \\\"role must be a Parse.Role or a String\\\";\\n  };\\n\\n  /**\\n   * Get whether users belonging to the given role are allowed\\n   * to write this object. Even if this returns false, the role may\\n   * still be able to write it if a parent role has write access.\\n   *\\n   * @param role The name of the role, or a Parse.Role object.\\n   * @return {Boolean} true if the role has write access. false otherwise.\\n   * @throws {String} If role is neither a Parse.Role nor a String.\\n   */\\n  Parse.ACL.prototype.getRoleWriteAccess = function(role) {\\n    if (role instanceof Parse.Role) {\\n      // Normalize to the String name\\n      role = role.getName();\\n    }\\n    if (_.isString(role)) {\\n      return this.getWriteAccess(\\\"role:\\\" + role);\\n    }\\n    throw \\\"role must be a Parse.Role or a String\\\";\\n  };\\n\\n  /**\\n   * Set whether users belonging to the given role are allowed\\n   * to read this object.\\n   *\\n   * @param role The name of the role, or a Parse.Role object.\\n   * @param {Boolean} allowed Whether the given role can read this object.\\n   * @throws {String} If role is neither a Parse.Role nor a String.\\n   */\\n  Parse.ACL.prototype.setRoleReadAccess = function(role, allowed) {\\n    if (role instanceof Parse.Role) {\\n      // Normalize to the String name\\n      role = role.getName();\\n    }\\n    if (_.isString(role)) {\\n      this.setReadAccess(\\\"role:\\\" + role, allowed);\\n      return;\\n    }\\n    throw \\\"role must be a Parse.Role or a String\\\";\\n  };\\n\\n  /**\\n   * Set whether users belonging to the given role are allowed\\n   * to write this object.\\n   *\\n   * @param role The name of the role, or a Parse.Role object.\\n   * @param {Boolean} allowed Whether the given role can write this object.\\n   * @throws {String} If role is neither a Parse.Role nor a String.\\n   */\\n  Parse.ACL.prototype.setRoleWriteAccess = function(role, allowed) {\\n    if (role instanceof Parse.Role) {\\n      // Normalize to the String name\\n      role = role.getName();\\n    }\\n    if (_.isString(role)) {\\n      this.setWriteAccess(\\\"role:\\\" + role, allowed);\\n      return;\\n    }\\n    throw \\\"role must be a Parse.Role or a String\\\";\\n  };\\n\\n}(this));\\n\\n(function(root) {\\n  root.Parse = root.Parse || {};\\n  var Parse = root.Parse;\\n  var _ = Parse._;\\n\\n  /**\\n   * @class\\n   * A Parse.Op is an atomic operation that can be applied to a field in a\\n   * Parse.Object. For example, calling <code>object.set(\\\"foo\\\", \\\"bar\\\")</code>\\n   * is an example of a Parse.Op.Set. Calling <code>object.unset(\\\"foo\\\")</code>\\n   * is a Parse.Op.Unset. These operations are stored in a Parse.Object and\\n   * sent to the server as part of <code>object.save()</code> operations.\\n   * Instances of Parse.Op should be immutable.\\n   *\\n   * You should not create subclasses of Parse.Op or instantiate Parse.Op\\n   * directly.\\n   */\\n  Parse.Op = function() {\\n    this._initialize.apply(this, arguments);\\n  };\\n\\n  Parse.Op.prototype = {\\n    _initialize: function() {}\\n  };\\n\\n  _.extend(Parse.Op, {\\n    /**\\n     * To create a new Op, call Parse.Op._extend();\\n     */\\n    _extend: Parse._extend,\\n\\n    // A map of __op string to decoder function.\\n    _opDecoderMap: {},\\n\\n    /**\\n     * Registers a function to convert a json object with an __op field into an\\n     * instance of a subclass of Parse.Op.\\n     */\\n    _registerDecoder: function(opName, decoder) {\\n      Parse.Op._opDecoderMap[opName] = decoder;\\n    },\\n\\n    /**\\n     * Converts a json object into an instance of a subclass of Parse.Op.\\n     */\\n    _decode: function(json) {\\n      var decoder = Parse.Op._opDecoderMap[json.__op];\\n      if (decoder) {\\n        return decoder(json);\\n      } else {\\n        return undefined;\\n      }\\n    }\\n  });\\n\\n  /*\\n   * Add a handler for Batch ops.\\n   */\\n  Parse.Op._registerDecoder(\\\"Batch\\\", function(json) {\\n    var op = null;\\n    Parse._arrayEach(json.ops, function(nextOp) {\\n      nextOp = Parse.Op._decode(nextOp);\\n      op = nextOp._mergeWithPrevious(op);\\n    });\\n    return op;\\n  });\\n\\n  /**\\n   * @class\\n   * A Set operation indicates that either the field was changed using\\n   * Parse.Object.set, or it is a mutable container that was detected as being\\n   * changed.\\n   */\\n  Parse.Op.Set = Parse.Op._extend(/** @lends Parse.Op.Set.prototype */ {\\n    _initialize: function(value) {\\n      this._value = value;\\n    },\\n\\n    /**\\n     * Returns the new value of this field after the set.\\n     */\\n    value: function() {\\n      return this._value;\\n    },\\n\\n    /**\\n     * Returns a JSON version of the operation suitable for sending to Parse.\\n     * @return {Object}\\n     */\\n    toJSON: function() {\\n      return Parse._encode(this.value());\\n    },\\n\\n    _mergeWithPrevious: function(previous) {\\n      return this;\\n    },\\n\\n    _estimate: function(oldValue) {\\n      return this.value();\\n    }\\n  });\\n\\n  /**\\n   * A sentinel value that is returned by Parse.Op.Unset._estimate to\\n   * indicate the field should be deleted. Basically, if you find _UNSET as a\\n   * value in your object, you should remove that key.\\n   */\\n  Parse.Op._UNSET = {};\\n\\n  /**\\n   * @class\\n   * An Unset operation indicates that this field has been deleted from the\\n   * object.\\n   */\\n  Parse.Op.Unset = Parse.Op._extend(/** @lends Parse.Op.Unset.prototype */ {\\n    /**\\n     * Returns a JSON version of the operation suitable for sending to Parse.\\n     * @return {Object}\\n     */\\n    toJSON: function() {\\n      return { __op: \\\"Delete\\\" };\\n    },\\n\\n    _mergeWithPrevious: function(previous) {\\n      return this;\\n    },\\n\\n    _estimate: function(oldValue) {\\n      return Parse.Op._UNSET;\\n    }\\n  });\\n\\n  Parse.Op._registerDecoder(\\\"Delete\\\", function(json) {\\n    return new Parse.Op.Unset();\\n  });\\n\\n  /**\\n   * @class\\n   * An Increment is an atomic operation where the numeric value for the field\\n   * will be increased by a given amount.\\n   */\\n  Parse.Op.Increment = Parse.Op._extend(\\n      /** @lends Parse.Op.Increment.prototype */ {\\n\\n    _initialize: function(amount) {\\n      this._amount = amount;\\n    },\\n\\n    /**\\n     * Returns the amount to increment by.\\n     * @return {Number} the amount to increment by.\\n     */\\n    amount: function() {\\n      return this._amount;\\n    },\\n\\n    /**\\n     * Returns a JSON version of the operation suitable for sending to Parse.\\n     * @return {Object}\\n     */\\n    toJSON: function() {\\n      return { __op: \\\"Increment\\\", amount: this._amount };\\n    },\\n\\n    _mergeWithPrevious: function(previous) {\\n      if (!previous) {\\n        return this;\\n      } else if (previous instanceof Parse.Op.Unset) {\\n        return new Parse.Op.Set(this.amount());\\n      } else if (previous instanceof Parse.Op.Set) {\\n        return new Parse.Op.Set(previous.value() + this.amount());\\n      } else if (previous instanceof Parse.Op.Increment) {\\n        return new Parse.Op.Increment(this.amount() + previous.amount());\\n      } else {\\n        throw \\\"Op is invalid after previous op.\\\";\\n      }\\n    },\\n\\n    _estimate: function(oldValue) {\\n      if (!oldValue) {\\n        return this.amount();\\n      }\\n      return oldValue + this.amount();\\n    }\\n  });\\n\\n  Parse.Op._registerDecoder(\\\"Increment\\\", function(json) {\\n    return new Parse.Op.Increment(json.amount);\\n  });\\n\\n  /**\\n   * @class\\n   * Add is an atomic operation where the given objects will be appended to the\\n   * array that is stored in this field.\\n   */\\n  Parse.Op.Add = Parse.Op._extend(/** @lends Parse.Op.Add.prototype */ {\\n    _initialize: function(objects) {\\n      this._objects = objects;\\n    },\\n\\n    /**\\n     * Returns the objects to be added to the array.\\n     * @return {Array} The objects to be added to the array.\\n     */\\n    objects: function() {\\n      return this._objects;\\n    },\\n\\n    /**\\n     * Returns a JSON version of the operation suitable for sending to Parse.\\n     * @return {Object}\\n     */\\n    toJSON: function() {\\n      return { __op: \\\"Add\\\", objects: Parse._encode(this.objects()) };\\n    },\\n\\n    _mergeWithPrevious: function(previous) {\\n      if (!previous) {\\n        return this;\\n      } else if (previous instanceof Parse.Op.Unset) {\\n        return new Parse.Op.Set(this.objects());\\n      } else if (previous instanceof Parse.Op.Set) {\\n        return new Parse.Op.Set(this._estimate(previous.value()));\\n      } else if (previous instanceof Parse.Op.Add) {\\n        return new Parse.Op.Add(previous.objects().concat(this.objects()));\\n      } else {\\n        throw \\\"Op is invalid after previous op.\\\";\\n      }\\n    },\\n\\n    _estimate: function(oldValue) {\\n      if (!oldValue) {\\n        return _.clone(this.objects());\\n      } else {\\n        return oldValue.concat(this.objects());\\n      }\\n    }\\n  });\\n\\n  Parse.Op._registerDecoder(\\\"Add\\\", function(json) {\\n    return new Parse.Op.Add(Parse._decode(undefined, json.objects));\\n  });\\n\\n  /**\\n   * @class\\n   * AddUnique is an atomic operation where the given items will be appended to\\n   * the array that is stored in this field only if they were not already\\n   * present in the array.\\n   */\\n  Parse.Op.AddUnique = Parse.Op._extend(\\n      /** @lends Parse.Op.AddUnique.prototype */ {\\n\\n    _initialize: function(objects) {\\n      this._objects = _.uniq(objects);\\n    },\\n\\n    /**\\n     * Returns the objects to be added to the array.\\n     * @return {Array} The objects to be added to the array.\\n     */\\n    objects: function() {\\n      return this._objects;\\n    },\\n\\n    /**\\n     * Returns a JSON version of the operation suitable for sending to Parse.\\n     * @return {Object}\\n     */\\n    toJSON: function() {\\n      return { __op: \\\"AddUnique\\\", objects: Parse._encode(this.objects()) };\\n    },\\n\\n    _mergeWithPrevious: function(previous) {\\n      if (!previous) {\\n        return this;\\n      } else if (previous instanceof Parse.Op.Unset) {\\n        return new Parse.Op.Set(this.objects());\\n      } else if (previous instanceof Parse.Op.Set) {\\n        return new Parse.Op.Set(this._estimate(previous.value()));\\n      } else if (previous instanceof Parse.Op.AddUnique) {\\n        return new Parse.Op.AddUnique(this._estimate(previous.objects()));\\n      } else {\\n        throw \\\"Op is invalid after previous op.\\\";\\n      }\\n    },\\n\\n    _estimate: function(oldValue) {\\n      if (!oldValue) {\\n        return _.clone(this.objects());\\n      } else {\\n        // We can't just take the _.uniq(_.union(...)) of oldValue and\\n        // this.objects, because the uniqueness may not apply to oldValue\\n        // (especially if the oldValue was set via .set())\\n        var newValue = _.clone(oldValue);\\n        Parse._arrayEach(this.objects(), function(obj) {\\n          if (obj instanceof Parse.Object && obj.id) {\\n            var matchingObj = _.find(newValue, function(anObj) {\\n              return (anObj instanceof Parse.Object) && (anObj.id === obj.id);\\n            });\\n            if (!matchingObj) {\\n              newValue.push(obj);\\n            } else {\\n              var index = _.indexOf(newValue, matchingObj);\\n              newValue[index] = obj;\\n            }\\n          } else if (!_.contains(newValue, obj)) {\\n            newValue.push(obj);\\n          }\\n        });\\n        return newValue;\\n      }\\n    }\\n  });\\n\\n  Parse.Op._registerDecoder(\\\"AddUnique\\\", function(json) {\\n    return new Parse.Op.AddUnique(Parse._decode(undefined, json.objects));\\n  });\\n\\n  /**\\n   * @class\\n   * Remove is an atomic operation where the given objects will be removed from\\n   * the array that is stored in this field.\\n   */\\n  Parse.Op.Remove = Parse.Op._extend(/** @lends Parse.Op.Remove.prototype */ {\\n    _initialize: function(objects) {\\n      this._objects = _.uniq(objects);\\n    },\\n\\n    /**\\n     * Returns the objects to be removed from the array.\\n     * @return {Array} The objects to be removed from the array.\\n     */\\n    objects: function() {\\n      return this._objects;\\n    },\\n\\n    /**\\n     * Returns a JSON version of the operation suitable for sending to Parse.\\n     * @return {Object}\\n     */\\n    toJSON: function() {\\n      return { __op: \\\"Remove\\\", objects: Parse._encode(this.objects()) };\\n    },\\n\\n    _mergeWithPrevious: function(previous) {\\n      if (!previous) {\\n        return this;\\n      } else if (previous instanceof Parse.Op.Unset) {\\n        return previous;\\n      } else if (previous instanceof Parse.Op.Set) {\\n        return new Parse.Op.Set(this._estimate(previous.value()));\\n      } else if (previous instanceof Parse.Op.Remove) {\\n        return new Parse.Op.Remove(_.union(previous.objects(), this.objects()));\\n      } else {\\n        throw \\\"Op is invalid after previous op.\\\";\\n      }\\n    },\\n\\n    _estimate: function(oldValue) {\\n      if (!oldValue) {\\n        return [];\\n      } else {\\n        var newValue = _.difference(oldValue, this.objects());\\n        // If there are saved Parse Objects being removed, also remove them.\\n        Parse._arrayEach(this.objects(), function(obj) {\\n          if (obj instanceof Parse.Object && obj.id) {\\n            newValue = _.reject(newValue, function(other) {\\n              return (other instanceof Parse.Object) && (other.id === obj.id);\\n            });\\n          }\\n        });\\n        return newValue;\\n      }\\n    }\\n  });\\n\\n  Parse.Op._registerDecoder(\\\"Remove\\\", function(json) {\\n    return new Parse.Op.Remove(Parse._decode(undefined, json.objects));\\n  });\\n\\n  /**\\n   * @class\\n   * A Relation operation indicates that the field is an instance of\\n   * Parse.Relation, and objects are being added to, or removed from, that\\n   * relation.\\n   */\\n  Parse.Op.Relation = Parse.Op._extend(\\n      /** @lends Parse.Op.Relation.prototype */ {\\n\\n    _initialize: function(adds, removes) {\\n      this._targetClassName = null;\\n\\n      var self = this;\\n\\n      var pointerToId = function(object) {\\n        if (object instanceof Parse.Object) {\\n          if (!object.id) {\\n            throw \\\"You can't add an unsaved Parse.Object to a relation.\\\";\\n          }\\n          if (!self._targetClassName) {\\n            self._targetClassName = object.className;\\n          }\\n          if (self._targetClassName !== object.className) {\\n            throw \\\"Tried to create a Parse.Relation with 2 different types: \\\" +\\n                  self._targetClassName + \\\" and \\\" + object.className + \\\".\\\";\\n          }\\n          return object.id;\\n        }\\n        return object;\\n      };\\n\\n      this.relationsToAdd = _.uniq(_.map(adds, pointerToId));\\n      this.relationsToRemove = _.uniq(_.map(removes, pointerToId));\\n    },\\n\\n    /**\\n     * Returns an array of unfetched Parse.Object that are being added to the\\n     * relation.\\n     * @return {Array}\\n     */\\n    added: function() {\\n      var self = this;\\n      return _.map(this.relationsToAdd, function(objectId) {\\n        var object = Parse.Object._create(self._targetClassName);\\n        object.id = objectId;\\n        return object;\\n      });\\n    },\\n\\n    /**\\n     * Returns an array of unfetched Parse.Object that are being removed from\\n     * the relation.\\n     * @return {Array}\\n     */\\n    removed: function() {\\n      var self = this;\\n      return _.map(this.relationsToRemove, function(objectId) {\\n        var object = Parse.Object._create(self._targetClassName);\\n        object.id = objectId;\\n        return object;\\n      });\\n    },\\n\\n    /**\\n     * Returns a JSON version of the operation suitable for sending to Parse.\\n     * @return {Object}\\n     */\\n    toJSON: function() {\\n      var adds = null;\\n      var removes = null;\\n      var self = this;\\n      var idToPointer = function(id) {\\n        return { __type: 'Pointer',\\n                 className: self._targetClassName,\\n                 objectId: id };\\n      };\\n      var pointers = null;\\n      if (this.relationsToAdd.length > 0) {\\n        pointers = _.map(this.relationsToAdd, idToPointer);\\n        adds = { \\\"__op\\\": \\\"AddRelation\\\", \\\"objects\\\": pointers };\\n      }\\n\\n      if (this.relationsToRemove.length > 0) {\\n        pointers = _.map(this.relationsToRemove, idToPointer);\\n        removes = { \\\"__op\\\": \\\"RemoveRelation\\\", \\\"objects\\\": pointers };\\n      }\\n\\n      if (adds && removes) {\\n        return { \\\"__op\\\": \\\"Batch\\\", \\\"ops\\\": [adds, removes]};\\n      }\\n\\n      return adds || removes || {};\\n    },\\n\\n    _mergeWithPrevious: function(previous) {\\n      if (!previous) {\\n        return this;\\n      } else if (previous instanceof Parse.Op.Unset) {\\n        throw \\\"You can't modify a relation after deleting it.\\\";\\n      } else if (previous instanceof Parse.Op.Relation) {\\n        if (previous._targetClassName &&\\n            previous._targetClassName !== this._targetClassName) {\\n          throw \\\"Related object must be of class \\\" + previous._targetClassName +\\n              \\\", but \\\" + this._targetClassName + \\\" was passed in.\\\";\\n        }\\n        var newAdd = _.union(_.difference(previous.relationsToAdd,\\n                                          this.relationsToRemove),\\n                             this.relationsToAdd);\\n        var newRemove = _.union(_.difference(previous.relationsToRemove,\\n                                             this.relationsToAdd),\\n                                this.relationsToRemove);\\n\\n        var newRelation = new Parse.Op.Relation(newAdd, newRemove);\\n        newRelation._targetClassName = this._targetClassName;\\n        return newRelation;\\n      } else {\\n        throw \\\"Op is invalid after previous op.\\\";\\n      }\\n    },\\n\\n    _estimate: function(oldValue, object, key) {\\n      if (!oldValue) {\\n        var relation = new Parse.Relation(object, key);\\n        relation.targetClassName = this._targetClassName;\\n      } else if (oldValue instanceof Parse.Relation) {\\n        if (this._targetClassName) {\\n          if (oldValue.targetClassName) {\\n            if (oldValue.targetClassName !== this._targetClassName) {\\n              throw \\\"Related object must be a \\\" + oldValue.targetClassName +\\n                  \\\", but a \\\" + this._targetClassName + \\\" was passed in.\\\";\\n            }\\n          } else {\\n            oldValue.targetClassName = this._targetClassName;\\n          }\\n        }\\n        return oldValue;\\n      } else {\\n        throw \\\"Op is invalid after previous op.\\\";\\n      }\\n    }\\n  });\\n\\n  Parse.Op._registerDecoder(\\\"AddRelation\\\", function(json) {\\n    return new Parse.Op.Relation(Parse._decode(undefined, json.objects), []);\\n  });\\n  Parse.Op._registerDecoder(\\\"RemoveRelation\\\", function(json) {\\n    return new Parse.Op.Relation([], Parse._decode(undefined, json.objects));\\n  });\\n\\n}(this));\\n\\n(function(root) {\\n  root.Parse = root.Parse || {};\\n  var Parse = root.Parse;\\n  var _ = Parse._;\\n\\n  /**\\n   * Creates a new Relation for the given parent object and key. This\\n   * constructor should rarely be used directly, but rather created by\\n   * Parse.Object.relation.\\n   * @param {Parse.Object} parent The parent of this relation.\\n   * @param {String} key The key for this relation on the parent.\\n   * @see Parse.Object#relation\\n   * @class\\n   *\\n   * <p>\\n   * A class that is used to access all of the children of a many-to-many\\n   * relationship.  Each instance of Parse.Relation is associated with a\\n   * particular parent object and key.\\n   * </p>\\n   */\\n  Parse.Relation = function(parent, key) {\\n    this.parent = parent;\\n    this.key = key;\\n    this.targetClassName = null;\\n  };\\n\\n  Parse.Relation.prototype = {\\n    /**\\n     * Makes sure that this relation has the right parent and key.\\n     */\\n    _ensureParentAndKey: function(parent, key) {\\n      this.parent = this.parent || parent;\\n      this.key = this.key || key;\\n      if (this.parent !== parent) {\\n        throw \\\"Internal Error. Relation retrieved from two different Objects.\\\";\\n      }\\n      if (this.key !== key) {\\n        throw \\\"Internal Error. Relation retrieved from two different keys.\\\";\\n      }\\n    },\\n\\n    /**\\n     * Adds a Parse.Object or an array of Parse.Objects to the relation.\\n     * @param {} objects The item or items to add.\\n     */\\n    add: function(objects) {\\n      if (!_.isArray(objects)) {\\n        objects = [objects];\\n      }\\n\\n      var change = new Parse.Op.Relation(objects, []);\\n      this.parent.set(this.key, change);\\n      this.targetClassName = change._targetClassName;\\n    },\\n\\n    /**\\n     * Removes a Parse.Object or an array of Parse.Objects from this relation.\\n     * @param {} objects The item or items to remove.\\n     */\\n    remove: function(objects) {\\n      if (!_.isArray(objects)) {\\n        objects = [objects];\\n      }\\n\\n      var change = new Parse.Op.Relation([], objects);\\n      this.parent.set(this.key, change);\\n      this.targetClassName = change._targetClassName;\\n    },\\n\\n    /**\\n     * Returns a JSON version of the object suitable for saving to disk.\\n     * @return {Object}\\n     */\\n    toJSON: function() {\\n      return { \\\"__type\\\": \\\"Relation\\\", \\\"className\\\": this.targetClassName };\\n    },\\n\\n    /**\\n     * Returns a Parse.Query that is limited to objects in this\\n     * relation.\\n     * @return {Parse.Query}\\n     */\\n    query: function() {\\n      var targetClass;\\n      var query;\\n      if (!this.targetClassName) {\\n        targetClass = Parse.Object._getSubclass(this.parent.className);\\n        query = new Parse.Query(targetClass);\\n        query._extraOptions.redirectClassNameForKey = this.key;\\n      } else {\\n        targetClass = Parse.Object._getSubclass(this.targetClassName);\\n        query = new Parse.Query(targetClass);\\n      }\\n      query._addCondition(\\\"$relatedTo\\\", \\\"object\\\", this.parent._toPointer());\\n      query._addCondition(\\\"$relatedTo\\\", \\\"key\\\", this.key);\\n\\n      return query;\\n    }\\n  };\\n}(this));\\n\\n(function(root) {\\n  root.Parse = root.Parse || {};\\n  var Parse = root.Parse;\\n  var _ = Parse._;\\n\\n  /**\\n   * A Promise is returned by async methods as a hook to provide callbacks to be\\n   * called when the async task is fulfilled.\\n   *\\n   * <p>Typical usage would be like:<pre>\\n   *    query.find().then(function(results) {\\n   *      results[0].set(\\\"foo\\\", \\\"bar\\\");\\n   *      return results[0].saveAsync();\\n   *    }).then(function(result) {\\n   *      console.log(\\\"Updated \\\" + result.id);\\n   *    });\\n   * </pre></p>\\n   *\\n   * @see Parse.Promise.prototype.then\\n   * @class\\n   */\\n  Parse.Promise = function() {\\n    this._resolved = false;\\n    this._rejected = false;\\n    this._resolvedCallbacks = [];\\n    this._rejectedCallbacks = [];\\n  };\\n\\n  _.extend(Parse.Promise, /** @lends Parse.Promise */ {\\n\\n    /**\\n     * Returns true iff the given object fulfils the Promise interface.\\n     * @return {Boolean}\\n     */\\n    is: function(promise) {\\n      return promise && promise.then && _.isFunction(promise.then);\\n    },\\n\\n    /**\\n     * Returns a new promise that is resolved with a given value.\\n     * @return {Parse.Promise} the new promise.\\n     */\\n    as: function() {\\n      var promise = new Parse.Promise();\\n      promise.resolve.apply(promise, arguments);\\n      return promise;\\n    },\\n\\n    /**\\n     * Returns a new promise that is rejected with a given error.\\n     * @return {Parse.Promise} the new promise.\\n     */\\n    error: function() {\\n      var promise = new Parse.Promise();\\n      promise.reject.apply(promise, arguments);\\n      return promise;\\n    },\\n\\n    /**\\n     * Returns a new promise that is fulfilled when all of the input promises\\n     * are resolved. If any promise in the list fails, then the returned promise\\n     * will fail with the last error. If they all succeed, then the returned\\n     * promise will succeed, with the results being the results of all the input\\n     * promises. For example: <pre>\\n     *   var p1 = Parse.Promise.as(1);\\n     *   var p2 = Parse.Promise.as(2);\\n     *   var p3 = Parse.Promise.as(3);\\n     *\\n     *   Parse.Promise.when(p1, p2, p3).then(function(r1, r2, r3) {\\n     *     console.log(r1);  // prints 1\\n     *     console.log(r2);  // prints 2\\n     *     console.log(r3);  // prints 3\\n     *   });</pre>\\n     *\\n     * The input promises can also be specified as an array: <pre>\\n     *   var promises = [p1, p2, p3];\\n     *   Parse.Promise.when(promises).then(function(r1, r2, r3) {\\n     *     console.log(r1);  // prints 1\\n     *     console.log(r2);  // prints 2\\n     *     console.log(r3);  // prints 3\\n     *   });\\n     * </pre>\\n     * @param {Array} promises a list of promises to wait for.\\n     * @return {Parse.Promise} the new promise.\\n     */\\n    when: function(promises) {\\n      // Allow passing in Promises as separate arguments instead of an Array.\\n      var objects;\\n      if (promises && Parse._isNullOrUndefined(promises.length)) {\\n        objects = arguments;\\n      } else {\\n        objects = promises;\\n      }\\n\\n      var total = objects.length;\\n      var hadError = false;\\n      var results = [];\\n      var errors = [];\\n      results.length = objects.length;\\n      errors.length = objects.length;\\n\\n      if (total === 0) {\\n        return Parse.Promise.as.apply(this, results);\\n      }\\n\\n      var promise = new Parse.Promise();\\n\\n      var resolveOne = function() {\\n        total = total - 1;\\n        if (total === 0) {\\n          if (hadError) {\\n            promise.reject(errors);\\n          } else {\\n            promise.resolve.apply(promise, results);\\n          }\\n        }\\n      };\\n\\n      Parse._arrayEach(objects, function(object, i) {\\n        if (Parse.Promise.is(object)) {\\n          object.then(function(result) {\\n            results[i] = result;\\n            resolveOne();\\n          }, function(error) {\\n            errors[i] = error;\\n            hadError = true;\\n            resolveOne();\\n          });\\n        } else {\\n          results[i] = object;\\n          resolveOne();\\n        }\\n      });\\n\\n      return promise;\\n    },\\n\\n    /**\\n     * Runs the given asyncFunction repeatedly, as long as the predicate\\n     * function returns a truthy value. Stops repeating if asyncFunction returns\\n     * a rejected promise.\\n     * @param {Function} predicate should return false when ready to stop.\\n     * @param {Function} asyncFunction should return a Promise.\\n     */\\n    _continueWhile: function(predicate, asyncFunction) {\\n      if (predicate()) {\\n        return asyncFunction().then(function() {\\n          return Parse.Promise._continueWhile(predicate, asyncFunction);\\n        });\\n      }\\n      return Parse.Promise.as();\\n    }\\n  });\\n\\n  _.extend(Parse.Promise.prototype, /** @lends Parse.Promise.prototype */ {\\n\\n    /**\\n     * Marks this promise as fulfilled, firing any callbacks waiting on it.\\n     * @param {Object} result the result to pass to the callbacks.\\n     */\\n    resolve: function(result) {\\n      if (this._resolved || this._rejected) {\\n        throw \\\"A promise was resolved even though it had already been \\\" +\\n          (this._resolved ? \\\"resolved\\\" : \\\"rejected\\\") + \\\".\\\";\\n      }\\n      this._resolved = true;\\n      this._result = arguments;\\n      var results = arguments;\\n      Parse._arrayEach(this._resolvedCallbacks, function(resolvedCallback) {\\n        resolvedCallback.apply(this, results);\\n      });\\n      this._resolvedCallbacks = [];\\n      this._rejectedCallbacks = [];\\n    },\\n\\n    /**\\n     * Marks this promise as fulfilled, firing any callbacks waiting on it.\\n     * @param {Object} error the error to pass to the callbacks.\\n     */\\n    reject: function(error) {\\n      if (this._resolved || this._rejected) {\\n        throw \\\"A promise was rejected even though it had already been \\\" +\\n          (this._resolved ? \\\"resolved\\\" : \\\"rejected\\\") + \\\".\\\";\\n      }\\n      this._rejected = true;\\n      this._error = error;\\n      Parse._arrayEach(this._rejectedCallbacks, function(rejectedCallback) {\\n        rejectedCallback(error);\\n      });\\n      this._resolvedCallbacks = [];\\n      this._rejectedCallbacks = [];\\n    },\\n\\n    /**\\n     * Adds callbacks to be called when this promise is fulfilled. Returns a new\\n     * Promise that will be fulfilled when the callback is complete. It allows\\n     * chaining. If the callback itself returns a Promise, then the one returned\\n     * by \\\"then\\\" will not be fulfilled until that one returned by the callback\\n     * is fulfilled.\\n     * @param {Function} resolvedCallback Function that is called when this\\n     * Promise is resolved. Once the callback is complete, then the Promise\\n     * returned by \\\"then\\\" will also be fulfilled.\\n     * @param {Function} rejectedCallback Function that is called when this\\n     * Promise is rejected with an error. Once the callback is complete, then\\n     * the promise returned by \\\"then\\\" with be resolved successfully. If\\n     * rejectedCallback is null, or it returns a rejected Promise, then the\\n     * Promise returned by \\\"then\\\" will be rejected with that error.\\n     * @return {Parse.Promise} A new Promise that will be fulfilled after this\\n     * Promise is fulfilled and either callback has completed. If the callback\\n     * returned a Promise, then this Promise will not be fulfilled until that\\n     * one is.\\n     */\\n    then: function(resolvedCallback, rejectedCallback) {\\n      var promise = new Parse.Promise();\\n\\n      var wrappedResolvedCallback = function() {\\n        var result = arguments;\\n        if (resolvedCallback) {\\n          result = [resolvedCallback.apply(this, result)];\\n        }\\n        if (result.length === 1 && Parse.Promise.is(result[0])) {\\n          result[0].then(function() {\\n            promise.resolve.apply(promise, arguments);\\n          }, function(error) {\\n            promise.reject(error);\\n          });\\n        } else {\\n          promise.resolve.apply(promise, result);\\n        }\\n      };\\n\\n      var wrappedRejectedCallback = function(error) {\\n        var result = [];\\n        if (rejectedCallback) {\\n          result = [rejectedCallback(error)];\\n          if (result.length === 1 && Parse.Promise.is(result[0])) {\\n            result[0].then(function() {\\n              promise.resolve.apply(promise, arguments);\\n            }, function(error) {\\n              promise.reject(error);\\n            });\\n          } else {\\n            // A Promises/A+ compliant implementation would call:\\n            // promise.resolve.apply(promise, result);\\n            promise.reject(result[0]);\\n          }\\n        } else {\\n          promise.reject(error);\\n        }\\n      };\\n\\n      if (this._resolved) {\\n        wrappedResolvedCallback.apply(this, this._result);\\n      } else if (this._rejected) {\\n        wrappedRejectedCallback(this._error);\\n      } else {\\n        this._resolvedCallbacks.push(wrappedResolvedCallback);\\n        this._rejectedCallbacks.push(wrappedRejectedCallback);\\n      }\\n\\n      return promise;\\n    },\\n\\n    /**\\n     * Add handlers to be called when the promise\\n     * is either resolved or rejected\\n     */\\n    always: function(callback) {\\n      return this.then(callback, callback);\\n    },\\n\\n    /**\\n     * Add handlers to be called when the Promise object is resolved\\n     */\\n    done: function(callback) {\\n      return this.then(callback);\\n    },\\n\\n    /**\\n     * Add handlers to be called when the Promise object is rejected\\n     */\\n    fail: function(callback) {\\n      return this.then(null, callback);\\n    },\\n\\n    /**\\n     * Run the given callbacks after this promise is fulfilled.\\n     * @param optionsOrCallback {} A Backbone-style options callback, or a\\n     * callback function. If this is an options object and contains a \\\"model\\\"\\n     * attributes, that will be passed to error callbacks as the first argument.\\n     * @param model {} If truthy, this will be passed as the first result of\\n     * error callbacks. This is for Backbone-compatability.\\n     * @return {Parse.Promise} A promise that will be resolved after the\\n     * callbacks are run, with the same result as this.\\n     */\\n    _thenRunCallbacks: function(optionsOrCallback, model) {\\n      var options;\\n      if (_.isFunction(optionsOrCallback)) {\\n        var callback = optionsOrCallback;\\n        options = {\\n          success: function(result) {\\n            callback(result, null);\\n          },\\n          error: function(error) {\\n            callback(null, error);\\n          }\\n        };\\n      } else {\\n        options = _.clone(optionsOrCallback);\\n      }\\n      options = options || {};\\n\\n      return this.then(function(result) {\\n        if (options.success) {\\n          options.success.apply(this, arguments);\\n        } else if (model) {\\n          // When there's no callback, a sync event should be triggered.\\n          model.trigger('sync', model, result, options);\\n        }\\n        return Parse.Promise.as.apply(Parse.Promise, arguments);\\n      }, function(error) {\\n        if (options.error) {\\n          if (!_.isUndefined(model)) {\\n            options.error(model, error);\\n          } else {\\n            options.error(error);\\n          }\\n        } else if (model) {\\n          // When there's no error callback, an error event should be triggered.\\n          model.trigger('error', model, error, options);\\n        }\\n        // By explicitly returning a rejected Promise, this will work with\\n        // either jQuery or Promises/A semantics.\\n        return Parse.Promise.error(error);\\n      });\\n    },\\n\\n    /**\\n     * Adds a callback function that should be called regardless of whether\\n     * this promise failed or succeeded. The callback will be given either the\\n     * array of results for its first argument, or the error as its second,\\n     * depending on whether this Promise was rejected or resolved. Returns a\\n     * new Promise, like \\\"then\\\" would.\\n     * @param {Function} continuation the callback.\\n     */\\n    _continueWith: function(continuation) {\\n      return this.then(function() {\\n        return continuation(arguments, null);\\n      }, function(error) {\\n        return continuation(null, error);\\n      });\\n    }\\n\\n  });\\n\\n}(this));\\n\\n/*jshint bitwise:false *//*global FileReader: true, File: true */\\n(function(root) {\\n  root.Parse = root.Parse || {};\\n  var Parse = root.Parse;\\n  var _ = Parse._;\\n\\n  var b64Digit = function(number) {\\n    if (number < 26) {\\n      return String.fromCharCode(65 + number);\\n    }\\n    if (number < 52) {\\n      return String.fromCharCode(97 + (number - 26));\\n    }\\n    if (number < 62) {\\n      return String.fromCharCode(48 + (number - 52));\\n    }\\n    if (number === 62) {\\n      return \\\"+\\\";\\n    }\\n    if (number === 63) {\\n      return \\\"/\\\";\\n    }\\n    throw \\\"Tried to encode large digit \\\" + number + \\\" in base64.\\\";\\n  };\\n\\n  var encodeBase64 = function(array) {\\n    var chunks = [];\\n    chunks.length = Math.ceil(array.length / 3);\\n    _.times(chunks.length, function(i) {\\n      var b1 = array[i * 3];\\n      var b2 = array[i * 3 + 1] || 0;\\n      var b3 = array[i * 3 + 2] || 0;\\n\\n      var has2 = (i * 3 + 1) < array.length;\\n      var has3 = (i * 3 + 2) < array.length;\\n\\n      chunks[i] = [\\n        b64Digit((b1 >> 2) & 0x3F),\\n        b64Digit(((b1 << 4) & 0x30) | ((b2 >> 4) & 0x0F)),\\n        has2 ? b64Digit(((b2 << 2) & 0x3C) | ((b3 >> 6) & 0x03)) : \\\"=\\\",\\n        has3 ? b64Digit(b3 & 0x3F) : \\\"=\\\"\\n      ].join(\\\"\\\");\\n    });\\n    return chunks.join(\\\"\\\");\\n  };\\n\\n\\n  // A list of file extensions to mime types as found here:\\n  // http://stackoverflow.com/questions/58510/using-net-how-can-you-find-the-\\n  //     mime-type-of-a-file-based-on-the-file-signature\\n  var mimeTypes = {\\n    ai: \\\"application/postscript\\\",\\n    aif: \\\"audio/x-aiff\\\",\\n    aifc: \\\"audio/x-aiff\\\",\\n    aiff: \\\"audio/x-aiff\\\",\\n    asc: \\\"text/plain\\\",\\n    atom: \\\"application/atom+xml\\\",\\n    au: \\\"audio/basic\\\",\\n    avi: \\\"video/x-msvideo\\\",\\n    bcpio: \\\"application/x-bcpio\\\",\\n    bin: \\\"application/octet-stream\\\",\\n    bmp: \\\"image/bmp\\\",\\n    cdf: \\\"application/x-netcdf\\\",\\n    cgm: \\\"image/cgm\\\",\\n    \\\"class\\\": \\\"application/octet-stream\\\",\\n    cpio: \\\"application/x-cpio\\\",\\n    cpt: \\\"application/mac-compactpro\\\",\\n    csh: \\\"application/x-csh\\\",\\n    css: \\\"text/css\\\",\\n    dcr: \\\"application/x-director\\\",\\n    dif: \\\"video/x-dv\\\",\\n    dir: \\\"application/x-director\\\",\\n    djv: \\\"image/vnd.djvu\\\",\\n    djvu: \\\"image/vnd.djvu\\\",\\n    dll: \\\"application/octet-stream\\\",\\n    dmg: \\\"application/octet-stream\\\",\\n    dms: \\\"application/octet-stream\\\",\\n    doc: \\\"application/msword\\\",\\n    docx: \\\"application/vnd.openxmlformats-officedocument.wordprocessingml.\\\" +\\n          \\\"document\\\",\\n    dotx: \\\"application/vnd.openxmlformats-officedocument.wordprocessingml.\\\" +\\n          \\\"template\\\",\\n    docm: \\\"application/vnd.ms-word.document.macroEnabled.12\\\",\\n    dotm: \\\"application/vnd.ms-word.template.macroEnabled.12\\\",\\n    dtd: \\\"application/xml-dtd\\\",\\n    dv: \\\"video/x-dv\\\",\\n    dvi: \\\"application/x-dvi\\\",\\n    dxr: \\\"application/x-director\\\",\\n    eps: \\\"application/postscript\\\",\\n    etx: \\\"text/x-setext\\\",\\n    exe: \\\"application/octet-stream\\\",\\n    ez: \\\"application/andrew-inset\\\",\\n    gif: \\\"image/gif\\\",\\n    gram: \\\"application/srgs\\\",\\n    grxml: \\\"application/srgs+xml\\\",\\n    gtar: \\\"application/x-gtar\\\",\\n    hdf: \\\"application/x-hdf\\\",\\n    hqx: \\\"application/mac-binhex40\\\",\\n    htm: \\\"text/html\\\",\\n    html: \\\"text/html\\\",\\n    ice: \\\"x-conference/x-cooltalk\\\",\\n    ico: \\\"image/x-icon\\\",\\n    ics: \\\"text/calendar\\\",\\n    ief: \\\"image/ief\\\",\\n    ifb: \\\"text/calendar\\\",\\n    iges: \\\"model/iges\\\",\\n    igs: \\\"model/iges\\\",\\n    jnlp: \\\"application/x-java-jnlp-file\\\",\\n    jp2: \\\"image/jp2\\\",\\n    jpe: \\\"image/jpeg\\\",\\n    jpeg: \\\"image/jpeg\\\",\\n    jpg: \\\"image/jpeg\\\",\\n    js: \\\"application/x-javascript\\\",\\n    kar: \\\"audio/midi\\\",\\n    latex: \\\"application/x-latex\\\",\\n    lha: \\\"application/octet-stream\\\",\\n    lzh: \\\"application/octet-stream\\\",\\n    m3u: \\\"audio/x-mpegurl\\\",\\n    m4a: \\\"audio/mp4a-latm\\\",\\n    m4b: \\\"audio/mp4a-latm\\\",\\n    m4p: \\\"audio/mp4a-latm\\\",\\n    m4u: \\\"video/vnd.mpegurl\\\",\\n    m4v: \\\"video/x-m4v\\\",\\n    mac: \\\"image/x-macpaint\\\",\\n    man: \\\"application/x-troff-man\\\",\\n    mathml: \\\"application/mathml+xml\\\",\\n    me: \\\"application/x-troff-me\\\",\\n    mesh: \\\"model/mesh\\\",\\n    mid: \\\"audio/midi\\\",\\n    midi: \\\"audio/midi\\\",\\n    mif: \\\"application/vnd.mif\\\",\\n    mov: \\\"video/quicktime\\\",\\n    movie: \\\"video/x-sgi-movie\\\",\\n    mp2: \\\"audio/mpeg\\\",\\n    mp3: \\\"audio/mpeg\\\",\\n    mp4: \\\"video/mp4\\\",\\n    mpe: \\\"video/mpeg\\\",\\n    mpeg: \\\"video/mpeg\\\",\\n    mpg: \\\"video/mpeg\\\",\\n    mpga: \\\"audio/mpeg\\\",\\n    ms: \\\"application/x-troff-ms\\\",\\n    msh: \\\"model/mesh\\\",\\n    mxu: \\\"video/vnd.mpegurl\\\",\\n    nc: \\\"application/x-netcdf\\\",\\n    oda: \\\"application/oda\\\",\\n    ogg: \\\"application/ogg\\\",\\n    pbm: \\\"image/x-portable-bitmap\\\",\\n    pct: \\\"image/pict\\\",\\n    pdb: \\\"chemical/x-pdb\\\",\\n    pdf: \\\"application/pdf\\\",\\n    pgm: \\\"image/x-portable-graymap\\\",\\n    pgn: \\\"application/x-chess-pgn\\\",\\n    pic: \\\"image/pict\\\",\\n    pict: \\\"image/pict\\\",\\n    png: \\\"image/png\\\",\\n    pnm: \\\"image/x-portable-anymap\\\",\\n    pnt: \\\"image/x-macpaint\\\",\\n    pntg: \\\"image/x-macpaint\\\",\\n    ppm: \\\"image/x-portable-pixmap\\\",\\n    ppt: \\\"application/vnd.ms-powerpoint\\\",\\n    pptx: \\\"application/vnd.openxmlformats-officedocument.presentationml.\\\" +\\n          \\\"presentation\\\",\\n    potx: \\\"application/vnd.openxmlformats-officedocument.presentationml.\\\" +\\n          \\\"template\\\",\\n    ppsx: \\\"application/vnd.openxmlformats-officedocument.presentationml.\\\" +\\n          \\\"slideshow\\\",\\n    ppam: \\\"application/vnd.ms-powerpoint.addin.macroEnabled.12\\\",\\n    pptm: \\\"application/vnd.ms-powerpoint.presentation.macroEnabled.12\\\",\\n    potm: \\\"application/vnd.ms-powerpoint.template.macroEnabled.12\\\",\\n    ppsm: \\\"application/vnd.ms-powerpoint.slideshow.macroEnabled.12\\\",\\n    ps: \\\"application/postscript\\\",\\n    qt: \\\"video/quicktime\\\",\\n    qti: \\\"image/x-quicktime\\\",\\n    qtif: \\\"image/x-quicktime\\\",\\n    ra: \\\"audio/x-pn-realaudio\\\",\\n    ram: \\\"audio/x-pn-realaudio\\\",\\n    ras: \\\"image/x-cmu-raster\\\",\\n    rdf: \\\"application/rdf+xml\\\",\\n    rgb: \\\"image/x-rgb\\\",\\n    rm: \\\"application/vnd.rn-realmedia\\\",\\n    roff: \\\"application/x-troff\\\",\\n    rtf: \\\"text/rtf\\\",\\n    rtx: \\\"text/richtext\\\",\\n    sgm: \\\"text/sgml\\\",\\n    sgml: \\\"text/sgml\\\",\\n    sh: \\\"application/x-sh\\\",\\n    shar: \\\"application/x-shar\\\",\\n    silo: \\\"model/mesh\\\",\\n    sit: \\\"application/x-stuffit\\\",\\n    skd: \\\"application/x-koan\\\",\\n    skm: \\\"application/x-koan\\\",\\n    skp: \\\"application/x-koan\\\",\\n    skt: \\\"application/x-koan\\\",\\n    smi: \\\"application/smil\\\",\\n    smil: \\\"application/smil\\\",\\n    snd: \\\"audio/basic\\\",\\n    so: \\\"application/octet-stream\\\",\\n    spl: \\\"application/x-futuresplash\\\",\\n    src: \\\"application/x-wais-source\\\",\\n    sv4cpio: \\\"application/x-sv4cpio\\\",\\n    sv4crc: \\\"application/x-sv4crc\\\",\\n    svg: \\\"image/svg+xml\\\",\\n    swf: \\\"application/x-shockwave-flash\\\",\\n    t: \\\"application/x-troff\\\",\\n    tar: \\\"application/x-tar\\\",\\n    tcl: \\\"application/x-tcl\\\",\\n    tex: \\\"application/x-tex\\\",\\n    texi: \\\"application/x-texinfo\\\",\\n    texinfo: \\\"application/x-texinfo\\\",\\n    tif: \\\"image/tiff\\\",\\n    tiff: \\\"image/tiff\\\",\\n    tr: \\\"application/x-troff\\\",\\n    tsv: \\\"text/tab-separated-values\\\",\\n    txt: \\\"text/plain\\\",\\n    ustar: \\\"application/x-ustar\\\",\\n    vcd: \\\"application/x-cdlink\\\",\\n    vrml: \\\"model/vrml\\\",\\n    vxml: \\\"application/voicexml+xml\\\",\\n    wav: \\\"audio/x-wav\\\",\\n    wbmp: \\\"image/vnd.wap.wbmp\\\",\\n    wbmxl: \\\"application/vnd.wap.wbxml\\\",\\n    wml: \\\"text/vnd.wap.wml\\\",\\n    wmlc: \\\"application/vnd.wap.wmlc\\\",\\n    wmls: \\\"text/vnd.wap.wmlscript\\\",\\n    wmlsc: \\\"application/vnd.wap.wmlscriptc\\\",\\n    wrl: \\\"model/vrml\\\",\\n    xbm: \\\"image/x-xbitmap\\\",\\n    xht: \\\"application/xhtml+xml\\\",\\n    xhtml: \\\"application/xhtml+xml\\\",\\n    xls: \\\"application/vnd.ms-excel\\\",\\n    xml: \\\"application/xml\\\",\\n    xpm: \\\"image/x-xpixmap\\\",\\n    xsl: \\\"application/xml\\\",\\n    xlsx: \\\"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet\\\",\\n    xltx: \\\"application/vnd.openxmlformats-officedocument.spreadsheetml.\\\" +\\n          \\\"template\\\",\\n    xlsm: \\\"application/vnd.ms-excel.sheet.macroEnabled.12\\\",\\n    xltm: \\\"application/vnd.ms-excel.template.macroEnabled.12\\\",\\n    xlam: \\\"application/vnd.ms-excel.addin.macroEnabled.12\\\",\\n    xlsb: \\\"application/vnd.ms-excel.sheet.binary.macroEnabled.12\\\",\\n    xslt: \\\"application/xslt+xml\\\",\\n    xul: \\\"application/vnd.mozilla.xul+xml\\\",\\n    xwd: \\\"image/x-xwindowdump\\\",\\n    xyz: \\\"chemical/x-xyz\\\",\\n    zip: \\\"application/zip\\\"\\n  };\\n\\n  /**\\n   * Reads a File using a FileReader.\\n   * @param file {File} the File to read.\\n   * @param type {String} (optional) the mimetype to override with.\\n   * @return {Parse.Promise} A Promise that will be fulfilled with a\\n   *     base64-encoded string of the data and its mime type.\\n   */\\n  var readAsync = function(file, type) {\\n    var promise = new Parse.Promise();\\n\\n    if (typeof(FileReader) === \\\"undefined\\\") {\\n      return Parse.Promise.error(new Parse.Error(\\n          Parse.Error.FILE_READ_ERROR,\\n          \\\"Attempted to use a FileReader on an unsupported browser.\\\"));\\n    }\\n\\n    var reader = new FileReader();\\n    reader.onloadend = function() {\\n      if (reader.readyState !== 2) {\\n        promise.reject(new Parse.Error(\\n            Parse.Error.FILE_READ_ERROR,\\n            \\\"Error reading file.\\\"));\\n        return;\\n      }\\n\\n      var dataURL = reader.result;\\n      var matches = /^data:([^;]*);base64,(.*)$/.exec(dataURL);\\n      if (!matches) {\\n        promise.reject(new Parse.Error(\\n            Parse.ERROR.FILE_READ_ERROR,\\n            \\\"Unable to interpret data URL: \\\" + dataURL));\\n        return;\\n      }\\n\\n      promise.resolve(matches[2], type || matches[1]);\\n    };\\n    reader.readAsDataURL(file);\\n    return promise;\\n  };\\n\\n  /**\\n   * A Parse.File is a local representation of a file that is saved to the Parse\\n   * cloud.\\n   * @class\\n   * @param name {String} The file's name. This will be prefixed by a unique\\n   *     value once the file has finished saving. The file name must begin with\\n   *     an alphanumeric character, and consist of alphanumeric characters,\\n   *     periods, spaces, underscores, or dashes.\\n   * @param data {Array} The data for the file, as either:\\n   *     1. an Array of byte value Numbers, or\\n   *     2. an Object like { base64: \\\"...\\\" } with a base64-encoded String.\\n   *     3. a File object selected with a file upload control. (3) only works\\n   *        in Firefox 3.6+, Safari 6.0.2+, Chrome 7+, and IE 10+.\\n   *        For example:<pre>\\n   * var fileUploadControl = $(\\\"#profilePhotoFileUpload\\\")[0];\\n   * if (fileUploadControl.files.length > 0) {\\n   *   var file = fileUploadControl.files[0];\\n   *   var name = \\\"photo.jpg\\\";\\n   *   var parseFile = new Parse.File(name, file);\\n   *   parseFile.save().then(function() {\\n   *     // The file has been saved to Parse.\\n   *   }, function(error) {\\n   *     // The file either could not be read, or could not be saved to Parse.\\n   *   });\\n   * }</pre>\\n   * @param type {String} Optional Content-Type header to use for the file. If\\n   *     this is omitted, the content type will be inferred from the name's\\n   *     extension.\\n   */\\n  Parse.File = function(name, data, type) {\\n    this._name = name;\\n\\n    // Guess the content type from the extension if we need to.\\n    var extension = /\\\\.([^.]*)$/.exec(name);\\n    if (extension) {\\n      extension = extension[1].toLowerCase();\\n    }\\n    var guessedType = type || mimeTypes[extension] || \\\"text/plain\\\";\\n\\n    if (_.isArray(data)) {\\n      this._source = Parse.Promise.as(encodeBase64(data), guessedType);\\n    } else if (data && data.base64) {\\n      // if it contains data uri, extract based64 and the type out of it.\\n      /*jslint maxlen: 1000*/\\n      var dataUriRegexp = /^data:([a-zA-Z]*\\\\/[a-zA-Z+.-]*);(charset=[a-zA-Z0-9\\\\-\\\\/\\\\s]*,)?base64,(\\\\S+)/;\\n      /*jslint maxlen: 80*/\\n\\n      var matches = dataUriRegexp.exec(data.base64);\\n      if (matches && matches.length > 0) {\\n        // if data URI with charset, there will have 4 matches.\\n        this._source = Parse.Promise.as(\\n          (matches.length === 4 ? matches[3] : matches[2]), matches[1]\\n        );\\n      } else {\\n        this._source = Parse.Promise.as(data.base64, guessedType);\\n      }\\n    } else if (typeof(File) !== \\\"undefined\\\" && data instanceof File) {\\n      this._source = readAsync(data, type);\\n    } else if (_.isString(data)) {\\n      throw \\\"Creating a Parse.File from a String is not yet supported.\\\";\\n    }\\n  };\\n\\n  Parse.File.prototype = {\\n\\n    /**\\n     * Gets the name of the file. Before save is called, this is the filename\\n     * given by the user. After save is called, that name gets prefixed with a\\n     * unique identifier.\\n     */\\n    name: function() {\\n      return this._name;\\n    },\\n\\n    /**\\n     * Gets the url of the file. It is only available after you save the file or\\n     * after you get the file from a Parse.Object.\\n     * @return {String}\\n     */\\n    url: function() {\\n      return this._url;\\n    },\\n\\n    /**\\n     * Saves the file to the Parse cloud.\\n     * @param {Object} options A Backbone-style options object.\\n     * @return {Parse.Promise} Promise that is resolved when the save finishes.\\n     */\\n    save: function(options) {\\n      options= options || {};\\n\\n      var self = this;\\n      if (!self._previousSave) {\\n        self._previousSave = self._source.then(function(base64, type) {\\n          var data = {\\n            base64: base64,\\n            _ContentType: type\\n          };\\n          return Parse._request({\\n            route: \\\"files\\\",\\n            className: self._name,\\n            method: 'POST',\\n            data: data,\\n            useMasterKey: options.useMasterKey\\n          });\\n\\n        }).then(function(response) {\\n          self._name = response.name;\\n          self._url = response.url;\\n          return self;\\n        });\\n      }\\n      return self._previousSave._thenRunCallbacks(options);\\n    }\\n  };\\n\\n}(this));\\n\\n// Parse.Object is analogous to the Java ParseObject.\\n// It also implements the same interface as a Backbone model.\\n\\n(function(root) {\\n  root.Parse = root.Parse || {};\\n  var Parse = root.Parse;\\n  var _ = Parse._;\\n\\n  /**\\n   * Creates a new model with defined attributes. A client id (cid) is\\n   * automatically generated and assigned for you.\\n   *\\n   * <p>You won't normally call this method directly.  It is recommended that\\n   * you use a subclass of <code>Parse.Object</code> instead, created by calling\\n   * <code>extend</code>.</p>\\n   *\\n   * <p>However, if you don't want to use a subclass, or aren't sure which\\n   * subclass is appropriate, you can use this form:<pre>\\n   *     var object = new Parse.Object(\\\"ClassName\\\");\\n   * </pre>\\n   * That is basically equivalent to:<pre>\\n   *     var MyClass = Parse.Object.extend(\\\"ClassName\\\");\\n   *     var object = new MyClass();\\n   * </pre></p>\\n   *\\n   * @param {Object} attributes The initial set of data to store in the object.\\n   * @param {Object} options A set of Backbone-like options for creating the\\n   *     object.  The only option currently supported is \\\"collection\\\".\\n   * @see Parse.Object.extend\\n   *\\n   * @class\\n   *\\n   * <p>The fundamental unit of Parse data, which implements the Backbone Model\\n   * interface.</p>\\n   */\\n  Parse.Object = function(attributes, options) {\\n    // Allow new Parse.Object(\\\"ClassName\\\") as a shortcut to _create.\\n    if (_.isString(attributes)) {\\n      return Parse.Object._create.apply(this, arguments);\\n    }\\n\\n    attributes = attributes || {};\\n    if (options && options.parse) {\\n      attributes = this.parse(attributes);\\n    }\\n    var defaults = Parse._getValue(this, 'defaults');\\n    if (defaults) {\\n      attributes = _.extend({}, defaults, attributes);\\n    }\\n    if (options && options.collection) {\\n      this.collection = options.collection;\\n    }\\n\\n    this._serverData = {};  // The last known data for this object from cloud.\\n    this._opSetQueue = [{}];  // List of sets of changes to the data.\\n    this.attributes = {};  // The best estimate of this's current data.\\n\\n    this._hashedJSON = {};  // Hash of values of containers at last save.\\n    this._escapedAttributes = {};\\n    this.cid = _.uniqueId('c');\\n    this.changed = {};\\n    this._silent = {};\\n    this._pending = {};\\n    if (!this.set(attributes, {silent: true})) {\\n      throw new Error(\\\"Can't create an invalid Parse.Object\\\");\\n    }\\n    this.changed = {};\\n    this._silent = {};\\n    this._pending = {};\\n    this._hasData = true;\\n    this._previousAttributes = _.clone(this.attributes);\\n    this.initialize.apply(this, arguments);\\n  };\\n\\n  /**\\n   * @lends Parse.Object.prototype\\n   * @property {String} id The objectId of the Parse Object.\\n   */\\n\\n  /**\\n   * Saves the given list of Parse.Object.\\n   * If any error is encountered, stops and calls the error handler.\\n   *\\n   * <pre>\\n   *   Parse.Object.saveAll([object1, object2, ...], {\\n   *     success: function(list) {\\n   *       // All the objects were saved.\\n   *     },\\n   *     error: function(error) {\\n   *       // An error occurred while saving one of the objects.\\n   *     },\\n   *   });\\n   * </pre>\\n   *\\n   * @param {Array} list A list of <code>Parse.Object</code>.\\n   * @param {Object} options A Backbone-style callback object.\\n   * Valid options are:<ul>\\n   *   <li>useMasterKey: In Cloud Code and Node only, causes the Master Key to\\n   *     be used for this request.\\n   * </ul>\\n   */\\n  Parse.Object.saveAll = function(list, options) {\\n    options = options || {};\\n    return Parse.Object._deepSaveAsync(list, {\\n      useMasterKey: options.useMasterKey\\n    })._thenRunCallbacks(options);\\n  };\\n\\n  /**\\n   * Destroy the given list of models on the server if it was already persisted.\\n   * Optimistically removes each model from its collection, if it has one.\\n   * If `wait: true` is passed, waits for the server to respond before removal.\\n   *\\n   * <p>Unlike saveAll, if an error occurs while deleting an individual model,\\n   * this method will continue trying to delete the rest of the models if\\n   * possible, except in the case of a fatal error like a connection error.\\n   *\\n   * <p>In particular, the Parse.Error object returned in the case of error may\\n   * be one of two types:\\n   *\\n   * <ul>\\n   *   <li>A Parse.Error.AGGREGATE_ERROR. This object's \\\"errors\\\" property is an\\n   *       array of other Parse.Error objects. Each error object in this array\\n   *       has an \\\"object\\\" property that references the object that could not be\\n   *       deleted (for instance, because that object could not be found).</li>\\n   *   <li>A non-aggregate Parse.Error. This indicates a serious error that\\n   *       caused the delete operation to be aborted partway through (for\\n   *       instance, a connection failure in the middle of the delete).</li>\\n   * </ul>\\n   *\\n   * <pre>\\n   *   Parse.Object.destroyAll([object1, object2, ...], {\\n   *     success: function() {\\n   *       // All the objects were deleted.\\n   *     },\\n   *     error: function(error) {\\n   *       // An error occurred while deleting one or more of the objects.\\n   *       // If this is an aggregate error, then we can inspect each error\\n   *       // object individually to determine the reason why a particular\\n   *       // object was not deleted.\\n   *       if (error.code == Parse.Error.AGGREGATE_ERROR) {\\n   *         for (var i = 0; i < error.errors.length; i++) {\\n   *           console.log(\\\"Couldn't delete \\\" + error.errors[i].object.id +\\n   *             \\\"due to \\\" + error.errors[i].message);\\n   *         }\\n   *       } else {\\n   *         console.log(\\\"Delete aborted because of \\\" + error.message);\\n   *       }\\n   *     },\\n   *   });\\n   * </pre>\\n   *\\n   * @param {Array} list A list of <code>Parse.Object</code>.\\n   * @param {Object} options A Backbone-style callback object.\\n   * Valid options are:<ul>\\n   *   <li>useMasterKey: In Cloud Code and Node only, causes the Master Key to\\n   *     be used for this request.\\n   * </ul>\\n   */\\n  Parse.Object.destroyAll = function(list, options) {\\n    options = options || {};\\n\\n    var triggerDestroy = function(object) {\\n      object.trigger('destroy', object, object.collection, options);\\n    };\\n\\n    var errors = [];\\n    var destroyBatch = function(batch) {\\n      var promise = Parse.Promise.as();\\n\\n      if (batch.length > 0) {\\n        promise = promise.then(function() {\\n          return Parse._request({\\n            route: \\\"batch\\\",\\n            method: \\\"POST\\\",\\n            useMasterKey: options.useMasterKey,\\n            data: {\\n              requests: _.map(batch, function(object) {\\n                return {\\n                  method: \\\"DELETE\\\",\\n                  path: \\\"/1/classes/\\\" + object.className + \\\"/\\\" + object.id\\n                };\\n              })\\n            }\\n          });\\n        }).then(function(responses, status, xhr) {\\n          Parse._arrayEach(batch, function(object, i) {\\n            if (responses[i].success && options.wait) {\\n              triggerDestroy(object);\\n            } else if (responses[i].error) {\\n              var error = new Parse.Error(responses[i].error.code,\\n                                          responses[i].error.error);\\n              error.object = object;\\n\\n              errors.push(error);\\n            }\\n          });\\n        });\\n      }\\n\\n      return promise;\\n    };\\n\\n    var promise = Parse.Promise.as();\\n    var batch = [];\\n    Parse._arrayEach(list, function(object, i) {\\n      if (!object.id || !options.wait) {\\n        triggerDestroy(object);\\n      }\\n\\n      if (object.id) {\\n        batch.push(object);\\n      }\\n\\n      if (batch.length === 20 || i+1 === list.length) {\\n        var thisBatch = batch;\\n        batch = [];\\n\\n        promise = promise.then(function() {\\n          return destroyBatch(thisBatch);\\n        });\\n      }\\n    });\\n\\n    return promise.then(function() {\\n      if (errors.length === 0) {\\n        return true;\\n      } else {\\n        var error = new Parse.Error(Parse.Error.AGGREGATE_ERROR,\\n                                    \\\"Error deleting an object in destroyAll\\\");\\n        error.errors = errors;\\n\\n        return Parse.Promise.error(error);\\n      }\\n    })._thenRunCallbacks(options);\\n  };\\n\\n  /**\\n   * Fetches the given list of Parse.Object.\\n   * If any error is encountered, stops and calls the error handler.\\n   *\\n   * <pre>\\n   *   Parse.Object.fetchAll([object1, object2, ...], {\\n   *     success: function(list) {\\n   *       // All the objects were fetched.\\n   *     },\\n   *     error: function(error) {\\n   *       // An error occurred while fetching one of the objects.\\n   *     },\\n   *   });\\n   * </pre>\\n   *\\n   * @param {Array} list A list of <code>Parse.Object</code>.\\n   * @param {Object} options A Backbone-style callback object.\\n   * Valid options are:<ul>\\n   *   <li>success: A Backbone-style success callback.\\n   *   <li>error: An Backbone-style error callback.\\n   * </ul>\\n   */\\n  Parse.Object.fetchAll = function(list, options) {\\n    return Parse.Object._fetchAll(\\n      list,\\n      true\\n    )._thenRunCallbacks(options);\\n  };\\n\\n  /**\\n   * Fetches the given list of Parse.Object if needed.\\n   * If any error is encountered, stops and calls the error handler.\\n   *\\n   * <pre>\\n   *   Parse.Object.fetchAllIfNeeded([object1, ...], {\\n   *     success: function(list) {\\n   *       // Objects were fetched and updated.\\n   *     },\\n   *     error: function(error) {\\n   *       // An error occurred while fetching one of the objects.\\n   *     },\\n   *   });\\n   * </pre>\\n   *\\n   * @param {Array} list A list of <code>Parse.Object</code>.\\n   * @param {Object} options A Backbone-style callback object.\\n   * Valid options are:<ul>\\n   *   <li>success: A Backbone-style success callback.\\n   *   <li>error: An Backbone-style error callback.\\n   * </ul>\\n   */\\n  Parse.Object.fetchAllIfNeeded = function(list, options) {\\n    return Parse.Object._fetchAll(\\n      list,\\n      false\\n    )._thenRunCallbacks(options);\\n  };\\n\\n  // Attach all inheritable methods to the Parse.Object prototype.\\n  _.extend(Parse.Object.prototype, Parse.Events,\\n           /** @lends Parse.Object.prototype */ {\\n    _existed: false,\\n\\n    /**\\n     * Initialize is an empty function by default. Override it with your own\\n     * initialization logic.\\n     */\\n    initialize: function(){},\\n\\n    /**\\n     * Returns a JSON version of the object suitable for saving to Parse.\\n     * @return {Object}\\n     */\\n    toJSON: function() {\\n      var json = this._toFullJSON();\\n      Parse._arrayEach([\\\"__type\\\", \\\"className\\\"],\\n                       function(key) { delete json[key]; });\\n      return json;\\n    },\\n\\n    _toFullJSON: function(seenObjects) {\\n      var json = _.clone(this.attributes);\\n      Parse._objectEach(json, function(val, key) {\\n        json[key] = Parse._encode(val, seenObjects);\\n      });\\n      Parse._objectEach(this._operations, function(val, key) {\\n        json[key] = val;\\n      });\\n\\n      if (_.has(this, \\\"id\\\")) {\\n        json.objectId = this.id;\\n      }\\n      if (_.has(this, \\\"createdAt\\\")) {\\n        if (_.isDate(this.createdAt)) {\\n          json.createdAt = this.createdAt.toJSON();\\n        } else {\\n          json.createdAt = this.createdAt;\\n        }\\n      }\\n\\n      if (_.has(this, \\\"updatedAt\\\")) {\\n        if (_.isDate(this.updatedAt)) {\\n          json.updatedAt = this.updatedAt.toJSON();\\n        } else {\\n          json.updatedAt = this.updatedAt;\\n        }\\n      }\\n      json.__type = \\\"Object\\\";\\n      json.className = this.className;\\n      return json;\\n    },\\n\\n    /**\\n     * Updates _hashedJSON to reflect the current state of this object.\\n     * Adds any changed hash values to the set of pending changes.\\n     */\\n    _refreshCache: function() {\\n      var self = this;\\n      if (self._refreshingCache) {\\n        return;\\n      }\\n      self._refreshingCache = true;\\n      Parse._objectEach(this.attributes, function(value, key) {\\n        if (value instanceof Parse.Object) {\\n          value._refreshCache();\\n        } else if (_.isObject(value)) {\\n          if (self._resetCacheForKey(key)) {\\n            self.set(key, new Parse.Op.Set(value), { silent: true });\\n          }\\n        }\\n      });\\n      delete self._refreshingCache;\\n    },\\n\\n    /**\\n     * Returns true if this object has been modified since its last\\n     * save/refresh.  If an attribute is specified, it returns true only if that\\n     * particular attribute has been modified since the last save/refresh.\\n     * @param {String} attr An attribute name (optional).\\n     * @return {Boolean}\\n     */\\n    dirty: function(attr) {\\n      this._refreshCache();\\n\\n      var currentChanges = _.last(this._opSetQueue);\\n\\n      if (attr) {\\n        return (currentChanges[attr] ? true : false);\\n      }\\n      if (!this.id) {\\n        return true;\\n      }\\n      if (_.keys(currentChanges).length > 0) {\\n        return true;\\n      }\\n      return false;\\n    },\\n\\n    /**\\n     * Returns an array of keys that have been modified since last save/refresh\\n     * @return {Array of string}\\n     */\\n    dirtyKeys: function() {\\n      return _.keys(_.last(this._opSetQueue));\\n    },\\n\\n    /**\\n     * Gets a Pointer referencing this Object.\\n     */\\n    _toPointer: function() {\\n      if (!this.id) {\\n        throw new Error(\\\"Can't serialize an unsaved Parse.Object\\\");\\n      }\\n      return { __type: \\\"Pointer\\\",\\n               className: this.className,\\n               objectId: this.id };\\n    },\\n\\n    /**\\n     * Gets the value of an attribute.\\n     * @param {String} attr The string name of an attribute.\\n     */\\n    get: function(attr) {\\n      return this.attributes[attr];\\n    },\\n\\n    /**\\n     * Gets a relation on the given class for the attribute.\\n     * @param String attr The attribute to get the relation for.\\n     */\\n    relation: function(attr) {\\n      var value = this.get(attr);\\n      if (value) {\\n        if (!(value instanceof Parse.Relation)) {\\n          throw \\\"Called relation() on non-relation field \\\" + attr;\\n        }\\n        value._ensureParentAndKey(this, attr);\\n        return value;\\n      } else {\\n        return new Parse.Relation(this, attr);\\n      }\\n    },\\n\\n    /**\\n     * Gets the HTML-escaped value of an attribute.\\n     */\\n    escape: function(attr) {\\n      var html = this._escapedAttributes[attr];\\n      if (html) {\\n        return html;\\n      }\\n      var val = this.attributes[attr];\\n      var escaped;\\n      if (Parse._isNullOrUndefined(val)) {\\n        escaped = '';\\n      } else {\\n        escaped = _.escape(val.toString());\\n      }\\n      this._escapedAttributes[attr] = escaped;\\n      return escaped;\\n    },\\n\\n    /**\\n     * Returns <code>true</code> if the attribute contains a value that is not\\n     * null or undefined.\\n     * @param {String} attr The string name of the attribute.\\n     * @return {Boolean}\\n     */\\n    has: function(attr) {\\n      return !Parse._isNullOrUndefined(this.attributes[attr]);\\n    },\\n\\n    /**\\n     * Pulls \\\"special\\\" fields like objectId, createdAt, etc. out of attrs\\n     * and puts them on \\\"this\\\" directly.  Removes them from attrs.\\n     * @param attrs - A dictionary with the data for this Parse.Object.\\n     */\\n    _mergeMagicFields: function(attrs) {\\n      // Check for changes of magic fields.\\n      var model = this;\\n      var specialFields = [\\\"id\\\", \\\"objectId\\\", \\\"createdAt\\\", \\\"updatedAt\\\"];\\n      Parse._arrayEach(specialFields, function(attr) {\\n        if (attrs[attr]) {\\n          if (attr === \\\"objectId\\\") {\\n            model.id = attrs[attr];\\n          } else if ((attr === \\\"createdAt\\\" || attr === \\\"updatedAt\\\") &&\\n                     !_.isDate(attrs[attr])) {\\n            model[attr] = Parse._parseDate(attrs[attr]);\\n          } else {\\n            model[attr] = attrs[attr];\\n          }\\n          delete attrs[attr];\\n        }\\n      });\\n    },\\n\\n    /**\\n     * Copies the given serverData to \\\"this\\\", refreshes attributes, and\\n     * clears pending changes;\\n     */\\n    _copyServerData: function(serverData) {\\n      // Copy server data\\n      var tempServerData = {};\\n      Parse._objectEach(serverData, function(value, key) {\\n        tempServerData[key] = Parse._decode(key, value);\\n      });\\n      this._serverData = tempServerData;\\n\\n      // Refresh the attributes.\\n      this._rebuildAllEstimatedData();\\n\\n\\n      // Clear out any changes the user might have made previously.\\n      this._refreshCache();\\n      this._opSetQueue = [{}];\\n\\n      // Refresh the attributes again.\\n      this._rebuildAllEstimatedData();\\n    },\\n\\n    /**\\n     * Merges another object's attributes into this object.\\n     */\\n    _mergeFromObject: function(other) {\\n      if (!other) {\\n        return;\\n      }\\n\\n      // This does the inverse of _mergeMagicFields.\\n      this.id = other.id;\\n      this.createdAt = other.createdAt;\\n      this.updatedAt = other.updatedAt;\\n\\n      this._copyServerData(other._serverData);\\n\\n      this._hasData = true;\\n    },\\n\\n    /**\\n     * Returns the json to be sent to the server.\\n     */\\n    _startSave: function() {\\n      this._opSetQueue.push({});\\n    },\\n\\n    /**\\n     * Called when a save fails because of an error. Any changes that were part\\n     * of the save need to be merged with changes made after the save. This\\n     * might throw an exception is you do conflicting operations. For example,\\n     * if you do:\\n     *   object.set(\\\"foo\\\", \\\"bar\\\");\\n     *   object.set(\\\"invalid field name\\\", \\\"baz\\\");\\n     *   object.save();\\n     *   object.increment(\\\"foo\\\");\\n     * then this will throw when the save fails and the client tries to merge\\n     * \\\"bar\\\" with the +1.\\n     */\\n    _cancelSave: function() {\\n      var self = this;\\n      var failedChanges = _.first(this._opSetQueue);\\n      this._opSetQueue = _.rest(this._opSetQueue);\\n      var nextChanges = _.first(this._opSetQueue);\\n      Parse._objectEach(failedChanges, function(op, key) {\\n        var op1 = failedChanges[key];\\n        var op2 = nextChanges[key];\\n        if (op1 && op2) {\\n          nextChanges[key] = op2._mergeWithPrevious(op1);\\n        } else if (op1) {\\n          nextChanges[key] = op1;\\n        }\\n      });\\n      this._saving = this._saving - 1;\\n    },\\n\\n    /**\\n     * Called when a save completes successfully. This merges the changes that\\n     * were saved into the known server data, and overrides it with any data\\n     * sent directly from the server.\\n     */\\n    _finishSave: function(serverData) {\\n      // Grab a copy of any object referenced by this object. These instances\\n      // may have already been fetched, and we don't want to lose their data.\\n      // Note that doing it like this means we will unify separate copies of the\\n      // same object, but that's a risk we have to take.\\n      var fetchedObjects = {};\\n      Parse._traverse(this.attributes, function(object) {\\n        if (object instanceof Parse.Object && object.id && object._hasData) {\\n          fetchedObjects[object.id] = object;\\n        }\\n      });\\n\\n      var savedChanges = _.first(this._opSetQueue);\\n      this._opSetQueue = _.rest(this._opSetQueue);\\n      this._applyOpSet(savedChanges, this._serverData);\\n      this._mergeMagicFields(serverData);\\n      var self = this;\\n      Parse._objectEach(serverData, function(value, key) {\\n        self._serverData[key] = Parse._decode(key, value);\\n\\n        // Look for any objects that might have become unfetched and fix them\\n        // by replacing their values with the previously observed values.\\n        var fetched = Parse._traverse(self._serverData[key], function(object) {\\n          if (object instanceof Parse.Object && fetchedObjects[object.id]) {\\n            return fetchedObjects[object.id];\\n          }\\n        });\\n        if (fetched) {\\n          self._serverData[key] = fetched;\\n        }\\n      });\\n      this._rebuildAllEstimatedData();\\n      this._saving = this._saving - 1;\\n    },\\n\\n    /**\\n     * Called when a fetch or login is complete to set the known server data to\\n     * the given object.\\n     */\\n    _finishFetch: function(serverData, hasData) {\\n\\n      this._opSetQueue = [{}];\\n\\n      // Bring in all the new server data.\\n      this._mergeMagicFields(serverData);\\n      this._copyServerData(serverData);\\n\\n      this._hasData = hasData;\\n    },\\n\\n    /**\\n     * Applies the set of Parse.Op in opSet to the object target.\\n     */\\n    _applyOpSet: function(opSet, target) {\\n      var self = this;\\n      Parse._objectEach(opSet, function(change, key) {\\n        target[key] = change._estimate(target[key], self, key);\\n        if (target[key] === Parse.Op._UNSET) {\\n          delete target[key];\\n        }\\n      });\\n    },\\n\\n    /**\\n     * Replaces the cached value for key with the current value.\\n     * Returns true if the new value is different than the old value.\\n     */\\n    _resetCacheForKey: function(key) {\\n      var value = this.attributes[key];\\n      if (_.isObject(value) &&\\n          !(value instanceof Parse.Object) &&\\n          !(value instanceof Parse.File)) {\\n        value = value.toJSON ? value.toJSON() : value;\\n        var json = JSON.stringify(value);\\n        if (this._hashedJSON[key] !== json) {\\n          this._hashedJSON[key] = json;\\n          return true;\\n        }\\n      }\\n      return false;\\n    },\\n\\n    /**\\n     * Populates attributes[key] by starting with the last known data from the\\n     * server, and applying all of the local changes that have been made to that\\n     * key since then.\\n     */\\n    _rebuildEstimatedDataForKey: function(key) {\\n      var self = this;\\n      delete this.attributes[key];\\n      if (this._serverData[key]) {\\n        this.attributes[key] = this._serverData[key];\\n      }\\n      Parse._arrayEach(this._opSetQueue, function(opSet) {\\n        var op = opSet[key];\\n        if (op) {\\n          self.attributes[key] = op._estimate(self.attributes[key], self, key);\\n          if (self.attributes[key] === Parse.Op._UNSET) {\\n            delete self.attributes[key];\\n          } else {\\n            self._resetCacheForKey(key);\\n          }\\n        }\\n      });\\n    },\\n\\n    /**\\n     * Populates attributes by starting with the last known data from the\\n     * server, and applying all of the local changes that have been made since\\n     * then.\\n     */\\n    _rebuildAllEstimatedData: function() {\\n      var self = this;\\n\\n      var previousAttributes = _.clone(this.attributes);\\n\\n      this.attributes = _.clone(this._serverData);\\n      Parse._arrayEach(this._opSetQueue, function(opSet) {\\n        self._applyOpSet(opSet, self.attributes);\\n        Parse._objectEach(opSet, function(op, key) {\\n          self._resetCacheForKey(key);\\n        });\\n      });\\n\\n      // Trigger change events for anything that changed because of the fetch.\\n      Parse._objectEach(previousAttributes, function(oldValue, key) {\\n        if (self.attributes[key] !== oldValue) {\\n          self.trigger('change:' + key, self, self.attributes[key], {});\\n        }\\n      });\\n      Parse._objectEach(this.attributes, function(newValue, key) {\\n        if (!_.has(previousAttributes, key)) {\\n          self.trigger('change:' + key, self, newValue, {});\\n        }\\n      });\\n    },\\n\\n    /**\\n     * Sets a hash of model attributes on the object, firing\\n     * <code>\\\"change\\\"</code> unless you choose to silence it.\\n     *\\n     * <p>You can call it with an object containing keys and values, or with one\\n     * key and value.  For example:<pre>\\n     *   gameTurn.set({\\n     *     player: player1,\\n     *     diceRoll: 2\\n     *   }, {\\n     *     error: function(gameTurnAgain, error) {\\n     *       // The set failed validation.\\n     *     }\\n     *   });\\n     *\\n     *   game.set(\\\"currentPlayer\\\", player2, {\\n     *     error: function(gameTurnAgain, error) {\\n     *       // The set failed validation.\\n     *     }\\n     *   });\\n     *\\n     *   game.set(\\\"finished\\\", true);</pre></p>\\n     *\\n     * @param {String} key The key to set.\\n     * @param {} value The value to give it.\\n     * @param {Object} options A set of Backbone-like options for the set.\\n     *     The only supported options are <code>silent</code>,\\n     *     <code>error</code>, and <code>promise</code>.\\n     * @return {Boolean} true if the set succeeded.\\n     * @see Parse.Object#validate\\n     * @see Parse.Error\\n     */\\n    set: function(key, value, options) {\\n      var attrs, attr;\\n      if (_.isObject(key) || Parse._isNullOrUndefined(key)) {\\n        attrs = key;\\n        Parse._objectEach(attrs, function(v, k) {\\n          attrs[k] = Parse._decode(k, v);\\n        });\\n        options = value;\\n      } else {\\n        attrs = {};\\n        attrs[key] = Parse._decode(key, value);\\n      }\\n\\n      // Extract attributes and options.\\n      options = options || {};\\n      if (!attrs) {\\n        return this;\\n      }\\n      if (attrs instanceof Parse.Object) {\\n        attrs = attrs.attributes;\\n      }\\n\\n      // If the unset option is used, every attribute should be a Unset.\\n      if (options.unset) {\\n        Parse._objectEach(attrs, function(unused_value, key) {\\n          attrs[key] = new Parse.Op.Unset();\\n        });\\n      }\\n\\n      // Apply all the attributes to get the estimated values.\\n      var dataToValidate = _.clone(attrs);\\n      var self = this;\\n      Parse._objectEach(dataToValidate, function(value, key) {\\n        if (value instanceof Parse.Op) {\\n          dataToValidate[key] = value._estimate(self.attributes[key],\\n                                                self, key);\\n          if (dataToValidate[key] === Parse.Op._UNSET) {\\n            delete dataToValidate[key];\\n          }\\n        }\\n      });\\n\\n      // Run validation.\\n      if (!this._validate(attrs, options)) {\\n        return false;\\n      }\\n\\n      this._mergeMagicFields(attrs);\\n\\n      options.changes = {};\\n      var escaped = this._escapedAttributes;\\n      var prev = this._previousAttributes || {};\\n\\n      // Update attributes.\\n      Parse._arrayEach(_.keys(attrs), function(attr) {\\n        var val = attrs[attr];\\n\\n        // If this is a relation object we need to set the parent correctly,\\n        // since the location where it was parsed does not have access to\\n        // this object.\\n        if (val instanceof Parse.Relation) {\\n          val.parent = self;\\n        }\\n\\n        if (!(val instanceof Parse.Op)) {\\n          val = new Parse.Op.Set(val);\\n        }\\n\\n        // See if this change will actually have any effect.\\n        var isRealChange = true;\\n        if (val instanceof Parse.Op.Set &&\\n            _.isEqual(self.attributes[attr], val.value)) {\\n          isRealChange = false;\\n        }\\n\\n        if (isRealChange) {\\n          delete escaped[attr];\\n          if (options.silent) {\\n            self._silent[attr] = true;\\n          } else {\\n            options.changes[attr] = true;\\n          }\\n        }\\n\\n        var currentChanges = _.last(self._opSetQueue);\\n        currentChanges[attr] = val._mergeWithPrevious(currentChanges[attr]);\\n        self._rebuildEstimatedDataForKey(attr);\\n\\n        if (isRealChange) {\\n          self.changed[attr] = self.attributes[attr];\\n          if (!options.silent) {\\n            self._pending[attr] = true;\\n          }\\n        } else {\\n          delete self.changed[attr];\\n          delete self._pending[attr];\\n        }\\n      });\\n\\n      if (!options.silent) {\\n        this.change(options);\\n      }\\n      return this;\\n    },\\n\\n    /**\\n     * Remove an attribute from the model, firing <code>\\\"change\\\"</code> unless\\n     * you choose to silence it. This is a noop if the attribute doesn't\\n     * exist.\\n     */\\n    unset: function(attr, options) {\\n      options = options || {};\\n      options.unset = true;\\n      return this.set(attr, null, options);\\n    },\\n\\n    /**\\n     * Atomically increments the value of the given attribute the next time the\\n     * object is saved. If no amount is specified, 1 is used by default.\\n     *\\n     * @param attr {String} The key.\\n     * @param amount {Number} The amount to increment by.\\n     */\\n    increment: function(attr, amount) {\\n      if (_.isUndefined(amount) || _.isNull(amount)) {\\n        amount = 1;\\n      }\\n      return this.set(attr, new Parse.Op.Increment(amount));\\n    },\\n\\n    /**\\n     * Atomically add an object to the end of the array associated with a given\\n     * key.\\n     * @param attr {String} The key.\\n     * @param item {} The item to add.\\n     */\\n    add: function(attr, item) {\\n      return this.set(attr, new Parse.Op.Add([item]));\\n    },\\n\\n    /**\\n     * Atomically add an object to the array associated with a given key, only\\n     * if it is not already present in the array. The position of the insert is\\n     * not guaranteed.\\n     *\\n     * @param attr {String} The key.\\n     * @param item {} The object to add.\\n     */\\n    addUnique: function(attr, item) {\\n      return this.set(attr, new Parse.Op.AddUnique([item]));\\n    },\\n\\n    /**\\n     * Atomically remove all instances of an object from the array associated\\n     * with a given key.\\n     *\\n     * @param attr {String} The key.\\n     * @param item {} The object to remove.\\n     */\\n    remove: function(attr, item) {\\n      return this.set(attr, new Parse.Op.Remove([item]));\\n    },\\n\\n    /**\\n     * Returns an instance of a subclass of Parse.Op describing what kind of\\n     * modification has been performed on this field since the last time it was\\n     * saved. For example, after calling object.increment(\\\"x\\\"), calling\\n     * object.op(\\\"x\\\") would return an instance of Parse.Op.Increment.\\n     *\\n     * @param attr {String} The key.\\n     * @returns {Parse.Op} The operation, or undefined if none.\\n     */\\n    op: function(attr) {\\n      return _.last(this._opSetQueue)[attr];\\n    },\\n\\n    /**\\n     * Clear all attributes on the model, firing <code>\\\"change\\\"</code> unless\\n     * you choose to silence it.\\n     */\\n    clear: function(options) {\\n      options = options || {};\\n      options.unset = true;\\n      var keysToClear = _.extend(this.attributes, this._operations);\\n      return this.set(keysToClear, options);\\n    },\\n\\n    /**\\n     * Returns a JSON-encoded set of operations to be sent with the next save\\n     * request.\\n     */\\n    _getSaveJSON: function() {\\n      var json = _.clone(_.first(this._opSetQueue));\\n      Parse._objectEach(json, function(op, key) {\\n        json[key] = op.toJSON();\\n      });\\n      return json;\\n    },\\n\\n    /**\\n     * Returns true if this object can be serialized for saving.\\n     */\\n    _canBeSerialized: function() {\\n      return Parse.Object._canBeSerializedAsValue(this.attributes);\\n    },\\n\\n    /**\\n     * Fetch the model from the server. If the server's representation of the\\n     * model differs from its current attributes, they will be overriden,\\n     * triggering a <code>\\\"change\\\"</code> event.\\n     *\\n     * @param {Object} options A Backbone-style callback object.\\n     * Valid options are:<ul>\\n     *   <li>success: A Backbone-style success callback.\\n     *   <li>error: An Backbone-style error callback.\\n     *   <li>useMasterKey: In Cloud Code and Node only, causes the Master Key to\\n     *     be used for this request.\\n     * </ul>\\n     * @return {Parse.Promise} A promise that is fulfilled when the fetch\\n     *     completes.\\n     */\\n    fetch: function(options) {\\n      var self = this;\\n      options = options || {};\\n      var request = Parse._request({\\n        method: 'GET',\\n        route: \\\"classes\\\",\\n        className: this.className,\\n        objectId: this.id,\\n        useMasterKey: options.useMasterKey\\n      });\\n      return request.then(function(response, status, xhr) {\\n        self._finishFetch(self.parse(response, status, xhr), true);\\n        return self;\\n      })._thenRunCallbacks(options, this);\\n    },\\n\\n    /**\\n     * Set a hash of model attributes, and save the model to the server.\\n     * updatedAt will be updated when the request returns.\\n     * You can either call it as:<pre>\\n     *   object.save();</pre>\\n     * or<pre>\\n     *   object.save(null, options);</pre>\\n     * or<pre>\\n     *   object.save(attrs, options);</pre>\\n     * or<pre>\\n     *   object.save(key, value, options);</pre>\\n     *\\n     * For example, <pre>\\n     *   gameTurn.save({\\n     *     player: \\\"Jake Cutter\\\",\\n     *     diceRoll: 2\\n     *   }, {\\n     *     success: function(gameTurnAgain) {\\n     *       // The save was successful.\\n     *     },\\n     *     error: function(gameTurnAgain, error) {\\n     *       // The save failed.  Error is an instance of Parse.Error.\\n     *     }\\n     *   });</pre>\\n     * or with promises:<pre>\\n     *   gameTurn.save({\\n     *     player: \\\"Jake Cutter\\\",\\n     *     diceRoll: 2\\n     *   }).then(function(gameTurnAgain) {\\n     *     // The save was successful.\\n     *   }, function(error) {\\n     *     // The save failed.  Error is an instance of Parse.Error.\\n     *   });</pre>\\n     *\\n     * @param {Object} options A Backbone-style callback object.\\n     * Valid options are:<ul>\\n     *   <li>wait: Set to true to wait for the server to confirm a successful\\n     *   save before modifying the attributes on the object.\\n     *   <li>silent: Set to true to avoid firing the `set` event.\\n     *   <li>success: A Backbone-style success callback.\\n     *   <li>error: An Backbone-style error callback.\\n     *   <li>useMasterKey: In Cloud Code and Node only, causes the Master Key to\\n     *     be used for this request.\\n     * </ul>\\n     * @return {Parse.Promise} A promise that is fulfilled when the save\\n     *     completes.\\n     * @see Parse.Error\\n     */\\n    save: function(arg1, arg2, arg3) {\\n      var i, attrs, current, options, saved;\\n      if (_.isObject(arg1) || Parse._isNullOrUndefined(arg1)) {\\n        attrs = arg1;\\n        options = arg2;\\n      } else {\\n        attrs = {};\\n        attrs[arg1] = arg2;\\n        options = arg3;\\n      }\\n\\n      // Make save({ success: function() {} }) work.\\n      if (!options && attrs) {\\n        var extra_keys = _.reject(attrs, function(value, key) {\\n          return _.include([\\\"success\\\", \\\"error\\\", \\\"wait\\\"], key);\\n        });\\n        if (extra_keys.length === 0) {\\n          var all_functions = true;\\n          if (_.has(attrs, \\\"success\\\") && !_.isFunction(attrs.success)) {\\n            all_functions = false;\\n          }\\n          if (_.has(attrs, \\\"error\\\") && !_.isFunction(attrs.error)) {\\n            all_functions = false;\\n          }\\n          if (all_functions) {\\n            // This attrs object looks like it's really an options object,\\n            // and there's no other options object, so let's just use it.\\n            return this.save(null, attrs);\\n          }\\n        }\\n      }\\n\\n      options = _.clone(options) || {};\\n      if (options.wait) {\\n        current = _.clone(this.attributes);\\n      }\\n\\n      var setOptions = _.clone(options) || {};\\n      if (setOptions.wait) {\\n        setOptions.silent = true;\\n      }\\n      var setError;\\n      setOptions.error = function(model, error) {\\n        setError = error;\\n      };\\n      if (attrs && !this.set(attrs, setOptions)) {\\n        return Parse.Promise.error(setError)._thenRunCallbacks(options, this);\\n      }\\n\\n      var model = this;\\n\\n      // If there is any unsaved child, save it first.\\n      model._refreshCache();\\n\\n\\n\\n      var unsavedChildren = [];\\n      var unsavedFiles = [];\\n      Parse.Object._findUnsavedChildren(model.attributes,\\n                                        unsavedChildren,\\n                                        unsavedFiles);\\n      if (unsavedChildren.length + unsavedFiles.length > 0) {\\n        return Parse.Object._deepSaveAsync(this.attributes, {\\n          useMasterKey: options.useMasterKey\\n        }).then(function() {\\n          return model.save(null, options);\\n        }, function(error) {\\n          return Parse.Promise.error(error)._thenRunCallbacks(options, model);\\n        });\\n      }\\n\\n      this._startSave();\\n      this._saving = (this._saving || 0) + 1;\\n\\n      this._allPreviousSaves = this._allPreviousSaves || Parse.Promise.as();\\n      this._allPreviousSaves = this._allPreviousSaves._continueWith(function() {\\n        var method = model.id ? 'PUT' : 'POST';\\n\\n        var json = model._getSaveJSON();\\n\\n        var route = \\\"classes\\\";\\n        var className = model.className;\\n        if (model.className === \\\"_User\\\" && !model.id) {\\n          // Special-case user sign-up.\\n          route = \\\"users\\\";\\n          className = null;\\n        }\\n        var request = Parse._request({\\n          route: route,\\n          className: className,\\n          objectId: model.id,\\n          method: method,\\n          useMasterKey: options.useMasterKey,\\n          data: json\\n        });\\n\\n        request = request.then(function(resp, status, xhr) {\\n          var serverAttrs = model.parse(resp, status, xhr);\\n          if (options.wait) {\\n            serverAttrs = _.extend(attrs || {}, serverAttrs);\\n          }\\n          model._finishSave(serverAttrs);\\n          if (options.wait) {\\n            model.set(current, setOptions);\\n          }\\n          return model;\\n\\n        }, function(error) {\\n          model._cancelSave();\\n          return Parse.Promise.error(error);\\n\\n        })._thenRunCallbacks(options, model);\\n\\n        return request;\\n      });\\n      return this._allPreviousSaves;\\n    },\\n\\n    /**\\n     * Destroy this model on the server if it was already persisted.\\n     * Optimistically removes the model from its collection, if it has one.\\n     * If `wait: true` is passed, waits for the server to respond\\n     * before removal.\\n     *\\n     * @param {Object} options A Backbone-style callback object.\\n     * Valid options are:<ul>\\n     *   <li>wait: Set to true to wait for the server to confirm successful\\n     *   deletion of the object before triggering the `destroy` event.\\n     *   <li>success: A Backbone-style success callback\\n     *   <li>error: An Backbone-style error callback.\\n     *   <li>useMasterKey: In Cloud Code and Node only, causes the Master Key to\\n     *     be used for this request.\\n     * </ul>\\n     * @return {Parse.Promise} A promise that is fulfilled when the destroy\\n     *     completes.\\n     */\\n    destroy: function(options) {\\n      options = options || {};\\n      var model = this;\\n\\n      var triggerDestroy = function() {\\n        model.trigger('destroy', model, model.collection, options);\\n      };\\n\\n      if (!this.id) {\\n        return triggerDestroy();\\n      }\\n\\n      if (!options.wait) {\\n        triggerDestroy();\\n      }\\n\\n      var request = Parse._request({\\n        route: \\\"classes\\\",\\n        className: this.className,\\n        objectId: this.id,\\n        method: 'DELETE',\\n        useMasterKey: options.useMasterKey\\n      });\\n      return request.then(function() {\\n        if (options.wait) {\\n          triggerDestroy();\\n        }\\n        return model;\\n      })._thenRunCallbacks(options, this);\\n    },\\n\\n    /**\\n     * Converts a response into the hash of attributes to be set on the model.\\n     * @ignore\\n     */\\n    parse: function(resp, status, xhr) {\\n      var output = _.clone(resp);\\n      _([\\\"createdAt\\\", \\\"updatedAt\\\"]).each(function(key) {\\n        if (output[key]) {\\n          output[key] = Parse._parseDate(output[key]);\\n        }\\n      });\\n      if (!output.updatedAt) {\\n        output.updatedAt = output.createdAt;\\n      }\\n      if (status) {\\n        this._existed = (status !== 201);\\n      }\\n      return output;\\n    },\\n\\n    /**\\n     * Creates a new model with identical attributes to this one.\\n     * @return {Parse.Object}\\n     */\\n    clone: function() {\\n      return new this.constructor(this.attributes);\\n    },\\n\\n    /**\\n     * Returns true if this object has never been saved to Parse.\\n     * @return {Boolean}\\n     */\\n    isNew: function() {\\n      return !this.id;\\n    },\\n\\n    /**\\n     * Call this method to manually fire a `\\\"change\\\"` event for this model and\\n     * a `\\\"change:attribute\\\"` event for each changed attribute.\\n     * Calling this will cause all objects observing the model to update.\\n     */\\n    change: function(options) {\\n      options = options || {};\\n      var changing = this._changing;\\n      this._changing = true;\\n\\n      // Silent changes become pending changes.\\n      var self = this;\\n      Parse._objectEach(this._silent, function(attr) {\\n        self._pending[attr] = true;\\n      });\\n\\n      // Silent changes are triggered.\\n      var changes = _.extend({}, options.changes, this._silent);\\n      this._silent = {};\\n      Parse._objectEach(changes, function(unused_value, attr) {\\n        self.trigger('change:' + attr, self, self.get(attr), options);\\n      });\\n      if (changing) {\\n        return this;\\n      }\\n\\n      // This is to get around lint not letting us make a function in a loop.\\n      var deleteChanged = function(value, attr) {\\n        if (!self._pending[attr] && !self._silent[attr]) {\\n          delete self.changed[attr];\\n        }\\n      };\\n\\n      // Continue firing `\\\"change\\\"` events while there are pending changes.\\n      while (!_.isEmpty(this._pending)) {\\n        this._pending = {};\\n        this.trigger('change', this, options);\\n        // Pending and silent changes still remain.\\n        Parse._objectEach(this.changed, deleteChanged);\\n        self._previousAttributes = _.clone(this.attributes);\\n      }\\n\\n      this._changing = false;\\n      return this;\\n    },\\n\\n    /**\\n     * Returns true if this object was created by the Parse server when the\\n     * object might have already been there (e.g. in the case of a Facebook\\n     * login)\\n     */\\n    existed: function() {\\n      return this._existed;\\n    },\\n\\n    /**\\n     * Determine if the model has changed since the last <code>\\\"change\\\"</code>\\n     * event.  If you specify an attribute name, determine if that attribute\\n     * has changed.\\n     * @param {String} attr Optional attribute name\\n     * @return {Boolean}\\n     */\\n    hasChanged: function(attr) {\\n      if (!arguments.length) {\\n        return !_.isEmpty(this.changed);\\n      }\\n      return this.changed && _.has(this.changed, attr);\\n    },\\n\\n    /**\\n     * Returns an object containing all the attributes that have changed, or\\n     * false if there are no changed attributes. Useful for determining what\\n     * parts of a view need to be updated and/or what attributes need to be\\n     * persisted to the server. Unset attributes will be set to undefined.\\n     * You can also pass an attributes object to diff against the model,\\n     * determining if there *would be* a change.\\n     */\\n    changedAttributes: function(diff) {\\n      if (!diff) {\\n        return this.hasChanged() ? _.clone(this.changed) : false;\\n      }\\n      var changed = {};\\n      var old = this._previousAttributes;\\n      Parse._objectEach(diff, function(diffVal, attr) {\\n        if (!_.isEqual(old[attr], diffVal)) {\\n          changed[attr] = diffVal;\\n        }\\n      });\\n      return changed;\\n    },\\n\\n    /**\\n     * Gets the previous value of an attribute, recorded at the time the last\\n     * <code>\\\"change\\\"</code> event was fired.\\n     * @param {String} attr Name of the attribute to get.\\n     */\\n    previous: function(attr) {\\n      if (!arguments.length || !this._previousAttributes) {\\n        return null;\\n      }\\n      return this._previousAttributes[attr];\\n    },\\n\\n    /**\\n     * Gets all of the attributes of the model at the time of the previous\\n     * <code>\\\"change\\\"</code> event.\\n     * @return {Object}\\n     */\\n    previousAttributes: function() {\\n      return _.clone(this._previousAttributes);\\n    },\\n\\n    /**\\n     * Checks if the model is currently in a valid state. It's only possible to\\n     * get into an *invalid* state if you're using silent changes.\\n     * @return {Boolean}\\n     */\\n    isValid: function() {\\n      return !this.validate(this.attributes);\\n    },\\n\\n    /**\\n     * You should not call this function directly unless you subclass\\n     * <code>Parse.Object</code>, in which case you can override this method\\n     * to provide additional validation on <code>set</code> and\\n     * <code>save</code>.  Your implementation should return\\n     *\\n     * @param {Object} attrs The current data to validate.\\n     * @param {Object} options A Backbone-like options object.\\n     * @return {} False if the data is valid.  An error object otherwise.\\n     * @see Parse.Object#set\\n     */\\n    validate: function(attrs, options) {\\n      if (_.has(attrs, \\\"ACL\\\") && !(attrs.ACL instanceof Parse.ACL)) {\\n        return new Parse.Error(Parse.Error.OTHER_CAUSE,\\n                               \\\"ACL must be a Parse.ACL.\\\");\\n      }\\n      var correct = true;\\n      Parse._objectEach(attrs, function(unused_value, key) {\\n        if (!(/^[A-Za-z][0-9A-Za-z_]*$/).test(key)) {\\n          correct = false;\\n        }\\n      });\\n      if (!correct) {\\n        return new Parse.Error(Parse.Error.INVALID_KEY_NAME);\\n      }\\n      return false;\\n    },\\n\\n    /**\\n     * Run validation against a set of incoming attributes, returning `true`\\n     * if all is well. If a specific `error` callback has been passed,\\n     * call that instead of firing the general `\\\"error\\\"` event.\\n     */\\n    _validate: function(attrs, options) {\\n      if (options.silent || !this.validate) {\\n        return true;\\n      }\\n      attrs = _.extend({}, this.attributes, attrs);\\n      var error = this.validate(attrs, options);\\n      if (!error) {\\n        return true;\\n      }\\n      if (options && options.error) {\\n        options.error(this, error, options);\\n      } else {\\n        this.trigger('error', this, error, options);\\n      }\\n      return false;\\n    },\\n\\n    /**\\n     * Returns the ACL for this object.\\n     * @returns {Parse.ACL} An instance of Parse.ACL.\\n     * @see Parse.Object#get\\n     */\\n    getACL: function() {\\n      return this.get(\\\"ACL\\\");\\n    },\\n\\n    /**\\n     * Sets the ACL to be used for this object.\\n     * @param {Parse.ACL} acl An instance of Parse.ACL.\\n     * @param {Object} options Optional Backbone-like options object to be\\n     *     passed in to set.\\n     * @return {Boolean} Whether the set passed validation.\\n     * @see Parse.Object#set\\n     */\\n    setACL: function(acl, options) {\\n      return this.set(\\\"ACL\\\", acl, options);\\n    }\\n\\n  });\\n\\n  /**\\n   * Returns the appropriate subclass for making new instances of the given\\n   * className string.\\n   */\\n  Parse.Object._getSubclass = function(className) {\\n    if (!_.isString(className)) {\\n      throw \\\"Parse.Object._getSubclass requires a string argument.\\\";\\n    }\\n    var ObjectClass = Parse.Object._classMap[className];\\n    if (!ObjectClass) {\\n      ObjectClass = Parse.Object.extend(className);\\n      Parse.Object._classMap[className] = ObjectClass;\\n    }\\n    return ObjectClass;\\n  };\\n\\n  /**\\n   * Creates an instance of a subclass of Parse.Object for the given classname.\\n   */\\n  Parse.Object._create = function(className, attributes, options) {\\n    var ObjectClass = Parse.Object._getSubclass(className);\\n    return new ObjectClass(attributes, options);\\n  };\\n\\n  /**\\n   * Returns a list of object ids given a list of objects.\\n   */\\n  Parse.Object._toObjectIdArray = function(list, omitObjectsWithData) {\\n    if (list.length === 0) {\\n      return Parse.Promise.as(list);\\n    }\\n\\n    var error;\\n    var className = list[0].className;\\n    var objectIds = [];\\n    for (var i = 0; i < list.length; i++) {\\n      var object = list[i];\\n      if (className !== object.className) {\\n        error = new Parse.Error(Parse.Error.INVALID_CLASS_NAME,\\n                                \\\"All objects should be of the same class\\\");\\n        return Parse.Promise.error(error);\\n      } else if (!object.id) {\\n        error = new Parse.Error(Parse.Error.MISSING_OBJECT_ID,\\n                                \\\"All objects must have an ID\\\");\\n        return Parse.Promise.error(error);\\n      } else if (omitObjectsWithData && object._hasData) {\\n        continue;\\n      }\\n      objectIds.push(object.id);\\n    }\\n\\n    return Parse.Promise.as(objectIds);\\n  };\\n\\n  /**\\n   * Updates a list of objects with fetched results.\\n   */\\n  Parse.Object._updateWithFetchedResults = function(list, fetched, forceFetch) {\\n    var fetchedObjectsById = {};\\n    Parse._arrayEach(fetched, function(object, i) {\\n      fetchedObjectsById[object.id] = object;\\n    });\\n\\n    for (var i = 0; i < list.length; i++) {\\n      var object = list[i];\\n      var fetchedObject = fetchedObjectsById[object.id];\\n      if (!fetchedObject && forceFetch) {\\n        var error = new Parse.Error(Parse.Error.OBJECT_NOT_FOUND,\\n                                \\\"All objects must exist on the server\\\");\\n        return Parse.Promise.error(error);\\n      }\\n\\n      object._mergeFromObject(fetchedObject);\\n    }\\n\\n    return Parse.Promise.as(list);\\n  };\\n\\n  /**\\n   * Fetches the objects given in list.  The forceFetch option will fetch all\\n   * objects if true and ignore objects with data if false.\\n   */\\n  Parse.Object._fetchAll = function(list, forceFetch) {\\n    if (list.length === 0) {\\n      return Parse.Promise.as(list);\\n    }\\n\\n    var omitObjectsWithData = !forceFetch;\\n    return Parse.Object._toObjectIdArray(\\n      list,\\n      omitObjectsWithData\\n    ).then(function(objectIds) {\\n      var className = list[0].className;\\n      var query = new Parse.Query(className);\\n      query.containedIn(\\\"objectId\\\", objectIds);\\n      query.limit = objectIds.length;\\n      return query.find();\\n    }).then(function(results) {\\n      return Parse.Object._updateWithFetchedResults(\\n        list,\\n        results,\\n        forceFetch\\n      );\\n    });\\n  };\\n\\n  // Set up a map of className to class so that we can create new instances of\\n  // Parse Objects from JSON automatically.\\n  Parse.Object._classMap = {};\\n\\n  Parse.Object._extend = Parse._extend;\\n\\n  /**\\n   * Creates a new subclass of Parse.Object for the given Parse class name.\\n   *\\n   * <p>Every extension of a Parse class will inherit from the most recent\\n   * previous extension of that class. When a Parse.Object is automatically\\n   * created by parsing JSON, it will use the most recent extension of that\\n   * class.</p>\\n   *\\n   * <p>You should call either:<pre>\\n   *     var MyClass = Parse.Object.extend(\\\"MyClass\\\", {\\n   *         <i>Instance methods</i>,\\n   *         initialize: function(attrs, options) {\\n   *             this.someInstanceProperty = [],\\n   *             <i>Other instance properties</i>\\n   *         }\\n   *     }, {\\n   *         <i>Class properties</i>\\n   *     });</pre>\\n   * or, for Backbone compatibility:<pre>\\n   *     var MyClass = Parse.Object.extend({\\n   *         className: \\\"MyClass\\\",\\n   *         <i>Instance methods</i>,\\n   *         initialize: function(attrs, options) {\\n   *             this.someInstanceProperty = [],\\n   *             <i>Other instance properties</i>\\n   *         }\\n   *     }, {\\n   *         <i>Class properties</i>\\n   *     });</pre></p>\\n   *\\n   * @param {String} className The name of the Parse class backing this model.\\n   * @param {Object} protoProps Instance properties to add to instances of the\\n   *     class returned from this method.\\n   * @param {Object} classProps Class properties to add the class returned from\\n   *     this method.\\n   * @return {Class} A new subclass of Parse.Object.\\n   */\\n  Parse.Object.extend = function(className, protoProps, classProps) {\\n    // Handle the case with only two args.\\n    if (!_.isString(className)) {\\n      if (className && _.has(className, \\\"className\\\")) {\\n        return Parse.Object.extend(className.className, className, protoProps);\\n      } else {\\n        throw new Error(\\n            \\\"Parse.Object.extend's first argument should be the className.\\\");\\n      }\\n    }\\n\\n    // If someone tries to subclass \\\"User\\\", coerce it to the right type.\\n    if (className === \\\"User\\\" && Parse.User._performUserRewrite) {\\n      className = \\\"_User\\\";\\n    }\\n    protoProps = protoProps || {};\\n    protoProps.className = className;\\n\\n    var NewClassObject = null;\\n    if (_.has(Parse.Object._classMap, className)) {\\n      var OldClassObject = Parse.Object._classMap[className];\\n      // This new subclass has been told to extend both from \\\"this\\\" and from\\n      // OldClassObject. This is multiple inheritance, which isn't supported.\\n      // For now, let's just pick one.\\n      NewClassObject = OldClassObject._extend(protoProps, classProps);\\n    } else {\\n      NewClassObject = this._extend(protoProps, classProps);\\n    }\\n    // Extending a subclass should reuse the classname automatically.\\n    NewClassObject.extend = function(arg0) {\\n      if (_.isString(arg0) || (arg0 && _.has(arg0, \\\"className\\\"))) {\\n        return Parse.Object.extend.apply(NewClassObject, arguments);\\n      }\\n      var newArguments = [className].concat(Parse._.toArray(arguments));\\n      return Parse.Object.extend.apply(NewClassObject, newArguments);\\n    };\\n    Parse.Object._classMap[className] = NewClassObject;\\n    return NewClassObject;\\n  };\\n\\n  Parse.Object._findUnsavedChildren = function(object, children, files) {\\n    Parse._traverse(object, function(object) {\\n      if (object instanceof Parse.Object) {\\n        object._refreshCache();\\n        if (object.dirty()) {\\n          children.push(object);\\n        }\\n        return;\\n      }\\n\\n      if (object instanceof Parse.File) {\\n        if (!object.url()) {\\n          files.push(object);\\n        }\\n        return;\\n      }\\n    });\\n  };\\n\\n  Parse.Object._canBeSerializedAsValue = function(object) {\\n\\n    if (object instanceof Parse.Object) {\\n      return !!object.id;\\n    }\\n    if (object instanceof Parse.File) {\\n      // Don't recurse indefinitely into files.\\n      return true;\\n    }\\n\\n    var canBeSerializedAsValue = true;\\n\\n    if (_.isArray(object)) {\\n      Parse._arrayEach(object, function(child) {\\n        if (!Parse.Object._canBeSerializedAsValue(child)) {\\n          canBeSerializedAsValue = false;\\n        }\\n      });\\n    } else if (_.isObject(object)) {\\n      Parse._objectEach(object, function(child) {\\n        if (!Parse.Object._canBeSerializedAsValue(child)) {\\n          canBeSerializedAsValue = false;\\n        }\\n      });\\n    }\\n    return canBeSerializedAsValue;\\n  };\\n\\n  /**\\n   * @param {Object} object The root object.\\n   * @param {Object} options: The only valid option is useMasterKey.\\n   */\\n  Parse.Object._deepSaveAsync = function(object, options) {\\n    var unsavedChildren = [];\\n    var unsavedFiles = [];\\n    Parse.Object._findUnsavedChildren(object, unsavedChildren, unsavedFiles);\\n\\n    var promise = Parse.Promise.as();\\n    _.each(unsavedFiles, function(file) {\\n      promise = promise.then(function() {\\n        return file.save(options);\\n      });\\n    });\\n\\n    var objects = _.uniq(unsavedChildren);\\n    var remaining = _.uniq(objects);\\n\\n    return promise.then(function() {\\n      return Parse.Promise._continueWhile(function() {\\n        return remaining.length > 0;\\n      }, function() {\\n\\n        // Gather up all the objects that can be saved in this batch.\\n        var batch = [];\\n        var newRemaining = [];\\n        Parse._arrayEach(remaining, function(object) {\\n          // Limit batches to 20 objects.\\n          if (batch.length > 20) {\\n            newRemaining.push(object);\\n            return;\\n          }\\n\\n          if (object._canBeSerialized()) {\\n            batch.push(object);\\n          } else {\\n            newRemaining.push(object);\\n          }\\n        });\\n        remaining = newRemaining;\\n\\n        // If we can't save any objects, there must be a circular reference.\\n        if (batch.length === 0) {\\n          return Parse.Promise.error(\\n            new Parse.Error(Parse.Error.OTHER_CAUSE,\\n                            \\\"Tried to save a batch with a cycle.\\\"));\\n        }\\n\\n        // Reserve a spot in every object's save queue.\\n        var readyToStart = Parse.Promise.when(_.map(batch, function(object) {\\n          return object._allPreviousSaves || Parse.Promise.as();\\n        }));\\n        var batchFinished = new Parse.Promise();\\n        Parse._arrayEach(batch, function(object) {\\n          object._allPreviousSaves = batchFinished;\\n        });\\n\\n        // Save a single batch, whether previous saves succeeded or failed.\\n        return readyToStart._continueWith(function() {\\n          return Parse._request({\\n            route: \\\"batch\\\",\\n            method: \\\"POST\\\",\\n            useMasterKey: options.useMasterKey,\\n            data: {\\n              requests: _.map(batch, function(object) {\\n                var json = object._getSaveJSON();\\n                var method = \\\"POST\\\";\\n\\n                var path = \\\"/1/classes/\\\" + object.className;\\n                if (object.id) {\\n                  path = path + \\\"/\\\" + object.id;\\n                  method = \\\"PUT\\\";\\n                }\\n\\n                object._startSave();\\n\\n                return {\\n                  method: method,\\n                  path: path,\\n                  body: json\\n                };\\n              })\\n            }\\n          }).then(function(response, status, xhr) {\\n            var error;\\n            Parse._arrayEach(batch, function(object, i) {\\n              if (response[i].success) {\\n                object._finishSave(\\n                  object.parse(response[i].success, status, xhr));\\n              } else {\\n                error = error || response[i].error;\\n                object._cancelSave();\\n              }\\n            });\\n            if (error) {\\n              return Parse.Promise.error(\\n                new Parse.Error(error.code, error.error));\\n            }\\n\\n          }).then(function(results) {\\n            batchFinished.resolve(results);\\n            return results;\\n          }, function(error) {\\n            batchFinished.reject(error);\\n            return Parse.Promise.error(error);\\n          });\\n        });\\n      });\\n    }).then(function() {\\n      return object;\\n    });\\n  };\\n\\n}(this));\\n\\n(function(root) {\\n  root.Parse = root.Parse || {};\\n  var Parse = root.Parse;\\n  var _ = Parse._;\\n\\n  /**\\n   * Represents a Role on the Parse server. Roles represent groupings of\\n   * Users for the purposes of granting permissions (e.g. specifying an ACL\\n   * for an Object). Roles are specified by their sets of child users and\\n   * child roles, all of which are granted any permissions that the parent\\n   * role has.\\n   *\\n   * <p>Roles must have a name (which cannot be changed after creation of the\\n   * role), and must specify an ACL.</p>\\n   * @class\\n   * A Parse.Role is a local representation of a role persisted to the Parse\\n   * cloud.\\n   */\\n  Parse.Role = Parse.Object.extend(\\\"_Role\\\", /** @lends Parse.Role.prototype */ {\\n    // Instance Methods\\n\\n    /**\\n     * Constructs a new ParseRole with the given name and ACL.\\n     *\\n     * @param {String} name The name of the Role to create.\\n     * @param {Parse.ACL} acl The ACL for this role. Roles must have an ACL.\\n     */\\n    constructor: function(name, acl) {\\n      if (_.isString(name) && (acl instanceof Parse.ACL)) {\\n        Parse.Object.prototype.constructor.call(this, null, null);\\n        this.setName(name);\\n        this.setACL(acl);\\n      } else {\\n        Parse.Object.prototype.constructor.call(this, name, acl);\\n      }\\n    },\\n\\n    /**\\n     * Gets the name of the role.  You can alternatively call role.get(\\\"name\\\")\\n     *\\n     * @return {String} the name of the role.\\n     */\\n    getName: function() {\\n      return this.get(\\\"name\\\");\\n    },\\n\\n    /**\\n     * Sets the name for a role. This value must be set before the role has\\n     * been saved to the server, and cannot be set once the role has been\\n     * saved.\\n     *\\n     * <p>\\n     *   A role's name can only contain alphanumeric characters, _, -, and\\n     *   spaces.\\n     * </p>\\n     *\\n     * <p>This is equivalent to calling role.set(\\\"name\\\", name)</p>\\n     *\\n     * @param {String} name The name of the role.\\n     * @param {Object} options Standard options object with success and error\\n     *     callbacks.\\n     */\\n    setName: function(name, options) {\\n      return this.set(\\\"name\\\", name, options);\\n    },\\n\\n    /**\\n     * Gets the Parse.Relation for the Parse.Users that are direct\\n     * children of this role. These users are granted any privileges that this\\n     * role has been granted (e.g. read or write access through ACLs). You can\\n     * add or remove users from the role through this relation.\\n     *\\n     * <p>This is equivalent to calling role.relation(\\\"users\\\")</p>\\n     *\\n     * @return {Parse.Relation} the relation for the users belonging to this\\n     *     role.\\n     */\\n    getUsers: function() {\\n      return this.relation(\\\"users\\\");\\n    },\\n\\n    /**\\n     * Gets the Parse.Relation for the Parse.Roles that are direct\\n     * children of this role. These roles' users are granted any privileges that\\n     * this role has been granted (e.g. read or write access through ACLs). You\\n     * can add or remove child roles from this role through this relation.\\n     *\\n     * <p>This is equivalent to calling role.relation(\\\"roles\\\")</p>\\n     *\\n     * @return {Parse.Relation} the relation for the roles belonging to this\\n     *     role.\\n     */\\n    getRoles: function() {\\n      return this.relation(\\\"roles\\\");\\n    },\\n\\n    /**\\n     * @ignore\\n     */\\n    validate: function(attrs, options) {\\n      if (\\\"name\\\" in attrs && attrs.name !== this.getName()) {\\n        var newName = attrs.name;\\n        if (this.id && this.id !== attrs.objectId) {\\n          // Check to see if the objectId being set matches this.id.\\n          // This happens during a fetch -- the id is set before calling fetch.\\n          // Let the name be set in this case.\\n          return new Parse.Error(Parse.Error.OTHER_CAUSE,\\n              \\\"A role's name can only be set before it has been saved.\\\");\\n        }\\n        if (!_.isString(newName)) {\\n          return new Parse.Error(Parse.Error.OTHER_CAUSE,\\n              \\\"A role's name must be a String.\\\");\\n        }\\n        if (!(/^[0-9a-zA-Z\\\\-_ ]+$/).test(newName)) {\\n          return new Parse.Error(Parse.Error.OTHER_CAUSE,\\n              \\\"A role's name can only contain alphanumeric characters, _,\\\" +\\n              \\\" -, and spaces.\\\");\\n        }\\n      }\\n      if (Parse.Object.prototype.validate) {\\n        return Parse.Object.prototype.validate.call(this, attrs, options);\\n      }\\n      return false;\\n    }\\n  });\\n}(this));\\n\\n\\n/*global _: false */\\n(function(root) {\\n  root.Parse = root.Parse || {};\\n  var Parse = root.Parse;\\n  var _ = Parse._;\\n\\n  /**\\n   * Creates a new instance with the given models and options.  Typically, you\\n   * will not call this method directly, but will instead make a subclass using\\n   * <code>Parse.Collection.extend</code>.\\n   *\\n   * @param {Array} models An array of instances of <code>Parse.Object</code>.\\n   *\\n   * @param {Object} options An optional object with Backbone-style options.\\n   * Valid options are:<ul>\\n   *   <li>model: The Parse.Object subclass that this collection contains.\\n   *   <li>query: An instance of Parse.Query to use when fetching items.\\n   *   <li>comparator: A string property name or function to sort by.\\n   * </ul>\\n   *\\n   * @see Parse.Collection.extend\\n   *\\n   * @class\\n   *\\n   * <p>Provides a standard collection class for our sets of models, ordered\\n   * or unordered.  For more information, see the\\n   * <a href=\\\"http://documentcloud.github.com/backbone/#Collection\\\">Backbone\\n   * documentation</a>.</p>\\n   */\\n  Parse.Collection = function(models, options) {\\n    options = options || {};\\n    if (options.comparator) {\\n      this.comparator = options.comparator;\\n    }\\n    if (options.model) {\\n      this.model = options.model;\\n    }\\n    if (options.query) {\\n      this.query = options.query;\\n    }\\n    this._reset();\\n    this.initialize.apply(this, arguments);\\n    if (models) {\\n      this.reset(models, {silent: true, parse: options.parse});\\n    }\\n  };\\n\\n  // Define the Collection's inheritable methods.\\n  _.extend(Parse.Collection.prototype, Parse.Events,\\n      /** @lends Parse.Collection.prototype */ {\\n\\n    // The default model for a collection is just a Parse.Object.\\n    // This should be overridden in most cases.\\n\\n    model: Parse.Object,\\n\\n    /**\\n     * Initialize is an empty function by default. Override it with your own\\n     * initialization logic.\\n     */\\n    initialize: function(){},\\n\\n    /**\\n     * The JSON representation of a Collection is an array of the\\n     * models' attributes.\\n     */\\n    toJSON: function() {\\n      return this.map(function(model){ return model.toJSON(); });\\n    },\\n\\n    /**\\n     * Add a model, or list of models to the set. Pass **silent** to avoid\\n     * firing the `add` event for every new model.\\n     *\\n     * @param {Array} models An array of instances of <code>Parse.Object</code>.\\n     *\\n     * @param {Object} options An optional object with Backbone-style options.\\n     * Valid options are:<ul>\\n     *   <li>at: The index at which to add the models.\\n     *   <li>silent: Set to true to avoid firing the `add` event for every new\\n     *   model.\\n     * </ul>\\n     */\\n    add: function(models, options) {\\n      var i, index, length, model, cid, id, cids = {}, ids = {};\\n      options = options || {};\\n      models = _.isArray(models) ? models.slice() : [models];\\n\\n      // Begin by turning bare objects into model references, and preventing\\n      // invalid models or duplicate models from being added.\\n      for (i = 0, length = models.length; i < length; i++) {\\n        models[i] = this._prepareModel(models[i], options);\\n        model = models[i];\\n        if (!model) {\\n          throw new Error(\\\"Can't add an invalid model to a collection\\\");\\n        }\\n        cid = model.cid;\\n        if (cids[cid] || this._byCid[cid]) {\\n          throw new Error(\\\"Duplicate cid: can't add the same model \\\" +\\n                          \\\"to a collection twice\\\");\\n        }\\n        id = model.id;\\n        if (!Parse._isNullOrUndefined(id) && (ids[id] || this._byId[id])) {\\n          throw new Error(\\\"Duplicate id: can't add the same model \\\" +\\n                          \\\"to a collection twice\\\");\\n        }\\n        ids[id] = model;\\n        cids[cid] = model;\\n      }\\n\\n      // Listen to added models' events, and index models for lookup by\\n      // `id` and by `cid`.\\n      for (i = 0; i < length; i++) {\\n        (model = models[i]).on('all', this._onModelEvent, this);\\n        this._byCid[model.cid] = model;\\n        if (model.id) {\\n          this._byId[model.id] = model;\\n        }\\n      }\\n\\n      // Insert models into the collection, re-sorting if needed, and triggering\\n      // `add` events unless silenced.\\n      this.length += length;\\n      index = Parse._isNullOrUndefined(options.at) ?\\n          this.models.length : options.at;\\n      this.models.splice.apply(this.models, [index, 0].concat(models));\\n      if (this.comparator) {\\n        this.sort({silent: true});\\n      }\\n      if (options.silent) {\\n        return this;\\n      }\\n      for (i = 0, length = this.models.length; i < length; i++) {\\n        model = this.models[i];\\n        if (cids[model.cid]) {\\n          options.index = i;\\n          model.trigger('add', model, this, options);\\n        }\\n      }\\n      return this;\\n    },\\n\\n    /**\\n     * Remove a model, or a list of models from the set. Pass silent to avoid\\n     * firing the <code>remove</code> event for every model removed.\\n     *\\n     * @param {Array} models The model or list of models to remove from the\\n     *   collection.\\n     * @param {Object} options An optional object with Backbone-style options.\\n     * Valid options are: <ul>\\n     *   <li>silent: Set to true to avoid firing the `remove` event.\\n     * </ul>\\n     */\\n    remove: function(models, options) {\\n      var i, l, index, model;\\n      options = options || {};\\n      models = _.isArray(models) ? models.slice() : [models];\\n      for (i = 0, l = models.length; i < l; i++) {\\n        model = this.getByCid(models[i]) || this.get(models[i]);\\n        if (!model) {\\n          continue;\\n        }\\n        delete this._byId[model.id];\\n        delete this._byCid[model.cid];\\n        index = this.indexOf(model);\\n        this.models.splice(index, 1);\\n        this.length--;\\n        if (!options.silent) {\\n          options.index = index;\\n          model.trigger('remove', model, this, options);\\n        }\\n        this._removeReference(model);\\n      }\\n      return this;\\n    },\\n\\n    /**\\n     * Gets a model from the set by id.\\n     * @param {String} id The Parse objectId identifying the Parse.Object to\\n     * fetch from this collection.\\n     */\\n    get: function(id) {\\n      return id && this._byId[id.id || id];\\n    },\\n\\n    /**\\n     * Gets a model from the set by client id.\\n     * @param {} cid The Backbone collection id identifying the Parse.Object to\\n     * fetch from this collection.\\n     */\\n    getByCid: function(cid) {\\n      return cid && this._byCid[cid.cid || cid];\\n    },\\n\\n    /**\\n     * Gets the model at the given index.\\n     *\\n     * @param {Number} index The index of the model to return.\\n     */\\n    at: function(index) {\\n      return this.models[index];\\n    },\\n\\n    /**\\n     * Forces the collection to re-sort itself. You don't need to call this\\n     * under normal circumstances, as the set will maintain sort order as each\\n     * item is added.\\n     * @param {Object} options An optional object with Backbone-style options.\\n     * Valid options are: <ul>\\n     *   <li>silent: Set to true to avoid firing the `reset` event.\\n     * </ul>\\n     */\\n    sort: function(options) {\\n      options = options || {};\\n      if (!this.comparator) {\\n        throw new Error('Cannot sort a set without a comparator');\\n      }\\n      var boundComparator = _.bind(this.comparator, this);\\n      if (this.comparator.length === 1) {\\n        this.models = this.sortBy(boundComparator);\\n      } else {\\n        this.models.sort(boundComparator);\\n      }\\n      if (!options.silent) {\\n        this.trigger('reset', this, options);\\n      }\\n      return this;\\n    },\\n\\n    /**\\n     * Plucks an attribute from each model in the collection.\\n     * @param {String} attr The attribute to return from each model in the\\n     * collection.\\n     */\\n    pluck: function(attr) {\\n      return _.map(this.models, function(model){ return model.get(attr); });\\n    },\\n\\n    /**\\n     * When you have more items than you want to add or remove individually,\\n     * you can reset the entire set with a new list of models, without firing\\n     * any `add` or `remove` events. Fires `reset` when finished.\\n     *\\n     * @param {Array} models The model or list of models to remove from the\\n     *   collection.\\n     * @param {Object} options An optional object with Backbone-style options.\\n     * Valid options are: <ul>\\n     *   <li>silent: Set to true to avoid firing the `reset` event.\\n     * </ul>\\n     */\\n    reset: function(models, options) {\\n      var self = this;\\n      models = models || [];\\n      options = options || {};\\n      Parse._arrayEach(this.models, function(model) {\\n        self._removeReference(model);\\n      });\\n      this._reset();\\n      this.add(models, {silent: true, parse: options.parse});\\n      if (!options.silent) {\\n        this.trigger('reset', this, options);\\n      }\\n      return this;\\n    },\\n\\n    /**\\n     * Fetches the default set of models for this collection, resetting the\\n     * collection when they arrive. If `add: true` is passed, appends the\\n     * models to the collection instead of resetting.\\n     *\\n     * @param {Object} options An optional object with Backbone-style options.\\n     * Valid options are:<ul>\\n     *   <li>silent: Set to true to avoid firing `add` or `reset` events for\\n     *   models fetched by this fetch.\\n     *   <li>success: A Backbone-style success callback.\\n     *   <li>error: An Backbone-style error callback.\\n     *   <li>useMasterKey: In Cloud Code and Node only, uses the Master Key for\\n     *       this request.\\n     * </ul>\\n     */\\n    fetch: function(options) {\\n      options = _.clone(options) || {};\\n      if (options.parse === undefined) {\\n        options.parse = true;\\n      }\\n      var collection = this;\\n      var query = this.query || new Parse.Query(this.model);\\n      return query.find({\\n        useMasterKey: options.useMasterKey\\n      }).then(function(results) {\\n        if (options.add) {\\n          collection.add(results, options);\\n        } else {\\n          collection.reset(results, options);\\n        }\\n        return collection;\\n      })._thenRunCallbacks(options, this);\\n    },\\n\\n    /**\\n     * Creates a new instance of a model in this collection. Add the model to\\n     * the collection immediately, unless `wait: true` is passed, in which case\\n     * we wait for the server to agree.\\n     *\\n     * @param {Parse.Object} model The new model to create and add to the\\n     *   collection.\\n     * @param {Object} options An optional object with Backbone-style options.\\n     * Valid options are:<ul>\\n     *   <li>wait: Set to true to wait for the server to confirm creation of the\\n     *       model before adding it to the collection.\\n     *   <li>silent: Set to true to avoid firing an `add` event.\\n     *   <li>success: A Backbone-style success callback.\\n     *   <li>error: An Backbone-style error callback.\\n     *   <li>useMasterKey: In Cloud Code and Node only, uses the Master Key for\\n     *       this request.\\n     * </ul>\\n     */\\n    create: function(model, options) {\\n      var coll = this;\\n      options = options ? _.clone(options) : {};\\n      model = this._prepareModel(model, options);\\n      if (!model) {\\n        return false;\\n      }\\n      if (!options.wait) {\\n        coll.add(model, options);\\n      }\\n      var success = options.success;\\n      options.success = function(nextModel, resp, xhr) {\\n        if (options.wait) {\\n          coll.add(nextModel, options);\\n        }\\n        if (success) {\\n          success(nextModel, resp);\\n        } else {\\n          nextModel.trigger('sync', model, resp, options);\\n        }\\n      };\\n      model.save(null, options);\\n      return model;\\n    },\\n\\n    /**\\n     * Converts a response into a list of models to be added to the collection.\\n     * The default implementation is just to pass it through.\\n     * @ignore\\n     */\\n    parse: function(resp, xhr) {\\n      return resp;\\n    },\\n\\n    /**\\n     * Proxy to _'s chain. Can't be proxied the same way the rest of the\\n     * underscore methods are proxied because it relies on the underscore\\n     * constructor.\\n     */\\n    chain: function() {\\n      return _(this.models).chain();\\n    },\\n\\n    /**\\n     * Reset all internal state. Called when the collection is reset.\\n     */\\n    _reset: function(options) {\\n      this.length = 0;\\n      this.models = [];\\n      this._byId  = {};\\n      this._byCid = {};\\n    },\\n\\n    /**\\n     * Prepare a model or hash of attributes to be added to this collection.\\n     */\\n    _prepareModel: function(model, options) {\\n      if (!(model instanceof Parse.Object)) {\\n        var attrs = model;\\n        options.collection = this;\\n        model = new this.model(attrs, options);\\n        if (!model._validate(model.attributes, options)) {\\n          model = false;\\n        }\\n      } else if (!model.collection) {\\n        model.collection = this;\\n      }\\n      return model;\\n    },\\n\\n    /**\\n     * Internal method to remove a model's ties to a collection.\\n     */\\n    _removeReference: function(model) {\\n      if (this === model.collection) {\\n        delete model.collection;\\n      }\\n      model.off('all', this._onModelEvent, this);\\n    },\\n\\n    /**\\n     * Internal method called every time a model in the set fires an event.\\n     * Sets need to update their indexes when models change ids. All other\\n     * events simply proxy through. \\\"add\\\" and \\\"remove\\\" events that originate\\n     * in other collections are ignored.\\n     */\\n    _onModelEvent: function(ev, model, collection, options) {\\n      if ((ev === 'add' || ev === 'remove') && collection !== this) {\\n        return;\\n      }\\n      if (ev === 'destroy') {\\n        this.remove(model, options);\\n      }\\n      if (model && ev === 'change:objectId') {\\n        delete this._byId[model.previous(\\\"objectId\\\")];\\n        this._byId[model.id] = model;\\n      }\\n      this.trigger.apply(this, arguments);\\n    }\\n\\n  });\\n\\n  // Underscore methods that we want to implement on the Collection.\\n  var methods = ['forEach', 'each', 'map', 'reduce', 'reduceRight', 'find',\\n    'detect', 'filter', 'select', 'reject', 'every', 'all', 'some', 'any',\\n    'include', 'contains', 'invoke', 'max', 'min', 'sortBy', 'sortedIndex',\\n    'toArray', 'size', 'first', 'initial', 'rest', 'last', 'without', 'indexOf',\\n    'shuffle', 'lastIndexOf', 'isEmpty', 'groupBy'];\\n\\n  // Mix in each Underscore method as a proxy to `Collection#models`.\\n  Parse._arrayEach(methods, function(method) {\\n    Parse.Collection.prototype[method] = function() {\\n      return _[method].apply(_, [this.models].concat(_.toArray(arguments)));\\n    };\\n  });\\n\\n  /**\\n   * Creates a new subclass of <code>Parse.Collection</code>.  For example,<pre>\\n   *   var MyCollection = Parse.Collection.extend({\\n   *     // Instance properties\\n   *\\n   *     model: MyClass,\\n   *     query: MyQuery,\\n   *\\n   *     getFirst: function() {\\n   *       return this.at(0);\\n   *     }\\n   *   }, {\\n   *     // Class properties\\n   *\\n   *     makeOne: function() {\\n   *       return new MyCollection();\\n   *     }\\n   *   });\\n   *\\n   *   var collection = new MyCollection();\\n   * </pre>\\n   *\\n   * @function\\n   * @param {Object} instanceProps Instance properties for the collection.\\n   * @param {Object} classProps Class properies for the collection.\\n   * @return {Class} A new subclass of <code>Parse.Collection</code>.\\n   */\\n  Parse.Collection.extend = Parse._extend;\\n\\n}(this));\\n\\n/*global _: false, document: false */\\n(function(root) {\\n  root.Parse = root.Parse || {};\\n  var Parse = root.Parse;\\n  var _ = Parse._;\\n\\n  /**\\n   * Creating a Parse.View creates its initial element outside of the DOM,\\n   * if an existing element is not provided...\\n   * @class\\n   *\\n   * <p>A fork of Backbone.View, provided for your convenience.  If you use this\\n   * class, you must also include jQuery, or another library that provides a\\n   * jQuery-compatible $ function.  For more information, see the\\n   * <a href=\\\"http://documentcloud.github.com/backbone/#View\\\">Backbone\\n   * documentation</a>.</p>\\n   * <p><strong><em>Available in the client SDK only.</em></strong></p>\\n   */\\n  Parse.View = function(options) {\\n    this.cid = _.uniqueId('view');\\n    this._configure(options || {});\\n    this._ensureElement();\\n    this.initialize.apply(this, arguments);\\n    this.delegateEvents();\\n  };\\n\\n  // Cached regex to split keys for `delegate`.\\n  var eventSplitter = /^(\\\\S+)\\\\s*(.*)$/;\\n\\n  // List of view options to be merged as properties.\\n\\n  var viewOptions = ['model', 'collection', 'el', 'id', 'attributes',\\n                     'className', 'tagName'];\\n\\n  // Set up all inheritable **Parse.View** properties and methods.\\n  _.extend(Parse.View.prototype, Parse.Events,\\n           /** @lends Parse.View.prototype */ {\\n\\n    // The default `tagName` of a View's element is `\\\"div\\\"`.\\n    tagName: 'div',\\n\\n    /**\\n     * jQuery delegate for element lookup, scoped to DOM elements within the\\n     * current view. This should be prefered to global lookups where possible.\\n     */\\n    $: function(selector) {\\n      return this.$el.find(selector);\\n    },\\n\\n    /**\\n     * Initialize is an empty function by default. Override it with your own\\n     * initialization logic.\\n     */\\n    initialize: function(){},\\n\\n    /**\\n     * The core function that your view should override, in order\\n     * to populate its element (`this.el`), with the appropriate HTML. The\\n     * convention is for **render** to always return `this`.\\n     */\\n    render: function() {\\n      return this;\\n    },\\n\\n    /**\\n     * Remove this view from the DOM. Note that the view isn't present in the\\n     * DOM by default, so calling this method may be a no-op.\\n     */\\n    remove: function() {\\n      this.$el.remove();\\n      return this;\\n    },\\n\\n    /**\\n     * For small amounts of DOM Elements, where a full-blown template isn't\\n     * needed, use **make** to manufacture elements, one at a time.\\n     * <pre>\\n     *     var el = this.make('li', {'class': 'row'},\\n     *                        this.model.escape('title'));</pre>\\n     */\\n    make: function(tagName, attributes, content) {\\n      var el = document.createElement(tagName);\\n      if (attributes) {\\n        Parse.$(el).attr(attributes);\\n      }\\n      if (content) {\\n        Parse.$(el).html(content);\\n      }\\n      return el;\\n    },\\n\\n    /**\\n     * Changes the view's element (`this.el` property), including event\\n     * re-delegation.\\n     */\\n    setElement: function(element, delegate) {\\n      this.$el = Parse.$(element);\\n      this.el = this.$el[0];\\n      if (delegate !== false) {\\n        this.delegateEvents();\\n      }\\n      return this;\\n    },\\n\\n    /**\\n     * Set callbacks.  <code>this.events</code> is a hash of\\n     * <pre>\\n     * *{\\\"event selector\\\": \\\"callback\\\"}*\\n     *\\n     *     {\\n     *       'mousedown .title':  'edit',\\n     *       'click .button':     'save'\\n     *       'click .open':       function(e) { ... }\\n     *     }\\n     * </pre>\\n     * pairs. Callbacks will be bound to the view, with `this` set properly.\\n     * Uses event delegation for efficiency.\\n     * Omitting the selector binds the event to `this.el`.\\n     * This only works for delegate-able events: not `focus`, `blur`, and\\n     * not `change`, `submit`, and `reset` in Internet Explorer.\\n     */\\n    delegateEvents: function(events) {\\n      events = events || Parse._getValue(this, 'events');\\n      if (!events) {\\n        return;\\n      }\\n      this.undelegateEvents();\\n      var self = this;\\n      Parse._objectEach(events, function(method, key) {\\n        if (!_.isFunction(method)) {\\n          method = self[events[key]];\\n        }\\n        if (!method) {\\n          throw new Error('Event \\\"' + events[key] + '\\\" does not exist');\\n        }\\n        var match = key.match(eventSplitter);\\n        var eventName = match[1], selector = match[2];\\n        method = _.bind(method, self);\\n        eventName += '.delegateEvents' + self.cid;\\n        if (selector === '') {\\n          self.$el.bind(eventName, method);\\n        } else {\\n          self.$el.delegate(selector, eventName, method);\\n        }\\n      });\\n    },\\n\\n    /**\\n     * Clears all callbacks previously bound to the view with `delegateEvents`.\\n     * You usually don't need to use this, but may wish to if you have multiple\\n     * Backbone views attached to the same DOM element.\\n     */\\n    undelegateEvents: function() {\\n      this.$el.unbind('.delegateEvents' + this.cid);\\n    },\\n\\n    /**\\n     * Performs the initial configuration of a View with a set of options.\\n     * Keys with special meaning *(model, collection, id, className)*, are\\n     * attached directly to the view.\\n     */\\n    _configure: function(options) {\\n      if (this.options) {\\n        options = _.extend({}, this.options, options);\\n      }\\n      var self = this;\\n      _.each(viewOptions, function(attr) {\\n        if (options[attr]) {\\n          self[attr] = options[attr];\\n        }\\n      });\\n      this.options = options;\\n    },\\n\\n    /**\\n     * Ensure that the View has a DOM element to render into.\\n     * If `this.el` is a string, pass it through `$()`, take the first\\n     * matching element, and re-assign it to `el`. Otherwise, create\\n     * an element from the `id`, `className` and `tagName` properties.\\n     */\\n    _ensureElement: function() {\\n      if (!this.el) {\\n        var attrs = Parse._getValue(this, 'attributes') || {};\\n        if (this.id) {\\n          attrs.id = this.id;\\n        }\\n        if (this.className) {\\n          attrs['class'] = this.className;\\n        }\\n        this.setElement(this.make(this.tagName, attrs), false);\\n      } else {\\n        this.setElement(this.el, false);\\n      }\\n    }\\n\\n  });\\n\\n  /**\\n   * @function\\n   * @param {Object} instanceProps Instance properties for the view.\\n   * @param {Object} classProps Class properies for the view.\\n   * @return {Class} A new subclass of <code>Parse.View</code>.\\n   */\\n  Parse.View.extend = Parse._extend;\\n\\n}(this));\\n\\n(function(root) {\\n  root.Parse = root.Parse || {};\\n  var Parse = root.Parse;\\n  var _ = Parse._;\\n\\n  /**\\n   * @class\\n   *\\n   * <p>A Parse.User object is a local representation of a user persisted to the\\n   * Parse cloud. This class is a subclass of a Parse.Object, and retains the\\n   * same functionality of a Parse.Object, but also extends it with various\\n   * user specific methods, like authentication, signing up, and validation of\\n   * uniqueness.</p>\\n   */\\n  Parse.User = Parse.Object.extend(\\\"_User\\\", /** @lends Parse.User.prototype */ {\\n    // Instance Variables\\n    _isCurrentUser: false,\\n\\n\\n    // Instance Methods\\n\\n    /**\\n     * Merges another object's attributes into this object.\\n     */\\n    _mergeFromObject: function(other) {\\n      if (other.getSessionToken()) {\\n        this._sessionToken = other.getSessionToken();\\n      }\\n      Parse.User.__super__._mergeFromObject.call(this, other);\\n    },\\n\\n    /**\\n     * Internal method to handle special fields in a _User response.\\n     */\\n    _mergeMagicFields: function(attrs) {\\n      if (attrs.sessionToken) {\\n        this._sessionToken = attrs.sessionToken;\\n        delete attrs.sessionToken;\\n      }\\n      Parse.User.__super__._mergeMagicFields.call(this, attrs);\\n    },\\n\\n    /**\\n     * Removes null values from authData (which exist temporarily for\\n     * unlinking)\\n     */\\n    _cleanupAuthData: function() {\\n      if (!this.isCurrent()) {\\n        return;\\n      }\\n      var authData = this.get('authData');\\n      if (!authData) {\\n        return;\\n      }\\n      Parse._objectEach(this.get('authData'), function(value, key) {\\n        if (!authData[key]) {\\n          delete authData[key];\\n        }\\n      });\\n    },\\n\\n    /**\\n     * Synchronizes authData for all providers.\\n     */\\n    _synchronizeAllAuthData: function() {\\n      var authData = this.get('authData');\\n      if (!authData) {\\n        return;\\n      }\\n\\n      var self = this;\\n      Parse._objectEach(this.get('authData'), function(value, key) {\\n        self._synchronizeAuthData(key);\\n      });\\n    },\\n\\n    /**\\n     * Synchronizes auth data for a provider (e.g. puts the access token in the\\n     * right place to be used by the Facebook SDK).\\n     */\\n    _synchronizeAuthData: function(provider) {\\n      if (!this.isCurrent()) {\\n        return;\\n      }\\n      var authType;\\n      if (_.isString(provider)) {\\n        authType = provider;\\n        provider = Parse.User._authProviders[authType];\\n      } else {\\n        authType = provider.getAuthType();\\n      }\\n      var authData = this.get('authData');\\n      if (!authData || !provider) {\\n        return;\\n      }\\n      var success = provider.restoreAuthentication(authData[authType]);\\n      if (!success) {\\n        this._unlinkFrom(provider);\\n      }\\n    },\\n\\n    _handleSaveResult: function(makeCurrent) {\\n      // Clean up and synchronize the authData object, removing any unset values\\n      if (makeCurrent) {\\n        this._isCurrentUser = true;\\n      }\\n      this._cleanupAuthData();\\n      this._synchronizeAllAuthData();\\n      // Don't keep the password around.\\n      delete this._serverData.password;\\n      this._rebuildEstimatedDataForKey(\\\"password\\\");\\n      this._refreshCache();\\n      if (makeCurrent || this.isCurrent()) {\\n        Parse.User._saveCurrentUser(this);\\n      }\\n    },\\n\\n    /**\\n     * Unlike in the Android/iOS SDKs, logInWith is unnecessary, since you can\\n     * call linkWith on the user (even if it doesn't exist yet on the server).\\n     */\\n    _linkWith: function(provider, options) {\\n      var authType;\\n      if (_.isString(provider)) {\\n        authType = provider;\\n        provider = Parse.User._authProviders[provider];\\n      } else {\\n        authType = provider.getAuthType();\\n      }\\n      if (_.has(options, 'authData')) {\\n        var authData = this.get('authData') || {};\\n        authData[authType] = options.authData;\\n        this.set('authData', authData);\\n\\n        // Overridden so that the user can be made the current user.\\n        var newOptions = _.clone(options) || {};\\n        newOptions.success = function(model) {\\n          model._handleSaveResult(true);\\n          if (options.success) {\\n            options.success.apply(this, arguments);\\n          }\\n        };\\n        return this.save({'authData': authData}, newOptions);\\n      } else {\\n        var self = this;\\n        var promise = new Parse.Promise();\\n        provider.authenticate({\\n          success: function(provider, result) {\\n            self._linkWith(provider, {\\n              authData: result,\\n              success: options.success,\\n              error: options.error\\n            }).then(function() {\\n              promise.resolve(self);\\n            });\\n          },\\n          error: function(provider, error) {\\n            if (options.error) {\\n              options.error(self, error);\\n            }\\n            promise.reject(error);\\n          }\\n        });\\n        return promise;\\n      }\\n    },\\n\\n    /**\\n     * Unlinks a user from a service.\\n     */\\n    _unlinkFrom: function(provider, options) {\\n      var authType;\\n      if (_.isString(provider)) {\\n        authType = provider;\\n        provider = Parse.User._authProviders[provider];\\n      } else {\\n        authType = provider.getAuthType();\\n      }\\n      var newOptions = _.clone(options);\\n      var self = this;\\n      newOptions.authData = null;\\n      newOptions.success = function(model) {\\n        self._synchronizeAuthData(provider);\\n        if (options.success) {\\n          options.success.apply(this, arguments);\\n        }\\n      };\\n      return this._linkWith(provider, newOptions);\\n    },\\n\\n    /**\\n     * Checks whether a user is linked to a service.\\n     */\\n    _isLinked: function(provider) {\\n      var authType;\\n      if (_.isString(provider)) {\\n        authType = provider;\\n      } else {\\n        authType = provider.getAuthType();\\n      }\\n      var authData = this.get('authData') || {};\\n      return !!authData[authType];\\n    },\\n\\n    /**\\n     * Deauthenticates all providers.\\n     */\\n    _logOutWithAll: function() {\\n      var authData = this.get('authData');\\n      if (!authData) {\\n        return;\\n      }\\n      var self = this;\\n      Parse._objectEach(this.get('authData'), function(value, key) {\\n        self._logOutWith(key);\\n      });\\n    },\\n\\n    /**\\n     * Deauthenticates a single provider (e.g. removing access tokens from the\\n     * Facebook SDK).\\n     */\\n    _logOutWith: function(provider) {\\n      if (!this.isCurrent()) {\\n        return;\\n      }\\n      if (_.isString(provider)) {\\n        provider = Parse.User._authProviders[provider];\\n      }\\n      if (provider && provider.deauthenticate) {\\n        provider.deauthenticate();\\n      }\\n    },\\n\\n    /**\\n     * Signs up a new user. You should call this instead of save for\\n     * new Parse.Users. This will create a new Parse.User on the server, and\\n     * also persist the session on disk so that you can access the user using\\n     * <code>current</code>.\\n     *\\n     * <p>A username and password must be set before calling signUp.</p>\\n     *\\n     * <p>Calls options.success or options.error on completion.</p>\\n     *\\n     * @param {Object} attrs Extra fields to set on the new user, or null.\\n     * @param {Object} options A Backbone-style options object.\\n     * @return {Parse.Promise} A promise that is fulfilled when the signup\\n     *     finishes.\\n     * @see Parse.User.signUp\\n     */\\n    signUp: function(attrs, options) {\\n      var error;\\n      options = options || {};\\n\\n      var username = (attrs && attrs.username) || this.get(\\\"username\\\");\\n      if (!username || (username === \\\"\\\")) {\\n        error = new Parse.Error(\\n            Parse.Error.OTHER_CAUSE,\\n            \\\"Cannot sign up user with an empty name.\\\");\\n        if (options && options.error) {\\n          options.error(this, error);\\n        }\\n        return Parse.Promise.error(error);\\n      }\\n\\n      var password = (attrs && attrs.password) || this.get(\\\"password\\\");\\n      if (!password || (password === \\\"\\\")) {\\n        error = new Parse.Error(\\n            Parse.Error.OTHER_CAUSE,\\n            \\\"Cannot sign up user with an empty password.\\\");\\n        if (options && options.error) {\\n          options.error(this, error);\\n        }\\n        return Parse.Promise.error(error);\\n      }\\n\\n      // Overridden so that the user can be made the current user.\\n      var newOptions = _.clone(options);\\n      newOptions.success = function(model) {\\n        model._handleSaveResult(true);\\n        if (options.success) {\\n          options.success.apply(this, arguments);\\n        }\\n      };\\n      return this.save(attrs, newOptions);\\n    },\\n\\n    /**\\n     * Logs in a Parse.User. On success, this saves the session to localStorage,\\n     * so you can retrieve the currently logged in user using\\n     * <code>current</code>.\\n     *\\n     * <p>A username and password must be set before calling logIn.</p>\\n     *\\n     * <p>Calls options.success or options.error on completion.</p>\\n     *\\n     * @param {Object} options A Backbone-style options object.\\n     * @see Parse.User.logIn\\n     * @return {Parse.Promise} A promise that is fulfilled with the user when\\n     *     the login is complete.\\n     */\\n    logIn: function(options) {\\n      var model = this;\\n      options = options || {};\\n      var request = Parse._request({\\n        route: \\\"login\\\",\\n        method: \\\"GET\\\",\\n        useMasterKey: options.useMasterKey,\\n        data: this.toJSON()\\n      });\\n      return request.then(function(resp, status, xhr) {\\n        var serverAttrs = model.parse(resp, status, xhr);\\n        model._finishFetch(serverAttrs);\\n        model._handleSaveResult(true);\\n        return model;\\n      })._thenRunCallbacks(options, this);\\n    },\\n\\n    /**\\n     * @see Parse.Object#save\\n     */\\n    save: function(arg1, arg2, arg3) {\\n      var i, attrs, current, options, saved;\\n      if (_.isObject(arg1) || _.isNull(arg1) || _.isUndefined(arg1)) {\\n        attrs = arg1;\\n        options = arg2;\\n      } else {\\n        attrs = {};\\n        attrs[arg1] = arg2;\\n        options = arg3;\\n      }\\n      options = options || {};\\n\\n      var newOptions = _.clone(options);\\n      newOptions.success = function(model) {\\n        model._handleSaveResult(false);\\n        if (options.success) {\\n          options.success.apply(this, arguments);\\n        }\\n      };\\n      return Parse.Object.prototype.save.call(this, attrs, newOptions);\\n    },\\n\\n    /**\\n     * @see Parse.Object#fetch\\n     */\\n    fetch: function(options) {\\n      var newOptions = options ? _.clone(options) : {};\\n      newOptions.success = function(model) {\\n        model._handleSaveResult(false);\\n        if (options && options.success) {\\n          options.success.apply(this, arguments);\\n        }\\n      };\\n      return Parse.Object.prototype.fetch.call(this, newOptions);\\n    },\\n\\n    /**\\n     * Returns true if <code>current</code> would return this user.\\n     * @see Parse.User#current\\n     */\\n    isCurrent: function() {\\n      return this._isCurrentUser;\\n    },\\n\\n    /**\\n     * Returns get(\\\"username\\\").\\n     * @return {String}\\n     * @see Parse.Object#get\\n     */\\n    getUsername: function() {\\n      return this.get(\\\"username\\\");\\n    },\\n\\n    /**\\n     * Calls set(\\\"username\\\", username, options) and returns the result.\\n     * @param {String} username\\n     * @param {Object} options A Backbone-style options object.\\n     * @return {Boolean}\\n     * @see Parse.Object.set\\n     */\\n    setUsername: function(username, options) {\\n      return this.set(\\\"username\\\", username, options);\\n    },\\n\\n    /**\\n     * Calls set(\\\"password\\\", password, options) and returns the result.\\n     * @param {String} password\\n     * @param {Object} options A Backbone-style options object.\\n     * @return {Boolean}\\n     * @see Parse.Object.set\\n     */\\n    setPassword: function(password, options) {\\n      return this.set(\\\"password\\\", password, options);\\n    },\\n\\n    /**\\n     * Returns get(\\\"email\\\").\\n     * @return {String}\\n     * @see Parse.Object#get\\n     */\\n    getEmail: function() {\\n      return this.get(\\\"email\\\");\\n    },\\n\\n    /**\\n     * Calls set(\\\"email\\\", email, options) and returns the result.\\n     * @param {String} email\\n     * @param {Object} options A Backbone-style options object.\\n     * @return {Boolean}\\n     * @see Parse.Object.set\\n     */\\n    setEmail: function(email, options) {\\n      return this.set(\\\"email\\\", email, options);\\n    },\\n\\n    /**\\n     * Checks whether this user is the current user and has been authenticated.\\n     * @return (Boolean) whether this user is the current user and is logged in.\\n     */\\n    authenticated: function() {\\n      return !!this._sessionToken &&\\n          (Parse.User.current() && Parse.User.current().id === this.id);\\n    },\\n\\n    /**\\n     * Returns the session token for this user, if the user has been logged in,\\n     * or if it is the result of a query with the master key. Otherwise, returns\\n     * undefined.\\n     * @return {String} the session token, or undefined\\n     */\\n    getSessionToken: function() {\\n      return this._sessionToken;\\n    }\\n\\n  }, /** @lends Parse.User */ {\\n    // Class Variables\\n\\n    // The currently logged-in user.\\n    _currentUser: null,\\n\\n    // Whether currentUser is known to match the serialized version on disk.\\n    // This is useful for saving a localstorage check if you try to load\\n    // _currentUser frequently while there is none stored.\\n    _currentUserMatchesDisk: false,\\n\\n    // The localStorage key suffix that the current user is stored under.\\n    _CURRENT_USER_KEY: \\\"currentUser\\\",\\n\\n    // The mapping of auth provider names to actual providers\\n    _authProviders: {},\\n\\n    // Whether to rewrite className User to _User\\n    _performUserRewrite: true,\\n\\n\\n    // Class Methods\\n\\n    /**\\n     * Signs up a new user with a username (or email) and password.\\n     * This will create a new Parse.User on the server, and also persist the\\n     * session in localStorage so that you can access the user using\\n     * {@link #current}.\\n     *\\n     * <p>Calls options.success or options.error on completion.</p>\\n     *\\n     * @param {String} username The username (or email) to sign up with.\\n     * @param {String} password The password to sign up with.\\n     * @param {Object} attrs Extra fields to set on the new user.\\n     * @param {Object} options A Backbone-style options object.\\n     * @return {Parse.Promise} A promise that is fulfilled with the user when\\n     *     the signup completes.\\n     * @see Parse.User#signUp\\n     */\\n    signUp: function(username, password, attrs, options) {\\n      attrs = attrs || {};\\n      attrs.username = username;\\n      attrs.password = password;\\n      var user = Parse.Object._create(\\\"_User\\\");\\n      return user.signUp(attrs, options);\\n    },\\n\\n    /**\\n     * Logs in a user with a username (or email) and password. On success, this\\n     * saves the session to disk, so you can retrieve the currently logged in\\n     * user using <code>current</code>.\\n     *\\n     * <p>Calls options.success or options.error on completion.</p>\\n     *\\n     * @param {String} username The username (or email) to log in with.\\n     * @param {String} password The password to log in with.\\n     * @param {Object} options A Backbone-style options object.\\n     * @return {Parse.Promise} A promise that is fulfilled with the user when\\n     *     the login completes.\\n     * @see Parse.User#logIn\\n     */\\n    logIn: function(username, password, options) {\\n      var user = Parse.Object._create(\\\"_User\\\");\\n      user._finishFetch({ username: username, password: password });\\n      return user.logIn(options);\\n    },\\n\\n    /**\\n     * Logs in a user with a session token. On success, this saves the session\\n     * to disk, so you can retrieve the currently logged in user using\\n     * <code>current</code>.\\n     *\\n     * <p>Calls options.success or options.error on completion.</p>\\n     *\\n     * @param {String} sessionToken The sessionToken to log in with.\\n     * @param {Object} options A Backbone-style options object.\\n     * @return {Parse.Promise} A promise that is fulfilled with the user when\\n     *     the login completes.\\n     */\\n    become: function(sessionToken, options) {\\n      options = options || {};\\n\\n      var user = Parse.Object._create(\\\"_User\\\");\\n      return Parse._request({\\n        route: \\\"users\\\",\\n        className: \\\"me\\\",\\n        method: \\\"GET\\\",\\n        useMasterKey: options.useMasterKey,\\n        sessionToken: sessionToken\\n      }).then(function(resp, status, xhr) {\\n        var serverAttrs = user.parse(resp, status, xhr);\\n        user._finishFetch(serverAttrs);\\n        user._handleSaveResult(true);\\n        return user;\\n\\n      })._thenRunCallbacks(options, user);\\n    },\\n\\n    /**\\n     * Logs out the currently logged in user session. This will remove the\\n     * session from disk, log out of linked services, and future calls to\\n     * <code>current</code> will return <code>null</code>.\\n     */\\n    logOut: function() {\\n      if (Parse.User._currentUser !== null) {\\n        Parse.User._currentUser._logOutWithAll();\\n        Parse.User._currentUser._isCurrentUser = false;\\n      }\\n      Parse.User._currentUserMatchesDisk = true;\\n      Parse.User._currentUser = null;\\n      Parse.localStorage.removeItem(\\n          Parse._getParsePath(Parse.User._CURRENT_USER_KEY));\\n    },\\n\\n    /**\\n     * Requests a password reset email to be sent to the specified email address\\n     * associated with the user account. This email allows the user to securely\\n     * reset their password on the Parse site.\\n     *\\n     * <p>Calls options.success or options.error on completion.</p>\\n     *\\n     * @param {String} email The email address associated with the user that\\n     *     forgot their password.\\n     * @param {Object} options A Backbone-style options object.\\n     */\\n    requestPasswordReset: function(email, options) {\\n      options = options || {};\\n      var request = Parse._request({\\n        route: \\\"requestPasswordReset\\\",\\n        method: \\\"POST\\\",\\n        useMasterKey: options.useMasterKey,\\n        data: { email: email }\\n      });\\n      return request._thenRunCallbacks(options);\\n    },\\n\\n    /**\\n     * Retrieves the currently logged in ParseUser with a valid session,\\n     * either from memory or localStorage, if necessary.\\n     * @return {Parse.Object} The currently logged in Parse.User.\\n     */\\n    current: function() {\\n      if (Parse.User._currentUser) {\\n        return Parse.User._currentUser;\\n      }\\n\\n      if (Parse.User._currentUserMatchesDisk) {\\n\\n        return Parse.User._currentUser;\\n      }\\n\\n      // Load the user from local storage.\\n      Parse.User._currentUserMatchesDisk = true;\\n\\n      var userData = Parse.localStorage.getItem(Parse._getParsePath(\\n          Parse.User._CURRENT_USER_KEY));\\n      if (!userData) {\\n\\n        return null;\\n      }\\n      Parse.User._currentUser = Parse.Object._create(\\\"_User\\\");\\n      Parse.User._currentUser._isCurrentUser = true;\\n\\n      var json = JSON.parse(userData);\\n      Parse.User._currentUser.id = json._id;\\n      delete json._id;\\n      Parse.User._currentUser._sessionToken = json._sessionToken;\\n      delete json._sessionToken;\\n      Parse.User._currentUser._finishFetch(json);\\n\\n      Parse.User._currentUser._synchronizeAllAuthData();\\n      Parse.User._currentUser._refreshCache();\\n      Parse.User._currentUser._opSetQueue = [{}];\\n      return Parse.User._currentUser;\\n    },\\n\\n    /**\\n     * Allow someone to define a custom User class without className\\n     * being rewritten to _User. The default behavior is to rewrite\\n     * User to _User for legacy reasons. This allows developers to\\n     * override that behavior.\\n     *\\n     * @param {Boolean} isAllowed Whether or not to allow custom User class\\n     */\\n    allowCustomUserClass: function(isAllowed) {\\n      this._performUserRewrite = !isAllowed;\\n    },\\n\\n    /**\\n     * Persists a user as currentUser to localStorage, and into the singleton.\\n     */\\n    _saveCurrentUser: function(user) {\\n      if (Parse.User._currentUser !== user) {\\n        Parse.User.logOut();\\n      }\\n      user._isCurrentUser = true;\\n      Parse.User._currentUser = user;\\n      Parse.User._currentUserMatchesDisk = true;\\n\\n      var json = user.toJSON();\\n      json._id = user.id;\\n      json._sessionToken = user._sessionToken;\\n      Parse.localStorage.setItem(\\n          Parse._getParsePath(Parse.User._CURRENT_USER_KEY),\\n          JSON.stringify(json));\\n    },\\n\\n    _registerAuthenticationProvider: function(provider) {\\n      Parse.User._authProviders[provider.getAuthType()] = provider;\\n      // Synchronize the current user with the auth provider.\\n      if (Parse.User.current()) {\\n        Parse.User.current()._synchronizeAuthData(provider.getAuthType());\\n      }\\n    },\\n\\n    _logInWith: function(provider, options) {\\n      var user = Parse.Object._create(\\\"_User\\\");\\n      return user._linkWith(provider, options);\\n    }\\n\\n  });\\n}(this));\\n\\n\\n// Parse.Query is a way to create a list of Parse.Objects.\\n(function(root) {\\n  root.Parse = root.Parse || {};\\n  var Parse = root.Parse;\\n  var _ = Parse._;\\n\\n  /**\\n   * Creates a new parse Parse.Query for the given Parse.Object subclass.\\n   * @param objectClass -\\n   *   An instance of a subclass of Parse.Object, or a Parse className string.\\n   * @class\\n   *\\n   * <p>Parse.Query defines a query that is used to fetch Parse.Objects. The\\n   * most common use case is finding all objects that match a query through the\\n   * <code>find</code> method. For example, this sample code fetches all objects\\n   * of class <code>MyClass</code>. It calls a different function depending on\\n   * whether the fetch succeeded or not.\\n   *\\n   * <pre>\\n   * var query = new Parse.Query(MyClass);\\n   * query.find({\\n   *   success: function(results) {\\n   *     // results is an array of Parse.Object.\\n   *   },\\n   *\\n   *   error: function(error) {\\n   *     // error is an instance of Parse.Error.\\n   *   }\\n   * });</pre></p>\\n   *\\n   * <p>A Parse.Query can also be used to retrieve a single object whose id is\\n   * known, through the get method. For example, this sample code fetches an\\n   * object of class <code>MyClass</code> and id <code>myId</code>. It calls a\\n   * different function depending on whether the fetch succeeded or not.\\n   *\\n   * <pre>\\n   * var query = new Parse.Query(MyClass);\\n   * query.get(myId, {\\n   *   success: function(object) {\\n   *     // object is an instance of Parse.Object.\\n   *   },\\n   *\\n   *   error: function(object, error) {\\n   *     // error is an instance of Parse.Error.\\n   *   }\\n   * });</pre></p>\\n   *\\n   * <p>A Parse.Query can also be used to count the number of objects that match\\n   * the query without retrieving all of those objects. For example, this\\n   * sample code counts the number of objects of the class <code>MyClass</code>\\n   * <pre>\\n   * var query = new Parse.Query(MyClass);\\n   * query.count({\\n   *   success: function(number) {\\n   *     // There are number instances of MyClass.\\n   *   },\\n   *\\n   *   error: function(error) {\\n   *     // error is an instance of Parse.Error.\\n   *   }\\n   * });</pre></p>\\n   */\\n  Parse.Query = function(objectClass) {\\n    if (_.isString(objectClass)) {\\n      objectClass = Parse.Object._getSubclass(objectClass);\\n    }\\n\\n    this.objectClass = objectClass;\\n\\n    this.className = objectClass.prototype.className;\\n\\n    this._where = {};\\n    this._include = [];\\n    this._limit = -1; // negative limit means, do not send a limit\\n    this._skip = 0;\\n    this._extraOptions = {};\\n  };\\n\\n  /**\\n   * Constructs a Parse.Query that is the OR of the passed in queries.  For\\n   * example:\\n   * <pre>var compoundQuery = Parse.Query.or(query1, query2, query3);</pre>\\n   *\\n   * will create a compoundQuery that is an or of the query1, query2, and\\n   * query3.\\n   * @param {...Parse.Query} var_args The list of queries to OR.\\n   * @return {Parse.Query} The query that is the OR of the passed in queries.\\n   */\\n  Parse.Query.or = function() {\\n    var queries = _.toArray(arguments);\\n    var className = null;\\n    Parse._arrayEach(queries, function(q) {\\n      if (_.isNull(className)) {\\n        className = q.className;\\n      }\\n\\n      if (className !== q.className) {\\n        throw \\\"All queries must be for the same class\\\";\\n      }\\n    });\\n    var query = new Parse.Query(className);\\n    query._orQuery(queries);\\n    return query;\\n  };\\n\\n  Parse.Query.prototype = {\\n    /**\\n     * Constructs a Parse.Object whose id is already known by fetching data from\\n     * the server.  Either options.success or options.error is called when the\\n     * find completes.\\n     *\\n     * @param {String} objectId The id of the object to be fetched.\\n     * @param {Object} options A Backbone-style options object.\\n     * Valid options are:<ul>\\n     *   <li>success: A Backbone-style success callback\\n     *   <li>error: An Backbone-style error callback.\\n     *   <li>useMasterKey: In Cloud Code and Node only, causes the Master Key to\\n     *     be used for this request.\\n     * </ul>\\n     */\\n    get: function(objectId, options) {\\n      var self = this;\\n      self.equalTo('objectId', objectId);\\n\\n      var firstOptions = {};\\n      if (options && _.has(options, 'useMasterKey')) {\\n        firstOptions = { useMasterKey: options.useMasterKey };\\n      }\\n\\n      return self.first(firstOptions).then(function(response) {\\n        if (response) {\\n          return response;\\n        }\\n\\n        var errorObject = new Parse.Error(Parse.Error.OBJECT_NOT_FOUND,\\n                                          \\\"Object not found.\\\");\\n        return Parse.Promise.error(errorObject);\\n\\n      })._thenRunCallbacks(options, null);\\n    },\\n\\n    /**\\n     * Returns a JSON representation of this query.\\n     * @return {Object} The JSON representation of the query.\\n     */\\n    toJSON: function() {\\n      var params = {\\n        where: this._where\\n      };\\n\\n      if (this._include.length > 0) {\\n        params.include = this._include.join(\\\",\\\");\\n      }\\n      if (this._select) {\\n        params.keys = this._select.join(\\\",\\\");\\n      }\\n      if (this._limit >= 0) {\\n        params.limit = this._limit;\\n      }\\n      if (this._skip > 0) {\\n        params.skip = this._skip;\\n      }\\n      if (this._order !== undefined) {\\n        params.order = this._order.join(\\\",\\\");\\n      }\\n\\n      Parse._objectEach(this._extraOptions, function(v, k) {\\n        params[k] = v;\\n      });\\n\\n      return params;\\n    },\\n\\n    /**\\n     * Retrieves a list of ParseObjects that satisfy this query.\\n     * Either options.success or options.error is called when the find\\n     * completes.\\n     *\\n     * @param {Object} options A Backbone-style options object. Valid options\\n     * are:<ul>\\n     *   <li>success: Function to call when the find completes successfully.\\n     *   <li>error: Function to call when the find fails.\\n     *   <li>useMasterKey: In Cloud Code and Node only, causes the Master Key to\\n     *     be used for this request.\\n     * </ul>\\n     *\\n     * @return {Parse.Promise} A promise that is resolved with the results when\\n     * the query completes.\\n     */\\n    find: function(options) {\\n      var self = this;\\n      options = options || {};\\n\\n      var request = Parse._request({\\n        route: \\\"classes\\\",\\n        className: this.className,\\n        method: \\\"GET\\\",\\n        useMasterKey: options.useMasterKey,\\n        data: this.toJSON()\\n      });\\n\\n      return request.then(function(response) {\\n        return _.map(response.results, function(json) {\\n          var obj;\\n          if (response.className) {\\n            obj = new Parse.Object(response.className);\\n          } else {\\n            obj = new self.objectClass();\\n          }\\n          obj._finishFetch(json, true);\\n          return obj;\\n        });\\n      })._thenRunCallbacks(options);\\n    },\\n\\n    /**\\n     * Counts the number of objects that match this query.\\n     * Either options.success or options.error is called when the count\\n     * completes.\\n     *\\n     * @param {Object} options A Backbone-style options object. Valid options\\n     * are:<ul>\\n     *   <li>success: Function to call when the count completes successfully.\\n     *   <li>error: Function to call when the find fails.\\n     *   <li>useMasterKey: In Cloud Code and Node only, causes the Master Key to\\n     *     be used for this request.\\n     * </ul>\\n     *\\n     * @return {Parse.Promise} A promise that is resolved with the count when\\n     * the query completes.\\n     */\\n    count: function(options) {\\n      var self = this;\\n      options = options || {};\\n\\n      var params = this.toJSON();\\n      params.limit = 0;\\n      params.count = 1;\\n      var request = Parse._request({\\n        route: \\\"classes\\\",\\n        className: self.className,\\n        method: \\\"GET\\\",\\n        useMasterKey: options.useMasterKey,\\n        data: params\\n      });\\n\\n      return request.then(function(response) {\\n        return response.count;\\n      })._thenRunCallbacks(options);\\n    },\\n\\n    /**\\n     * Retrieves at most one Parse.Object that satisfies this query.\\n     *\\n     * Either options.success or options.error is called when it completes.\\n     * success is passed the object if there is one. otherwise, undefined.\\n     *\\n     * @param {Object} options A Backbone-style options object. Valid options\\n     * are:<ul>\\n     *   <li>success: Function to call when the find completes successfully.\\n     *   <li>error: Function to call when the find fails.\\n     *   <li>useMasterKey: In Cloud Code and Node only, causes the Master Key to\\n     *     be used for this request.\\n     * </ul>\\n     *\\n     * @return {Parse.Promise} A promise that is resolved with the object when\\n     * the query completes.\\n     */\\n    first: function(options) {\\n      var self = this;\\n      options = options || {};\\n\\n      var params = this.toJSON();\\n      params.limit = 1;\\n      var request = Parse._request({\\n        route: \\\"classes\\\",\\n        className: this.className,\\n        method: \\\"GET\\\",\\n        useMasterKey: options.useMasterKey,\\n        data: params\\n      });\\n\\n      return request.then(function(response) {\\n        return _.map(response.results, function(json) {\\n          var obj = new self.objectClass();\\n          obj._finishFetch(json, true);\\n          return obj;\\n        })[0];\\n      })._thenRunCallbacks(options);\\n    },\\n\\n    /**\\n     * Returns a new instance of Parse.Collection backed by this query.\\n     * @param {Array} items An array of instances of <code>Parse.Object</code>\\n     *     with which to start this Collection.\\n     * @param {Object} options An optional object with Backbone-style options.\\n     * Valid options are:<ul>\\n     *   <li>model: The Parse.Object subclass that this collection contains.\\n     *   <li>query: An instance of Parse.Query to use when fetching items.\\n     *   <li>comparator: A string property name or function to sort by.\\n     * </ul>\\n     * @return {Parse.Collection}\\n     */\\n    collection: function(items, options) {\\n      options = options || {};\\n      return new Parse.Collection(items, _.extend(options, {\\n        model: this.objectClass,\\n        query: this\\n      }));\\n    },\\n\\n    /**\\n     * Sets the number of results to skip before returning any results.\\n     * This is useful for pagination.\\n     * Default is to skip zero results.\\n     * @param {Number} n the number of results to skip.\\n     * @return {Parse.Query} Returns the query, so you can chain this call.\\n     */\\n    skip: function(n) {\\n      this._skip = n;\\n      return this;\\n    },\\n\\n    /**\\n     * Sets the limit of the number of results to return. The default limit is\\n     * 100, with a maximum of 1000 results being returned at a time.\\n     * @param {Number} n the number of results to limit to.\\n     * @return {Parse.Query} Returns the query, so you can chain this call.\\n     */\\n    limit: function(n) {\\n      this._limit = n;\\n      return this;\\n    },\\n\\n    /**\\n     * Add a constraint to the query that requires a particular key's value to\\n     * be equal to the provided value.\\n     * @param {String} key The key to check.\\n     * @param value The value that the Parse.Object must contain.\\n     * @return {Parse.Query} Returns the query, so you can chain this call.\\n     */\\n    equalTo: function(key, value) {\\n      if (_.isUndefined(value)) {\\n        return this.doesNotExist(key);\\n      }\\n\\n      this._where[key] = Parse._encode(value);\\n      return this;\\n    },\\n\\n    /**\\n     * Helper for condition queries\\n     */\\n    _addCondition: function(key, condition, value) {\\n      // Check if we already have a condition\\n      if (!this._where[key]) {\\n        this._where[key] = {};\\n      }\\n      this._where[key][condition] = Parse._encode(value);\\n      return this;\\n    },\\n\\n    /**\\n     * Add a constraint to the query that requires a particular key's value to\\n     * be not equal to the provided value.\\n     * @param {String} key The key to check.\\n     * @param value The value that must not be equalled.\\n     * @return {Parse.Query} Returns the query, so you can chain this call.\\n     */\\n    notEqualTo: function(key, value) {\\n      this._addCondition(key, \\\"$ne\\\", value);\\n      return this;\\n    },\\n\\n    /**\\n     * Add a constraint to the query that requires a particular key's value to\\n     * be less than the provided value.\\n     * @param {String} key The key to check.\\n     * @param value The value that provides an upper bound.\\n     * @return {Parse.Query} Returns the query, so you can chain this call.\\n     */\\n    lessThan: function(key, value) {\\n      this._addCondition(key, \\\"$lt\\\", value);\\n      return this;\\n    },\\n\\n    /**\\n     * Add a constraint to the query that requires a particular key's value to\\n     * be greater than the provided value.\\n     * @param {String} key The key to check.\\n     * @param value The value that provides an lower bound.\\n     * @return {Parse.Query} Returns the query, so you can chain this call.\\n     */\\n    greaterThan: function(key, value) {\\n      this._addCondition(key, \\\"$gt\\\", value);\\n      return this;\\n    },\\n\\n    /**\\n     * Add a constraint to the query that requires a particular key's value to\\n     * be less than or equal to the provided value.\\n     * @param {String} key The key to check.\\n     * @param value The value that provides an upper bound.\\n     * @return {Parse.Query} Returns the query, so you can chain this call.\\n     */\\n    lessThanOrEqualTo: function(key, value) {\\n      this._addCondition(key, \\\"$lte\\\", value);\\n      return this;\\n    },\\n\\n    /**\\n     * Add a constraint to the query that requires a particular key's value to\\n     * be greater than or equal to the provided value.\\n     * @param {String} key The key to check.\\n     * @param value The value that provides an lower bound.\\n     * @return {Parse.Query} Returns the query, so you can chain this call.\\n     */\\n    greaterThanOrEqualTo: function(key, value) {\\n      this._addCondition(key, \\\"$gte\\\", value);\\n      return this;\\n    },\\n\\n    /**\\n     * Add a constraint to the query that requires a particular key's value to\\n     * be contained in the provided list of values.\\n     * @param {String} key The key to check.\\n     * @param {Array} values The values that will match.\\n     * @return {Parse.Query} Returns the query, so you can chain this call.\\n     */\\n    containedIn: function(key, values) {\\n      this._addCondition(key, \\\"$in\\\", values);\\n      return this;\\n    },\\n\\n    /**\\n     * Add a constraint to the query that requires a particular key's value to\\n     * not be contained in the provided list of values.\\n     * @param {String} key The key to check.\\n     * @param {Array} values The values that will not match.\\n     * @return {Parse.Query} Returns the query, so you can chain this call.\\n     */\\n    notContainedIn: function(key, values) {\\n      this._addCondition(key, \\\"$nin\\\", values);\\n      return this;\\n    },\\n\\n    /**\\n     * Add a constraint to the query that requires a particular key's value to\\n     * contain each one of the provided list of values.\\n     * @param {String} key The key to check.  This key's value must be an array.\\n     * @param {Array} values The values that will match.\\n     * @return {Parse.Query} Returns the query, so you can chain this call.\\n     */\\n    containsAll: function(key, values) {\\n      this._addCondition(key, \\\"$all\\\", values);\\n      return this;\\n    },\\n\\n\\n    /**\\n     * Add a constraint for finding objects that contain the given key.\\n     * @param {String} key The key that should exist.\\n     * @return {Parse.Query} Returns the query, so you can chain this call.\\n     */\\n    exists: function(key) {\\n      this._addCondition(key, \\\"$exists\\\", true);\\n      return this;\\n    },\\n\\n    /**\\n     * Add a constraint for finding objects that do not contain a given key.\\n     * @param {String} key The key that should not exist\\n     * @return {Parse.Query} Returns the query, so you can chain this call.\\n     */\\n    doesNotExist: function(key) {\\n      this._addCondition(key, \\\"$exists\\\", false);\\n      return this;\\n    },\\n\\n    /**\\n     * Add a regular expression constraint for finding string values that match\\n     * the provided regular expression.\\n     * This may be slow for large datasets.\\n     * @param {String} key The key that the string to match is stored in.\\n     * @param {RegExp} regex The regular expression pattern to match.\\n     * @return {Parse.Query} Returns the query, so you can chain this call.\\n     */\\n    matches: function(key, regex, modifiers) {\\n      this._addCondition(key, \\\"$regex\\\", regex);\\n      if (!modifiers) { modifiers = \\\"\\\"; }\\n      // Javascript regex options support mig as inline options but store them\\n      // as properties of the object. We support mi & should migrate them to\\n      // modifiers\\n      if (regex.ignoreCase) { modifiers += 'i'; }\\n      if (regex.multiline) { modifiers += 'm'; }\\n\\n      if (modifiers && modifiers.length) {\\n        this._addCondition(key, \\\"$options\\\", modifiers);\\n      }\\n      return this;\\n    },\\n\\n    /**\\n     * Add a constraint that requires that a key's value matches a Parse.Query\\n     * constraint.\\n     * @param {String} key The key that the contains the object to match the\\n     *                     query.\\n     * @param {Parse.Query} query The query that should match.\\n     * @return {Parse.Query} Returns the query, so you can chain this call.\\n     */\\n    matchesQuery: function(key, query) {\\n      var queryJSON = query.toJSON();\\n      queryJSON.className = query.className;\\n      this._addCondition(key, \\\"$inQuery\\\", queryJSON);\\n      return this;\\n    },\\n\\n   /**\\n     * Add a constraint that requires that a key's value not matches a\\n     * Parse.Query constraint.\\n     * @param {String} key The key that the contains the object to match the\\n     *                     query.\\n     * @param {Parse.Query} query The query that should not match.\\n     * @return {Parse.Query} Returns the query, so you can chain this call.\\n     */\\n    doesNotMatchQuery: function(key, query) {\\n      var queryJSON = query.toJSON();\\n      queryJSON.className = query.className;\\n      this._addCondition(key, \\\"$notInQuery\\\", queryJSON);\\n      return this;\\n    },\\n\\n\\n    /**\\n     * Add a constraint that requires that a key's value matches a value in\\n     * an object returned by a different Parse.Query.\\n     * @param {String} key The key that contains the value that is being\\n     *                     matched.\\n     * @param {String} queryKey The key in the objects returned by the query to\\n     *                          match against.\\n     * @param {Parse.Query} query The query to run.\\n     * @return {Parse.Query} Returns the query, so you can chain this call.\\n     */\\n    matchesKeyInQuery: function(key, queryKey, query) {\\n      var queryJSON = query.toJSON();\\n      queryJSON.className = query.className;\\n      this._addCondition(key, \\\"$select\\\",\\n                         { key: queryKey, query: queryJSON });\\n      return this;\\n    },\\n\\n    /**\\n     * Add a constraint that requires that a key's value not match a value in\\n     * an object returned by a different Parse.Query.\\n     * @param {String} key The key that contains the value that is being\\n     *                     excluded.\\n     * @param {String} queryKey The key in the objects returned by the query to\\n     *                          match against.\\n     * @param {Parse.Query} query The query to run.\\n     * @return {Parse.Query} Returns the query, so you can chain this call.\\n     */\\n    doesNotMatchKeyInQuery: function(key, queryKey, query) {\\n      var queryJSON = query.toJSON();\\n      queryJSON.className = query.className;\\n      this._addCondition(key, \\\"$dontSelect\\\",\\n                         { key: queryKey, query: queryJSON });\\n      return this;\\n    },\\n\\n    /**\\n     * Add constraint that at least one of the passed in queries matches.\\n     * @param {Array} queries\\n     * @return {Parse.Query} Returns the query, so you can chain this call.\\n     */\\n    _orQuery: function(queries) {\\n      var queryJSON = _.map(queries, function(q) {\\n        return q.toJSON().where;\\n      });\\n\\n      this._where.$or = queryJSON;\\n      return this;\\n    },\\n\\n    /**\\n     * Converts a string into a regex that matches it.\\n     * Surrounding with \\\\Q .. \\\\E does this, we just need to escape \\\\E's in\\n     * the text separately.\\n     */\\n    _quote: function(s) {\\n      return \\\"\\\\\\\\Q\\\" + s.replace(\\\"\\\\\\\\E\\\", \\\"\\\\\\\\E\\\\\\\\\\\\\\\\E\\\\\\\\Q\\\") + \\\"\\\\\\\\E\\\";\\n    },\\n\\n    /**\\n     * Add a constraint for finding string values that contain a provided\\n     * string.  This may be slow for large datasets.\\n     * @param {String} key The key that the string to match is stored in.\\n     * @param {String} substring The substring that the value must contain.\\n     * @return {Parse.Query} Returns the query, so you can chain this call.\\n     */\\n    contains: function(key, value) {\\n      this._addCondition(key, \\\"$regex\\\", this._quote(value));\\n      return this;\\n    },\\n\\n    /**\\n     * Add a constraint for finding string values that start with a provided\\n     * string.  This query will use the backend index, so it will be fast even\\n     * for large datasets.\\n     * @param {String} key The key that the string to match is stored in.\\n     * @param {String} prefix The substring that the value must start with.\\n     * @return {Parse.Query} Returns the query, so you can chain this call.\\n     */\\n    startsWith: function(key, value) {\\n      this._addCondition(key, \\\"$regex\\\", \\\"^\\\" + this._quote(value));\\n      return this;\\n    },\\n\\n    /**\\n     * Add a constraint for finding string values that end with a provided\\n     * string.  This will be slow for large datasets.\\n     * @param {String} key The key that the string to match is stored in.\\n     * @param {String} suffix The substring that the value must end with.\\n     * @return {Parse.Query} Returns the query, so you can chain this call.\\n     */\\n    endsWith: function(key, value) {\\n      this._addCondition(key, \\\"$regex\\\", this._quote(value) + \\\"$\\\");\\n      return this;\\n    },\\n\\n    /**\\n     * Sorts the results in ascending order by the given key.\\n     *\\n     * @param {(String|String[]|...String} key The key to order by, which is a\\n     * string of comma separated values, or an Array of keys, or multiple keys.\\n     * @return {Parse.Query} Returns the query, so you can chain this call.\\n     */\\n    ascending: function() {\\n      this._order = [];\\n      return this.addAscending.apply(this, arguments);\\n    },\\n\\n    /**\\n     * Sorts the results in ascending order by the given key,\\n     * but can also add secondary sort descriptors without overwriting _order.\\n     *\\n     * @param {(String|String[]|...String} key The key to order by, which is a\\n     * string of comma separated values, or an Array of keys, or multiple keys.\\n     * @return {Parse.Query} Returns the query, so you can chain this call.\\n     */\\n    addAscending: function(key) {\\n      var self = this;\\n      if (!this._order) {\\n        this._order = [];\\n      }\\n      Parse._arrayEach(arguments, function(key) {\\n        if (Array.isArray(key)) {\\n          key = key.join();\\n        }\\n        self._order = self._order.concat(key.replace(/\\\\s/g, \\\"\\\").split(\\\",\\\"));\\n      });\\n      return this;\\n    },\\n\\n    /**\\n     * Sorts the results in descending order by the given key.\\n     *\\n     * @param {(String|String[]|...String} key The key to order by, which is a\\n     * string of comma separated values, or an Array of keys, or multiple keys.\\n     * @return {Parse.Query} Returns the query, so you can chain this call.\\n     */\\n    descending: function(key) {\\n      this._order = [];\\n      return this.addDescending.apply(this, arguments);\\n    },\\n\\n    /**\\n     * Sorts the results in descending order by the given key,\\n     * but can also add secondary sort descriptors without overwriting _order.\\n     *\\n     * @param {(String|String[]|...String} key The key to order by, which is a\\n     * string of comma separated values, or an Array of keys, or multiple keys.\\n     * @return {Parse.Query} Returns the query, so you can chain this call.\\n     */\\n    addDescending: function(key) {\\n      var self = this;\\n      if (!this._order) {\\n        this._order = [];\\n      }\\n      Parse._arrayEach(arguments, function(key) {\\n        if (Array.isArray(key)) {\\n          key = key.join();\\n        }\\n        self._order = self._order.concat(\\n          _.map(key.replace(/\\\\s/g, \\\"\\\").split(\\\",\\\"),\\n            function(k) { return \\\"-\\\" + k; }));\\n      });\\n      return this;\\n    },\\n\\n    /**\\n     * Add a proximity based constraint for finding objects with key point\\n     * values near the point given.\\n     * @param {String} key The key that the Parse.GeoPoint is stored in.\\n     * @param {Parse.GeoPoint} point The reference Parse.GeoPoint that is used.\\n     * @return {Parse.Query} Returns the query, so you can chain this call.\\n     */\\n    near: function(key, point) {\\n      if (!(point instanceof Parse.GeoPoint)) {\\n        // Try to cast it to a GeoPoint, so that near(\\\"loc\\\", [20,30]) works.\\n        point = new Parse.GeoPoint(point);\\n      }\\n      this._addCondition(key, \\\"$nearSphere\\\", point);\\n      return this;\\n    },\\n\\n    /**\\n     * Add a proximity based constraint for finding objects with key point\\n     * values near the point given and within the maximum distance given.\\n     * @param {String} key The key that the Parse.GeoPoint is stored in.\\n     * @param {Parse.GeoPoint} point The reference Parse.GeoPoint that is used.\\n     * @param {Number} maxDistance Maximum distance (in radians) of results to\\n     *   return.\\n     * @return {Parse.Query} Returns the query, so you can chain this call.\\n     */\\n    withinRadians: function(key, point, distance) {\\n      this.near(key, point);\\n      this._addCondition(key, \\\"$maxDistance\\\", distance);\\n      return this;\\n    },\\n\\n    /**\\n     * Add a proximity based constraint for finding objects with key point\\n     * values near the point given and within the maximum distance given.\\n     * Radius of earth used is 3958.8 miles.\\n     * @param {String} key The key that the Parse.GeoPoint is stored in.\\n     * @param {Parse.GeoPoint} point The reference Parse.GeoPoint that is used.\\n     * @param {Number} maxDistance Maximum distance (in miles) of results to\\n     *     return.\\n     * @return {Parse.Query} Returns the query, so you can chain this call.\\n     */\\n    withinMiles: function(key, point, distance) {\\n      return this.withinRadians(key, point, distance / 3958.8);\\n    },\\n\\n    /**\\n     * Add a proximity based constraint for finding objects with key point\\n     * values near the point given and within the maximum distance given.\\n     * Radius of earth used is 6371.0 kilometers.\\n     * @param {String} key The key that the Parse.GeoPoint is stored in.\\n     * @param {Parse.GeoPoint} point The reference Parse.GeoPoint that is used.\\n     * @param {Number} maxDistance Maximum distance (in kilometers) of results\\n     *     to return.\\n     * @return {Parse.Query} Returns the query, so you can chain this call.\\n     */\\n    withinKilometers: function(key, point, distance) {\\n      return this.withinRadians(key, point, distance / 6371.0);\\n    },\\n\\n    /**\\n     * Add a constraint to the query that requires a particular key's\\n     * coordinates be contained within a given rectangular geographic bounding\\n     * box.\\n     * @param {String} key The key to be constrained.\\n     * @param {Parse.GeoPoint} southwest\\n     *     The lower-left inclusive corner of the box.\\n     * @param {Parse.GeoPoint} northeast\\n     *     The upper-right inclusive corner of the box.\\n     * @return {Parse.Query} Returns the query, so you can chain this call.\\n     */\\n    withinGeoBox: function(key, southwest, northeast) {\\n      if (!(southwest instanceof Parse.GeoPoint)) {\\n        southwest = new Parse.GeoPoint(southwest);\\n      }\\n      if (!(northeast instanceof Parse.GeoPoint)) {\\n        northeast = new Parse.GeoPoint(northeast);\\n      }\\n      this._addCondition(key, '$within', { '$box': [southwest, northeast] });\\n      return this;\\n    },\\n\\n    /**\\n     * Include nested Parse.Objects for the provided key.  You can use dot\\n     * notation to specify which fields in the included object are also fetch.\\n     * @param {String} key The name of the key to include.\\n     * @return {Parse.Query} Returns the query, so you can chain this call.\\n     */\\n    include: function() {\\n      var self = this;\\n      Parse._arrayEach(arguments, function(key) {\\n        if (_.isArray(key)) {\\n          self._include = self._include.concat(key);\\n        } else {\\n          self._include.push(key);\\n        }\\n      });\\n      return this;\\n    },\\n\\n    /**\\n     * Restrict the fields of the returned Parse.Objects to include only the\\n     * provided keys.  If this is called multiple times, then all of the keys\\n     * specified in each of the calls will be included.\\n     * @param {Array} keys The names of the keys to include.\\n     * @return {Parse.Query} Returns the query, so you can chain this call.\\n     */\\n    select: function() {\\n      var self = this;\\n      this._select = this._select || [];\\n      Parse._arrayEach(arguments, function(key) {\\n        if (_.isArray(key)) {\\n          self._select = self._select.concat(key);\\n        } else {\\n          self._select.push(key);\\n        }\\n      });\\n      return this;\\n    },\\n\\n    /**\\n     * Iterates over each result of a query, calling a callback for each one. If\\n     * the callback returns a promise, the iteration will not continue until\\n     * that promise has been fulfilled. If the callback returns a rejected\\n     * promise, then iteration will stop with that error. The items are\\n     * processed in an unspecified order. The query may not have any sort order,\\n     * and may not use limit or skip.\\n     * @param {Function} callback Callback that will be called with each result\\n     *     of the query.\\n     * @param {Object} options An optional Backbone-like options object with\\n     *     success and error callbacks that will be invoked once the iteration\\n     *     has finished.\\n     * @return {Parse.Promise} A promise that will be fulfilled once the\\n     *     iteration has completed.\\n     */\\n    each: function(callback, options) {\\n      options = options || {};\\n\\n      if (this._order || this._skip || (this._limit >= 0)) {\\n        var error =\\n          \\\"Cannot iterate on a query with sort, skip, or limit.\\\";\\n        return Parse.Promise.error(error)._thenRunCallbacks(options);\\n      }\\n\\n      var promise = new Parse.Promise();\\n\\n      var query = new Parse.Query(this.objectClass);\\n      // We can override the batch size from the options.\\n      // This is undocumented, but useful for testing.\\n      query._limit = options.batchSize || 100;\\n      query._where = _.clone(this._where);\\n      query._include = _.clone(this._include);\\n\\n      query.ascending('objectId');\\n\\n      var finished = false;\\n      return Parse.Promise._continueWhile(function() {\\n        return !finished;\\n\\n      }, function() {\\n        return query.find().then(function(results) {\\n          var callbacksDone = Parse.Promise.as();\\n          Parse._.each(results, function(result) {\\n            callbacksDone = callbacksDone.then(function() {\\n              return callback(result);\\n            });\\n          });\\n\\n          return callbacksDone.then(function() {\\n            if (results.length >= query._limit) {\\n              query.greaterThan(\\\"objectId\\\", results[results.length - 1].id);\\n            } else {\\n              finished = true;\\n            }\\n          });\\n        });\\n      })._thenRunCallbacks(options);\\n    }\\n  };\\n\\n}(this));\\n\\n/*global FB: false , console: false*/\\n(function(root) {\\n  root.Parse = root.Parse || {};\\n  var Parse = root.Parse;\\n  var _ = Parse._;\\n\\n  var PUBLIC_KEY = \\\"*\\\";\\n\\n  var initialized = false;\\n  var requestedPermissions;\\n  var initOptions;\\n  var provider = {\\n    authenticate: function(options) {\\n      var self = this;\\n      FB.login(function(response) {\\n        if (response.authResponse) {\\n          if (options.success) {\\n            options.success(self, {\\n              id: response.authResponse.userID,\\n              access_token: response.authResponse.accessToken,\\n              expiration_date: new Date(response.authResponse.expiresIn * 1000 +\\n                  (new Date()).getTime()).toJSON()\\n            });\\n          }\\n        } else {\\n          if (options.error) {\\n            options.error(self, response);\\n          }\\n        }\\n      }, {\\n        scope: requestedPermissions\\n      });\\n    },\\n    restoreAuthentication: function(authData) {\\n      if (authData) {\\n        var authResponse = {\\n          userID: authData.id,\\n          accessToken: authData.access_token,\\n          expiresIn: (Parse._parseDate(authData.expiration_date).getTime() -\\n              (new Date()).getTime()) / 1000\\n        };\\n        var newOptions = _.clone(initOptions);\\n        newOptions.authResponse = authResponse;\\n\\n        // Suppress checks for login status from the browser.\\n        newOptions.status = false;\\n\\n        // If the user doesn't match the one known by the FB SDK, log out.\\n        // Most of the time, the users will match -- it's only in cases where\\n        // the FB SDK knows of a different user than the one being restored\\n        // from a Parse User that logged in with username/password.\\n        var existingResponse = FB.getAuthResponse();\\n        if (existingResponse &&\\n            existingResponse.userID !== authResponse.userID) {\\n          FB.logout();\\n        }\\n\\n        FB.init(newOptions);\\n      }\\n      return true;\\n    },\\n    getAuthType: function() {\\n      return \\\"facebook\\\";\\n    },\\n    deauthenticate: function() {\\n      this.restoreAuthentication(null);\\n    }\\n  };\\n\\n  /**\\n   * Provides a set of utilities for using Parse with Facebook.\\n   * @namespace\\n   * Provides a set of utilities for using Parse with Facebook.\\n   */\\n  Parse.FacebookUtils = {\\n    /**\\n     * Initializes Parse Facebook integration.  Call this function after you\\n     * have loaded the Facebook Javascript SDK with the same parameters\\n     * as you would pass to<code>\\n     * <a href=\\n     * \\\"https://developers.facebook.com/docs/reference/javascript/FB.init/\\\">\\n     * FB.init()</a></code>.  Parse.FacebookUtils will invoke FB.init() for you\\n     * with these arguments.\\n     *\\n     * @param {Object} options Facebook options argument as described here:\\n     *   <a href=\\n     *   \\\"https://developers.facebook.com/docs/reference/javascript/FB.init/\\\">\\n     *   FB.init()</a>. The status flag will be coerced to 'false' because it\\n     *   interferes with Parse Facebook integration. Call FB.getLoginStatus()\\n     *   explicitly if this behavior is required by your application.\\n     */\\n    init: function(options) {\\n      if (typeof(FB) === 'undefined') {\\n        throw \\\"The Facebook JavaScript SDK must be loaded before calling init.\\\";\\n      }\\n      initOptions = _.clone(options) || {};\\n      if (initOptions.status && typeof(console) !== \\\"undefined\\\") {\\n        var warn = console.warn || console.log || function() {};\\n        warn.call(console, \\\"The 'status' flag passed into\\\" +\\n          \\\" FB.init, when set to true, can interfere with Parse Facebook\\\" +\\n          \\\" integration, so it has been suppressed. Please call\\\" +\\n          \\\" FB.getLoginStatus() explicitly if you require this behavior.\\\");\\n      }\\n      initOptions.status = false;\\n      FB.init(initOptions);\\n      Parse.User._registerAuthenticationProvider(provider);\\n      initialized = true;\\n    },\\n\\n    /**\\n     * Gets whether the user has their account linked to Facebook.\\n     *\\n     * @param {Parse.User} user User to check for a facebook link.\\n     *     The user must be logged in on this device.\\n     * @return {Boolean} <code>true</code> if the user has their account\\n     *     linked to Facebook.\\n     */\\n    isLinked: function(user) {\\n      return user._isLinked(\\\"facebook\\\");\\n    },\\n\\n    /**\\n     * Logs in a user using Facebook. This method delegates to the Facebook\\n     * SDK to authenticate the user, and then automatically logs in (or\\n     * creates, in the case where it is a new user) a Parse.User.\\n     *\\n     * @param {String, Object} permissions The permissions required for Facebook\\n     *    log in.  This is a comma-separated string of permissions.\\n     *    Alternatively, supply a Facebook authData object as described in our\\n     *    REST API docs if you want to handle getting facebook auth tokens\\n     *    yourself.\\n     * @param {Object} options Standard options object with success and error\\n     *    callbacks.\\n     */\\n    logIn: function(permissions, options) {\\n      if (!permissions || _.isString(permissions)) {\\n        if (!initialized) {\\n          throw \\\"You must initialize FacebookUtils before calling logIn.\\\";\\n        }\\n        requestedPermissions = permissions;\\n        return Parse.User._logInWith(\\\"facebook\\\", options);\\n      } else {\\n        var newOptions = _.clone(options) || {};\\n        newOptions.authData = permissions;\\n        return Parse.User._logInWith(\\\"facebook\\\", newOptions);\\n      }\\n    },\\n\\n    /**\\n     * Links Facebook to an existing PFUser. This method delegates to the\\n     * Facebook SDK to authenticate the user, and then automatically links\\n     * the account to the Parse.User.\\n     *\\n     * @param {Parse.User} user User to link to Facebook. This must be the\\n     *     current user.\\n     * @param {String, Object} permissions The permissions required for Facebook\\n     *    log in.  This is a comma-separated string of permissions.\\n     *    Alternatively, supply a Facebook authData object as described in our\\n     *    REST API docs if you want to handle getting facebook auth tokens\\n     *    yourself.\\n     * @param {Object} options Standard options object with success and error\\n     *    callbacks.\\n     */\\n    link: function(user, permissions, options) {\\n      if (!permissions || _.isString(permissions)) {\\n        if (!initialized) {\\n          throw \\\"You must initialize FacebookUtils before calling link.\\\";\\n        }\\n        requestedPermissions = permissions;\\n        return user._linkWith(\\\"facebook\\\", options);\\n      } else {\\n        var newOptions = _.clone(options) || {};\\n        newOptions.authData = permissions;\\n        return user._linkWith(\\\"facebook\\\", newOptions);\\n      }\\n    },\\n\\n    /**\\n     * Unlinks the Parse.User from a Facebook account.\\n     *\\n     * @param {Parse.User} user User to unlink from Facebook. This must be the\\n     *     current user.\\n     * @param {Object} options Standard options object with success and error\\n     *    callbacks.\\n     */\\n    unlink: function(user, options) {\\n      if (!initialized) {\\n        throw \\\"You must initialize FacebookUtils before calling unlink.\\\";\\n      }\\n      return user._unlinkFrom(\\\"facebook\\\", options);\\n    }\\n  };\\n\\n}(this));\\n\\n/*global _: false, document: false, window: false, navigator: false */\\n(function(root) {\\n  root.Parse = root.Parse || {};\\n  var Parse = root.Parse;\\n  var _ = Parse._;\\n\\n  /**\\n   * History serves as a global router (per frame) to handle hashchange\\n   * events or pushState, match the appropriate route, and trigger\\n   * callbacks. You shouldn't ever have to create one of these yourself\\n   *  you should use the reference to <code>Parse.history</code>\\n   * that will be created for you automatically if you make use of\\n   * Routers with routes.\\n   * @class\\n   *\\n   * <p>A fork of Backbone.History, provided for your convenience.  If you\\n   * use this class, you must also include jQuery, or another library\\n   * that provides a jQuery-compatible $ function.  For more information,\\n   * see the <a href=\\\"http://documentcloud.github.com/backbone/#History\\\">\\n   * Backbone documentation</a>.</p>\\n   * <p><strong><em>Available in the client SDK only.</em></strong></p>\\n   */\\n  Parse.History = function() {\\n    this.handlers = [];\\n    _.bindAll(this, 'checkUrl');\\n  };\\n\\n  // Cached regex for cleaning leading hashes and slashes .\\n  var routeStripper = /^[#\\\\/]/;\\n\\n  // Cached regex for detecting MSIE.\\n  var isExplorer = /msie [\\\\w.]+/;\\n\\n  // Has the history handling already been started?\\n  Parse.History.started = false;\\n\\n  // Set up all inheritable **Parse.History** properties and methods.\\n  _.extend(Parse.History.prototype, Parse.Events,\\n           /** @lends Parse.History.prototype */ {\\n\\n    // The default interval to poll for hash changes, if necessary, is\\n    // twenty times a second.\\n    interval: 50,\\n\\n    // Gets the true hash value. Cannot use location.hash directly due to bug\\n    // in Firefox where location.hash will always be decoded.\\n    getHash: function(windowOverride) {\\n      var loc = windowOverride ? windowOverride.location : window.location;\\n      var match = loc.href.match(/#(.*)$/);\\n      return match ? match[1] : '';\\n    },\\n\\n    // Get the cross-browser normalized URL fragment, either from the URL,\\n    // the hash, or the override.\\n    getFragment: function(fragment, forcePushState) {\\n      if (Parse._isNullOrUndefined(fragment)) {\\n        if (this._hasPushState || forcePushState) {\\n          fragment = window.location.pathname;\\n          var search = window.location.search;\\n          if (search) {\\n            fragment += search;\\n          }\\n        } else {\\n          fragment = this.getHash();\\n        }\\n      }\\n      if (!fragment.indexOf(this.options.root)) {\\n        fragment = fragment.substr(this.options.root.length);\\n      }\\n      return fragment.replace(routeStripper, '');\\n    },\\n\\n    /**\\n     * Start the hash change handling, returning `true` if the current\\n     * URL matches an existing route, and `false` otherwise.\\n     */\\n    start: function(options) {\\n      if (Parse.History.started) {\\n        throw new Error(\\\"Parse.history has already been started\\\");\\n      }\\n      Parse.History.started = true;\\n\\n      // Figure out the initial configuration. Do we need an iframe?\\n      // Is pushState desired ... is it available?\\n      this.options = _.extend({}, {root: '/'}, this.options, options);\\n      this._wantsHashChange = this.options.hashChange !== false;\\n      this._wantsPushState = !!this.options.pushState;\\n      this._hasPushState = !!(this.options.pushState &&\\n                              window.history &&\\n                              window.history.pushState);\\n      var fragment = this.getFragment();\\n      var docMode = document.documentMode;\\n      var oldIE = (isExplorer.exec(navigator.userAgent.toLowerCase()) &&\\n                   (!docMode || docMode <= 7));\\n\\n      if (oldIE) {\\n        this.iframe = Parse.$('<iframe src=\\\"javascript:0\\\" tabindex=\\\"-1\\\" />')\\n                      .hide().appendTo('body')[0].contentWindow;\\n        this.navigate(fragment);\\n      }\\n\\n      // Depending on whether we're using pushState or hashes, and whether\\n      // 'onhashchange' is supported, determine how we check the URL state.\\n      if (this._hasPushState) {\\n        Parse.$(window).bind('popstate', this.checkUrl);\\n      } else if (this._wantsHashChange &&\\n                 ('onhashchange' in window) &&\\n                 !oldIE) {\\n        Parse.$(window).bind('hashchange', this.checkUrl);\\n      } else if (this._wantsHashChange) {\\n        this._checkUrlInterval = window.setInterval(this.checkUrl,\\n                                                    this.interval);\\n      }\\n\\n      // Determine if we need to change the base url, for a pushState link\\n      // opened by a non-pushState browser.\\n      this.fragment = fragment;\\n      var loc = window.location;\\n      var atRoot  = loc.pathname === this.options.root;\\n\\n      // If we've started off with a route from a `pushState`-enabled browser,\\n      // but we're currently in a browser that doesn't support it...\\n      if (this._wantsHashChange &&\\n          this._wantsPushState &&\\n          !this._hasPushState &&\\n          !atRoot) {\\n        this.fragment = this.getFragment(null, true);\\n        window.location.replace(this.options.root + '#' + this.fragment);\\n        // Return immediately as browser will do redirect to new url\\n        return true;\\n\\n      // Or if we've started out with a hash-based route, but we're currently\\n      // in a browser where it could be `pushState`-based instead...\\n      } else if (this._wantsPushState &&\\n                 this._hasPushState &&\\n                 atRoot &&\\n                 loc.hash) {\\n        this.fragment = this.getHash().replace(routeStripper, '');\\n        window.history.replaceState({}, document.title,\\n            loc.protocol + '//' + loc.host + this.options.root + this.fragment);\\n      }\\n\\n      if (!this.options.silent) {\\n        return this.loadUrl();\\n      }\\n    },\\n\\n    // Disable Parse.history, perhaps temporarily. Not useful in a real app,\\n    // but possibly useful for unit testing Routers.\\n    stop: function() {\\n      Parse.$(window).unbind('popstate', this.checkUrl)\\n                     .unbind('hashchange', this.checkUrl);\\n      window.clearInterval(this._checkUrlInterval);\\n      Parse.History.started = false;\\n    },\\n\\n    // Add a route to be tested when the fragment changes. Routes added later\\n    // may override previous routes.\\n    route: function(route, callback) {\\n      this.handlers.unshift({route: route, callback: callback});\\n    },\\n\\n    // Checks the current URL to see if it has changed, and if it has,\\n    // calls `loadUrl`, normalizing across the hidden iframe.\\n    checkUrl: function(e) {\\n      var current = this.getFragment();\\n      if (current === this.fragment && this.iframe) {\\n        current = this.getFragment(this.getHash(this.iframe));\\n      }\\n      if (current === this.fragment) {\\n        return false;\\n      }\\n      if (this.iframe) {\\n        this.navigate(current);\\n      }\\n      if (!this.loadUrl()) {\\n        this.loadUrl(this.getHash());\\n      }\\n    },\\n\\n    // Attempt to load the current URL fragment. If a route succeeds with a\\n    // match, returns `true`. If no defined routes matches the fragment,\\n    // returns `false`.\\n    loadUrl: function(fragmentOverride) {\\n      var fragment = this.fragment = this.getFragment(fragmentOverride);\\n      var matched = _.any(this.handlers, function(handler) {\\n        if (handler.route.test(fragment)) {\\n          handler.callback(fragment);\\n          return true;\\n        }\\n      });\\n      return matched;\\n    },\\n\\n    // Save a fragment into the hash history, or replace the URL state if the\\n    // 'replace' option is passed. You are responsible for properly URL-encoding\\n    // the fragment in advance.\\n    //\\n    // The options object can contain `trigger: true` if you wish to have the\\n    // route callback be fired (not usually desirable), or `replace: true`, if\\n    // you wish to modify the current URL without adding an entry to the\\n    // history.\\n    navigate: function(fragment, options) {\\n      if (!Parse.History.started) {\\n        return false;\\n      }\\n      if (!options || options === true) {\\n        options = {trigger: options};\\n      }\\n      var frag = (fragment || '').replace(routeStripper, '');\\n      if (this.fragment === frag) {\\n        return;\\n      }\\n\\n      // If pushState is available, we use it to set the fragment as a real URL.\\n      if (this._hasPushState) {\\n        if (frag.indexOf(this.options.root) !== 0) {\\n          frag = this.options.root + frag;\\n        }\\n        this.fragment = frag;\\n        var replaceOrPush = options.replace ? 'replaceState' : 'pushState';\\n        window.history[replaceOrPush]({}, document.title, frag);\\n\\n      // If hash changes haven't been explicitly disabled, update the hash\\n      // fragment to store history.\\n      } else if (this._wantsHashChange) {\\n        this.fragment = frag;\\n        this._updateHash(window.location, frag, options.replace);\\n        if (this.iframe &&\\n            (frag !== this.getFragment(this.getHash(this.iframe)))) {\\n          // Opening and closing the iframe tricks IE7 and earlier\\n          // to push a history entry on hash-tag change.\\n          // When replace is true, we don't want this.\\n          if (!options.replace) {\\n            this.iframe.document.open().close();\\n          }\\n          this._updateHash(this.iframe.location, frag, options.replace);\\n        }\\n\\n      // If you've told us that you explicitly don't want fallback hashchange-\\n      // based history, then `navigate` becomes a page refresh.\\n      } else {\\n        window.location.assign(this.options.root + fragment);\\n      }\\n      if (options.trigger) {\\n        this.loadUrl(fragment);\\n      }\\n    },\\n\\n    // Update the hash location, either replacing the current entry, or adding\\n    // a new one to the browser history.\\n    _updateHash: function(location, fragment, replace) {\\n      if (replace) {\\n        var s = location.toString().replace(/(javascript:|#).*$/, '');\\n        location.replace(s + '#' + fragment);\\n      } else {\\n        location.hash = fragment;\\n      }\\n    }\\n  });\\n}(this));\\n\\n/*global _: false*/\\n(function(root) {\\n  root.Parse = root.Parse || {};\\n  var Parse = root.Parse;\\n  var _ = Parse._;\\n\\n  /**\\n   * Routers map faux-URLs to actions, and fire events when routes are\\n   * matched. Creating a new one sets its `routes` hash, if not set statically.\\n   * @class\\n   *\\n   * <p>A fork of Backbone.Router, provided for your convenience.\\n   * For more information, see the\\n   * <a href=\\\"http://documentcloud.github.com/backbone/#Router\\\">Backbone\\n   * documentation</a>.</p>\\n   * <p><strong><em>Available in the client SDK only.</em></strong></p>\\n   */\\n  Parse.Router = function(options) {\\n    options = options || {};\\n    if (options.routes) {\\n      this.routes = options.routes;\\n    }\\n    this._bindRoutes();\\n    this.initialize.apply(this, arguments);\\n  };\\n\\n  // Cached regular expressions for matching named param parts and splatted\\n  // parts of route strings.\\n  var namedParam    = /:\\\\w+/g;\\n  var splatParam    = /\\\\*\\\\w+/g;\\n  var escapeRegExp  = /[\\\\-\\\\[\\\\]{}()+?.,\\\\\\\\\\\\^\\\\$\\\\|#\\\\s]/g;\\n\\n  // Set up all inheritable **Parse.Router** properties and methods.\\n  _.extend(Parse.Router.prototype, Parse.Events,\\n           /** @lends Parse.Router.prototype */ {\\n\\n    /**\\n     * Initialize is an empty function by default. Override it with your own\\n     * initialization logic.\\n     */\\n    initialize: function(){},\\n\\n    /**\\n     * Manually bind a single named route to a callback. For example:\\n     *\\n     * <pre>this.route('search/:query/p:num', 'search', function(query, num) {\\n     *       ...\\n     *     });</pre>\\n     */\\n    route: function(route, name, callback) {\\n      Parse.history = Parse.history || new Parse.History();\\n      if (!_.isRegExp(route)) {\\n        route = this._routeToRegExp(route);\\n      }\\n      if (!callback) {\\n        callback = this[name];\\n      }\\n      Parse.history.route(route, _.bind(function(fragment) {\\n        var args = this._extractParameters(route, fragment);\\n        if (callback) {\\n          callback.apply(this, args);\\n        }\\n        this.trigger.apply(this, ['route:' + name].concat(args));\\n        Parse.history.trigger('route', this, name, args);\\n      }, this));\\n      return this;\\n    },\\n\\n    /**\\n     * Whenever you reach a point in your application that you'd\\n     * like to save as a URL, call navigate in order to update the\\n     * URL. If you wish to also call the route function, set the\\n     * trigger option to true. To update the URL without creating\\n     * an entry in the browser's history, set the replace option\\n     * to true.\\n     */\\n    navigate: function(fragment, options) {\\n      Parse.history.navigate(fragment, options);\\n    },\\n\\n    // Bind all defined routes to `Parse.history`. We have to reverse the\\n    // order of the routes here to support behavior where the most general\\n    // routes can be defined at the bottom of the route map.\\n    _bindRoutes: function() {\\n      if (!this.routes) {\\n        return;\\n      }\\n      var routes = [];\\n      for (var route in this.routes) {\\n        if (this.routes.hasOwnProperty(route)) {\\n          routes.unshift([route, this.routes[route]]);\\n        }\\n      }\\n      for (var i = 0, l = routes.length; i < l; i++) {\\n        this.route(routes[i][0], routes[i][1], this[routes[i][1]]);\\n      }\\n    },\\n\\n    // Convert a route string into a regular expression, suitable for matching\\n    // against the current location hash.\\n    _routeToRegExp: function(route) {\\n      route = route.replace(escapeRegExp, '\\\\\\\\$&')\\n                   .replace(namedParam, '([^\\\\/]+)')\\n                   .replace(splatParam, '(.*?)');\\n      return new RegExp('^' + route + '$');\\n    },\\n\\n    // Given a route, and a URL fragment that it matches, return the array of\\n    // extracted parameters.\\n    _extractParameters: function(route, fragment) {\\n      return route.exec(fragment).slice(1);\\n    }\\n  });\\n\\n  /**\\n   * @function\\n   * @param {Object} instanceProps Instance properties for the router.\\n   * @param {Object} classProps Class properies for the router.\\n   * @return {Class} A new subclass of <code>Parse.Router</code>.\\n   */\\n  Parse.Router.extend = Parse._extend;\\n}(this));\\n(function(root) {\\n  root.Parse = root.Parse || {};\\n  var Parse = root.Parse;\\n  var _ = Parse._;\\n\\n  /**\\n   * @namespace Contains functions for calling and declaring\\n   * <a href=\\\"/docs/cloud_code_guide#functions\\\">cloud functions</a>.\\n   * <p><strong><em>\\n   *   Some functions are only available from Cloud Code.\\n   * </em></strong></p>\\n   */\\n  Parse.Cloud = Parse.Cloud || {};\\n\\n  _.extend(Parse.Cloud, /** @lends Parse.Cloud */ {\\n    /**\\n     * Makes a call to a cloud function.\\n     * @param {String} name The function name.\\n     * @param {Object} data The parameters to send to the cloud function.\\n     * @param {Object} options A Backbone-style options object\\n     * options.success, if set, should be a function to handle a successful\\n     * call to a cloud function.  options.error should be a function that\\n     * handles an error running the cloud function.  Both functions are\\n     * optional.  Both functions take a single argument.\\n     * @return {Parse.Promise} A promise that will be resolved with the result\\n     * of the function.\\n     */\\n    run: function(name, data, options) {\\n      options = options || {};\\n\\n      var request = Parse._request({\\n        route: \\\"functions\\\",\\n        className: name,\\n        method: 'POST',\\n        useMasterKey: options.useMasterKey,\\n        data: Parse._encode(data, null, true)\\n      });\\n\\n      return request.then(function(resp) {\\n        return Parse._decode(null, resp).result;\\n      })._thenRunCallbacks(options);\\n    }\\n  });\\n}(this));\\n\\n(function(root) {\\n  root.Parse = root.Parse || {};\\n  var Parse = root.Parse;\\n\\n  Parse.Installation = Parse.Object.extend(\\\"_Installation\\\");\\n\\n  /**\\n   * Contains functions to deal with Push in Parse\\n   * @name Parse.Push\\n   * @namespace\\n   */\\n  Parse.Push = Parse.Push || {};\\n\\n  /**\\n   * Sends a push notification.\\n   * @param {Object} data -  The data of the push notification.  Valid fields\\n   * are:\\n   *   <ol>\\n   *     <li>channels - An Array of channels to push to.</li>\\n   *     <li>push_time - A Date object for when to send the push.</li>\\n   *     <li>expiration_time -  A Date object for when to expire\\n   *         the push.</li>\\n   *     <li>expiration_interval - The seconds from now to expire the push.</li>\\n   *     <li>where - A Parse.Query over Parse.Installation that is used to match\\n   *         a set of installations to push to.</li>\\n   *     <li>data - The data to send as part of the push</li>\\n   *   <ol>\\n   * @param {Object} options An object that has an optional success function,\\n   * that takes no arguments and will be called on a successful push, and\\n   * an error function that takes a Parse.Error and will be called if the push\\n   * failed.\\n   */\\n  Parse.Push.send = function(data, options) {\\n    options = options || {};\\n\\n    if (data.where) {\\n      data.where = data.where.toJSON().where;\\n    }\\n\\n    if (data.push_time) {\\n      data.push_time = data.push_time.toJSON();\\n    }\\n\\n    if (data.expiration_time) {\\n      data.expiration_time = data.expiration_time.toJSON();\\n    }\\n\\n    if (data.expiration_time && data.expiration_interval) {\\n      throw \\\"Both expiration_time and expiration_interval can't be set\\\";\\n    }\\n\\n    var request = Parse._request({\\n      route: 'push',\\n      method: 'POST',\\n      data: data,\\n      useMasterKey: options.useMasterKey\\n    });\\n    return request._thenRunCallbacks(options);\\n  };\\n}(this));\\n\"","// style-loader: Adds some css to the DOM by adding a <style> tag\nvar dispose = require(\"!/Users/joe/Documents/_projects/gratzi/pegg/dev/pegg/node_modules/style-loader/addStyle.js\")\n\t// The css code:\n\t(require(\"!!/Users/joe/Documents/_projects/gratzi/pegg/dev/pegg/node_modules/css-loader/index.js!/Users/joe/Documents/_projects/gratzi/pegg/dev/pegg/bower_components/famous/core/famous.css\"))\nif(module.hot) {\n\tmodule.hot.accept();\n\tmodule.hot.dispose(dispose);\n}","// style-loader: Adds some css to the DOM by adding a <style> tag\nvar dispose = require(\"!/Users/joe/Documents/_projects/gratzi/pegg/dev/pegg/node_modules/style-loader/addStyle.js\")\n\t// The css code:\n\t(require(\"!!/Users/joe/Documents/_projects/gratzi/pegg/dev/pegg/node_modules/sass-loader/index.js?outputStyle=expanded&includePaths[]=./bower_components/!/Users/joe/Documents/_projects/gratzi/pegg/dev/pegg/src/css/app.scss\"))\nif(module.hot) {\n\tmodule.hot.accept();\n\tmodule.hot.dispose(dispose);\n}","// style-loader: Adds some css to the DOM by adding a <style> tag\nvar dispose = require(\"!/Users/joe/Documents/_projects/gratzi/pegg/dev/pegg/node_modules/style-loader/addStyle.js\")\n\t// The css code:\n\t(require(\"!!/Users/joe/Documents/_projects/gratzi/pegg/dev/pegg/node_modules/sass-loader/index.js?outputStyle=expanded&includePaths[]=./bower_components/!/Users/joe/Documents/_projects/gratzi/pegg/dev/pegg/src/css/card.scss\"))\nif(module.hot) {\n\tmodule.hot.accept();\n\tmodule.hot.dispose(dispose);\n}","// style-loader: Adds some css to the DOM by adding a <style> tag\nvar dispose = require(\"!/Users/joe/Documents/_projects/gratzi/pegg/dev/pegg/node_modules/style-loader/addStyle.js\")\n\t// The css code:\n\t(require(\"!!/Users/joe/Documents/_projects/gratzi/pegg/dev/pegg/node_modules/sass-loader/index.js?outputStyle=expanded&includePaths[]=./bower_components/!/Users/joe/Documents/_projects/gratzi/pegg/dev/pegg/src/css/header.scss\"))\nif(module.hot) {\n\tmodule.hot.accept();\n\tmodule.hot.dispose(dispose);\n}","// style-loader: Adds some css to the DOM by adding a <style> tag\nvar dispose = require(\"!/Users/joe/Documents/_projects/gratzi/pegg/dev/pegg/node_modules/style-loader/addStyle.js\")\n\t// The css code:\n\t(require(\"!!/Users/joe/Documents/_projects/gratzi/pegg/dev/pegg/node_modules/sass-loader/index.js?outputStyle=expanded&includePaths[]=./bower_components/!/Users/joe/Documents/_projects/gratzi/pegg/dev/pegg/src/css/widgets/fpsmeter.scss\"))\nif(module.hot) {\n\tmodule.hot.accept();\n\tmodule.hot.dispose(dispose);\n}"],"sourceRoot":"webpack-module://"}